00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/2/2020 6:20:27 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/1/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 000018CE             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001944             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010DC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010EE             28                  JSR     CONVERT
0000103E  4EB9 0000115A             29                  JSR     TEST_RANGE
00001044  4EB9 00001172             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 0000197B             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010DC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010EE             47                  JSR     CONVERT
00001086  4EB9 0000115A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001172             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0032                 56                  BLT     RESET_INPUT
000010A4                            57                 
000010A4  41F9 00001288             58  PREPARE         LEA         NIBBLE1_JUMP,A0              
000010AA  2479 00000100             59                  MOVE.L      STARTING_ADDRESS,A2
000010B0  2679 00000150             60                  MOVE.L      ENDING_ADDRESS,A3
000010B6                            61                                     
000010B6                            62                  
000010B6  220A                      63  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010B8  4EB9 000017D6             64                  JSR     PRINTNUM            ; prints out address                    
000010BE  4EB9 0000117A             65                  JSR     OPCODE_DECODE       ; decode the opcode
000010C4  4EB9 0000181E             66                  JSR     PRINTENTER          ; prints a new line
000010CA  B5CB                      67                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010CC  6FE8                      68                  BLE     DISASSEMBLE         ; if not, loop
000010CE                            69  
000010CE  103C 0009                 70  STOP            MOVE.B  #9,D0
000010D2  4E4F                      71                  TRAP    #15
000010D4                            72  
000010D4                            73  *--------------------SUBROUTINES------------------    
000010D4                            74  
000010D4  143C 0001                 75  RESET_INPUT     MOVE.B  #1,D2
000010D8  6000 0062                 76                  BRA     INVALID            
000010DC                            77                  
000010DC  7800                      78  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010DE  B204                      79                  CMP.B   D4,D1               ; D1 stores length
000010E0  6700 005A                 80                  BEQ     INVALID             ; input is null
000010E4  0C41 0008                 81                  CMPI    #$8,D1              ; check if input is longer than a longword
000010E8  6E00 0052                 82                  BGT     INVALID             ; input is longer than a longword
000010EC  4E75                      83                  RTS
000010EE                            84                              
000010EE  4283                      85  CONVERT         CLR.L   D3
000010F0  4284                      86                  CLR.L   D4
000010F2  1619                      87                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010F4  B63C 0039                 88                  CMP.B   #57,D3
000010F8  6E00 0012                 89                  BGT     NOTNUMBER
000010FC                            90                  
000010FC  B63C 002F                 91                  CMP.B   #47,D3
00001100  6E00 0002                 92                  BGT     ISNUMBER
00001104                            93                  
00001104  0603 00D0                 94  ISNUMBER        ADD.B   #-48,D3             ; current char is number
00001108  6000 001A                 95                  BRA     CONCAT
0000110C                            96              
0000110C  B63C 0041                 97  NOTNUMBER       CMP.B   #65,D3
00001110  6D00 002A                 98                  BLT     INVALID
00001114  B63C 0046                 99                  CMP.B   #70,D3
00001118  6E00 0022                100                  BGT     INVALID  
0000111C  0603 00C9                101                  ADD.B   #-55,D3             ; is letter             
00001120  6000 0002                102                  BRA     CONCAT
00001124                           103              
00001124  BC3C 0000                104  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001128  6D00 0010                105                  BLT     RETURN
0000112C  1806                     106                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000112E  E50C                     107                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001130  E9AB                     108                  LSL.L   D4,D3               ; moves current char to correct position  
00001132  DA83                     109                  ADD.L   D3,D5               ; D5 stores converted input so far
00001134  0606 00FF                110                  ADD.B   #-1,D6  
00001138  60B4                     111                  BRA     CONVERT             ; continue loop for remaining chars
0000113A                           112                  
0000113A  4E75                     113  RETURN          RTS
0000113C                           114                  
0000113C  227C 00000000            115  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001142  43F9 000019B1            116                  LEA     BAD_INPUT,A1        ; output invalid message
00001148  103C 000E                117                  MOVE.B  #14,D0
0000114C  4E4F                     118                  TRAP    #15
0000114E  B47C 0001                119                  CMP     #1,D2
00001152  6700 FEB8                120                  BEQ     INPUT1
00001156  6000 FEFA                121                  BRA     INPUT2
0000115A                           122  
0000115A  4284                     123  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000115C  223C 00001000            124                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001162  BA81                     125                  CMP.L      D1,D5            ; Compare minimum address with input
00001164  6DD6                     126                  BLT        INVALID          ; input is too low. 
00001166  223C 00FFFFFE            127                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000116C  BA81                     128                  CMP.L      D1,D5            ; compare maximum address with input
0000116E  6ECC                     129                  BGT        INVALID          ; input too large
00001170  4E75                     130                  RTS                         ; input is within range
00001172                           131             
00001172  0805 0000                132  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001176  66C4                     133                  BNE        INVALID
00001178  4E75                     134                  RTS
0000117A                           135  
0000117A                           136  *PRINT_LOCATION
0000117A                           137  *    MOVE.L      A2,D5 * Save the address we are at
0000117A                           138  *    LSR         #8,D5                                       * Shift 4 bytes left most to print out
0000117A                           139  *    LSR         #8,D5
0000117A                           140  *    MOVE.W      D5,TEMP_CURRENT_4_NIBBLES                   * Get the entire long address
0000117A                           141  *    JSR         HEX_TO_ASCII
0000117A                           142  *    MOVE.W      A2,D5
0000117A                           143  *    MOVE.W      D5,TEMP_CURRENT_4_NIBBLES
0000117A                           144  *    JSR         HEX_TO_ASCII
0000117A                           145  *    JSR         PRINT_SPACE
0000117A                           146  *    RTS
0000117A                           147                  
0000117A                           148  *HEX_TO_ASCII    LEA         HEX_CHARACTER_JUMP_TABLE,A4             * Load the table to print out ascii charracter
0000117A                           149  *                MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000117A                           150  *                JSR         GET_THE_FIRST_NIBBLE                    * Get the left most hex value and convert
0000117A                           151  *                MULU        #6,D3
0000117A                           152  *                JSR         0(A4,D3)
0000117A                           153  *                MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000117A                           154  *                JSR         GET_THE_SECOND_NIBBLE
0000117A                           155  *                MULU        #6,D3
0000117A                           156  *                JSR         0(A4,D3)
0000117A                           157  *                MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000117A                           158  *                JSR         GET_THE_THIRD_NIBBLE
0000117A                           159  *                MULU        #6,D3
0000117A                           160  *                JSR         0(A4,D3)
0000117A                           161  *                MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000117A                           162  *                JSR         GET_THE_FOURTH_NIBBLE
0000117A                           163  *                MULU        #6,D3
0000117A                           164  *                JSR         0(A4,D3)
0000117A                           165  *                CLR.W       D3
0000117A                           166  *                RTS            
0000117A                           167  
0000117A                           168  
0000117A                           169  * Checks every single possible opcode we could have. Jump table
0000117A                           170  * Inputs: (A2) which is a pointer to intruction word to be translated
0000117A                           171  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000117A                           172  
0000117A  301A                     173  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000117C  33C0 00000200            174                  MOVE.W  D0,CURRENT_INSTR
00001182                           175                  
00001182  B07C 4E71                176  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001186  6600 0010                177                  BNE     CASE_MOVE               ; checks the next case if not equal
0000118A  4BF9 000019F2            178                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001190  4EB9 0000180C            179                  JSR     PRINTNULL               ; prints NOP                
00001196  4E75                     180                  RTS                             ; returns from the subroutine
00001198                           181                  
00001198                           182                  * if first two bits are 00, next two are not 00
00001198  3200                     183  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
0000119A  C27C C000                184                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000119E  6600 00C0                185                  BNE     CASE_MOVEQ              ; if not 0, not a  move instruction
000011A2  B07C 0FFF                186                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000011A6  6F00 00B8                187                  BLE     CASE_MOVEQ              ; if less than or equal to, not a move             
000011AA                           188                  
000011AA                           189                  ; get destination
000011AA  323C 0001                190                  MOVE.W  #1,D1                   ; specifies that we are looking for dest addressing mode
000011AE  4EB9 000015E0            191                  JSR     GET_EA                  ; gets effective address, output: D1 = EA
000011B4  3C01                     192                  MOVE.W  D1,D6                   ; saves EA to D6 so it doesn't get overwritten
000011B6  323C 0001                193                  MOVE.W  #1,D1                   ; specifies that we are looking for dest Xn
000011BA  4EB9 0000160A            194                  JSR     GET_XN                  ; Gets Xn, puts it into D1
000011C0  3E01                     195                  MOVE.W  D1,D7                   ; saves Xn to D7 so it doesn't get overwritten
000011C2                           196  
000011C2  4BF9 00001891            197  CHECKDEST       LEA     VALIDEA_MOVE_DEST,A5    ; load valid move EA
000011C8  3206                     198                  MOVE.W  D6,D1                   ; marks down that we are checking EA
000011CA  4EB9 00001652            199                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
000011D0  B27C 0002                200                  CMP.W   #2,D1                   ; checks if it is Xn
000011D4  6700 0074                201                  BEQ     CHECKMOVE_XN            ; branches to CHECKXn if it is
000011D8  B27C 0001                202                  CMP.W   #1,D1                   ; Checks if it is invalid
000011DC  6700 0066                203                  BEQ     EAMOVE_INVALID          ; branches to CHECKXn if it is
000011E0                           204                  
000011E0                           205                  ; get source
000011E0  323C 0000                206  EAMOVE_VALID    MOVE.W  #0,D1                   ; specifies that we are looking for source addressing mode
000011E4  4EB9 000015E0            207                  JSR     GET_EA                  ; gets effective address, output: D1 = EA
000011EA  3801                     208                  MOVE.W  D1,D4                   ; saves EA to D6 so it doesn't get overwritten
000011EC  323C 0000                209                  MOVE.W  #0,D1                   ; specifies that we are looking for source Xn
000011F0  4EB9 0000160A            210                  JSR     GET_XN                  ; Gets Xn, puts it into D1
000011F6  3A01                     211                  MOVE.W  D1,D5                   ; saves Xn to D7 so it doesn't get overwritten
000011F8                           212                  
000011F8                           213                  ; print source
000011F8  3200                     214                  MOVE.W  D0,D1                   ; stores d0 in d1
000011FA  C27C 01C0                215                  AND.W   #$01C0, D1              ; appplies a bitmask to get 3 bits, check if its 001
000011FE  B27C 0040                216                  CMP.W   #$0040, D1              ; confirms if it is a MOVEA
00001202  6700 000C                217                  BEQ     INSERTA                 ; branches to MOVEA, otherwise it is a normal MOVE
00001206                           218   
00001206  4BF9 000019F7            219                  LEA     MSG_MOVE,A5             ; loads string pointer for MOVE into A5
0000120C  6000 0008                220                  BRA     PRINTMOVE               ; Branches to print move
00001210                           221                  
00001210  4BF9 000019FD            222  INSERTA         LEA     MSG_MOVEA,A5            ; loads string pointer for MOVEA into A5
00001216                           223  
00001216  4EB9 0000180C            224  PRINTMOVE       JSR     PRINTNULL               ; prints out MOVE
0000121C  4EB9 0000182E            225                  JSR     PRINTMOVESIZE           ; prints out the size  
00001222  3404                     226                  MOVE.W  D4,D2                   ; Moves D6 (dest effective address) to D2
00001224  3605                     227                  MOVE.W  D5,D3                   ; Moves D7 (dest Xn if applicable) to D3 
00001226  4EB9 00001686            228                  JSR     EA_TO_STRING            ; outputs it into a string
0000122C                           229                  
0000122C                           230                  ; prints a comma to seperate
0000122C  4BF9 00001AF3            231                  LEA     MSG_COMMA,A5            ; loads string pointer into A5
00001232  4EB9 0000180C            232                  JSR     PRINTNULL               ; prints out MOVE
00001238                           233                  
00001238                           234                  ; print destination
00001238  3406                     235                  MOVE.W  D6,D2                   ; Moves D6 (dest effective address) to D2
0000123A  3607                     236                  MOVE.W  D7,D3                   ; Moves D7 (dest Xn if applicable) to D3 
0000123C  4EB9 00001686            237                  JSR     EA_TO_STRING            ; outputs it into a string
00001242  4E75                     238                  RTS                             ; exits subroutine
00001244                           239                       
00001244                           240                                 
00001244  4EB9 0000152A            241  EAMOVE_INVALID  JSR     CASE_DATA               ; prints out the data                    
0000124A                           242  
0000124A  4BF9 000018CB            243  CHECKMOVE_Xn    LEA     VALIDXN_SHORTLONG,A5    ; Loads Xn into A5
00001250  3207                     244                  MOVE.W  D7,D1                   ; Loads D2 into D1 to check the Xn
00001252  4EB9 00001652            245                  JSR     CHECKEAXN_IFVALID       ; checks if the Xn is valid, put result in D1
00001258  4A41                     246                  TST.W   D1                      ; checks if it is valid
0000125A  6784                     247                  BEQ     EAMOVE_VALID            ; go to EA_VALID to print
0000125C  60E6                     248                  BRA     EAMOVE_INVALID          ; branches to EA_INVALID if not              
0000125E                           249                  
0000125E  4E75                     250                  RTS                             ; returns from subroutine     
00001260                           251  
00001260                           252  CASE_MOVEM  
00001260                           253  
00001260                           254  CASE_MOVEQ  
00001260                           255  
00001260  3600                     256  GET_NIBBLE1     MOVE.W      D0,D3
00001262  E04B                     257                  LSR         #8,D3                               
00001264  E84B                     258                  LSR         #4,D3                               
00001266  B67C 0009                259                  CMP.W       #9,D3
0000126A  6700 002E                260                  BEQ         FIRST_NIBBLE_9
0000126E  B67C 000D                261                  CMP.W       #13,D3
00001272  6700 0026                262                  BEQ         FIRST_NIBBLE_C
00001276  B67C 000E                263                  CMP.W       #14,D3
0000127A  6700 003C                264                  BEQ         FIRST_NIBBLE_D
0000127E                           265                  
0000127E  3600                     266  GET_NIBBLE2     MOVE.W      D0,D3
00001280  E94B                     267                  LSL         #4,D3                               
00001282  E84B                     268                  LSR         #4,D3                               
00001284  E04B                     269                  LSR         #8,D3                               
00001286  4E75                     270                  RTS
00001288                           271  
00001288                           272  NIBBLE1_JUMP    *JMP         FIRST_NIBBLE_0                
00001288                           273  *                JMP         FIRST_NIBBLE_1               
00001288                           274  *                JMP         FIRST_NIBBLE_2               
00001288                           275  *                JMP         FIRST_NIBBLE_3               
00001288                           276  *                JMP         FIRST_NIBBLE_4               
00001288                           277  *                JMP         FIRST_NIBBLE_5               
00001288                           278  *                JMP         FIRST_NIBBLE_6               
00001288                           279  *                JMP         FIRST_NIBBLE_7               
00001288                           280  *                JMP         FIRST_NIBBLE_8              
00001288  4EF9 0000129A            281                  JMP         FIRST_NIBBLE_9      ; SUB         
0000128E                           282  *                JMP         FIRST_NIBBLE_A              
0000128E                           283  *                JMP         FIRST_NIBBLE_B               
0000128E  4EF9 0000129A            284                  JMP         FIRST_NIBBLE_C      ; AND, MULS              
00001294  4EF9 000012B8            285                  JMP         FIRST_NIBBLE_D      ; ADD, ADDA               
0000129A                           286  *                JMP         FIRST_NIBBLE_E               
0000129A                           287  *                JMP         FIRST_NIBBLE_F 
0000129A                           288  
0000129A                           289  FIRST_NIBBLE_9   
0000129A                           290  
0000129A  3639 00000200            291  FIRST_NIBBLE_C  MOVE.W      CURRENT_INSTR,D3
000012A0  4EB9 000012D8            292                  JSR         GET_VARS
000012A6  3639 00000300            293                  MOVE.W      OPMODE_VAR,D3
000012AC  B67C 0007                294                  CMP.W       #%111,D3
000012B0  6700 00B0                295                  BEQ         CASE_MULS
000012B4  6000 00AC                296                  BRA         CASE_AND
000012B8                           297  
000012B8  3639 00000200            298  FIRST_NIBBLE_D  MOVE.W      CURRENT_INSTR,D3
000012BE  4EB9 000012D8            299                  JSR         GET_VARS
000012C4  3639 00000300            300                  MOVE.W      OPMODE_VAR,D3
000012CA  B67C 0003                301                  CMP.W       #%11,D3
000012CE  6700 0068                302                  BEQ         CASE_ADDA
000012D2  6000 0058                303                  BRA         CASE_ADD
000012D6  4E75                     304                  RTS
000012D8                           305  
000012D8                           306  *Gets bits 11-0, at 3 bit increments
000012D8  3639 00000200            307  GET_VARS        MOVE.W      CURRENT_INSTR,D3
000012DE  E94B                     308                  LSL         #4,D3                               
000012E0  E84B                     309                  LSR         #4,D3                               
000012E2  E04B                     310                  LSR         #8,D3                               
000012E4  E24B                     311                  LSR         #1,D3
000012E6  33C3 00000250            312                  MOVE.W      D3,REG_VAR
000012EC  3600                     313                  MOVE.W      D0,D3                               
000012EE  EF4B                     314                  LSL         #7,D3
000012F0  EE4B                     315                  LSR         #7,D3
000012F2  EC4B                     316                  LSR         #6,D3
000012F4  33C3 00000300            317                  MOVE.W      D3,OPMODE_VAR
000012FA  3639 00000200            318                  MOVE.W      CURRENT_INSTR,D3                    
00001300  E14B                     319                  LSL         #8,D3
00001302  E54B                     320                  LSL         #2,D3
00001304  E04B                     321                  LSR         #8,D3
00001306  E44B                     322                  LSR         #2,D3
00001308  E64B                     323                  LSR         #3,D3
0000130A  33C3 00000350            324                  MOVE.W      D3,EA_MODE                           
00001310  3639 00000200            325                  MOVE.W      CURRENT_INSTR,D3
00001316  E14B                     326                  LSL         #8,D3
00001318  EB4B                     327                  LSL         #5,D3
0000131A  E04B                     328                  LSR         #8,D3
0000131C  EA4B                     329                  LSR         #5,D3
0000131E  33C3 00000400            330                  MOVE.W      D3,EA_REG
00001324  3639 00000200            331                  MOVE.W      CURRENT_INSTR,D3
0000132A  4E75                     332                  RTS    
0000132C                           333  
0000132C  43F9 00001A17            334  CASE_ADD        LEA         MSG_ADDA,A1
00001332  103C 000E                335                  MOVE.B      #14,D0
00001336  4E4F                     336                  TRAP        #15 
00001338                           337  
00001338  43F9 00001A17            338  CASE_ADDA       LEA         MSG_ADDA,A1
0000133E  103C 000E                339                  MOVE.B      #14,D0
00001342  4E4F                     340                  TRAP        #15                 ; print "ADDA"
00001344  3639 00000300            341                  MOVE.W      OPMODE_VAR,D3
0000134A  4EB9 00001356            342                  JSR         ADDA_SIZE
00001350  4EB9 0000152E            343                  JSR         ADDR_MODE_JUMP_TABLE
00001356                           344                      
00001356                           345              
00001356  B67C 0007                346  ADDA_SIZE       CMP.W       #%111,D3
0000135A  6700 0268                347                  BEQ         PRINT_WORD 
0000135E  6000 0272                348                  BRA         PRINT_LONG          
00001362                           349                  
00001362                           350  
00001362                           351  CASE_ADDQ
00001362                           352  
00001362                           353  CASE_SUB
00001362                           354  
00001362                           355  CASE_MULS
00001362                           356  
00001362                           357  CASE_DIVU
00001362                           358  
00001362                           359  CASE_LEA
00001362                           360  
00001362                           361  *---------------AND opcode----------------------
00001362  43F9 00001A3C            362  CASE_AND        LEA         MSG_AND,A1
00001368  103C 000E                363                  MOVE.B      #14,D0
0000136C  4E4F                     364                  TRAP        #15 
0000136E  4EB8 12D8                365                  JSR         GET_VARS
00001372  4EB9 00001396            366                  JSR         AND_SIZE                        ; .B, .W, or .L  
00001378  3A39 00000200            367                  MOVE.W      CURRENT_INSTR, D5                         
0000137E  EF4D                     368                  LSL.W       #7, D5                        
00001380  E04D                     369                  LSR.W       #8, D5                   
00001382  EE4D                     370                  LSR.W       #7, D5                     
00001384  BA3C 0000                371                  CMP.B       #00, D5                         ; check if destination is a Dn?
00001388  6700 0030                372                  BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
0000138C  BA3C 0001                373                  CMP.B       #$01,D5                         ; Is the destination not a Dn?
00001390  6700 00A2                374                  BEQ         DEST_EA                         ; branch to DEST_EA            
00001394  4E75                     375                  RTS
00001396                           376     
00001396  0C39 0000 00000300       377  AND_SIZE        CMP.B       #%00,OPMODE_VAR       
0000139E  6700 0216                378                  BEQ         PRINT_BYTE
000013A2  0C39 0001 00000300       379                  CMP.B       #$01, OPMODE_VAR
000013AA  6700 0218                380                  BEQ         PRINT_WORD
000013AE  0C39 0002 00000300       381                  CMP.B       #$02, OPMODE_VAR
000013B6  6700 021A                382                  BEQ         PRINT_LONG    
000013BA                           383      
000013BA  3A39 00000200            384  DEST_DN         MOVE.W      CURRENT_INSTR, D5               
000013C0  ED4D                     385                  LSL.W       #6,D5
000013C2  E94D                     386                  LSL.W       #4,D5
000013C4  EC4D                     387                  LSR.W       #6,D5
000013C6  E84D                     388                  LSR.W       #4,D5
000013C8  E64D                     389                  LSR.W       #3,D5                           ; d5 stores EA mode                
000013CA                           390                    
000013CA  3C39 00000200            391                  MOVE.W      CURRENT_INSTR, D6               
000013D0  ED4D                     392                  LSL.W       #6,D5
000013D2  E94D                     393                  LSL.W       #4,D5
000013D4  E74E                     394                  LSL.W       #3,D6
000013D6  EC4E                     395                  LSR.W       #6,D6
000013D8  E84E                     396                  LSR.W       #4,D6
000013DA  E64E                     397                  LSR.W       #3,D6                           ; d6 stores EA register
000013DC  4EB9 00001410            398                  JSR         FIND_EA
000013E2                           399  
000013E2                           400                  
000013E2  3A39 00000200            401                  MOVE.W      CURRENT_INSTR, D5               
000013E8  E94D                     402                  LSL.W       #4, D5                         
000013EA  E04D                     403                  LSR.W       #8, D5                          ; shift bits to get register
000013EC  EA4D                     404                  LSR.W       #5, D5                          ; D5 contains register
000013EE  43F9 00001AF3            405                  LEA         MSG_COMMA, A1                   
000013F4  103C 000E                406                  MOVE.B      #14,D0
000013F8  4E4F                     407                  TRAP        #15                             ; print comma
000013FA  43F9 00001AE3            408                  LEA         MSG_DR, A1                      ; print D
00001400  103C 000E                409                  MOVE.B      #14,D0
00001404  4E4F                     410                  TRAP        #15
00001406  2245                     411                  MOVEA.L     D5,A1
00001408  103C 000E                412                  MOVE.B      #14,D0
0000140C  4E4F                     413                  TRAP        #15                              
0000140E  4E75                     414                  RTS        
00001410                           415  
00001410  BA7C 0002                416  FIND_EA        CMP.W       #%010,D5
00001414  6700 02CC                417                  BEQ         CASE_ARI
00001418  BA7C 0003                418                  CMP.W       #%011,D5
0000141C  6700 02F4                419                  BEQ         CASE_ARIPOST
00001420  BA7C 0004                420                  CMP.W       #%100,D5
00001424  6700 0328                421                  BEQ         CASE_ARIPRE
00001428  BA7C 0007                422                  CMP.W       #%111,D5
0000142C  6700 035C                423                  BEQ         CASE_OTHER
00001430  6000 043A                424                  BRA         ERROR    
00001434                           425                                       
00001434  3A39 00000200            426  DEST_EA         MOVE.W      CURRENT_INSTR, D5               
0000143A  E94D                     427                  LSL.W       #4, D5                         
0000143C  E04D                     428                  LSR.W       #8, D5                          ; shift bits to get register
0000143E  EA4D                     429                  LSR.W       #5, D5                          ; D5 contains register
00001440                           430  
00001440  43F9 00001AE3            431                  LEA         MSG_DR, A1                   
00001446  103C 000E                432                  MOVE.B      #14,D0
0000144A  4E4F                     433                  TRAP        #15                             ; print D
0000144C  2245                     434                  MOVEA.L     D5,A1  
0000144E  103C 000E                435                  MOVE.B      #14,D0                          ; print register
00001452  4E4F                     436                  TRAP        #15
00001454                           437                  
00001454  43F9 00001AF3            438                  LEA         MSG_COMMA, A1                   
0000145A  103C 000E                439                  MOVE.B      #14,D0
0000145E  4E4F                     440                  TRAP        #15                             ; print comma
00001460                           441                  
00001460  3A39 00000200            442                  MOVE.W      CURRENT_INSTR, D5               
00001466  ED4D                     443                  LSL.W       #6,D5
00001468  E94D                     444                  LSL.W       #4,D5
0000146A  EC4D                     445                  LSR.W       #6,D5
0000146C  E84D                     446                  LSR.W       #4,D5
0000146E  E64D                     447                  LSR.W       #3,D5                           ; d5 stores EA mode                
00001470                           448                    
00001470  3C39 00000200            449                  MOVE.W      CURRENT_INSTR, D6               
00001476  ED4E                     450                  LSL.W       #6,D6
00001478  E94E                     451                  LSL.W       #4,D6
0000147A  E74E                     452                  LSL.W       #3,D6
0000147C  EC4E                     453                  LSR.W       #6,D6
0000147E  E84E                     454                  LSR.W       #4,D6
00001480  E64E                     455                  LSR.W       #3,D6                           ; d6 stores EA register
00001482  4EB8 1410                456                  JSR         FIND_EA                          
00001486  4E75                     457                  RTS                                     Return full instruction               
00001488                           458  CASE_OR
00001488                           459  
00001488                           460  CASE_NOT
00001488                           461  
00001488                           462  CASE_LSL
00001488                           463  
00001488                           464  CASE_LSR
00001488                           465  
00001488                           466  CASE_ASL
00001488                           467  
00001488                           468  CASE_ASR
00001488                           469               
00001488  3200                     470  CASE_BRA        MOVE.W  D0,D1               ; Copies instruction word to D1
0000148A  C27C FF00                471                  AND.W   #$FF00,D1           ; Applies a bitmask to get first 8 bits                
0000148E  B27C 6000                472                  CMP.W   #$6000,D1           ; Checks if it fits the BRA opcode
00001492  6600 0018                473                  BNE.W   CASE_BCC            ; If its not, check BCC
00001496                           474                  
00001496  4BF9 00001ADB            475                  LEA     MSG_BRA,A5          ; loads string pointer for BRA into A5
0000149C  4EB9 0000180C            476                  JSR     PRINTNULL           ; prints BRA
000014A2                           477  
000014A2  3400                     478                  MOVE.W  D0,D2               ; Copies instruction word to D1
000014A4  4EB9 00001634            479                  JSR     GETDISPLACEMENT     ; finds the displacement
000014AA  4E75                     480                  RTS
000014AC                           481                  
000014AC                           482  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
000014AC                           483  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
000014AC  3200                     484  CASE_BCC        MOVE.W  D0,D1               ; 
000014AE  C27C F000                485                  AND.W   #$F000,D1           ; get top 4 bits
000014B2  B27C 6000                486                  CMP.W   #$6000,D1           ; make sure top 4 bits are 6
000014B6  6600 005C                487                  BNE.W   CASE_JSR            ;
000014BA  C27C 0F00                488                  AND.W   #$0F00,D1           ; get next 4 bits, condition code
000014BE                           489                  *LSL.W   #8,D1               ; shifts 8 bits to the right
000014BE                           490                  
000014BE  B27C 0E00                491                  CMP.W   #$0E00,D1              ; checks if D1 is BGT (1 1 1 0)
000014C2  6700 0036                492                  BEQ     CASE_BGT            ; branches to BGT if it is
000014C6                           493                  
000014C6  B27C 0F00                494                  CMP.W   #$0F00,D1              ; checks if D1 is BLE (1 1 1 1)
000014CA  6700 001E                495                  BEQ     CASE_BLE            ; branches to BLE if it is
000014CE                           496                      
000014CE  B27C 0700                497                  CMP.W   #$0700,D1              ; checks if D1 is BEQ (0 1 1 1)
000014D2  6700 0006                498                  BEQ     CASE_BEQ            ; branches to BEQ if it is
000014D6  6000 0054                499                  BRA     CASE_EPICFAIL       ; BCC condition code not in the system
000014DA                           500    
000014DA  4BF9 00001A6E            501  CASE_BEQ        LEA     MSG_BEQ,A5          ; loads string pointer for BEQ into A5
000014E0  4EB9 0000180C            502                  JSR     PRINTNULL           ; prints BEQ
000014E6  6000 0022                503                  BRA     PRINTBCCDIS
000014EA                           504  
000014EA  4BF9 00001A96            505  CASE_BLE        LEA     MSG_BLE,A5          ; loads string pointer for BLE into A5
000014F0  4EB9 0000180C            506                  JSR     PRINTNULL           ; prints BLE
000014F6  6000 0012                507                  BRA     PRINTBCCDIS
000014FA                           508                  
000014FA  4BF9 00001A86            509  CASE_BGT        LEA     MSG_BGT,A5          ; loads string pointer for BGT into A5
00001500  4EB9 0000180C            510                  JSR     PRINTNULL           ; prints BGT
00001506  6000 0002                511                  BRA     PRINTBCCDIS
0000150A                           512  
0000150A  3400                     513  PRINTBCCDIS     MOVE.W  D0,D2               ; Copies instruction word to D1
0000150C  4EB9 00001634            514                  JSR     GETDISPLACEMENT     ; finds the displacement
00001512  4E75                     515                  RTS              
00001514                           516  
00001514                           517  CASE_JSR
00001514                           518  
00001514  B07C 4E75                519  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001518  6600 FC7E                520                  BNE     CASE_MOVE           ; checks the next case if not equal
0000151C  4BF9 00001AD6            521                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001522  4EB9 0000180C            522                  JSR     PRINTNULL           ; prints RTS                
00001528  4E75                     523                  RTS                         ; returns from the subroutine
0000152A                           524  
0000152A                           525                  
0000152A                           526  
0000152A                           527  CASE_DATA           
0000152A  4E75                     528                      RTS               
0000152C                           529  
0000152C  4E75                     530  CASE_EPICFAIL       RTS
0000152E                           531  
0000152E  4EF9 0000155E            532  ADDR_MODE_JUMP_TABLE    JMP         ADDR_MODE_000                       * Data register mode Dn
00001534  4EF9 00001566            533                          JMP         ADDR_MODE_001                       * ADdress register mode   An
0000153A  4EF9 0000156E            534                          JMP         ADDR_MODE_010                       * Indirect address register mode (An)
00001540  4EF9 00001576            535                          JMP         ADDR_MODE_011                       * Address register with increment (An)+
00001546  4EF9 0000157E            536                          JMP         ADDR_MODE_100                       * Address register with decrement -(An)
0000154C  4EF9 00001586            537                          JMP         ADDR_MODE_101                       * Not supported
00001552  4EF9 0000158C            538                          JMP         ADDR_MODE_110                       * Not supported
00001558  4EF9 00001592            539                          JMP         ADDR_MODE_111                       * This could be immediate, absolute short or absolute long
0000155E                           540  
0000155E                           541  *Dn
0000155E  4EB9 000016B2            542  ADDR_MODE_000           JSR         CASE_DR
00001564  4E75                     543                          RTS
00001566                           544  
00001566                           545  * An
00001566  4EB9 000016CA            546  ADDR_MODE_001           JSR         CASE_AR
0000156C  4E75                     547                          RTS
0000156E                           548  
0000156E                           549  * (An)
0000156E  4EB9 000016E2            550  ADDR_MODE_010           JSR         CASE_ARI
00001574  4E75                     551                          RTS
00001576                           552  *(An)+
00001576                           553  ADDR_MODE_011           
00001576  4EB9 00001712            554                          JSR         CASE_ARIPOST
0000157C  4E75                     555                          RTS
0000157E                           556                          
0000157E                           557  * -(An)
0000157E  4EB9 0000174E            558  ADDR_MODE_100           JSR         CASE_ARIPRE
00001584  4E75                     559                          RTS
00001586                           560                          
00001586                           561  * Not supported
00001586  6000 02E4                562  ADDR_MODE_101           BRA         ERROR
0000158A  4E75                     563                          RTS
0000158C                           564                          
0000158C                           565  * Not supported
0000158C  6000 02DE                566  ADDR_MODE_110           BRA         ERROR
00001590  4E75                     567                          RTS
00001592                           568  
00001592                           569  * Immediate data, absolute long or absolute short
00001592  49F9 000015B6            570  ADDR_MODE_111           LEA         ADDR_111_JUMP_TABLE,A4      * Print out the appropriate value
00001598  3639 00000200            571                          MOVE.W      CURRENT_INSTR,D3
0000159E  C6FC 0006                572                          MULU        #6,D3
000015A2  4EB4 3000                573                          JSR         0(A4,D3)
000015A6                           574  *                        LEA         SHORT_OR_LONG_PRINT,A4          * Prepare the table to print out the data
000015A6  3639 00000200            575                          MOVE.W      CURRENT_INSTR,D3
000015AC  C6FC 0006                576                          MULU        #6,D3                           * Use THIRD_TEMP_VAR as a place holder for the data we want to print out for register mode 111.
000015B0                           577                                                  * In the code before this, we need to move the appropriate data into this address. Either the destination or the source
000015B0  4EB4 3000                578                          JSR         0(A4,D3)                        * Print out the appropriate long or short value
000015B4  4E75                     579                          RTS
000015B6                           580  
000015B6                           581  ADDR_111_JUMP_TABLE   ;JMP         PRINT_SHORT_SYMBOL
000015B6                           582  *                        JMP         PRINT_LONG_SYMBOL
000015B6                           583  *                        JMP         PRINT_IMMEDIATE_DATA_AND_HEX
000015B6                           584  
000015B6                           585  *Print .B, .W, or .L
000015B6  43F9 00001AFA            586  PRINT_BYTE          LEA     MSG_B,A1
000015BC  103C 000E                587                      MOVE.B  #14,D0
000015C0  4E4F                     588                      TRAP    #15
000015C2  4E75                     589                      RTS
000015C4                           590                      
000015C4  43F9 00001B00            591  PRINT_WORD          LEA     MSG_W,A1
000015CA  103C 000E                592                      MOVE.B  #14,D0
000015CE  4E4F                     593                      TRAP    #15
000015D0  4E75                     594                      RTS
000015D2                           595  
000015D2  43F9 00001B06            596  PRINT_LONG          LEA     MSG_L,A1
000015D8  103C 000E                597                      MOVE.B  #14,D0
000015DC  4E4F                     598                      TRAP    #15
000015DE  4E75                     599                      RTS
000015E0                           600  
000015E0                           601  
000015E0                           602  * Finds the EA type
000015E0                           603  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
000015E0                           604  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000015E0  48E7 3000                605  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000015E4  4A41                     606                      TST.W     D1                    ; compares D1 to 0
000015E6  6700 000E                607                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
000015EA                           608                      
000015EA  343C 01C0                609  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
000015EE  363C 0006                610                      MOVE.W    #6,D3                 ; stores the shift amount to D3
000015F2  6000 000A                611                      BRA       FINDTYPEEA            
000015F6                           612  
000015F6  343C 0038                613  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
000015FA  363C 0003                614                      MOVE.W    #3,D3                 ; stores the shift amount to D3
000015FE                           615  
000015FE                           616  
000015FE  3200                     617  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001600  C242                     618                      AND.W     D2,D1                 ; applies bitmask to D1
00001602  E669                     619                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001604  4CDF 000C                620                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001608  4E75                     621                      RTS                             ; returns from subroutine    
0000160A                           622                      
0000160A                           623  * Finds Xn type
0000160A                           624  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
0000160A                           625  * Output: Addressing Mode (3 bits, 0 to 7) in D1
0000160A  48E7 3000                626  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
0000160E  4A41                     627                      TST.W     D1                    ; compares D1 to 0
00001610  6700 000E                628                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001614                           629  
00001614  343C 0E00                630  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001618  363C 0009                631                      MOVE.W    #9,D3                 ; stores the shift amount to D3
0000161C  6000 000A                632                      BRA       FINDTYPEXN            ; finds the type of Xn
00001620                           633  
00001620  343C 0007                634  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001624  363C 0000                635                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001628                           636                      
00001628  3200                     637  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
0000162A  C242                     638                      AND.W     D2,D1                 ; applies bitmask to D1
0000162C  E669                     639                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
0000162E  4CDF 000C                640                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001632  4E75                     641                      RTS                             ; returns from subroutine 
00001634                           642                                            
00001634                           643  * Gets the displacement and pritns it 
00001634                           644  * Inputs: D2 = instruction word, A2 = address of next word
00001634                           645  * Outputs: prints out displacement
00001634  48E7 4004                646  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001638  3A4A                     647                      MOVE.W    A2,A5                 ; copies A2 to A5
0000163A  C47C 00FF                648                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
0000163E  6600 0004                649                      BNE       PRINTADDRESS          ; prints address if not 0
00001642  341A                     650                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001644                           651                      
00001644  D44D                     652  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001646  3202                     653                      MOVE.W    D2,D1                 ; moves address to D1 to print it
00001648  4EB9 000017D6            654                      JSR       PRINTNUM              ; prints address
0000164E                           655                      
0000164E  4CDF 2002                656                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001652                           657                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001652                           658                                        
00001652                           659                   
00001652                           660                          
00001652                           661  * Checks if EA is valid
00001652                           662  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit), 
00001652                           663  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001652  2F02                     664  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001654                           665  
00001654  141D                     666  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001656  B43C 00FF                667                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
0000165A  6700 000A                668                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
0000165E  B202                     669                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001660  6700 000C                670                     BEQ        VALIDEA               ; branches to valid EA
00001664  60EE                     671                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001666                           672                     
00001666  323C 0001                673  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
0000166A  6000 0016                674                     BRA        CHECKEAEXIT           ; exists the subroutine        
0000166E                           675                    
0000166E  B43C 0007                676  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001672  6700 000A                677                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001676  323C 0000                678                     MOVE.W     #$0,D1                ; marks that it is valid
0000167A  6000 0006                679                     BRA        CHECKEAEXIT           ; exits the subroutine
0000167E                           680  
0000167E  323C 0002                681  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001682                           682  
00001682  241F                     683  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001684  4E75                     684                     RTS                              ; returns from subroutine
00001686                           685  
00001686                           686  * Converts EA and Xn into a string                                
00001686                           687  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001686                           688  * Outputs: Prints out EA and Xn into a string
00001686  48E7 C004                689  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
0000168A  B47C 0001                690                     CMP.W    #An,D2                  ; checks if it is An
0000168E  6700 003A                691                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001692                           692                     
00001692  B47C 0002                693                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001696  6700 004A                694                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
0000169A                           695                     
0000169A  B47C 0003                696                     CMP.W    #AnPost,D2              ; checks if it is (An)+
0000169E  6700 0072                697                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
000016A2                           698                     
000016A2  B47C 0004                699                     CMP.W    #AnPre,D2               ; checks if it is -(An)
000016A6  6700 00A6                700                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
000016AA                           701                     
000016AA  B47C 0007                702                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
000016AE  6700 00DA                703                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
000016B2                           704                     ; otherwise assumes D2 = #Dn which means its a data register                   
000016B2                           705  
000016B2                           706  * data register, Dn
000016B2  4BF9 00001AE3            707  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
000016B8  4EB9 0000180C            708                     JSR      PRINTNULL               ; Prints D
000016BE  3203                     709                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000016C0  4EB9 000017D6            710                     JSR      PRINTNUM                ; Prints the Xn
000016C6  6000 0108                711                     BRA      EA_TO_STRING_EXIT       ; exits           
000016CA                           712  
000016CA                           713  
000016CA                           714  * address register
000016CA  4BF9 00001AE5            715  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
000016D0  4EB9 0000180C            716                     JSR      PRINTNULL               ; Prints A
000016D6  3203                     717                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000016D8  4EB9 000017D6            718                     JSR      PRINTNUM                ; Prints the Xn
000016DE  6000 00F0                719                     BRA      EA_TO_STRING_EXIT       ; exits
000016E2                           720  
000016E2                           721  * address register indirect
000016E2  4BF9 00001AE7            722  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
000016E8  4EB9 0000180C            723                     JSR      PRINTNULL               ; Prints (
000016EE  4BF9 00001AE5            724                     LEA      MSG_AR,A5               ; Loads A into A5
000016F4  4EB9 0000180C            725                     JSR      PRINTNULL               ; Prints A
000016FA  3203                     726                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000016FC  4EB9 000017D6            727                     JSR      PRINTNUM                ; Prints the Xn
00001702  4BF9 00001AE9            728                     LEA      MSG_RB,A5               ; Loads ) into A5
00001708  4EB9 0000180C            729                     JSR      PRINTNULL               ; Prints )
0000170E  6000 00C0                730                     BRA      EA_TO_STRING_EXIT       ; exits
00001712                           731  
00001712                           732  * address register indirect post increment
00001712  4BF9 00001AE7            733  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001718  4EB9 0000180C            734                     JSR      PRINTNULL               ; Prints (
0000171E  4BF9 00001AE5            735                     LEA      MSG_AR,A5               ; Loads A into A5
00001724  4EB9 0000180C            736                     JSR      PRINTNULL               ; Prints A
0000172A  3203                     737                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000172C  4EB9 000017D6            738                     JSR      PRINTNUM                ; Prints the Xn
00001732  4BF9 00001AE9            739                     LEA      MSG_RB,A5               ; Loads ) into A5
00001738  4EB9 0000180C            740                     JSR      PRINTNULL               ; Prints )
0000173E  4BF9 00001AEB            741                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001744  4EB9 0000180C            742                     JSR      PRINTNULL               ; Prints +
0000174A  6000 0084                743                     BRA      EA_TO_STRING_EXIT       ; exits
0000174E                           744  
0000174E                           745  
0000174E                           746  * address register indirect pre increment
0000174E  4BF9 00001AED            747  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001754  4EB9 0000180C            748                     JSR      PRINTNULL               ; Prints -
0000175A  4BF9 00001AE7            749                     LEA      MSG_LB,A5               ; Loads ( into A5
00001760  4EB9 0000180C            750                     JSR      PRINTNULL               ; Prints (
00001766  4BF9 00001AE5            751                     LEA      MSG_AR,A5               ; Loads A into A5
0000176C  4EB9 0000180C            752                     JSR      PRINTNULL               ; Prints A
00001772  3203                     753                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001774  4EB9 000017D6            754                     JSR      PRINTNUM                ; Prints the Xn
0000177A  4BF9 00001AE9            755                     LEA      MSG_RB,A5               ; Loads ) into A5
00001780  4EB9 0000180C            756                     JSR      PRINTNULL               ; Prints )
00001786  6000 0048                757                     BRA      EA_TO_STRING_EXIT       ; exits
0000178A                           758  
0000178A                           759  * other (long, short, immediate) with Xn
0000178A  301A                     760  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
0000178C  B67C 0000                761                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001790  6700 0022                762                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001794                           763                     
00001794  B67C 0001                764                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001798  6700 002A                765                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
0000179C                           766  
0000179C                           767  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
0000179C                           768  * immediate
0000179C  4BF9 00001AEF            769  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000017A2  4EB9 0000180C            770                     JSR      PRINTNULL               ; Prints #  
000017A8                           771                     * uncomment after converting to hex 
000017A8                           772                     *LEA      MSG_HEX,A5              ; Loads $ into A5
000017A8                           773                     *JSR      PRINTNULL               ; Prints $
000017A8  3200                     774                     MOVE.W   D0, D1                  ; moves instruction word into d1
000017AA  4EB9 000017D6            775                     JSR      PRINTNUM 
000017B0  6000 001E                776                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
000017B4                           777                     
000017B4                           778  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
000017B4                           779  
000017B4                           780  * word address
000017B4                           781  CASE_WORD          
000017B4                           782                     *LEA      MSG_HEX,A5              ; Loads $ into A5
000017B4                           783                     *JSR      PRINTNULL               ; Prints $
000017B4  3200                     784                     MOVE.W   D0, D1                  ; moves instruction word into d1
000017B6  383C 0000                785                     MOVE.W   #0, D4                  ; moves length size (word) into d4
000017BA  4EB9 000017E6            786                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000017C0  6000 000E                787                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
000017C4                           788  
000017C4                           789  * long address 
000017C4                           790  CASE_LONG          
000017C4                           791                     *LEA      MSG_HEX,A5              ; Loads $ into A5
000017C4                           792                     *JSR      PRINTNULL               ; Prints $
000017C4  3200                     793                     MOVE.W   D0, D1                  ; moves instruction word into d1
000017C6  383C 0001                794                     MOVE.W   #1, D4                  ; moves length size (long) into d4
000017CA  4EB9 000017E6            795                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000017D0                           796  
000017D0                           797  
000017D0                           798  * exits subroutine
000017D0  4CDF 2003                799  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
000017D4  4E75                     800                      RTS                              ; returns from subroutine
000017D6                           801  
000017D6                           802  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
000017D6                           803  
000017D6                           804  * Prints out the content of D1
000017D6                           805  * Input: number in D1 to be printed
000017D6                           806  * Output: contents of D1 printed
000017D6  48E7 C000                807  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000017DA  103C 0003                808                   MOVE.B      #3,D0               ; prints D1
000017DE  4E4F                     809                   TRAP        #15                 ; is trap task 3
000017E0                           810              
000017E0  4CDF 0003                811                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000017E4  4E75                     812                   RTS                             ; returns from subroutine
000017E6                           813                   
000017E6                           814  * DELETE LATER: THIS IS A  WIP AND DOESNT ACHIEVE PROPER FUNCTIONALITY YET
000017E6                           815                   
000017E6                           816  * Prints out the content of D1 and formats it to have the length of WORD or a LONG
000017E6                           817  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
000017E6                           818  * Output: contents of D1 printed
000017E6  48E7 6000                819  PRINTSHORTLONGNUM         MOVEM.L     D1-D2, -(SP)        ; saves D0 and D1
000017EA  103C 0003                820                            MOVE.B      #3,D0               ; prints D1
000017EE  4E4F                     821                            TRAP        #15                 ; is trap task 3
000017F0  4CDF 0003                822                            MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000017F4  4E75                     823                  RTS                                       ; returns from subroutine
000017F6                           824  
000017F6                           825  * Converts decimal number to hex format
000017F6                           826  *DECTOHEX                  MOVE                
000017F6                           827               
000017F6                           828              
000017F6                           829  * Prints contents of things between a range
000017F6                           830  * input: A5, A6 (the range)
000017F6                           831  * output: prints memory contents from A5 to A6 as strings   
000017F6  48E7 C040                832  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
000017FA  224D                     833                  MOVEA.L     A5, A1           ; loads A5 into A1
000017FC  9DCD                     834                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
000017FE  320E                     835                  MOVE.W      A6, D1           ; move n into D1
00001800  103C 0001                836                  MOVE.B      #1, D0           ; display n characters of string at A1
00001804  4E4F                     837                  TRAP        #15              ; is trap task 1
00001806  4CDF 0203                838                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
0000180A  4E75                     839                  RTS                          ; returns
0000180C                           840      
0000180C                           841  * Prints null terminated string
0000180C                           842  * input: string pointed to by A5
0000180C                           843  * output: prints out the null terminated string
0000180C  48E7 8040                844  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001810  224D                     845                  MOVE.L      A5,A1           ; loads A5 into A1
00001812  103C 000E                846                  MOVE.B      #14,D0          ; prints null terminated string
00001816  4E4F                     847                  TRAP        #15             ; is trap task 10
00001818  4CDF 0201                848                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
0000181C  4E75                     849                  RTS                         ; returns from subroutine
0000181E                           850                  
0000181E  2F0D                     851  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001820  4BF9 000019EF            852                  LEA         NEW_LINE,A5     ; Prints null
00001826  4EB8 180C                853                  JSR         PRINTNULL       ; prints the new line
0000182A  2A5F                     854                  MOVE.L      (SP)+,A5        ; returns A5
0000182C  4E75                     855                  RTS
0000182E                           856  
0000182E                           857  * Prints the size of the MOVE or MOVEA operation  
0000182E                           858  * input: D0
0000182E                           859  * output: prints out the size of a MOVE or MOVEA operation        
0000182E  48E7 8004                860  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001832  3200                     861                  MOVE.W  D0,D1               ; stores d0 in d1
00001834  C07C 3000                862                  AND.W   #$3000,D0           ; gets the size
00001838  B07C 2000                863                  CMP.W   #$2000,D0           ; checks if is long
0000183C  6700 001E                864                  BEQ     MOVE_LONG
00001840  B07C 3000                865                  CMP.W   #$3000,D0           ; checks if is word
00001844  6700 000C                866                  BEQ     MOVE_WORD      
00001848                           867                  
00001848  4BF9 00001AFA            868  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
0000184E  6000 0012                869                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001852                           870  
00001852  4BF9 00001B00            871  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001858  6000 0008                872                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000185C                           873  
0000185C  4BF9 00001B06            874  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001862                           875                  
00001862  4EB8 180C                876  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001866  4CDF 2001                877                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
0000186A  4E75                     878                  RTS
0000186C                           879  
0000186C  43F9 000019D3            880  ERROR           LEA     ERROR_MSG,A1
00001872  103C 000E                881                  MOVE.B  #14,D0
00001876  4E4F                     882                  TRAP    #15 
00001878                           883         
00001878                           884  * DELETE THIS: Test                
00001878  2661                     885  DELETEME        MOVEA.L  -(A1),A3
0000187A  6700 000A                886                  BEQ      DELETEMEAGAIN  
0000187E  6F00 0006                887                  BLE      DELETEMEAGAIN
00001882  6E00 0002                888                  BGT      DELETEMEAGAIN        
00001886                           889                  
00001886                           890  DELETEMEAGAIN                 
00001886                           891            
00001886  FFFF FFFF                892      SIMHALT             ; halt simulator
0000188A                           893  
0000188A                           894  * Put variables and constants here
0000188A                           895  
0000188A  =0000000D                896  CR                              EQU     $0D
0000188A  =0000000A                897  LF                              EQU     $0A 
0000188A  =00000009                898  TAB                             EQU     $09  
0000188A                           899  
0000188A                           900  * Addressing Modes
0000188A  =00000000                901  Dn                              EQU     0
0000188A  =00000001                902  An                              EQU     1
0000188A  =00000002                903  AnIndirect                      EQU     2
0000188A  =00000003                904  AnPost                          EQU     3
0000188A  =00000004                905  AnPre                           EQU     4
0000188A  =00000007                906  Other                           EQU     7           ; short, long, immediate
0000188A                           907  
0000188A                           908  * Xn
0000188A  =00000000                909  ABSShort                        EQU     0
0000188A  =00000001                910  ABSLong                         EQU     1
0000188A  =00000004                911  XnImmediate                     EQU     4
0000188A                           912  
0000188A                           913  * Valid Addressing Modes
0000188A= 00 01 02 03 04 07 FF     914  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001891                           915  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001891= 00 01 02 03 04 07 FF     916  VALIDEA_MOVE_DEST               DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1 * DELETE THIS, REPLACE WITH VALIDEA_ALL
00001898= 00 02 03 04 07 FF        917  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000189E= 02 04 07 FF              918  VALIDEA_MOVEM                   DC.B    AnIndirect,AnPre,Other,-1
000018A2= 02 03 07 FF              919  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
000018A6= 02 03 04 07 FF           920  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
000018AB= 00 02 03 04 07 FF        921  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000018B1= 01 07 FF                 922  VALIDEA_LEA                     DC.B    An,Other,-1
000018B4= 00 02 03 04 07 FF        923  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000018BA= 02 03 04 07 FF           924  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
000018BF= 02 03 04 07 FF           925  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR
000018C4= 02 07 FF                 926  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
000018C7                           927  
000018C7                           928  * Valid Xn
000018C7= 00 01 04 FF              929  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
000018CB                           930  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
000018CB= 00 01 FF                 931  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
000018CE                           932  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
000018CE                           933  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
000018CE                           934  
000018CE                           935  
000018CE                           936  * Starting messages
000018CE= 57 65 6C 63 6F 6D ...    937  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
000018F5= 46 6F 72 6D 61 74 ...    938                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001944= 50 6C 65 61 73 65 ...    939  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
0000197B= 50 6C 65 61 73 65 ...    940  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
000019B1= 49 6E 76 61 6C 69 ...    941  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
000019D3= 45 72 72 6F 72 20 ...    942  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
000019EF= 0D 0A 00                 943  NEW_LINE                        DC.B    CR,LF,0
000019F2                           944  
000019F2                           945  * Opcode Messages
000019F2= 09 4E 4F 50 00           946  MSG_NOP                         DC.B    TAB,'NOP',0
000019F7= 09 4D 4F 56 45 00        947  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000019FD= 09 4D 4F 56 45 41 00     948  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001A04= 09 4D 4F 56 45 51 00     949  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001A0B= 09 4D 4F 56 45 4D 00     950  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001A12= 09 41 44 44 00           951  MSG_ADD                         DC.B    TAB,'ADD',0
00001A17= 09 41 44 44 41 00        952  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001A1D= 09 41 44 44 51 00        953  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001A23= 09 53 55 42 00           954  MSG_SUB                         DC.B    TAB,'SUB',0
00001A28= 09 4D 55 4C 53 00        955  MSG_MULS                        DC.B    TAB,'MULS',0
00001A2E= 09 44 49 56 55 00        956  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001A34= 09 4C 45 41 09 09 ...    957  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001A3C= 09 41 4E 44 00           958  MSG_AND                         DC.B    TAB,'AND',0
00001A41= 09 4F 52 00              959  MSG_OR                          DC.B    TAB,'OR',0
00001A45= 09 4E 4F 54 00           960  MSG_NOT                         DC.B    TAB,'NOT',0
00001A4A= 09 4C 53 4C 00           961  MSG_LSL                         DC.B    TAB,'LSL',0
00001A4F= 09 4C 53 52 00           962  MSG_LSR                         DC.B    TAB,'LSR',0
00001A54= 09 41 53 4C 00           963  MSG_ASL                         DC.B    TAB,'ASL',0
00001A59= 09 41 53 52 00           964  MSG_ASR                         DC.B    TAB,'ASR',0
00001A5E= 09 42 43 43 09 09 ...    965  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001A66= 09 42 43 53 09 09 ...    966  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001A6E= 09 42 45 51 09 09 ...    967  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001A76= 09 42 4E 45 09 09 ...    968  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001A7E= 09 42 47 45 09 09 ...    969  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001A86= 09 42 47 54 09 09 ...    970  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001A8E= 09 42 48 49 09 09 ...    971  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001A96= 09 42 4C 45 09 09 ...    972  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001A9E= 09 42 4C 53 09 09 ...    973  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001AA6= 09 42 4C 54 09 09 ...    974  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001AAE= 09 42 4D 49 09 09 ...    975  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001AB6= 09 42 50 4C 09 09 ...    976  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001ABE= 09 42 56 43 09 09 ...    977  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001AC6= 09 42 56 53 09 09 ...    978  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001ACE= 09 4A 53 52 09 09 ...    979  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001AD6= 09 52 54 53 00           980  MSG_RTS                         DC.B    TAB,'RTS',0
00001ADB= 09 42 52 41 09 09 ...    981  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001AE3                           982  
00001AE3                           983  * Effective Addresses Messages
00001AE3= 44 00                    984  MSG_DR                          DC.B    'D',0
00001AE5= 41 00                    985  MSG_AR                          DC.B    'A',0
00001AE7= 28 00                    986  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001AE9= 29 00                    987  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001AEB= 2B 00                    988  MSG_PLUS                        DC.B    '+',0
00001AED= 2D 00                    989  MSG_MINUS                       DC.B    '-',0
00001AEF= 23 00                    990  MSG_POUND                       DC.B    '#',0 
00001AF1= 24 00                    991  MSG_HEX                         DC.B    '$',0 
00001AF3= 2C 20 00                 992  MSG_COMMA                       DC.B    ', ',0 
00001AF6= 20 00                    993  MSG_SPACE                       DC.B    ' ',0
00001AF8= 09 00                    994  MSG_TAB                         DC.B    TAB,0
00001AFA                           995  
00001AFA                           996  * Size Messages
00001AFA= 2E 42 09 09 09 00        997  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001B00= 2E 57 09 09 09 00        998  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001B06= 2E 4C 09 09 09 00        999  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001B0C                          1000  
00001B0C                          1001  * Variables
00001B0C  =00000100               1002  STARTING_ADDRESS                EQU     $100
00001B0C  =00000150               1003  ENDING_ADDRESS                  EQU     $150
00001B0C  =00000200               1004  CURRENT_INSTR                   EQU     $200
00001B0C  =00000250               1005  REG_VAR                         EQU     $250 * Hold bits 11-9
00001B0C  =00000300               1006  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001B0C  =00000350               1007  EA_MODE                         EQU     $350 * Hold bits 5-3
00001B0C  =00000400               1008  EA_REG                          EQU     $400 * Hold bits 2-0
00001B0C                          1009  
00001B0C                          1010              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_SIZE           1356
ADDR_111_JUMP_TABLE  15B6
ADDR_MODE_000       155E
ADDR_MODE_001       1566
ADDR_MODE_010       156E
ADDR_MODE_011       1576
ADDR_MODE_100       157E
ADDR_MODE_101       1586
ADDR_MODE_110       158C
ADDR_MODE_111       1592
ADDR_MODE_JUMP_TABLE  152E
AN                  1
AND_SIZE            1396
ANINDIRECT          2
ANPOST              3
ANPRE               4
BAD_INPUT           19B1
CASE_ADD            132C
CASE_ADDA           1338
CASE_ADDQ           1362
CASE_AND            1362
CASE_AR             16CA
CASE_ARI            16E2
CASE_ARIPOST        1712
CASE_ARIPRE         174E
CASE_ASL            1488
CASE_ASR            1488
CASE_BCC            14AC
CASE_BEQ            14DA
CASE_BGT            14FA
CASE_BLE            14EA
CASE_BRA            1488
CASE_DATA           152A
CASE_DIVU           1362
CASE_DR             16B2
CASE_EPICFAIL       152C
CASE_IMMEDIATE      179C
CASE_JSR            1514
CASE_LEA            1362
CASE_LONG           17C4
CASE_LSL            1488
CASE_LSR            1488
CASE_MOVE           1198
CASE_MOVEM          1260
CASE_MOVEQ          1260
CASE_MULS           1362
CASE_NOP            1182
CASE_NOT            1488
CASE_OR             1488
CASE_OTHER          178A
CASE_RTS            1514
CASE_SUB            1362
CASE_WORD           17B4
CHECKDEST           11C2
CHECKEAEXIT         1682
CHECKEAMLOOP        1654
CHECKEAXN_IFVALID   1652
CHECKMOVE_XN        124A
CHECK_LENGTH        10DC
CHECK_ODD           1172
CHECK_ORDER         109A
CONCAT              1124
CONVERT             10EE
CR                  D
CURRENT_INSTR       200
DELETEME            1878
DELETEMEAGAIN       1886
DESTEA              15EA
DESTXN              1614
DEST_DN             13BA
DEST_EA             1434
DISASSEMBLE         10B6
DN                  0
EAMOVE_INVALID      1244
EAMOVE_VALID        11E0
EA_MODE             350
EA_REG              400
EA_TO_STRING        1686
EA_TO_STRING_EXIT   17D0
ENDING              197B
ENDING_ADDRESS      150
ERROR               186C
ERROR_MSG           19D3
FINDTYPEEA          15FE
FINDTYPEXN          1628
FIND_EA             1410
FINISHMOVE          1862
FIRST_NIBBLE_9      129A
FIRST_NIBBLE_C      129A
FIRST_NIBBLE_D      12B8
GETDISPLACEMENT     1634
GET_EA              15E0
GET_NIBBLE1         1260
GET_NIBBLE2         127E
GET_VARS            12D8
GET_XN              160A
INPUT1              100C
INPUT2              1052
INSERTA             1210
INVALID             113C
INVALIDEA           1666
ISNUMBER            1104
LF                  A
MOVE_BYTE           1848
MOVE_LONG           185C
MOVE_WORD           1852
MSG_ADD             1A12
MSG_ADDA            1A17
MSG_ADDQ            1A1D
MSG_AND             1A3C
MSG_AR              1AE5
MSG_ASL             1A54
MSG_ASR             1A59
MSG_B               1AFA
MSG_BCC             1A5E
MSG_BCS             1A66
MSG_BEQ             1A6E
MSG_BGE             1A7E
MSG_BGT             1A86
MSG_BHI             1A8E
MSG_BLE             1A96
MSG_BLS             1A9E
MSG_BLT             1AA6
MSG_BMI             1AAE
MSG_BNE             1A76
MSG_BPL             1AB6
MSG_BRA             1ADB
MSG_BVC             1ABE
MSG_BVS             1AC6
MSG_COMMA           1AF3
MSG_DIVU            1A2E
MSG_DR              1AE3
MSG_HEX             1AF1
MSG_JSR             1ACE
MSG_L               1B06
MSG_LB              1AE7
MSG_LEA             1A34
MSG_LSL             1A4A
MSG_LSR             1A4F
MSG_MINUS           1AED
MSG_MOVE            19F7
MSG_MOVEA           19FD
MSG_MOVEM           1A0B
MSG_MOVEQ           1A04
MSG_MULS            1A28
MSG_NOP             19F2
MSG_NOT             1A45
MSG_OR              1A41
MSG_PLUS            1AEB
MSG_POUND           1AEF
MSG_RB              1AE9
MSG_RTS             1AD6
MSG_SPACE           1AF6
MSG_SUB             1A23
MSG_TAB             1AF8
MSG_W               1B00
NEW_LINE            19EF
NIBBLE1_JUMP        1288
NOTNUMBER           110C
OPCODE_DECODE       117A
OPMODE_VAR          300
OTHER               7
OTHEREA             167E
PREPARE             10A4
PRINTADDRESS        1644
PRINTBCCDIS         150A
PRINTENTER          181E
PRINTMOVE           1216
PRINTMOVESIZE       182E
PRINTNULL           180C
PRINTNUM            17D6
PRINTRANGE          17F6
PRINTSHORTLONGNUM   17E6
PRINT_BYTE          15B6
PRINT_LONG          15D2
PRINT_WORD          15C4
REG_VAR             250
RESET_INPUT         10D4
RETURN              113A
SOURCEEA            15F6
SOURCEXN            1620
START               1000
STARTING            1944
STARTING_ADDRESS    100
STOP                10CE
TAB                 9
TEST_RANGE          115A
VALIDEA             166E
VALIDEA_ADDSUB_DESTOPERAND  18A6
VALIDEA_ALL         188A
VALIDEA_ANDORNOT    18B4
VALIDEA_ANDOR_DESTOPERAND  18BA
VALIDEA_JSR         18C4
VALIDEA_LEA         18B1
VALIDEA_MOVEM       189E
VALIDEA_MOVEM_MEMTOREG  18A2
VALIDEA_MOVEQ       1898
VALIDEA_MOVE_DEST   1891
VALIDEA_MULSDIVU    18AB
VALIDEA_SHIFT       18BF
VALIDXN_ALL         18C7
VALIDXN_SHORTLONG   18CB
WELCOME             18CE
XNIMMEDIATE         4
