00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/8/2020 3:41:28 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00002155             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 0000217D             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 000021C8             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000021E8             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 00001146             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 00001158             36                  JSR     CONVERT
00001052  4EB9 000011C4             37                  JSR     TEST_RANGE
00001058  4EB9 000011DC             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 0000221F             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 00001146             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 00001158             55                  JSR     CONVERT
0000109A  4EB9 000011C4             56                  JSR     TEST_RANGE
000010A0  4EB9 000011DC             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0088                 64                  BLT     RESET_INPUT
000010B8                            65                                 
000010B8                            66  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010B8                            67                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010B8                            68                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010B8  4EB9 000011F0             69                  JSR     OPCODE_DECODE       ; decode the opcode
000010BE  4EB9 0000207E             70                  JSR     PRINTENTER          ; prints a new line
000010C4  B5CB                      71                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010C6  6FF0                      72                  BLE     DISASSEMBLE         ; if not, loop
000010C8                            73  
000010C8  4BF9 000022A2             74  FINISHED        LEA     DONE,A5
000010CE  4EB9 0000206C             75                  JSR     PRINTNULL
000010D4  103C 0005                 76                  MOVE.B  #5,D0
000010D8  4E4F                      77                  TRAP    #15
000010DA                            78                  
000010DA  B23C 000D                 79                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010DE  6700 0008                 80                  BEQ     RESTART             ; it's Enter, restart
000010E2                            81                  
000010E2  103C 0009                 82                  MOVE.B  #9,D0
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  103C 000B                 85  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010EC  323C FF00                 86                  MOVE.W  #$FF00, D1          Clear Screen
000010F0  4E4F                      87                  TRAP    #15                 Call Trap
000010F2                            88                  
000010F2  103C 000C                 89                  MOVE.B  #12,D0              Keyboard echo
000010F6  123C 0001                 90                  MOVE.B  #1,D1               Visible
000010FA  4E4F                      91                  TRAP    #15
000010FC                            92                  
000010FC  207C 00000000             93                  MOVE.L  #$0000000, A0       ; Reset A1
00001102  227C 00000000             94                  MOVE.L  #$0000000, A1       ; Reset A1
00001108  247C 00000000             95                  MOVE.L  #$0000000, A2       ; Reset A2
0000110E  267C 00000000             96                  MOVE.L  #$0000000, A3       ; Reset A3
00001114  287C 00000000             97                  MOVE.L  #$0000000, A4       ; Reset A4
0000111A  2A7C 00000000             98                  MOVE.L  #$0000000, A5       ; Reset A5
00001120  2C7C 00000000             99                  MOVE.L  #$0000000, A6       ; Reset A6
00001126  2E7C 01000000            100                  MOVEA.L #$01000000,A7       ; Reset A7
0000112C  4281                     101                  CLR.L   D1                  ; Reset D1
0000112E  4281                     102                  CLR.L   D1                  ; Reset D1
00001130  4282                     103                  CLR.L   D2                  ; Reset D2
00001132  4283                     104                  CLR.L   D3                  ; Reset D3
00001134  4284                     105                  CLR.L   D4                  ; Reset D4
00001136  4285                     106                  CLR.L   D5                  ; Reset D5
00001138  4286                     107                  CLR.L   D6                  ; Reset D6
0000113A  6000 FEC4                108                  BRA     START               ; branch to start of program
0000113E                           109  
0000113E                           110  *--------------------SUBROUTINES------------------    
0000113E                           111  
0000113E  143C 0001                112  RESET_INPUT     MOVE.B  #1,D2
00001142  6000 0062                113                  BRA     INVALID            
00001146                           114                  
00001146  7800                     115  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001148  B204                     116                  CMP.B   D4,D1               ; D1 stores length
0000114A  6700 005A                117                  BEQ     INVALID             ; input is null
0000114E  0C41 0008                118                  CMPI    #$8,D1              ; check if input is longer than a longword
00001152  6600 0052                119                  BNE     INVALID             ; input is longer than a longword
00001156  4E75                     120                  RTS
00001158                           121                              
00001158  4283                     122  CONVERT         CLR.L   D3
0000115A  4284                     123                  CLR.L   D4
0000115C  1619                     124                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000115E  B63C 0039                125                  CMP.B   #57,D3
00001162  6E00 0012                126                  BGT     NOTNUMBER
00001166                           127                  
00001166  B63C 002F                128                  CMP.B   #47,D3
0000116A  6E00 0002                129                  BGT     ISNUMBER
0000116E                           130                  
0000116E  0603 00D0                131  ISNUMBER        ADD.B   #-48,D3             ; current char is number
00001172  6000 001A                132                  BRA     CONCAT
00001176                           133              
00001176  B63C 0041                134  NOTNUMBER       CMP.B   #65,D3
0000117A  6D00 002A                135                  BLT     INVALID
0000117E  B63C 0046                136                  CMP.B   #70,D3
00001182  6E00 0022                137                  BGT     INVALID  
00001186  0603 00C9                138                  ADD.B   #-55,D3             ; is letter             
0000118A  6000 0002                139                  BRA     CONCAT
0000118E                           140              
0000118E  BC3C 0000                141  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001192  6D00 0010                142                  BLT     RETURN
00001196  1806                     143                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001198  E50C                     144                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
0000119A  E9AB                     145                  LSL.L   D4,D3               ; moves current char to correct position  
0000119C  DA83                     146                  ADD.L   D3,D5               ; D5 stores converted input so far
0000119E  0606 00FF                147                  ADD.B   #-1,D6  
000011A2  60B4                     148                  BRA     CONVERT             ; continue loop for remaining chars
000011A4                           149                  
000011A4  4E75                     150  RETURN          RTS
000011A6                           151                  
000011A6  227C 00000000            152  INVALID         MOVEA.L #$0000000, A1       ; clear A1
000011AC  43F9 00002255            153                  LEA     BAD_INPUT,A1        ; output invalid message
000011B2  103C 000E                154                  MOVE.B  #14,D0
000011B6  4E4F                     155                  TRAP    #15
000011B8  B47C 0001                156                  CMP     #1,D2
000011BC  6700 FE62                157                  BEQ     INPUT1
000011C0  6000 FEA4                158                  BRA     INPUT2
000011C4                           159  
000011C4  4284                     160  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011C6  223C 00001000            161                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011CC  BA81                     162                  CMP.L      D1,D5            ; Compare minimum address with input
000011CE  6DD6                     163                  BLT        INVALID          ; input is too low. 
000011D0  223C 00FFFFFE            164                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011D6  BA81                     165                  CMP.L      D1,D5            ; compare maximum address with input
000011D8  6ECC                     166                  BGT        INVALID          ; input too large
000011DA  4E75                     167                  RTS                         ; input is within range
000011DC                           168             
000011DC  0805 0000                169  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011E0  66C4                     170                  BNE        INVALID
000011E2  4E75                     171                  RTS
000011E4                           172  
000011E4                           173  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
000011E4                           174  *                MOVE.L  A6,D1                   ; loads current address in D1
000011E4                           175  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E4                           176  *                JSR     PRINTSHORTLONGNUM       ; prints out address
000011E4                           177  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
000011E4                           178  *                RTS
000011E4  220E                     179                  MOVE.L  A6,D1                   ; loads current address in D1
000011E6  7801                     180                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E8  4EB9 00001F46            181                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011EE  4E75                     182                  RTS
000011F0                           183  
000011F0                           184  
000011F0                           185  
000011F0                           186  * Checks every single possible opcode we could have. Jump table
000011F0                           187  * Inputs: (A2) which is a pointer to intruction word to be translated
000011F0                           188  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011F0                           189  
000011F0  3C4A                     190  OPCODE_DECODE   MOVE.W  A2,A6
000011F2  301A                     191                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011F4                           192                  
000011F4                           193  
000011F4                           194  *---------------NOP opcode----------------------                
000011F4  B07C 4E71                195  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011F8  6600 0014                196                  BNE     CASE_MOVE               ; checks the next case if not equal
000011FC                           197                  
000011FC  4EB8 11E4                198                  JSR     PRINT_ADDR
00001200  4BF9 000022DB            199                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001206  4EB9 0000206C            200                  JSR     PRINTNULL               ; prints NOP                
0000120C  4E75                     201                  RTS                             ; returns from the subroutine
0000120E                           202  
0000120E                           203  *---------------MOVE opcode----------------------              
0000120E                           204                  * if first two bits are 00, next two are not 00
0000120E  3200                     205  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001210  C27C C000                206                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001214  6600 009E                207                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001218  B07C 0FFF                208                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
0000121C  6F00 0096                209                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001220                           210                  
00001220                           211                  ; Check source
00001220  4BF9 00002118            212                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001226  4DF9 0000214E            213                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000122C  3E3C 0000                214                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001230  4EB9 00001C38            215                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001236  B27C 0001                216                  CMP.W   #1,D1                    ; checks if invalid
0000123A  6700 09A0                217                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000123E  3802                     218                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
00001240  3A03                     219                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001242                           220                  
00001242                           221                  ; Check destination
00001242  4BF9 00002118            222                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001248  4DF9 00002152            223                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000124E  3E3C 0001                224                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001252  4EB9 00001C38            225                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001258  B27C 0001                226                  CMP.W   #1,D1                    ; checks if invalid
0000125C  6700 097E                227                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001260  3C02                     228                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001262  3E03                     229                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001264                           230                  
00001264                           231                  ; Checking if it is MOVEA
00001264  3200                     232                  MOVE.W  D0,D1                    ; stores d0 in d1
00001266  C27C 01C0                233                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
0000126A  B27C 0040                234                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000126E  6700 0010                235                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001272                           236                  
00001272  4EB8 11E4                237                  JSR     PRINT_ADDR               ; print address
00001276  4BF9 000022E0            238                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
0000127C  6000 0008                239                  BRA     PRINTMOVE                ; Branches to print move
00001280                           240                  
00001280  4BF9 000022E6            241  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001286                           242   
00001286  4EB9 0000206C            243  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
0000128C  4EB9 0000208E            244                  JSR     PRINTMOVESIZE            ; prints out the size  
00001292  3404                     245                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001294  3605                     246                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001296  4EB9 00001DA6            247                  JSR     EA_TO_STRING             ; outputs it into a string
0000129C                           248                  
0000129C                           249                  ; prints a comma to seperate
0000129C  4BF9 000023D8            250                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000012A2  4EB9 0000206C            251                  JSR     PRINTNULL                ; prints out MOVE
000012A8                           252                  
000012A8                           253                  ; print destination
000012A8  3406                     254                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
000012AA  3607                     255                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
000012AC  4EB9 00001DA6            256                  JSR     EA_TO_STRING             ; outputs it into a string
000012B2  4E75                     257                  RTS                              ; exits subroutine                 
000012B4                           258                
000012B4                           259  *---------------MOVEM opcode----------------------                
000012B4  3200                     260  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012B6  C27C FB80                261                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012BA  B27C 4880                262                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012BE  6600 00F4                263                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012C2                           264                  
000012C2                           265                  ; Check D
000012C2  3200                     266                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012C4  C27C 0400                267                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012C8  3E01                     268                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012CA  B27C 0400                269                  CMP.W   #$0400,D1                       ; checks if value is 1
000012CE  6700 0074                270                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012D2                           271  
000012D2                           272  MOVEM_REG2MEM   ; loads EA and XN
000012D2  3E3C 0000                273                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000012D6  4BF9 00002125            274                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
000012DC  4DF9 00002152            275                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000012E2  4EB9 00001C38            276                  JSR     CHECKGET_EAXN
000012E8  B27C 0001                277                  CMP.W   #1,D1                           ; checks if D1 invalid
000012EC  6700 08EE                278                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000012F0  4EB8 11E4                279                  JSR     PRINT_ADDR                      ; prints the address
000012F4  4BF9 000022F4            280                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000012FA  4EB9 0000206C            281                  JSR     PRINTNULL                       ; prints MOVEM
00001300                           282                  
00001300                           283                  ; finds and prints size
00001300  3200                     284                  MOVE.W  D0,D1                           ; copies D0
00001302  C27C 0040                285                  AND.W   #$0040,D1                       ; gets the size bit
00001306  6600 0012                286                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
0000130A                           287  
0000130A  4BF9 000023E7            288  REG2MEMWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001310  4EB9 0000206C            289                  JSR     PRINTNULL                       ; prints MOVEM
00001316  6000 000E                290                  BRA     PRINTREG2MEM                    ; prints the registers           
0000131A                           291                  
0000131A  4BF9 000023ED            292  REG2MEMLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001320  4EB9 0000206C            293                  JSR     PRINTNULL                       ; prints MOVEM 
00001326                           294             
00001326  383C 0001                295  PRINTREG2MEM    MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
0000132A  4EB9 00001CD0            296                  JSR     PRINTREGISTERS                  ; prints registers
00001330  4BF9 000023D8            297                  LEA     MSG_COMMA,A5                    ; loads comma
00001336  4EB9 0000206C            298                  JSR     PRINTNULL                       ; prints comma
0000133C  4EB9 00001DA6            299                  JSR     EA_TO_STRING                    ; prints EA
00001342  4E75                     300                  RTS
00001344                           301  
00001344                           302  MOVEM_MEM2REG  ; loads EA and XN
00001344  3E3C 0000                303                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001348  4BF9 00002129            304                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
0000134E  4DF9 00002152            305                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001354  4EB9 00001C38            306                  JSR     CHECKGET_EAXN
0000135A  B27C 0001                307                  CMP.W   #1,D1                           ; checks if D1 invalid
0000135E  6700 087C                308                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001362  4EB8 11E4                309                  JSR     PRINT_ADDR                      ; prints the address
00001366  4BF9 000022F4            310                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000136C  4EB9 0000206C            311                  JSR     PRINTNULL                       ; prints MOVEM
00001372                           312                  
00001372                           313                  ; finds and prints size
00001372  3200                     314                  MOVE.W  D0,D1                           ; copies D0
00001374  C27C 0040                315                  AND.W   #$0040,D1                       ; gets the size bit
00001378  6600 0010                316                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
0000137C                           317  
0000137C  4BF9 000023E7            318  MEM2REGWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001382  4EB9 0000206C            319                  JSR     PRINTNULL                       ; prints MOVEM
00001388  609C                     320                  BRA     PRINTREG2MEM                    ; prints the registers           
0000138A                           321                  
0000138A  4BF9 000023ED            322  MEM2REGLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001390  4EB9 0000206C            323                  JSR     PRINTNULL                       ; prints MOVEM 
00001396                           324             
00001396  4EB9 00001DA6            325  PRINTMEM2REG    JSR     EA_TO_STRING                    ; prints EA
0000139C  4BF9 000023D8            326                  LEA     MSG_COMMA,A5                    ; loads comma
000013A2  4EB9 0000206C            327                  JSR     PRINTNULL                       ; prints comma
000013A8  383C FFFF                328                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
000013AC  4EB9 00001CD0            329                  JSR     PRINTREGISTERS                  ; prints registers
000013B2  4E75                     330                  RTS
000013B4                           331                          
000013B4                           332  
000013B4                           333  *---------------MOVEQ opcode----------------------
000013B4  3200                     334  CASE_MOVEQ      MOVE.W  D0,D1
000013B6  C27C F100                335                  AND.W   #$F100,D1
000013BA  B27C 7000                336                  CMP.W   #$7000,D1
000013BE  6600 004C                337                  BNE     CASE_ADD
000013C2                           338                  
000013C2                           339                  ;loads Register
000013C2  323C 0001                340                  MOVE.W  #1,D1                           ; copies instruction word to D1
000013C6  4EB9 00001C0E            341                  JSR     GET_XN                          ; gets XN and puts in D1
000013CC  3401                     342                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000013CE                           343                  
000013CE                           344                  ;loads DATA
000013CE  3200                     345                  MOVE.W  D0,D1
000013D0  C27C 00FF                346                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000013D4  3601                     347                  MOVE.W  D1,D3                          ;copy data into D3
000013D6                           348                                                        ;must convert bits to hex
000013D6                           349                                  
000013D6  4EB8 11E4                350  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
000013DA                           351  
000013DA  4BF9 000022ED            352                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000013E0  4EB9 0000206C            353                  JSR     PRINTNULL  
000013E6                           354                  
000013E6  4BF9 000023ED            355                  LEA     MSG_L,A5                        ;PRINT SIZE L
000013EC  4EB9 0000206C            356                  JSR     PRINTNULL
000013F2                           357      
000013F2  4BF9 000022D7            358                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000013F8  4EB9 0000206C            359                  JSR     PRINTNULL
000013FE                           360                  
000013FE  4BF9 000023D4            361                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
00001404  4EB9 0000206C            362                  JSR     PRINTNULL
0000140A  4E75                     363                  RTS
0000140C                           364                  
0000140C                           365  *---------------ADD opcode----------------------                
0000140C                           366  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
0000140C  3200                     367  CASE_ADD        MOVE.W  D0,D1
0000140E  C27C F000                368                  AND.W   #$F000,D1
00001412  B27C D000                369                  CMP.W   #$D000,D1
00001416  6600 01A2                370                  BNE     CASE_ADDQ
0000141A                           371   
0000141A  4EB8 11E4                372                  JSR     PRINT_ADDR              ; print address
0000141E                           373                  
0000141E  4EB9 00001438            374                  JSR     ADD_SUB_HELP
00001424                           375                  
00001424                           376                  ; bits 7-8 determine if it is ADDA or ADD
00001424  3200                     377                  MOVE.W  D0,D1
00001426  E149                     378                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001428  E049                     379                  LSR.W   #8,D1
0000142A  EC49                     380                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000142C  B27C 0003                381                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001430  6700 0120                382                  BEQ     CASE_ADDA
00001434                           383                  
00001434  6000 0048                384                  BRA     PRINTADD                ; Branches to print add
00001438                           385                  
00001438                           386                  ; Check bits 0-5 
00001438  4BF9 00002118            387  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000143E  4DF9 0000214E            388                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001444  3E3C 0000                389                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001448  4EB9 00001C38            390                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000144E  B27C 0001                391                  CMP.W       #1,D1                    ; checks if invalid
00001452  6700 0788                392                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001456  3802                     393                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001458  3A03                     394                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000145A                           395                  
0000145A                           396                  ; Check 6-11
0000145A  4BF9 00002118            397                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001460  4DF9 00002152            398                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001466  3E3C 0001                399                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000146A  4EB9 00001C38            400                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001470  B27C 0001                401                  CMP.W       #1,D1                    ; checks if invalid
00001474  6700 0766                402                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001478  3C02                     403                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
0000147A  3E03                     404                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
0000147C                           405    
0000147C  4E75                     406                  RTS                
0000147E                           407                    
0000147E  4BF9 000022FB            408  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001484  4EB9 0000206C            409                  JSR         PRINTNULL               ; print ADD
0000148A  3200                     410                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000148C  4EB9 00001496            411                  JSR         ADD_SUB_SIZE
00001492  6000 0050                412                  BRA         FINISH_ADD
00001496                           413                    
00001496  3200                     414  ADD_SUB_SIZE    MOVE.W      D0,D1
00001498  E149                     415                  LSL.W       #8,D1
0000149A  E049                     416                  LSR.W       #8,D1
0000149C  EC49                     417                  LSR.W       #6,D1                   ; gets bits 6-7
0000149E                           418                    
0000149E  B27C 0000                419                  CMP.W       #0,D1
000014A2  6700 0016                420                  BEQ         ADD_SUB_BYTE
000014A6  B27C 0001                421                  CMP.W       #1,D1                   ; if 1, it is a word
000014AA  6700 001C                422                  BEQ         ADD_SUB_WORD
000014AE  B27C 0002                423                  CMP.W       #2,D1                   ; if 2, it is a long
000014B2  6700 0022                424                  BEQ         ADD_SUB_LONG
000014B6  6000 0254                425                  BRA         CASE_SUBA                    ; error
000014BA                           426                    
000014BA  4BF9 000023E1            427  ADD_SUB_BYTE    LEA         MSG_B,A5
000014C0  4EB9 0000206C            428                  JSR         PRINTNULL
000014C6  4E75                     429                  RTS
000014C8                           430                    
000014C8  4BF9 000023E7            431  ADD_SUB_WORD    LEA         MSG_W,A5
000014CE  4EB9 0000206C            432                  JSR         PRINTNULL
000014D4  4E75                     433                  RTS
000014D6                           434    
000014D6  4BF9 000023ED            435  ADD_SUB_LONG    LEA         MSG_L,A5
000014DC  4EB9 0000206C            436                  JSR         PRINTNULL
000014E2  4E75                     437                  RTS
000014E4                           438        
000014E4  4EB9 000014EC            439  FINISH_ADD      JSR         ADD_SUB_OPERAND
000014EA  4E75                     440                  RTS
000014EC                           441    
000014EC  EF49                     442  ADD_SUB_OPERAND LSL.W       #7,D1
000014EE  EE49                     443                  LSR.W       #7,D1
000014F0  E049                     444                  LSR.W       #8,D1
000014F2  B27C 0001                445                  CMP.W       #1,D1
000014F6  6600 002E                446                  BNE         Dn_PLUS_EA          
000014FA                           447                    
000014FA                           448                  ; print Data Register
000014FA  4BF9 000023C8            449                  LEA         MSG_DR,A5
00001500  4EB9 0000206C            450                  JSR         PRINTNULL
00001506  3207                     451                  MOVE.W      D7,D1
00001508  4EB9 00001F22            452                  JSR         PRINTNUM                
0000150E                           453                  
0000150E                           454                  ; prints a comma to seperate
0000150E  4BF9 000023D8            455                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001514  4EB9 0000206C            456                  JSR         PRINTNULL                ; prints out MOVE
0000151A                           457                 
0000151A                           458                  ; below is EA+Dn->Dn  
0000151A  3404                     459                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000151C  3605                     460                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000151E  4EB9 00001DA6            461                  JSR         EA_TO_STRING             ; outputs it into a string
00001524  4E75                     462                  RTS                                 ; exits subroutine 
00001526                           463  
00001526                           464  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001526  3404                     465                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001528  3605                     466                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000152A  4EB9 00001DA6            467                  JSR         EA_TO_STRING             ; outputs it into a string   
00001530                           468                  
00001530                           469                  ; prints a comma to seperate
00001530  4BF9 000023D8            470                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001536  4EB9 0000206C            471                  JSR         PRINTNULL                ; prints out MOVE
0000153C                           472                  
0000153C                           473                  ; below is Dn+EA->EA
0000153C  4BF9 000023C8            474                  LEA         MSG_DR,A5                ; print data register
00001542  4EB9 0000206C            475                  JSR         PRINTNULL
00001548  3207                     476                  MOVE.W      D7,D1
0000154A  4EB9 00001F22            477                  JSR         PRINTNUM             
00001550  4E75                     478                  RTS                                  ; exits subroutine          
00001552                           479                        
00001552                           480  *---------------ADDA opcode----------------------
00001552                           481  CASE_ADDA       ; gets bit 8 (size bit)
00001552  3200                     482                  MOVE.W      D0,D1
00001554  EF49                     483                  LSL.W       #7,D1
00001556  EE49                     484                  LSR.W       #7,D1
00001558  E049                     485                  LSR         #8,D1                   
0000155A                           486                  
0000155A  4BF9 00002300            487                  LEA         MSG_ADDA,A5             ; print ADDA
00001560  4EB9 0000206C            488                  JSR         PRINTNULL
00001566                           489                   
00001566  B27C 0001                490                  CMP.W       #1,D1
0000156A  6700 0012                491                  BEQ         ADDA_LONG
0000156E                           492                    
0000156E  4BF9 000023E7            493                  LEA         MSG_W,A5
00001574  4EB9 0000206C            494                  JSR         PRINTNULL
0000157A  6000 0012                495                  BRA         FINISH_ADDA   
0000157E                           496                    
0000157E  4BF9 000023ED            497  ADDA_LONG       LEA         MSG_L,A5
00001584  4EB9 0000206C            498                  JSR         PRINTNULL
0000158A  6000 0002                499                  BRA         FINISH_ADDA
0000158E                           500                    
0000158E  3404                     501  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001590  3605                     502                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001592  4EB9 00001DA6            503                  JSR         EA_TO_STRING             ; outputs it into a string
00001598                           504                    
00001598                           505                  ; prints a comma to seperate
00001598  4BF9 000023D8            506                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000159E  4EB9 0000206C            507                  JSR         PRINTNULL                ; prints out MOVE
000015A4                           508            
000015A4  4BF9 000023CA            509                  LEA         MSG_AR,A5                ; print address register
000015AA  4EB9 0000206C            510                  JSR         PRINTNULL
000015B0  3207                     511                  MOVE.W      D7,D1
000015B2  4EB9 00001F22            512                  JSR         PRINTNUM             
000015B8  4E75                     513                  RTS                              ; exits subroutine
000015BA                           514                  
000015BA                           515  *---------------ADDQ opcode----------------------                  
000015BA  3200                     516  CASE_ADDQ       MOVE.W      D0,D1
000015BC  C27C F000                517                  AND.W       #$F000,D1       
000015C0  B27C 5000                518                  CMP.W       #$5000,D1
000015C4  6600 00CC                519                  BNE         CASE_SUB
000015C8                           520                                                   
000015C8  4EB8 11E4                521                  JSR         PRINT_ADDR              ; print address  
000015CC  4BF9 00002306            522                  LEA         MSG_ADDQ,A5             ; print ADDQ
000015D2  4EB9 0000206C            523                  JSR         PRINTNULL
000015D8                           524                  
000015D8                           525                  ; get bits 6-7 (size bits)
000015D8  3200                     526                  MOVE.W      D0,D1
000015DA  E149                     527                  LSL.W       #8,D1
000015DC  E049                     528                  LSR.W       #8,D1
000015DE  EC49                     529                  LSR.W       #6,D1
000015E0  3401                     530                  MOVE.W      D1,D2
000015E2                           531                  
000015E2                           532                  ; Check bits 0-5 
000015E2  4BF9 00002118            533                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000015E8  4DF9 0000214E            534                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000015EE  3E3C 0000                535                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000015F2  4EB9 00001C38            536                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000015F8  B27C 0001                537                  CMP.W       #1,D1                    ; checks if invalid
000015FC  6700 05DE                538                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001600  3802                     539                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001602  3A03                     540                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001604                           541                  
00001604  B47C 0001                542                  CMP.W       #1,D2
00001608  6700 001A                543                  BEQ         ADDQ_WORD
0000160C  B47C 0002                544                  CMP.W       #2,D2
00001610  6700 0022                545                  BEQ         ADDQ_LONG
00001614                           546                    
00001614  4BF9 000023E1            547  ADDQ_BYTE       LEA         MSG_B,A5
0000161A  4EB9 0000206C            548                  JSR         PRINTNULL
00001620  6000 0022                549                  BRA         FINISH_ADDQ  
00001624                           550   
00001624  4BF9 000023E7            551  ADDQ_WORD       LEA         MSG_W,A5
0000162A  4EB9 0000206C            552                  JSR         PRINTNULL
00001630  6000 0012                553                  BRA         FINISH_ADDQ                 
00001634                           554    
00001634  4BF9 000023ED            555  ADDQ_LONG       LEA         MSG_L,A5
0000163A  4EB9 0000206C            556                  JSR         PRINTNULL
00001640  6000 0002                557                  BRA         FINISH_ADDQ                  
00001644                           558                    
00001644  4EB9 00001662            559  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000164A                           560   
0000164A                           561                  ; prints a comma to seperate
0000164A  4BF9 000023D8            562                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001650  4EB9 0000206C            563                  JSR         PRINTNULL                ; prints out MOVE
00001656                           564                    
00001656                           565                  ; prints destination
00001656  3404                     566                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001658  3605                     567                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000165A  4EB9 00001DA6            568                  JSR         EA_TO_STRING             ; outputs it into a string
00001660                           569                 
00001660  4E75                     570                  RTS
00001662                           571   
00001662  4BF9 000023D4            572  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
00001668  4EB9 0000206C            573                  JSR         PRINTNULL
0000166E                           574                  ; gets bits 9-11 (data bits)
0000166E  E949                     575                  LSL.W       #4,D1
00001670  E849                     576                  LSR.W       #4,D1                               ; get rid of left 4 bits
00001672  E049                     577                  LSR.W       #8,D1
00001674  E249                     578                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001676                           579                  
00001676  B27C 0000                580                  CMP.W       #0,D1
0000167A  6700 000A                581                  BEQ         PRINT_8
0000167E  4EB9 00001F22            582                  JSR         PRINTNUM
00001684  4E75                     583                  RTS 
00001686                           584  
00001686  123C 0008                585  PRINT_8         MOVE.B      #8,D1
0000168A  4EB9 00001F22            586                  JSR         PRINTNUM
00001690  4E75                     587                  RTS   
00001692                           588         
00001692                           589  *---------------SUB opcode---------------------- 
00001692  3200                     590  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
00001694  C27C F000                591                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001698  B27C 9000                592                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000169C  6600 0084                593                  BNE         CASE_LEA
000016A0                           594                 
000016A0  4EB8 1438                595                  JSR         ADD_SUB_HELP
000016A4  4EB8 11E4                596                  JSR         PRINT_ADDR                          ; print address               
000016A8                           597                  
000016A8  6000 0002                598                  BRA         PRINTSUB                            ; Branches to print move
000016AC                           599  
000016AC  4BF9 0000230C            600  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
000016B2  4EB9 0000206C            601                  JSR         PRINTNULL
000016B8  3200                     602                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000016BA  4EB8 1496                603                  JSR         ADD_SUB_SIZE
000016BE  3200                     604                  MOVE.W      D0,D1
000016C0  E149                     605                  LSL.W       #8,D1
000016C2  E049                     606                  LSR.W       #8,D1
000016C4  EC49                     607                  LSR.W       #6,D1
000016C6  B27C 0003                608                  CMP.W       #3,D1
000016CA  6600 0006                609                  BNE         FINISH_SUB
000016CE  6000 0008                610                  BRA         FINISH_SUBA                         ; same as ADDA
000016D2                           611                  
000016D2  4EB8 14EC                612  FINISH_SUB      JSR     ADD_SUB_OPERAND
000016D6  4E75                     613                  RTS
000016D8                           614                    
000016D8  3404                     615  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016DA  3605                     616                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016DC  4EB9 00001DA6            617                  JSR         EA_TO_STRING             ; outputs it into a string
000016E2                           618                
000016E2                           619                  ; prints a comma to seperate
000016E2  4BF9 000023D8            620                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016E8  4EB9 0000206C            621                  JSR         PRINTNULL                ; prints out MOVE
000016EE                           622          
000016EE  4BF9 000023CA            623                  LEA         MSG_AR,A5                ; print address register
000016F4  4EB9 0000206C            624                  JSR         PRINTNULL
000016FA  3200                     625                  MOVE.W      D0,D1
000016FC  E949                     626                  LSL.W       #4,D1
000016FE  E849                     627                  LSR.W       #4,D1
00001700  E049                     628                  LSR.W       #8,D1
00001702  E249                     629                  LSR.W       #1,D1
00001704  4EB9 00001F22            630                  JSR         PRINTNUM             
0000170A  4E75                     631                  RTS                              ; exits subroutine
0000170C                           632  
0000170C                           633  
0000170C                           634  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000170C  3200                     635  CASE_SUBA       MOVE.W      D0,D1
0000170E  EF49                     636                  LSL.W       #7,D1
00001710  EE49                     637                  LSR.W       #7,D1
00001712  E049                     638                  LSR.W       #8,D1
00001714  B23C 0000                639                  CMP.B       #0,D1
00001718  6700 FDAE                640                  BEQ         ADD_SUB_WORD
0000171C  6000 FDB8                641                  BRA         ADD_SUB_LONG
00001720  4E75                     642                  RTS         
00001722                           643                   
00001722  3200                     644  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001724  C27C F000                645                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001728  B27C 4000                646                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000172C  6600 0086                647                  BNE.W   CASE_AND                             ; If its not, check AND
00001730  3200                     648                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001732  C27C 01C0                649                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001736  B27C 01C0                650                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000173A  6600 0078                651                  BNE.W   CASE_AND                             ; If its not, check AND
0000173E                           652                  
0000173E                           653                  ; Check source
0000173E  4BF9 00002138            654                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001744  4DF9 00002152            655                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000174A  3E3C 0000                656                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
0000174E  4EB9 00001C38            657                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001754  3802                     658                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001756  3A03                     659                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001758                           660                  
00001758                           661                  ; Check destination
00001758  4BF9 00002138            662                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000175E  4DF9 00002152            663                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001764  3E3C 0001                664                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
00001768  4EB9 00001C38            665                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000176E  3C02                     666                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001770  3E03                     667                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001772                           668  
00001772  4BF9 0000231D            669                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
00001778  4EB9 0000206C            670                  JSR     PRINTNULL                            ; prints LEA
0000177E                           671                  
0000177E                           672                  ; print source
0000177E  3404                     673                  MOVE.W  D4,D2
00001780  3605                     674                  MOVE.W  D5,D3
00001782  4EB9 00001DA6            675                  JSR     EA_TO_STRING                         ; Prints out the EA
00001788                           676                  
00001788                           677                  ; comma
00001788  4BF9 000023D8            678                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
0000178E  4EB9 0000206C            679                  JSR     PRINTNULL                       
00001794                           680                   
00001794                           681                  ; register
00001794  4BF9 000023CA            682                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
0000179A  4EB9 0000206C            683                  JSR     PRINTNULL 
000017A0  3401                     684                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000017A2  323C 0001                685                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000017A6  4EB9 00001C0E            686                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000017AC  4EB9 00001F22            687                  JSR     PRINTNUM                             ; Prints the number in D1
000017B2  4E75                     688                  RTS
000017B4                           689  
000017B4                           690  *---------------AND opcode----------------------
000017B4  3200                     691  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017B6  C27C F000                692                  AND.W       #$F000,D1       
000017BA  B27C C000                693                  CMP.W       #$C000,D1
000017BE  6600 009E                694                  BNE         CASE_OR
000017C2                           695                  
000017C2  3200                     696                  MOVE.W      D0,D1
000017C4  E149                     697                  LSL.W       #8,D1
000017C6  E049                     698                  LSR.W       #8,D1
000017C8  EC49                     699                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000017CA  3C01                     700                  MOVE.W      D1,D6
000017CC  BC7C 0003                701                  CMP.W       #3,D6
000017D0  6700 0066                702                  BEQ         INV_INSTR
000017D4                           703                  
000017D4  4EB8 11E4                704                  JSR         PRINT_ADDR                      ; print address
000017D8  4BF9 00002325            705                  LEA         MSG_AND,A5                      ; print AND
000017DE  4EB9 0000206C            706                  JSR         PRINTNULL
000017E4                           707                  
000017E4  3206                     708                  MOVE.W      D6,D1
000017E6  B27C 0000                709                  CMP.W       #0,D1
000017EA  6700 0012                710                  BEQ         AND_BYTE
000017EE  B27C 0001                711                  CMP.W       #1,D1                   ; if 1, it is a word
000017F2  6700 001A                712                  BEQ         AND_WORD
000017F6  B27C 0002                713                  CMP.W       #2,D1                   ; if 2, it is a long
000017FA  6700 0022                714                  BEQ         AND_LONG
000017FE                           715                  
000017FE  4BF9 000023E1            716  AND_BYTE        LEA         MSG_B,A5
00001804  4EB9 0000206C            717                  JSR         PRINTNULL
0000180A  6000 0022                718                  BRA         FINISH_AND
0000180E                           719                                    
0000180E  4BF9 000023E7            720  AND_WORD        LEA         MSG_W,A5
00001814  4EB9 0000206C            721                  JSR         PRINTNULL
0000181A  6000 0012                722                  BRA         FINISH_AND
0000181E                           723    
0000181E  4BF9 000023ED            724  AND_LONG        LEA         MSG_L,A5
00001824  4EB9 0000206C            725                  JSR         PRINTNULL
0000182A  6000 0002                726                  BRA         FINISH_AND
0000182E                           727        
0000182E  4EB8 1438                728  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001832  4EB8 14EC                729                  JSR         ADD_SUB_OPERAND
00001836  4E75                     730                  RTS
00001838                           731                  
00001838  4BF9 00002293            732  INV_INSTR       LEA         INVALID_INSTR,A5
0000183E  4EB9 0000206C            733                  JSR         PRINTNULL
00001844  2200                     734                  MOVE.L      D0,D1
00001846  383C 0000                735                  MOVE.W      #0,D4
0000184A  4EB9 00001F46            736                  JSR         PRINTSHORTLONGNUM
00001850  4BF9 000022D4            737                  LEA         NEW_LINE,A5
00001856  4EB9 0000206C            738                  JSR         PRINTNULL
0000185C  4E75                     739                  RTS               
0000185E                           740                  
0000185E                           741  *---------------OR opcode----------------------            
0000185E  3200                     742  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001860  C27C F000                743                  AND.W       #$F000,D1       
00001864  B27C 8000                744                  CMP.W       #$8000,D1
00001868  6600 004C                745                  BNE         CASE_NOT
0000186C                           746                                                
0000186C  3200                     747                  MOVE.W      D0,D1
0000186E  E149                     748                  LSL.W       #8,D1
00001870  E049                     749                  LSR.W       #8,D1
00001872  EC49                     750                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001874  B27C 0003                751                  CMP.W       #3,D1
00001878  3C01                     752                  MOVE.W      D1,D6
0000187A  67BC                     753                  BEQ         INV_INSTR
0000187C                           754                  
0000187C  4EB8 11E4                755                  JSR         PRINT_ADDR                      ; print address
00001880                           756                  
00001880  4BF9 0000232A            757                  LEA         MSG_OR,A5
00001886  4EB9 0000206C            758                  JSR         PRINTNULL                       ; print "OR"
0000188C                           759                  
0000188C  3206                     760                  MOVE.W      D6,D1
0000188E  4EB9 0000189E            761                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001894  4EB8 1438                762                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001898  4EB8 14EC                763                  JSR         ADD_SUB_OPERAND                 ; print 
0000189C  4E75                     764                  RTS
0000189E                           765  
0000189E  B27C 0000                766  OR_SIZE         CMP.W       #0,D1
000018A2  6700 FC16                767                  BEQ         ADD_SUB_BYTE
000018A6  B27C 0001                768                  CMP.W       #1,D1                   ; if 1, it is a word
000018AA  6700 FC1C                769                  BEQ         ADD_SUB_WORD
000018AE  B27C 0002                770                  CMP.W       #2,D1                   ; if 2, it is a long
000018B2  6700 FC22                771                  BEQ         ADD_SUB_LONG
000018B6                           772                  ; no need for rts, since ADD_SUB_ already has                
000018B6                           773  
000018B6                           774  *---------------NOT opcode----------------------
000018B6  3200                     775  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018B8  C27C FF00                776                  AND.W       #$FF00,D1       
000018BC  B27C 4600                777                  CMP.W       #$4600,D1
000018C0  6600 0050                778                  BNE         CASE_LSDASDROD
000018C4                           779                 
000018C4                           780                  ; get bits 6-7 (size)
000018C4  3200                     781                  MOVE.W      D0,D1
000018C6  E149                     782                  LSL.W       #8,D1
000018C8  E049                     783                  LSR.W       #8,D1
000018CA  EC49                     784                  LSR.W       #6,D1 
000018CC  3C01                     785                  MOVE.W      D1,D6                         
000018CE  BC7C 0003                786                  CMP.W       #3,D6
000018D2  6700 FF64                787                  BEQ         INV_INSTR
000018D6                           788                  
000018D6  4EB8 11E4                789                  JSR         PRINT_ADDR
000018DA                           790                  
000018DA  4BF9 0000232E            791                  LEA         MSG_NOT,A5
000018E0  4EB9 0000206C            792                  JSR         PRINTNULL                       ; print "NOT"
000018E6                           793                                 
000018E6  3206                     794                  MOVE.W      D6,D1
000018E8                           795  
000018E8  4EB8 189E                796                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000018EC                           797                  
000018EC                           798                  ; get bits 0-5 
000018EC  4BF9 00002118            799                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000018F2  4DF9 0000214E            800                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000018F8  3E3C 0000                801                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000018FC  4EB9 00001C38            802                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001902  B27C 0001                803                  CMP.W       #1,D1                    ; checks if invalid
00001906  6700 02D4                804                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000190A  4EB9 00001DA6            805                  JSR         EA_TO_STRING             ; outputs it into a string
00001910                           806    
00001910  4E75                     807                  RTS
00001912                           808  
00001912  3200                     809  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001914  C27C F000                810                  AND.W       #$F000, D1                       ; gets first 4 bits
00001918  B27C E000                811                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
0000191C  6600 0218                812                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001920  3400                     813                  MOVE.W      D0,D2                            ; copies D0 to D2
00001922  4EB9 00001CC0            814                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001928  B47C 0003                815                  CMP.W       #$3, D2                          ; checks if it is memory or register option
0000192C  6600 00CC                816                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001930                           817                  
00001930  3400                     818  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001932  4EB9 00001CAE            819                  JSR         GETROTATION                      ; gets rotation value of D2
00001938  B47C 0000                820                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
0000193C  6700 0014                821                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001940  B47C 0003                822                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001944  6700 0016                823                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001948                           824                  
00001948  4BF9 00002333            825  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
0000194E  6000 0012                826                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001952                           827  
00001952  4BF9 00002337            828  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001958  6000 0008                829                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000195C                           830  
0000195C  4BF9 0000233B            831  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001962                           832                  
00001962  4EB8 11E4                833  PRINTSHIFTMEM   JSR         PRINT_ADDR                       ; prints address
00001966  4EB9 0000206C            834                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
0000196C  3400                     835                  MOVE.W      D0,D2                            ; copies D0 to D2
0000196E  4EB9 00001CB8            836                  JSR         GETDIRECTION                     ; gets direction
00001974  B47C 0000                837                  CMP.W       #0,D2                            ; checking if its right
00001978  6700 000C                838                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
0000197C                           839  
0000197C  4BF9 000023C6            840  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001982  6000 0008                841                  BRA         PRINT_MEMDIR                     ; branches for printing
00001986                           842          
00001986  4BF9 000023C4            843  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
0000198C                           844  
0000198C  4EB9 0000206C            845  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001992  4BF9 000023E7            846                  LEA         MSG_W,A5                         ; loads .W into A5
00001998  4EB9 0000206C            847                  JSR         PRINTNULL                        ; Prints .W
0000199E  6000 0002                848                  BRA         GETMEMSOURCE                     ; checks the source 
000019A2                           849                  
000019A2                           850  ; get source addressing mode       
000019A2                           851  GETMEMSOURCE                                                 
000019A2  323C 0000                852                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
000019A6  4EB9 00001BE4            853                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
000019AC  3801                     854                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
000019AE  323C 0000                855                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
000019B2  4EB9 00001C0E            856                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000019B8  3A01                     857                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000019BA                           858  
000019BA  4BF9 00002146            859  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000019C0  3204                     860                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000019C2  4EB9 00001D72            861                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000019C8  B27C 0002                862                  CMP.W       #2,D1                            ; checks if it is Xn
000019CC  6700 0016                863                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000019D0  B27C 0001                864                  CMP.W       #1,D1                            ; Checks if it is invalid
000019D4  6700 0206                865                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000019D8                           866  
000019D8  3404                     867  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000019DA  3605                     868                  MOVE.W      D5,D3                            ; moves EA to D3
000019DC  4EB9 00001DA6            869                  JSR         EA_TO_STRING                     ; prints out the EA
000019E2  4E75                     870                  RTS                
000019E4                           871                  
000019E4                           872                  
000019E4  4BF9 00002152            873  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000019EA  3205                     874                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000019EC  4EB9 00001D72            875                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000019F2  4A41                     876                  TST.W       D1                               ; checks if it is valid
000019F4  67E2                     877                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000019F6  6000 01E4                878                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000019FA                           879  
000019FA                           880  
000019FA  3602                     881  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000019FC  3200                     882                  MOVE.W      D0,D1                            ; copies D0 to D1
000019FE  C27C 0018                883                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001A02  E649                     884                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001A04  B27C 0000                885                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001A08  6700 0014                886                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001A0C  B27C 0003                887                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001A10  6700 0016                888                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001A14                           889                  
00001A14  4BF9 00002333            890  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001A1A  6000 0012                891                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A1E                           892  
00001A1E  4BF9 00002337            893  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001A24  6000 0008                894                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A28                           895  
00001A28  4BF9 0000233B            896  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001A2E                           897                  
00001A2E  4EB8 11E4                898  PRINTSHIFTREG   JSR         PRINT_ADDR                       ; prints address
00001A32  4EB9 0000206C            899                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001A38  3400                     900                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A3A  4EB9 00001CB8            901                  JSR         GETDIRECTION                     ; gets direction
00001A40  B47C 0000                902                  CMP.W       #0,D2                            ; checking if its right
00001A44  6700 000C                903                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001A48                           904  
00001A48  4BF9 000023C6            905  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001A4E  6000 000C                906                  BRA         PRINT_REGDIR                     ; branches for printing
00001A52                           907          
00001A52  4BF9 000023C4            908  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001A58  6000 0002                909                  BRA         PRINT_REGDIR                     ; branches for printing
00001A5C                           910                  
00001A5C  4EB9 0000206C            911  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001A62                           912  
00001A62  3400                     913  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001A64  4EB9 00001CC0            914                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A6A  B47C 0001                915                  CMP.W       #1,D2                            ; Checks if it is word size
00001A6E  6700 0014                916                  BEQ         REG_WORD                         ; Prints .W
00001A72  B47C 0002                917                  CMP.W       #2,D2                            ; Checks if it is long size
00001A76  6700 0016                918                  BEQ         REG_LONG                         ; Prints .L
00001A7A                           919  
00001A7A  4BF9 000023E1            920  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001A80  6000 0012                921                  BRA         PRINTREGEA      
00001A84                           922  
00001A84  4BF9 000023E7            923  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001A8A  6000 0008                924                  BRA         PRINTREGEA      
00001A8E                           925                             
00001A8E  4BF9 000023ED            926  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001A94                           927  
00001A94  4EB9 0000206C            928  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001A9A  3400                     929                  MOVE.W      D0,D2                            ; copies D0 to D1
00001A9C  4EB9 00001CC8            930                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001AA2  B27C 0001                931                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001AA6  6700 0048                932                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001AAA                           933                                  
00001AAA  3400                     934  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001AAC  4EB9 00001CC0            935                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AB2  3202                     936                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AB4  4BF9 000023D4            937                  LEA         MSG_POUND, A5                    ; loads # into A5
00001ABA  4EB9 0000206C            938                  JSR         PRINTNULL                        ; prints #
00001AC0  4EB9 00001F22            939                  JSR         PRINTNUM                         ; prints shift count
00001AC6  4BF9 000023D8            940                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001ACC  4EB9 0000206C            941                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001AD2  4BF9 000023C8            942                  LEA         MSG_DR, A5                       ; loads D into A5
00001AD8  4EB9 0000206C            943                  JSR         PRINTNULL                        ; prints out D 
00001ADE  323C 0000                944                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001AE2  4EB9 00001C0E            945                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001AE8  4EB9 00001F22            946                  JSR         PRINTNUM                         ; prints data register number in D1          
00001AEE  4E75                     947                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001AF0                           948                  
00001AF0  3400                     949  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001AF2  4EB9 00001CC0            950                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AF8  3202                     951                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AFA  4BF9 000023C8            952                  LEA         MSG_DR, A5                       ; loads D into A5
00001B00  4EB9 0000206C            953                  JSR         PRINTNULL                        ; prints D
00001B06  4EB9 00001F22            954                  JSR         PRINTNUM                         ; prints register number
00001B0C  4BF9 000023D8            955                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001B12  4EB9 0000206C            956                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001B18  4BF9 000023C8            957                  LEA         MSG_DR, A5                       ; loads D into A5
00001B1E  4EB9 0000206C            958                  JSR         PRINTNULL                        ; prints out D 
00001B24  323C 0000                959                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001B28  4EB9 00001C0E            960                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001B2E  4EB9 00001F22            961                  JSR         PRINTNUM                         ; prints data register number in D1          
00001B34  4E75                     962                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001B36                           963               
00001B36  3200                     964  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001B38  C27C FF00                965                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001B3C  B27C 6000                966                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001B40  6600 001C                967                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001B44                           968                  
00001B44  4EB8 11E4                969                  JSR     PRINT_ADDR
00001B48  4BF9 000023BC            970                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001B4E  4EB9 0000206C            971                  JSR     PRINTNULL                            ; prints BRA
00001B54                           972  
00001B54  3400                     973                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001B56  4EB9 00001C80            974                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001B5C  4E75                     975                  RTS
00001B5E                           976                  
00001B5E                           977  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001B5E                           978  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001B5E  3200                     979  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B60  C27C F000                980                  AND.W   #$F000,D1                            ; get top 4 bits
00001B64  B27C 6000                981                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001B68  6600 0058                982                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001B6C  3200                     983                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B6E  C27C 0F00                984                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001B72  E049                     985                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001B74                           986                  
00001B74  B27C 000E                987                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001B78  6700 002A                988                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001B7C                           989                  
00001B7C  B27C 000F                990                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001B80  6700 0018                991                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001B84                           992                      
00001B84  B27C 0007                993                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001B88  6700 0006                994                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001B8C  6000 004E                995                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001B90                           996     
00001B90  4BF9 0000234F            997  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001B96  6000 0016                998                  BRA     PRINTBCC
00001B9A                           999  
00001B9A  4BF9 00002377           1000  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001BA0  6000 000C               1001                  BRA     PRINTBCC
00001BA4                          1002                  
00001BA4  4BF9 00002367           1003  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001BAA  6000 0002               1004                  BRA     PRINTBCC
00001BAE                          1005  
00001BAE  4EB8 11E4               1006  PRINTBCC        JSR     PRINT_ADDR                           ; prints address
00001BB2  4EB9 0000206C           1007                  JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001BB8  3400                    1008                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001BBA  4EB9 00001C80           1009                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001BC0  4E75                    1010                  RTS              
00001BC2                          1011                  
00001BC2                          1012  
00001BC2                          1013  CASE_JSR       
00001BC2                          1014  
00001BC2  B07C 4E75               1015  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001BC6  6600 0014               1016                  BNE     CASE_DATA           ; checks the next case if not equal
00001BCA  4EB8 11E4               1017                  JSR     PRINT_ADDR          ; prints address
00001BCE  4BF9 000023B7           1018                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001BD4  4EB9 0000206C           1019                  JSR     PRINTNULL           ; prints RTS                
00001BDA  4E75                    1020                  RTS                         ; returns from the subroutine
00001BDC                          1021  
00001BDC                          1022                  
00001BDC                          1023  
00001BDC  4EB8 1838               1024  CASE_DATA           JSR INV_INSTR  
00001BE0  4E75                    1025                      RTS               
00001BE2                          1026  
00001BE2  4E75                    1027  CASE_EPICFAIL       RTS
00001BE4                          1028  
00001BE4                          1029  
00001BE4                          1030  * Finds the EA type
00001BE4                          1031  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001BE4                          1032  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001BE4  48E7 3000               1033  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001BE8  4A41                    1034                      TST.W     D1                    ; compares D1 to 0
00001BEA  6700 000E               1035                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001BEE                          1036                      
00001BEE  343C 01C0               1037  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001BF2  363C 0006               1038                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001BF6  6000 000A               1039                      BRA       FINDTYPEEA            
00001BFA                          1040  
00001BFA  343C 0038               1041  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001BFE  363C 0003               1042                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001C02                          1043  
00001C02                          1044  
00001C02  3200                    1045  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001C04  C242                    1046                      AND.W     D2,D1                 ; applies bitmask to D1
00001C06  E669                    1047                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C08  4CDF 000C               1048                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C0C  4E75                    1049                      RTS                             ; returns from subroutine    
00001C0E                          1050                      
00001C0E                          1051  * Finds Xn type
00001C0E                          1052  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001C0E                          1053  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001C0E  48E7 3000               1054  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001C12  4A41                    1055                      TST.W     D1                    ; compares D1 to 0
00001C14  6700 000E               1056                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001C18                          1057  
00001C18  343C 0E00               1058  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001C1C  363C 0009               1059                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001C20  6000 000A               1060                      BRA       FINDTYPEXN            ; finds the type of Xn
00001C24                          1061  
00001C24  343C 0007               1062  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001C28  363C 0000               1063                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001C2C                          1064                      
00001C2C  3200                    1065  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001C2E  C242                    1066                      AND.W     D2,D1                 ; applies bitmask to D1
00001C30  E669                    1067                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C32  4CDF 000C               1068                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C36  4E75                    1069                      RTS                             ; returns from subroutine 
00001C38                          1070                      
00001C38                          1071  * Checks and gets the EA and Xn
00001C38                          1072  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001C38                          1073  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001C38  3207                    1074  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001C3A  4EB8 1BE4               1075                  JSR     GET_EA                  ; Gets EA
00001C3E  3401                    1076                  MOVE.W  D1,D2                   ; Stores EA in D2
00001C40  3207                    1077                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001C42  4EB8 1C0E               1078                  JSR     GET_XN                  ; Gets Xn
00001C46  3601                    1079                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001C48  3202                    1080                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001C4A                          1081                  
00001C4A  4EB9 00001D72           1082                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001C50  B27C 0002               1083                  CMP.W   #2,D1                   ; checks if it is Xn
00001C54  6700 0012               1084                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001C58  B27C 0001               1085                  CMP.W   #1,D1                   ; Checks if it is invalid
00001C5C  6700 001C               1086                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001C60                          1087                  
00001C60                          1088                  
00001C60  323C 0000               1089  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001C64  6000 0018               1090                  BRA     END_CHECKGET
00001C68                          1091        
00001C68                          1092  ; need XN
00001C68  2A4E                    1093  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001C6A  3203                    1094                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001C6C  4EB9 00001D72           1095                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001C72  4A41                    1096                  TST.W   D1                      ; checks if it is valid
00001C74  67EA                    1097                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001C76  6000 0002               1098                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001C7A                          1099   
00001C7A  323C 0001               1100  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001C7E                          1101  
00001C7E  4E75                    1102  END_CHECKGET    RTS          
00001C80                          1103                                            
00001C80                          1104                                            
00001C80                          1105  * Gets the displacement and pritns it 
00001C80                          1106  * Inputs: D2 = instruction word, A2 = address of next word
00001C80                          1107  * Outputs: prints out displacement
00001C80  48E7 4004               1108  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001C84  3A4A                    1109                      MOVE.W    A2,A5                 ; copies A2 to A5
00001C86  C47C 00FF               1110                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001C8A  6600 0004               1111                      BNE       PRINTADDRESS          ; prints address if not 0
00001C8E  341A                    1112                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001C90                          1113                      
00001C90  D44D                    1114  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001C92  3202                    1115                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001C94  183C 0000               1116                      MOVE.B    #0,D4                 ; marks address as word  length
00001C98  4BF9 000023D6           1117                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001C9E  4EB9 0000206C           1118                      JSR       PRINTNULL             ; prints null
00001CA4  4EB9 00001F46           1119                      JSR       PRINTSHORTLONGNUM     ; prints address
00001CAA                          1120                      
00001CAA  4CDF 2002               1121                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001CAE                          1122                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001CAE                          1123  
00001CAE                          1124  * Gets the rotation value for ASd and LSd
00001CAE                          1125  * Input: D2 = instruction word copy (of D0)                                    
00001CAE                          1126  * Output: rotation  value in D2             
00001CAE  C47C 0E00               1127  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001CB2  E04A                    1128                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CB4  E24A                    1129                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001CB6  4E75                    1130                      RTS                             ; return from subroutine
00001CB8                          1131  
00001CB8                          1132  * Gets the direction value for ASd and LSd
00001CB8                          1133  * Input: D2 = instruction word copy (of D0)                                    
00001CB8                          1134  * Output: direction value in D2             
00001CB8  C47C 0100               1135  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001CBC  E04A                    1136                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CBE  4E75                    1137                      RTS                             ; return from subroutine
00001CC0                          1138  
00001CC0                          1139  * Gets the rotation size value for ASd and LSd
00001CC0                          1140  * Input: D2 = instruction word copy (of D0)                                    
00001CC0                          1141  * Output: rotation size value in D2             
00001CC0  C47C 00C0               1142  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001CC4  EC4A                    1143                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CC6  4E75                    1144                      RTS                             ; return from subroutine
00001CC8                          1145  
00001CC8                          1146  * Gets the rotation location  value for ASd and LSd
00001CC8                          1147  * Input: D2 = instruction word copy (of D0)                                    
00001CC8                          1148  * Output: rotation location value in D2             
00001CC8  C47C 0020               1149  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001CCC  EA4A                    1150                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CCE  4E75                    1151                      RTS                             ; return from subroutine
00001CD0                          1152  
00001CD0                          1153  * Prints out registers for MOVEM
00001CD0                          1154  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001CD0                          1155  * Output: printed out registers
00001CD0                          1156  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001CD0  48E7 0706               1157  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001CD4  3A3C 0000               1158                      MOVE.W     #0,D5                ; sets counter to 0
00001CD8  3E1A                    1159                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001CDA  B83C 0001               1160                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001CDE  6600 0010               1161                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001CE2                          1162  
00001CE2  3C3C 0000               1163  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001CE6  4BF9 000023C8           1164                      LEA        MSG_DR,A5            ; loads D to A5
00001CEC  6000 000C               1165                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001CF0                          1166                      
00001CF0  3C3C 0007               1167  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001CF4  4BF9 000023CA           1168                      LEA        MSG_AR,A5            ; loads A to A5
00001CFA                          1169                      
00001CFA  E34F                    1170  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001CFC  6500 0018               1171                      BCS        PRINTREG             ; if pushes out a 1
00001D00  DC44                    1172                      ADD.W      D4,D6                ; decrements or increments
00001D02  5245                    1173                      ADD.W      #1,D5                ; increments D5
00001D04  BA7C 0008               1174                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D08  66F0                    1175                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D0A  B83C 0001               1176                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D0E  6600 0052               1177                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D12  6000 0042               1178                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001D16                          1179                      
00001D16  4EB9 0000206C           1180  PRINTREG            JSR        PRINTNULL
00001D1C  3206                    1181                      MOVE.W     D6,D1
00001D1E  4EB9 00001F22           1182                      JSR        PRINTNUM 
00001D24                          1183    
00001D24  BE7C 0000               1184  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001D28  6600 0006               1185                      BNE        PRINTMORE            ; continue if there is more
00001D2C  6000 0040               1186                      BRA        DONEPRINTINGREG      ; exit case
00001D30                          1187  
00001D30  2C4D                    1188  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001D32  4BF9 000023DB           1189                      LEA        MSG_SLASH,A5         ; leads / into A5
00001D38  4EB9 0000206C           1190                      JSR        PRINTNULL            ; prints the slash
00001D3E  2A4E                    1191                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001D40  DC44                    1192                      ADD.W      D4,D6                ; decrements or increments
00001D42  5245                    1193                      ADD.W      #1,D5                ; increments D5
00001D44  BA7C 0008               1194                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D48  66B0                    1195                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D4A  B83C 0001               1196                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D4E  6600 0012               1197                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D52  6000 0002               1198                      BRA        REGTOMEM2            ; loops
00001D56                          1199  
00001D56  3C3C 0000               1200  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001D5A  4BF9 000023CA           1201                      LEA        MSG_AR,A5            ; loads A to A5
00001D60  6098                    1202                      BRA        PRINTREGISTERLOOP    ; loops
00001D62                          1203  
00001D62  3C3C 0007               1204  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001D66  4BF9 000023C8           1205                      LEA        MSG_DR,A5            ; loads D to A5
00001D6C  608C                    1206                      BRA        PRINTREGISTERLOOP    ; loops
00001D6E                          1207  
00001D6E  4CDF 60E0               1208  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001D72                          1209  
00001D72                          1210                          
00001D72                          1211  * Checks if EA or Xn is valid
00001D72                          1212  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001D72                          1213  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001D72  2F02                    1214  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001D74                          1215  
00001D74  141D                    1216  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001D76  B43C 00FF               1217                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001D7A  6700 000A               1218                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001D7E  B202                    1219                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001D80  6700 000C               1220                     BEQ        VALIDEA               ; branches to valid EA
00001D84  60EE                    1221                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001D86                          1222                     
00001D86  323C 0001               1223  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001D8A  6000 0016               1224                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001D8E                          1225                    
00001D8E  B43C 0007               1226  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001D92  6700 000A               1227                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001D96  323C 0000               1228                     MOVE.W     #$0,D1                ; marks that it is valid
00001D9A  6000 0006               1229                     BRA        CHECKEAEXIT           ; exits the subroutine
00001D9E                          1230  
00001D9E  323C 0002               1231  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001DA2                          1232  
00001DA2  241F                    1233  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001DA4  4E75                    1234                     RTS                              ; returns from subroutine
00001DA6                          1235  
00001DA6                          1236  * Converts EA and Xn into a string                                
00001DA6                          1237  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001DA6                          1238  * Outputs: Prints out EA and Xn into a string
00001DA6  48E7 C004               1239  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001DAA  B47C 0001               1240                     CMP.W    #An,D2                  ; checks if it is An
00001DAE  6700 003A               1241                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001DB2                          1242                     
00001DB2  B47C 0002               1243                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001DB6  6700 004A               1244                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001DBA                          1245                     
00001DBA  B47C 0003               1246                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001DBE  6700 0072               1247                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001DC2                          1248                     
00001DC2  B47C 0004               1249                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001DC6  6700 00A6               1250                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001DCA                          1251                     
00001DCA  B47C 0007               1252                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001DCE  6700 00DA               1253                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001DD2                          1254                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001DD2                          1255  
00001DD2                          1256  * data register, Dn
00001DD2  4BF9 000023C8           1257  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001DD8  4EB9 0000206C           1258                     JSR      PRINTNULL               ; Prints D
00001DDE  3203                    1259                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DE0  4EB9 00001F22           1260                     JSR      PRINTNUM                ; Prints the Xn
00001DE6  6000 0134               1261                     BRA      EA_TO_STRING_EXIT       ; exits           
00001DEA                          1262  
00001DEA                          1263  
00001DEA                          1264  * address register
00001DEA  4BF9 000023CA           1265  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001DF0  4EB9 0000206C           1266                     JSR      PRINTNULL               ; Prints A
00001DF6  3203                    1267                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DF8  4EB9 00001F22           1268                     JSR      PRINTNUM                ; Prints the Xn
00001DFE  6000 011C               1269                     BRA      EA_TO_STRING_EXIT       ; exits
00001E02                          1270  
00001E02                          1271  * address register indirect
00001E02  4BF9 000023CC           1272  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001E08  4EB9 0000206C           1273                     JSR      PRINTNULL               ; Prints (
00001E0E  4BF9 000023CA           1274                     LEA      MSG_AR,A5               ; Loads A into A5
00001E14  4EB9 0000206C           1275                     JSR      PRINTNULL               ; Prints A
00001E1A  3203                    1276                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E1C  4EB9 00001F22           1277                     JSR      PRINTNUM                ; Prints the Xn
00001E22  4BF9 000023CE           1278                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E28  4EB9 0000206C           1279                     JSR      PRINTNULL               ; Prints )
00001E2E  6000 00EC               1280                     BRA      EA_TO_STRING_EXIT       ; exits
00001E32                          1281  
00001E32                          1282  * address register indirect post increment
00001E32  4BF9 000023CC           1283  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001E38  4EB9 0000206C           1284                     JSR      PRINTNULL               ; Prints (
00001E3E  4BF9 000023CA           1285                     LEA      MSG_AR,A5               ; Loads A into A5
00001E44  4EB9 0000206C           1286                     JSR      PRINTNULL               ; Prints A
00001E4A  3203                    1287                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E4C  4EB9 00001F22           1288                     JSR      PRINTNUM                ; Prints the Xn
00001E52  4BF9 000023CE           1289                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E58  4EB9 0000206C           1290                     JSR      PRINTNULL               ; Prints )
00001E5E  4BF9 000023D0           1291                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001E64  4EB9 0000206C           1292                     JSR      PRINTNULL               ; Prints +
00001E6A  6000 00B0               1293                     BRA      EA_TO_STRING_EXIT       ; exits
00001E6E                          1294  
00001E6E                          1295  
00001E6E                          1296  * address register indirect pre increment
00001E6E  4BF9 000023D2           1297  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001E74  4EB9 0000206C           1298                     JSR      PRINTNULL               ; Prints -
00001E7A  4BF9 000023CC           1299                     LEA      MSG_LB,A5               ; Loads ( into A5
00001E80  4EB9 0000206C           1300                     JSR      PRINTNULL               ; Prints (
00001E86  4BF9 000023CA           1301                     LEA      MSG_AR,A5               ; Loads A into A5
00001E8C  4EB9 0000206C           1302                     JSR      PRINTNULL               ; Prints A
00001E92  3203                    1303                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E94  4EB9 00001F22           1304                     JSR      PRINTNUM                ; Prints the Xn
00001E9A  4BF9 000023CE           1305                     LEA      MSG_RB,A5               ; Loads ) into A5
00001EA0  4EB9 0000206C           1306                     JSR      PRINTNULL               ; Prints )
00001EA6  6000 0074               1307                     BRA      EA_TO_STRING_EXIT       ; exits
00001EAA                          1308  
00001EAA                          1309  * other (long, short, immediate) with Xn yes
00001EAA  301A                    1310  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001EAC  B67C 0000               1311                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001EB0  6700 002E               1312                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001EB4                          1313                     
00001EB4  B67C 0001               1314                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001EB8  6700 0042               1315                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001EBC                          1316  
00001EBC                          1317  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001EBC                          1318  * immediate
00001EBC  4BF9 000023D4           1319  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001EC2  4EB9 0000206C           1320                     JSR      PRINTNULL               ; Prints #  
00001EC8  4BF9 000023D6           1321                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001ECE  4EB9 0000206C           1322                     JSR      PRINTNULL               ; Prints $
00001ED4  3200                    1323                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001ED6  4EB9 00001F32           1324                     JSR      PRINTHEXNUM 
00001EDC  6000 003E               1325                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001EE0                          1326                     
00001EE0                          1327  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001EE0                          1328  
00001EE0                          1329  * word address
00001EE0                          1330  CASE_WORD          
00001EE0  4BF9 000023D6           1331                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EE6  4EB9 0000206C           1332                     JSR      PRINTNULL               ; Prints $
00001EEC  3200                    1333                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001EEE  383C 0000               1334                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001EF2  4EB9 00001F46           1335                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001EF8  6000 0022               1336                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001EFC                          1337  
00001EFC                          1338  * long address 
00001EFC                          1339  CASE_LONG          
00001EFC  4BF9 000023D6           1340                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001F02  4EB9 0000206C           1341                     JSR      PRINTNULL               ; Prints $
00001F08  3200                    1342                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001F0A  383C 0001               1343                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001F0E  4EB9 00001F46           1344                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001F14  321A                    1345                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001F16  4EB9 00001F22           1346                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001F1C                          1347  
00001F1C                          1348  
00001F1C                          1349  * exits subroutine
00001F1C  4CDF 2003               1350  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001F20  4E75                    1351                      RTS                              ; returns from subroutine
00001F22                          1352  
00001F22                          1353  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001F22                          1354  
00001F22                          1355  * Prints out the content of D1 as a decimal number
00001F22                          1356  * Input: number in D1 to be printed
00001F22                          1357  * Output: contents of D1 printed
00001F22  48E7 C000               1358  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F26  103C 0003               1359                   MOVE.B      #3,D0               ; prints D1
00001F2A  4E4F                    1360                   TRAP        #15                 ; is trap task 3
00001F2C                          1361              
00001F2C  4CDF 0003               1362                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F30  4E75                    1363                   RTS                             ; returns from subroutine
00001F32                          1364                   
00001F32                          1365  * Prints out the content of D1 as a hex number
00001F32                          1366  * Input: number in D1 to be printed
00001F32                          1367  * Output: contents of D1 printed
00001F32  48E7 C000               1368  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F36  143C 0010               1369                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001F3A  103C 000F               1370                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001F3E  4E4F                    1371                   TRAP        #15                 ; is trap task 15
00001F40  4CDF 0003               1372                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F44  4E75                    1373                   RTS                             ; returns from subroutine
00001F46                          1374                   
00001F46                          1375  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001F46                          1376  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001F46                          1377  * Output: contents of D1 printed
00001F46  48E7 E000               1378  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001F4A  B83C 0001               1379                            CMP.B       #1,D4               ; checks size of number
00001F4E  6700 0042               1380                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001F52                          1381  
00001F52  3401                    1382  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001F54  C47C F000               1383                            AND.W       #$F000,D2           ; gets the first digit
00001F58  B47C 0000               1384                            CMP.W       #0, D2              ; checks if it is 0
00001F5C  6600 00DC               1385                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F60  4EB9 0000204A           1386                            JSR         PRINTZERO           ; prints a zero
00001F66                          1387                            
00001F66  3401                    1388                            MOVE.W      D1,D2               ; copies number to D2
00001F68  C47C 0F00               1389                            AND.W       #$0F00,D2           ; gets the second digit
00001F6C  B47C 0000               1390                            CMP.W       #0, D2              ; checks if it is 0
00001F70  6600 00C8               1391                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F74  4EB9 0000204A           1392                            JSR         PRINTZERO           ; prints a zero
00001F7A                          1393                            
00001F7A  3401                    1394                            MOVE.W      D1,D2               ; copies number to D2
00001F7C  C47C 00F0               1395                            AND.W       #$00F0,D2           ; gets the third digit
00001F80  B47C 0000               1396                            CMP.W       #0, D2              ; checks if it is 0
00001F84  6600 00B4               1397                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F88  4EB9 0000204A           1398                            JSR         PRINTZERO           ; prints a zero
00001F8E  6000 00AA               1399                            BRA         PRINTASHEX          ; prints last digit
00001F92                          1400                            
00001F92  2401                    1401  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001F94  C4BC F0000000           1402                            AND.L       #$F0000000,D2       ; gets the first digit
00001F9A  B4BC 00000000           1403                            CMP.L       #0, D2              ; checks if it is 0
00001FA0  6600 0098               1404                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FA4  4EB9 0000204A           1405                            JSR         PRINTZERO           ; prints a zero
00001FAA                          1406                            
00001FAA  2401                    1407                            MOVE.L      D1,D2               ; copies number to D2
00001FAC  C4BC 0F000000           1408                            AND.L       #$0F000000,D2       ; gets the second digit
00001FB2  B4BC 00000000           1409                            CMP.L       #0, D2              ; checks if it is 0
00001FB8  6600 0080               1410                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FBC  4EB9 0000204A           1411                            JSR         PRINTZERO           ; prints a zero
00001FC2                          1412                            
00001FC2  2401                    1413                            MOVE.L      D1,D2               ; copies number to D2
00001FC4  C4BC 00F00000           1414                            AND.L       #$00F00000,D2       ; gets the third digit
00001FCA  B4BC 00000000           1415                            CMP.L       #0, D2              ; checks if it is 0
00001FD0  6600 0068               1416                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FD4  4EB9 0000204A           1417                            JSR         PRINTZERO           ; prints a zero
00001FDA                          1418                            
00001FDA  2401                    1419                            MOVE.L      D1,D2               ; copies number to D2
00001FDC  C4BC 000F0000           1420                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001FE2  B4BC 00000000           1421                            CMP.L       #0, D2              ; checks if it is 0
00001FE8  6600 0050               1422                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FEC  4EB9 0000204A           1423                            JSR         PRINTZERO           ; prints a zero
00001FF2                          1424                            
00001FF2  2401                    1425                            MOVE.L      D1,D2               ; copies number to D2
00001FF4  C4BC 0000F000           1426                            AND.L       #$0000F000,D2       ; gets the fith digit
00001FFA  B4BC 00000000           1427                            CMP.L       #0, D2              ; checks if it is 0
00002000  6600 0038               1428                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002004  4EB9 0000204A           1429                            JSR         PRINTZERO           ; prints a zero
0000200A                          1430                            
0000200A  2401                    1431                            MOVE.L      D1,D2               ; copies number to D2
0000200C  C4BC 00000F00           1432                            AND.L       #$00000F00,D2       ; gets the sixth digit
00002012  B4BC 00000000           1433                            CMP.L       #0, D2              ; checks if it is 0
00002018  6600 0020               1434                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000201C  4EB9 0000204A           1435                            JSR         PRINTZERO           ; prints a zero
00002022                          1436                            
00002022  2401                    1437                            MOVE.L      D1,D2               ; copies number to D2
00002024  C4BC 000000F0           1438                            AND.L       #$000000F0,D2       ; gets the seventh digit
0000202A  B4BC 00000000           1439                            CMP.L       #0, D2              ; checks if it is 0
00002030  6600 0008               1440                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002034  4EB9 0000204A           1441                            JSR         PRINTZERO           ; prints a zero
0000203A                          1442  
0000203A  143C 0010               1443  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
0000203E  103C 000F               1444                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002042  4E4F                    1445                            TRAP        #15                 ; is trap task 15
00002044  4CDF 0007               1446                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002048  4E75                    1447                            RTS                             ; returns from subroutine    
0000204A                          1448  * Prints a zero
0000204A                          1449  * Input: nothing
0000204A                          1450  * Output: 0 printed out to the console
0000204A  2F01                    1451  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
0000204C  7200                    1452                            MOVE.L      #0,D1               ; moves 0 to D1
0000204E  4EB8 1F22               1453                            JSR         PRINTNUM            ; prints the number
00002052  221F                    1454                            MOVE.L      (SP)+,D1            ; restores D1
00002054  4E75                    1455                            RTS                             ; returns from subroutine
00002056                          1456              
00002056                          1457  * Prints contents of things between a range
00002056                          1458  * input: A5, A6 (the range)
00002056                          1459  * output: prints memory contents from A5 to A6 as strings   
00002056  48E7 C040               1460  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
0000205A  224D                    1461                  MOVEA.L     A5, A1           ; loads A5 into A1
0000205C  9DCD                    1462                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
0000205E  320E                    1463                  MOVE.W      A6, D1           ; move n into D1
00002060  103C 0001               1464                  MOVE.B      #1, D0           ; display n characters of string at A1
00002064  4E4F                    1465                  TRAP        #15              ; is trap task 1
00002066  4CDF 0203               1466                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
0000206A  4E75                    1467                  RTS                          ; returns
0000206C                          1468      
0000206C                          1469  * Prints null terminated string
0000206C                          1470  * input: string pointed to by A5
0000206C                          1471  * output: prints out the null terminated string
0000206C  48E7 8040               1472  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002070  224D                    1473                  MOVE.L      A5,A1           ; loads A5 into A1
00002072  103C 000E               1474                  MOVE.B      #14,D0          ; prints null terminated string
00002076  4E4F                    1475                  TRAP        #15             ; is trap task 10
00002078  4CDF 0201               1476                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
0000207C  4E75                    1477                  RTS                         ; returns from subroutine
0000207E                          1478                  
0000207E  2F0D                    1479  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002080  4BF9 000022D4           1480                  LEA         NEW_LINE,A5     ; Prints null
00002086  4EB8 206C               1481                  JSR         PRINTNULL       ; prints the new line
0000208A  2A5F                    1482                  MOVE.L      (SP)+,A5        ; returns A5
0000208C  4E75                    1483                  RTS
0000208E                          1484  
0000208E                          1485  * Prints the size of the MOVE or MOVEA operation  
0000208E                          1486  * input: D0
0000208E                          1487  * output: prints out the size of a MOVE or MOVEA operation        
0000208E  48E7 8004               1488  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00002092  3200                    1489                  MOVE.W  D0,D1               ; stores d0 in d1
00002094  C07C 3000               1490                  AND.W   #$3000,D0           ; gets the size
00002098  B07C 2000               1491                  CMP.W   #$2000,D0           ; checks if is long
0000209C  6700 001E               1492                  BEQ     MOVE_LONG
000020A0  B07C 3000               1493                  CMP.W   #$3000,D0           ; checks if is word
000020A4  6700 000C               1494                  BEQ     MOVE_WORD      
000020A8                          1495                  
000020A8  4BF9 000023E1           1496  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000020AE  6000 0012               1497                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020B2                          1498  
000020B2  4BF9 000023E7           1499  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000020B8  6000 0008               1500                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020BC                          1501  
000020BC  4BF9 000023ED           1502  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000020C2                          1503                  
000020C2  4EB8 206C               1504  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000020C6  4CDF 2001               1505                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000020CA  4E75                    1506                  RTS
000020CC                          1507  
000020CC  43F9 00002277           1508  ERROR           LEA     ERROR_MSG,A1
000020D2  103C 000E               1509                  MOVE.B  #14,D0
000020D6  4E4F                    1510                  TRAP    #15 
000020D8                          1511         
000020D8                          1512  * DELETE THIS: Test                
000020D8  2661                    1513  DELETEME        MOVEA.L  -(A1),A3
000020DA  6700 0038               1514                  BEQ      DELETEMEAGAIN  
000020DE  6F00 0034               1515                  BLE      DELETEMEAGAIN
000020E2  6E00 0030               1516                  BGT      DELETEMEAGAIN
000020E6                          1517  
000020E6  E40A                    1518                  LSR.B      #2,D2
000020E8  E2E2                    1519                  LSR.W      -(A2)
000020EA  E2DA                    1520                  LSR.W      (A2)+
000020EC  E4AA                    1521                  LSR.L      D2,D2 
000020EE  E50A                    1522                  LSL.B      #2,D2
000020F0  E3E2                    1523                  LSL.W      -(A2)
000020F2  E3DA                    1524                  LSL.W      (A2)+
000020F4  E5AA                    1525                  LSL.L      D2,D2
000020F6  E51A                    1526                  ROL.B      #2,D2
000020F8  E7E2                    1527                  ROL.W      -(A2)
000020FA  E7DA                    1528                  ROL.W      (A2)+
000020FC  E5BA                    1529                  ROL.L      D2,D2
000020FE  E41A                    1530                  ROR.B      #2,D2
00002100  E6E2                    1531                  ROR.W      -(A2)
00002102  E6DA                    1532                  ROR.W      (A2)+
00002104  E4BA                    1533                  ROR.L      D2,D2
00002106                          1534                  
00002106  504D                    1535                  ADDQ.W      #8,A5
00002108  D6C2                    1536                  ADDA.W      D2,A3
0000210A  9BCB                    1537                  SUB.L       A3,A5        
0000210C  8A43                    1538                  OR.W        D3,D5
0000210E  4642                    1539                  NOT.W       D2
00002110                          1540                  
00002110  C5FC 0010               1541                  MULS.W    #$0010,D2
00002114                          1542                  
00002114                          1543  DELETEMEAGAIN                 
00002114                          1544            
00002114  FFFF FFFF               1545      SIMHALT             ; halt simulator
00002118                          1546  
00002118                          1547  * Put variables and constants here
00002118                          1548  
00002118  =0000000D               1549  CR                              EQU     $0D
00002118  =0000000A               1550  LF                              EQU     $0A 
00002118  =00000009               1551  TAB                             EQU     $09  
00002118                          1552  
00002118                          1553  * Addressing Modes
00002118  =00000000               1554  Dn                              EQU     0
00002118  =00000001               1555  An                              EQU     1
00002118  =00000002               1556  AnIndirect                      EQU     2
00002118  =00000003               1557  AnPost                          EQU     3
00002118  =00000004               1558  AnPre                           EQU     4
00002118  =00000007               1559  Other                           EQU     7           ; short, long, immediate
00002118                          1560  
00002118                          1561  * Xn
00002118  =00000000               1562  ABSShort                        EQU     0
00002118  =00000001               1563  ABSLong                         EQU     1
00002118  =00000004               1564  XnImmediate                     EQU     4
00002118                          1565  
00002118                          1566  * Valid Addressing Modes
00002118= 00 01 02 03 04 07 FF    1567  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
0000211F                          1568  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
0000211F= 00 02 03 04 07 FF       1569  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002125= 02 04 07 FF             1570  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002129= 02 03 07 FF             1571  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000212D= 02 03 04 07 FF          1572  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002132= 00 02 03 04 07 FF       1573  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002138= 01 07 FF                1574  VALIDEA_LEA                     DC.B    An,Other,-1
0000213B= 00 02 03 04 07 FF       1575  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002141= 02 03 04 07 FF          1576  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002146= 02 03 04 07 FF          1577  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
0000214B= 02 07 FF                1578  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
0000214E                          1579  
0000214E                          1580  * Valid Xn
0000214E= 00 01 04 FF             1581  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00002152                          1582  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00002152= 00 01 FF                1583  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00002155                          1584  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00002155                          1585  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00002155                          1586  
00002155                          1587  * posible memory ASd/LSd rotation values
00002155  =00000000               1588  ASd_MEM                         EQU     0   
00002155  =00000001               1589  LSd_MEM                         EQU     1 
00002155  =00000003               1590  ROd_MEM                         EQU     3
00002155                          1591   
00002155  =00000000               1592  ASd_REG                         EQU     0   
00002155  =00000001               1593  LSd_REG                         EQU     1 
00002155  =00000003               1594  ROd_REG                         EQU     3
00002155                          1595  
00002155                          1596  * Messages
00002155= 57 65 6C 63 6F 6D ...   1597  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
0000217D= 46 6F 72 6D 61 74 ...   1598  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
000021C8= 4C 65 74 74 65 72 ...   1599  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000021E8= 50 6C 65 61 73 65 ...   1600  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
0000221F= 50 6C 65 61 73 65 ...   1601  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00002255= 49 6E 76 61 6C 69 ...   1602  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002277= 45 72 72 6F 72 20 ...   1603  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00002293= 31 30 30 30 09 09 ...   1604  INVALID_INSTR                   DC.B    '1000',TAB,TAB,'DATA',TAB,TAB,TAB,'$',0
000022A2= 46 69 6E 69 73 68 ...   1605  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
000022D4= 0D 0A 00                1606  NEW_LINE                        DC.B    CR,LF,0
000022D7= 09 09 09 00             1607  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000022DB                          1608  
000022DB                          1609  * Opcode Messages
000022DB= 09 4E 4F 50 00          1610  MSG_NOP                         DC.B    TAB,'NOP',0
000022E0= 09 4D 4F 56 45 00       1611  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000022E6= 09 4D 4F 56 45 41 00    1612  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000022ED= 09 4D 4F 56 45 51 00    1613  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000022F4= 09 4D 4F 56 45 4D 00    1614  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000022FB= 09 41 44 44 00          1615  MSG_ADD                         DC.B    TAB,'ADD',0
00002300= 09 41 44 44 41 00       1616  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002306= 09 41 44 44 51 00       1617  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
0000230C= 09 53 55 42 00          1618  MSG_SUB                         DC.B    TAB,'SUB',0
00002311= 09 4D 55 4C 53 00       1619  MSG_MULS                        DC.B    TAB,'MULS',0
00002317= 09 44 49 56 55 00       1620  MSG_DIVU                        DC.B    TAB,'DIVU',0
0000231D= 09 4C 45 41 09 09 ...   1621  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00002325= 09 41 4E 44 00          1622  MSG_AND                         DC.B    TAB,'AND',0
0000232A= 09 4F 52 00             1623  MSG_OR                          DC.B    TAB,'OR',0
0000232E= 09 4E 4F 54 00          1624  MSG_NOT                         DC.B    TAB,'NOT',0
00002333= 09 4C 53 00             1625  MSG_LSd                         DC.B    TAB,'LS',0
00002337= 09 41 53 00             1626  MSG_ASd                         DC.B    TAB,'AS',0
0000233B= 09 52 4F 00             1627  MSG_ROd                         DC.B    TAB,'RO',0
0000233F= 09 42 43 43 09 09 ...   1628  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00002347= 09 42 43 53 09 09 ...   1629  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
0000234F= 09 42 45 51 09 09 ...   1630  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00002357= 09 42 4E 45 09 09 ...   1631  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
0000235F= 09 42 47 45 09 09 ...   1632  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00002367= 09 42 47 54 09 09 ...   1633  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
0000236F= 09 42 48 49 09 09 ...   1634  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00002377= 09 42 4C 45 09 09 ...   1635  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
0000237F= 09 42 4C 53 09 09 ...   1636  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00002387= 09 42 4C 54 09 09 ...   1637  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
0000238F= 09 42 4D 49 09 09 ...   1638  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00002397= 09 42 50 4C 09 09 ...   1639  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
0000239F= 09 42 56 43 09 09 ...   1640  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
000023A7= 09 42 56 53 09 09 ...   1641  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
000023AF= 09 4A 53 52 09 09 ...   1642  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
000023B7= 09 52 54 53 00          1643  MSG_RTS                         DC.B    TAB,'RTS',0
000023BC= 09 42 52 41 09 09 ...   1644  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
000023C4                          1645  
000023C4                          1646  * Direction for LSd and ASd
000023C4= 52 00                   1647  MSG_RIGHT                       DC.B    'R',0
000023C6= 4C 00                   1648  MSG_LEFT                        DC.B    'L',0
000023C8                          1649  
000023C8                          1650  * Effective Addresses Messages
000023C8= 44 00                   1651  MSG_DR                          DC.B    'D',0
000023CA= 41 00                   1652  MSG_AR                          DC.B    'A',0
000023CC= 28 00                   1653  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000023CE= 29 00                   1654  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000023D0= 2B 00                   1655  MSG_PLUS                        DC.B    '+',0
000023D2= 2D 00                   1656  MSG_MINUS                       DC.B    '-',0
000023D4= 23 00                   1657  MSG_POUND                       DC.B    '#',0 
000023D6= 24 00                   1658  MSG_HEX                         DC.B    '$',0 
000023D8= 2C 20 00                1659  MSG_COMMA                       DC.B    ', ',0
000023DB= 2F 00                   1660  MSG_SLASH                       DC.B    '/',0  
000023DD= 20 00                   1661  MSG_SPACE                       DC.B    ' ',0
000023DF= 09 00                   1662  MSG_TAB                         DC.B    TAB,0
000023E1                          1663  
000023E1                          1664  * Size Messages
000023E1= 2E 42 09 09 09 00       1665  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
000023E7= 2E 57 09 09 09 00       1666  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
000023ED= 2E 4C 09 09 09 00       1667  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
000023F3                          1668  
000023F3                          1669  * Variables
000023F3  =00000100               1670  STARTING_ADDRESS                EQU     $100
000023F3  =00000150               1671  ENDING_ADDRESS                  EQU     $150
000023F3  =00000200               1672  CURRENT_INSTR                   EQU     $200
000023F3  =00000250               1673  REG_VAR                         EQU     $250 * Hold bits 11-9
000023F3  =00000300               1674  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000023F3  =00000350               1675  EA_MODE                         EQU     $350 * Hold bits 5-3
000023F3  =00000400               1676  EA_REG                          EQU     $400 * Hold bits 2-0
000023F3                          1677  
000023F3                          1678              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           157E
ADDQ_BYTE           1614
ADDQ_LONG           1634
ADDQ_WORD           1624
ADD_SUB_BYTE        14BA
ADD_SUB_HELP        1438
ADD_SUB_LONG        14D6
ADD_SUB_OPERAND     14EC
ADD_SUB_SIZE        1496
ADD_SUB_WORD        14C8
AN                  1
AND_BYTE            17FE
AND_LONG            181E
AND_WORD            180E
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           2255
CASE_ADD            140C
CASE_ADDA           1552
CASE_ADDQ           15BA
CASE_AND            17B4
CASE_AR             1DEA
CASE_ARI            1E02
CASE_ARIPOST        1E32
CASE_ARIPRE         1E6E
CASE_ASDMEM         1952
CASE_ASDREG         1A1E
CASE_BCC            1B5E
CASE_BEQ            1B90
CASE_BGT            1BA4
CASE_BLE            1B9A
CASE_BRA            1B36
CASE_DATA           1BDC
CASE_DR             1DD2
CASE_EPICFAIL       1BE2
CASE_IMMEDIATE      1EBC
CASE_JSR            1BC2
CASE_LEA            1722
CASE_LEFTMEM        197C
CASE_LEFTREG        1A48
CASE_LONG           1EFC
CASE_LSDASDROD      1912
CASE_LSDMEM         1948
CASE_LSDREG         1A14
CASE_MOVE           120E
CASE_MOVEM          12B4
CASE_MOVEQ          13B4
CASE_NOP            11F4
CASE_NOT            18B6
CASE_OR             185E
CASE_OTHER          1EAA
CASE_RIGHTMEM       1986
CASE_RIGHTREG       1A52
CASE_RODMEM         195C
CASE_RODREG         1A28
CASE_RTS            1BC2
CASE_SHIFTMEM       1930
CASE_SHIFTREG       19FA
CASE_SUB            1692
CASE_SUBA           170C
CASE_WORD           1EE0
CHECKEAEXIT         1DA2
CHECKEAMLOOP        1D74
CHECKEAXN_IFVALID   1D72
CHECKGET_EAXN       1C38
CHECKMEMSOURE       19BA
CHECKMOREBITS       1D24
CHECKSHIFT_XN       19E4
CHECK_LENGTH        1146
CHECK_ODD           11DC
CHECK_ORDER         10AE
CHECK_XN            1C68
CONCAT              118E
CONVERT             1158
CR                  D
CURRENT_INSTR       200
DELETEME            20D8
DELETEMEAGAIN       2114
DESTEA              1BEE
DESTXN              1C18
DISASSEMBLE         10B8
DN                  0
DN_PLUS_EA          1526
DONE                22A2
DONEPRINTINGREG     1D6E
EASHIFT_VALID       19D8
EAXN_INVALID        1C7A
EAXN_VALID          1C60
EA_MODE             350
EA_REG              400
EA_TO_STRING        1DA6
EA_TO_STRING_EXIT   1F1C
ENDING              221F
ENDING_ADDRESS      150
END_CHECKGET        1C7E
ERROR               20CC
ERROR_MSG           2277
FINDTYPEEA          1C02
FINDTYPEXN          1C2C
FINISHED            10C8
FINISHMOVE          20C2
FINISH_ADD          14E4
FINISH_ADDA         158E
FINISH_ADDQ         1644
FINISH_AND          182E
FINISH_SUB          16D2
FINISH_SUBA         16D8
FORMAT1             217D
FORMAT2             21C8
GETDIRECTION        1CB8
GETDISPLACEMENT     1C80
GETMEMSOURCE        19A2
GETROTATION         1CAE
GETROTATIONLOCATION  1CC8
GETROTATIONSIZE     1CC0
GET_EA              1BE4
GET_XN              1C0E
INPUT1              1020
INPUT2              1066
INSERTA             1280
INVALID             11A6
INVALIDEA           1D86
INVALID_INSTR       2293
INV_INSTR           1838
ISNUMBER            116E
LF                  A
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         138A
MEM2REGWORD         137C
MEMTOREG1           1CF0
MEMTOREG2           1D62
MOVEM_MEM2REG       1344
MOVEM_REG2MEM       12D2
MOVE_BYTE           20A8
MOVE_LONG           20BC
MOVE_WORD           20B2
MSG_ADD             22FB
MSG_ADDA            2300
MSG_ADDQ            2306
MSG_AND             2325
MSG_AR              23CA
MSG_ASD             2337
MSG_B               23E1
MSG_BCC             233F
MSG_BCS             2347
MSG_BEQ             234F
MSG_BGE             235F
MSG_BGT             2367
MSG_BHI             236F
MSG_BLE             2377
MSG_BLS             237F
MSG_BLT             2387
MSG_BMI             238F
MSG_BNE             2357
MSG_BPL             2397
MSG_BRA             23BC
MSG_BVC             239F
MSG_BVS             23A7
MSG_COMMA           23D8
MSG_DIVU            2317
MSG_DR              23C8
MSG_HEX             23D6
MSG_JSR             23AF
MSG_L               23ED
MSG_LB              23CC
MSG_LEA             231D
MSG_LEFT            23C6
MSG_LSD             2333
MSG_MINUS           23D2
MSG_MOVE            22E0
MSG_MOVEA           22E6
MSG_MOVEM           22F4
MSG_MOVEQ           22ED
MSG_MULS            2311
MSG_NOP             22DB
MSG_NOT             232E
MSG_OR              232A
MSG_PLUS            23D0
MSG_POUND           23D4
MSG_RB              23CE
MSG_RIGHT           23C4
MSG_ROD             233B
MSG_RTS             23B7
MSG_SLASH           23DB
MSG_SPACE           23DD
MSG_SUB             230C
MSG_TAB             23DF
MSG_W               23E7
NEW_LINE            22D4
NOTNUMBER           1176
OPCODE_DECODE       11F0
OPMODE_VAR          300
OR_SIZE             189E
OTHER               7
OTHEREA             1D9E
PRINTADD            147E
PRINTADDRESS        1C90
PRINTASHEX          203A
PRINTBCC            1BAE
PRINTENTER          207E
PRINTHEXNUM         1F32
PRINTLONGZERO       1F92
PRINTMEM2REG        1396
PRINTMORE           1D30
PRINTMOVE           1286
PRINTMOVESIZE       208E
PRINTNULL           206C
PRINTNUM            1F22
PRINTRANGE          2056
PRINTREG            1D16
PRINTREG2MEM        1326
PRINTREGEA          1A94
PRINTREGISTERLOOP   1CFA
PRINTREGISTERS      1CD0
PRINTREGSIZE        1A62
PRINTSHIFTMEM       1962
PRINTSHIFTREG       1A2E
PRINTSHORTLONGNUM   1F46
PRINTSHORTZERO      1F52
PRINTSUB            16AC
PRINTZERO           204A
PRINT_8             1686
PRINT_ADDQ_DATA     1662
PRINT_ADDR          11E4
PRINT_MEMDIR        198C
PRINT_MOVEQ         13D6
PRINT_REGDIR        1A5C
REG2MEMLONG         131A
REG2MEMWORD         130A
REGTOMEM1           1CE2
REGTOMEM2           1D56
REG_BYTE            1A7A
REG_IMMEDIATE       1AAA
REG_LONG            1A8E
REG_REGISTER        1AF0
REG_VAR             250
REG_WORD            1A84
RESET_INPUT         113E
RESTART             10E8
RETURN              11A4
ROD_MEM             3
ROD_REG             3
SOURCEEA            1BFA
SOURCEXN            1C24
START               1000
STARTING            21E8
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11C4
THREE_TAB           22D7
VALIDEA             1D8E
VALIDEA_ADDSUB_DESTOPERAND  212D
VALIDEA_ALL         2118
VALIDEA_ANDORNOT    213B
VALIDEA_ANDOR_DESTOPERAND  2141
VALIDEA_JSR         214B
VALIDEA_LEA         2138
VALIDEA_MOVEM_MEMTOREG  2129
VALIDEA_MOVEM_REGTOMEM  2125
VALIDEA_MOVEQ       211F
VALIDEA_MULSDIVU    2132
VALIDEA_SHIFT       2146
VALIDXN_ALL         214E
VALIDXN_SHORTLONG   2152
WELCOME             2155
XNIMMEDIATE         4
