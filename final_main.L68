00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/7/2020 10:04:20 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001F65             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001FDB             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010C2             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010D4             28                  JSR     CONVERT
0000103E  4EB9 00001140             29                  JSR     TEST_RANGE
00001044  4EB9 00001158             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00002012             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010C2             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010D4             47                  JSR     CONVERT
00001086  4EB9 00001140             48                  JSR     TEST_RANGE
0000108C  4EB9 00001158             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0018                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4                            58  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010A4                            59                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A4                            60                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010A4  4EB9 0000116C             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010AA  4EB9 00001E8E             62                  JSR     PRINTENTER          ; prints a new line
000010B0  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010B2  6FF0                      64                  BLE     DISASSEMBLE         ; if not, loop
000010B4                            65  
000010B4  103C 0009                 66  STOP            MOVE.B  #9,D0
000010B8  4E4F                      67                  TRAP    #15
000010BA                            68  
000010BA                            69  *--------------------SUBROUTINES------------------    
000010BA                            70  
000010BA  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010BE  6000 0062                 72                  BRA     INVALID            
000010C2                            73                  
000010C2  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010C4  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010C6  6700 005A                 76                  BEQ     INVALID             ; input is null
000010CA  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010CE  6600 0052                 78                  BNE     INVALID             ; input is longer than a longword
000010D2  4E75                      79                  RTS
000010D4                            80                              
000010D4  4283                      81  CONVERT         CLR.L   D3
000010D6  4284                      82                  CLR.L   D4
000010D8  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010DA  B63C 0039                 84                  CMP.B   #57,D3
000010DE  6E00 0012                 85                  BGT     NOTNUMBER
000010E2                            86                  
000010E2  B63C 002F                 87                  CMP.B   #47,D3
000010E6  6E00 0002                 88                  BGT     ISNUMBER
000010EA                            89                  
000010EA  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010EE  6000 001A                 91                  BRA     CONCAT
000010F2                            92              
000010F2  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
000010F6  6D00 002A                 94                  BLT     INVALID
000010FA  B63C 0046                 95                  CMP.B   #70,D3
000010FE  6E00 0022                 96                  BGT     INVALID  
00001102  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001106  6000 0002                 98                  BRA     CONCAT
0000110A                            99              
0000110A  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000110E  6D00 0010                101                  BLT     RETURN
00001112  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001114  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001116  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001118  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
0000111A  0606 00FF                106                  ADD.B   #-1,D6  
0000111E  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
00001120                           108                  
00001120  4E75                     109  RETURN          RTS
00001122                           110                  
00001122  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001128  43F9 00002048            112                  LEA     BAD_INPUT,A1        ; output invalid message
0000112E  103C 000E                113                  MOVE.B  #14,D0
00001132  4E4F                     114                  TRAP    #15
00001134  B47C 0001                115                  CMP     #1,D2
00001138  6700 FED2                116                  BEQ     INPUT1
0000113C  6000 FF14                117                  BRA     INPUT2
00001140                           118  
00001140  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
00001142  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001148  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
0000114A  6DD6                     122                  BLT        INVALID          ; input is too low. 
0000114C  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
00001152  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
00001154  6ECC                     125                  BGT        INVALID          ; input too large
00001156  4E75                     126                  RTS                         ; input is within range
00001158                           127             
00001158  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
0000115C  66C4                     129                  BNE        INVALID
0000115E  4E75                     130                  RTS
00001160                           131  
00001160  220E                     132  PRINT_ADDR      MOVE.L  A6,D1                   ; loads current address in D1
00001162  7801                     133                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001164  4EB9 00001D56            134                  JSR     PRINTSHORTLONGNUM       ; prints out address
0000116A  4E75                     135                  RTS
0000116C                           136  
0000116C                           137  
0000116C                           138  * Checks every single possible opcode we could have. Jump table
0000116C                           139  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116C                           140  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116C                           141  
0000116C  3C4A                     142  OPCODE_DECODE   MOVE.W  A2,A6
0000116E  301A                     143                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
00001170                           144                  
00001170                           145  
00001170                           146  *---------------NOP opcode----------------------                
00001170  B07C 4E71                147  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001174  6600 0014                148                  BNE     CASE_MOVE               ; checks the next case if not equal
00001178                           149                  
00001178  4EB8 1160                150                  JSR     PRINT_ADDR
0000117C                           151                  
0000117C  4BF9 0000209B            152                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001182  4EB9 00001E7C            153                  JSR     PRINTNULL               ; prints NOP                
00001188  4E75                     154                  RTS                             ; returns from the subroutine
0000118A                           155  
0000118A                           156  *---------------MOVE opcode----------------------              
0000118A                           157                  * if first two bits are 00, next two are not 00
0000118A  3200                     158  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
0000118C  C27C C000                159                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001190  6600 009E                160                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001194  B07C 0FFF                161                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001198  6F00 0096                162                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
0000119C                           163                  
0000119C                           164                  ; Check source
0000119C  4BF9 00001F28            165                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011A2  4DF9 00001F5E            166                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A8  3E3C 0000                167                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011AC  4EB9 00001AEA            168                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011B2  B27C 0001                169                  CMP.W   #1,D1                    ; checks if invalid
000011B6  6700 08DA                170                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011BA  3802                     171                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011BC  3A03                     172                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011BE                           173                  
000011BE                           174                  ; Check destination
000011BE  4BF9 00001F28            175                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011C4  4DF9 00001F62            176                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011CA  3E3C 0001                177                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011CE  4EB9 00001AEA            178                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011D4  B27C 0001                179                  CMP.W   #1,D1                    ; checks if invalid
000011D8  6700 08B8                180                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011DC  3C02                     181                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011DE  3E03                     182                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011E0                           183                  
000011E0                           184                  ; Checking if it is MOVEA
000011E0  3200                     185                  MOVE.W  D0,D1                    ; stores d0 in d1
000011E2  C27C 01C0                186                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011E6  B27C 0040                187                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011EA  6700 0010                188                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011EE                           189                  
000011EE  4EB8 1160                190                  JSR     PRINT_ADDR              ; print address
000011F2                           191   
000011F2  4BF9 000020A0            192                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011F8  6000 0008                193                  BRA     PRINTMOVE                ; Branches to print move
000011FC                           194                  
000011FC  4BF9 000020A6            195  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001202                           196   
00001202  4EB9 00001E7C            197  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001208  4EB9 00001E9E            198                  JSR     PRINTMOVESIZE            ; prints out the size  
0000120E  3404                     199                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001210  3605                     200                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001212  4EB9 00001BB6            201                  JSR     EA_TO_STRING             ; outputs it into a string
00001218                           202                  
00001218                           203                  ; prints a comma to seperate
00001218  4BF9 00002198            204                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000121E  4EB9 00001E7C            205                  JSR     PRINTNULL                ; prints out MOVE
00001224                           206                  
00001224                           207                  ; print destination
00001224  3406                     208                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001226  3607                     209                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001228  4EB9 00001BB6            210                  JSR     EA_TO_STRING             ; outputs it into a string
0000122E  4E75                     211                  RTS                              ; exits subroutine                 
00001230                           212                
00001230                           213  *---------------MOVEM opcode----------------------                
00001230  3200                     214  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001232  C27C FB80                215                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001236  B27C 4880                216                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000123A  6600 005A                217                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000123E                           218                  
0000123E                           219                  ; loads EA and XN
0000123E  323C 0000                220                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001242  4EB9 00001A96            221                  JSR     GET_EA                          ; gets EA and puts in D1
00001248  3401                     222                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
0000124A  323C 0000                223                  MOVE.W  #0,D1                           ; copies instruction word to D1
0000124E  4EB9 00001AC0            224                  JSR     GET_XN                          ; gets XN and puts in D1
00001254  3601                     225                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
00001256                           226                  
00001256                           227                  ; Check D
00001256  3200                     228                  MOVE.W  D0,D1                           ; copies instruction word to D1
00001258  C27C 0400                229                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
0000125C  3E01                     230                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
0000125E  B27C 0400                231                  CMP.W   #$0400,D1                       ; checks if value is 1
00001262  6700 0032                232                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
00001266                           233  
00001266  4BF9 00001F35            234  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000126C  3202                     235                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
0000126E  4EB9 00001B82            236                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001274  B27C 0001                237                  CMP.W   #1,D1                           ; checks if D1 invalid
00001278  6700 0818                238                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000127C  B27C 0002                239                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001280                           240                  
00001280  4BF9 00001F35            241  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001286  3203                     242                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
00001288  4EB9 00001B82            243                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
0000128E  B27C 0001                244                  CMP.W   #1,D1                           ; checks if D1 invalid
00001292  6700 07FE                245                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001296                           246  
00001296                           247                  
00001296                           248  
00001296                           249  MOVEM_MEM2REG    
00001296                           250                          
00001296                           251  
00001296                           252  *---------------MOVEQ opcode----------------------
00001296  3200                     253  CASE_MOVEQ      MOVE.W  D0,D1
00001298  C27C F100                254                  AND.W   #$F100,D1
0000129C  B27C 7000                255                  CMP.W   #$7000,D1
000012A0  6600 004C                256                  BNE     CASE_ADD
000012A4                           257                  
000012A4                           258                  ;loads Register
000012A4  323C 0001                259                  MOVE.W  #1,D1                           ; copies instruction word to D1
000012A8  4EB9 00001AC0            260                  JSR     GET_XN                          ; gets XN and puts in D1
000012AE  3401                     261                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012B0                           262                  
000012B0                           263                  ;loads DATA
000012B0  3200                     264                  MOVE.W  D0,D1
000012B2  C27C 00FF                265                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012B6  3601                     266                  MOVE.W  D1,D3                          ;copy data into D3
000012B8                           267                                                        ;must convert bits to hex
000012B8                           268                                  
000012B8  4EB8 1160                269  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
000012BC                           270  
000012BC  4BF9 000020AD            271                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012C2  4EB9 00001E7C            272                  JSR     PRINTNULL  
000012C8                           273                  
000012C8  4BF9 000021AB            274                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012CE  4EB9 00001E7C            275                  JSR     PRINTNULL
000012D4                           276      
000012D4  4BF9 00002097            277                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000012DA  4EB9 00001E7C            278                  JSR     PRINTNULL
000012E0                           279                  
000012E0  4BF9 00002194            280                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012E6  4EB9 00001E7C            281                  JSR     PRINTNULL
000012EC  4E75                     282                  RTS
000012EE                           283                  
000012EE                           284  *---------------ADD opcode----------------------                
000012EE                           285  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000012EE  3200                     286  CASE_ADD        MOVE.W  D0,D1
000012F0  C27C F000                287                  AND.W   #$F000,D1
000012F4  B27C D000                288                  CMP.W   #$D000,D1
000012F8  6600 01A2                289                  BNE     CASE_ADDQ
000012FC                           290                  
000012FC  4EB8 1160                291                  JSR     PRINT_ADDR              ; print address
00001300                           292                  
00001300  4EB9 0000131A            293                  JSR     ADD_SUB_HELP
00001306                           294                  
00001306                           295                  ; bits 7-8 determine if it is ADDA or ADD
00001306  3200                     296                  MOVE.W  D0,D1
00001308  E149                     297                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000130A  E049                     298                  LSR.W   #8,D1
0000130C  EC49                     299                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000130E  B27C 0003                300                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001312  6700 0120                301                  BEQ     CASE_ADDA
00001316                           302                  
00001316  6000 0048                303                  BRA     PRINTADD                ; Branches to print add
0000131A                           304                  
0000131A                           305                  ; Check bits 0-5 
0000131A  4BF9 00001F28            306  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001320  4DF9 00001F5E            307                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001326  3E3C 0000                308                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000132A  4EB9 00001AEA            309                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001330  B27C 0001                310                  CMP.W       #1,D1                    ; checks if invalid
00001334  6700 075C                311                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001338  3802                     312                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
0000133A  3A03                     313                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000133C                           314                  
0000133C                           315                  ; Check 6-11
0000133C  4BF9 00001F28            316                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001342  4DF9 00001F62            317                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001348  3E3C 0001                318                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000134C  4EB9 00001AEA            319                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001352  B27C 0001                320                  CMP.W       #1,D1                    ; checks if invalid
00001356  6700 073A                321                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000135A  3C02                     322                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
0000135C  3E03                     323                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
0000135E                           324    
0000135E  4E75                     325                  RTS                
00001360                           326                    
00001360  4BF9 000020BB            327  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001366  4EB9 00001E7C            328                  JSR         PRINTNULL               ; print ADD
0000136C  3200                     329                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000136E  4EB9 00001378            330                  JSR         ADD_SUB_SIZE
00001374  6000 0050                331                  BRA         FINISH_ADD
00001378                           332                    
00001378  3200                     333  ADD_SUB_SIZE    MOVE.W      D0,D1
0000137A  E149                     334                  LSL.W       #8,D1
0000137C  E049                     335                  LSR.W       #8,D1
0000137E  EC49                     336                  LSR.W       #6,D1                   ; gets bits 6-7
00001380                           337                    
00001380  B27C 0000                338                  CMP.W       #0,D1
00001384  6700 0016                339                  BEQ         ADD_SUB_BYTE
00001388  B27C 0001                340                  CMP.W       #1,D1                   ; if 1, it is a word
0000138C  6700 001C                341                  BEQ         ADD_SUB_WORD
00001390  B27C 0002                342                  CMP.W       #2,D1                   ; if 2, it is a long
00001394  6700 0022                343                  BEQ         ADD_SUB_LONG
00001398  6000 0254                344                  BRA         CASE_SUBA                    ; error
0000139C                           345                    
0000139C  4BF9 0000219F            346  ADD_SUB_BYTE    LEA         MSG_B,A5
000013A2  4EB9 00001E7C            347                  JSR         PRINTNULL
000013A8  4E75                     348                  RTS
000013AA                           349                    
000013AA  4BF9 000021A5            350  ADD_SUB_WORD    LEA         MSG_W,A5
000013B0  4EB9 00001E7C            351                  JSR         PRINTNULL
000013B6  4E75                     352                  RTS
000013B8                           353    
000013B8  4BF9 000021AB            354  ADD_SUB_LONG    LEA         MSG_L,A5
000013BE  4EB9 00001E7C            355                  JSR         PRINTNULL
000013C4  4E75                     356                  RTS
000013C6                           357        
000013C6  4EB9 000013CE            358  FINISH_ADD      JSR         ADD_SUB_OPERAND
000013CC  4E75                     359                  RTS
000013CE                           360    
000013CE  EF49                     361  ADD_SUB_OPERAND LSL.W       #7,D1
000013D0  EE49                     362                  LSR.W       #7,D1
000013D2  E049                     363                  LSR.W       #8,D1
000013D4  B27C 0001                364                  CMP.W       #1,D1
000013D8  6600 002E                365                  BNE         Dn_PLUS_EA          
000013DC                           366                    
000013DC                           367                  ; print Data Register
000013DC  4BF9 00002188            368                  LEA         MSG_DR,A5
000013E2  4EB9 00001E7C            369                  JSR         PRINTNULL
000013E8  3207                     370                  MOVE.W      D7,D1
000013EA  4EB9 00001D32            371                  JSR         PRINTNUM                
000013F0                           372                  
000013F0                           373                  ; prints a comma to seperate
000013F0  4BF9 00002198            374                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000013F6  4EB9 00001E7C            375                  JSR         PRINTNULL                ; prints out MOVE
000013FC                           376                 
000013FC                           377                  ; below is EA+Dn->Dn  
000013FC  3404                     378                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000013FE  3605                     379                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001400  4EB9 00001BB6            380                  JSR         EA_TO_STRING             ; outputs it into a string
00001406  4E75                     381                  RTS                                 ; exits subroutine 
00001408                           382  
00001408                           383  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001408  3404                     384                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000140A  3605                     385                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000140C  4EB9 00001BB6            386                  JSR         EA_TO_STRING             ; outputs it into a string   
00001412                           387                  
00001412                           388                  ; prints a comma to seperate
00001412  4BF9 00002198            389                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001418  4EB9 00001E7C            390                  JSR         PRINTNULL                ; prints out MOVE
0000141E                           391                  
0000141E                           392                  ; below is Dn+EA->EA
0000141E  4BF9 00002188            393                  LEA         MSG_DR,A5                ; print data register
00001424  4EB9 00001E7C            394                  JSR         PRINTNULL
0000142A  3207                     395                  MOVE.W      D7,D1
0000142C  4EB9 00001D32            396                  JSR         PRINTNUM             
00001432  4E75                     397                  RTS                                  ; exits subroutine          
00001434                           398                        
00001434                           399  *---------------ADDA opcode----------------------
00001434                           400  CASE_ADDA       ; gets bit 8 (size bit)
00001434  3200                     401                  MOVE.W      D0,D1
00001436  EF49                     402                  LSL.W       #7,D1
00001438  EE49                     403                  LSR.W       #7,D1
0000143A  E049                     404                  LSR         #8,D1                   
0000143C                           405                  
0000143C  4BF9 000020C0            406                  LEA         MSG_ADDA,A5             ; print ADDA
00001442  4EB9 00001E7C            407                  JSR         PRINTNULL
00001448                           408                   
00001448  B27C 0001                409                  CMP.W       #1,D1
0000144C  6700 0012                410                  BEQ         ADDA_LONG
00001450                           411                    
00001450  4BF9 000021A5            412                  LEA         MSG_W,A5
00001456  4EB9 00001E7C            413                  JSR         PRINTNULL
0000145C  6000 0012                414                  BRA         FINISH_ADDA   
00001460                           415                    
00001460  4BF9 000021AB            416  ADDA_LONG       LEA         MSG_L,A5
00001466  4EB9 00001E7C            417                  JSR         PRINTNULL
0000146C  6000 0002                418                  BRA         FINISH_ADDA
00001470                           419                    
00001470  3404                     420  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001472  3605                     421                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001474  4EB9 00001BB6            422                  JSR         EA_TO_STRING             ; outputs it into a string
0000147A                           423                    
0000147A                           424                  ; prints a comma to seperate
0000147A  4BF9 00002198            425                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001480  4EB9 00001E7C            426                  JSR         PRINTNULL                ; prints out MOVE
00001486                           427            
00001486  4BF9 0000218A            428                  LEA         MSG_AR,A5                ; print address register
0000148C  4EB9 00001E7C            429                  JSR         PRINTNULL
00001492  3207                     430                  MOVE.W      D7,D1
00001494  4EB9 00001D32            431                  JSR         PRINTNUM             
0000149A  4E75                     432                  RTS                              ; exits subroutine
0000149C                           433                  
0000149C                           434  *---------------ADDQ opcode----------------------                  
0000149C  3200                     435  CASE_ADDQ       MOVE.W      D0,D1
0000149E  C27C F000                436                  AND.W       #$F000,D1       
000014A2  B27C 5000                437                  CMP.W       #$5000,D1
000014A6  6600 00CC                438                  BNE         CASE_SUB
000014AA                           439                                                   
000014AA  4EB8 1160                440                  JSR         PRINT_ADDR              ; print address  
000014AE  4BF9 000020C6            441                  LEA         MSG_ADDQ,A5             ; print ADDQ
000014B4  4EB9 00001E7C            442                  JSR         PRINTNULL
000014BA                           443                  
000014BA                           444                  ; get bits 6-7 (size bits)
000014BA  3200                     445                  MOVE.W      D0,D1
000014BC  E149                     446                  LSL.W       #8,D1
000014BE  E049                     447                  LSR.W       #8,D1
000014C0  EC49                     448                  LSR.W       #6,D1
000014C2  3401                     449                  MOVE.W      D1,D2
000014C4                           450                  
000014C4                           451                  ; Check bits 0-5 
000014C4  4BF9 00001F28            452                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000014CA  4DF9 00001F5E            453                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000014D0  3E3C 0000                454                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000014D4  4EB9 00001AEA            455                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000014DA  B27C 0001                456                  CMP.W       #1,D1                    ; checks if invalid
000014DE  6700 05B2                457                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000014E2  3802                     458                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000014E4  3A03                     459                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000014E6                           460                  
000014E6  B47C 0001                461                  CMP.W       #1,D2
000014EA  6700 001A                462                  BEQ         ADDQ_WORD
000014EE  B47C 0002                463                  CMP.W       #2,D2
000014F2  6700 0022                464                  BEQ         ADDQ_LONG
000014F6                           465                    
000014F6  4BF9 0000219F            466  ADDQ_BYTE       LEA         MSG_B,A5
000014FC  4EB9 00001E7C            467                  JSR         PRINTNULL
00001502  6000 0022                468                  BRA         FINISH_ADDQ  
00001506                           469   
00001506  4BF9 000021A5            470  ADDQ_WORD       LEA         MSG_W,A5
0000150C  4EB9 00001E7C            471                  JSR         PRINTNULL
00001512  6000 0012                472                  BRA         FINISH_ADDQ                 
00001516                           473    
00001516  4BF9 000021AB            474  ADDQ_LONG       LEA         MSG_L,A5
0000151C  4EB9 00001E7C            475                  JSR         PRINTNULL
00001522  6000 0002                476                  BRA         FINISH_ADDQ                  
00001526                           477                    
00001526  4EB9 00001544            478  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000152C                           479   
0000152C                           480                  ; prints a comma to seperate
0000152C  4BF9 00002198            481                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001532  4EB9 00001E7C            482                  JSR         PRINTNULL                ; prints out MOVE
00001538                           483                    
00001538                           484                  ; prints destination
00001538  3404                     485                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000153A  3605                     486                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000153C  4EB9 00001BB6            487                  JSR         EA_TO_STRING             ; outputs it into a string
00001542                           488                 
00001542  4E75                     489                  RTS
00001544                           490   
00001544  4BF9 00002194            491  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
0000154A  4EB9 00001E7C            492                  JSR         PRINTNULL
00001550                           493                  ; gets bits 9-11 (data bits)
00001550  E949                     494                  LSL.W       #4,D1
00001552  E849                     495                  LSR.W       #4,D1                               ; get rid of left 4 bits
00001554  E049                     496                  LSR.W       #8,D1
00001556  E249                     497                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001558                           498                  
00001558  B27C 0000                499                  CMP.W       #0,D1
0000155C  6700 000A                500                  BEQ         PRINT_8
00001560  4EB9 00001D32            501                  JSR         PRINTNUM
00001566  4E75                     502                  RTS 
00001568                           503  
00001568  123C 0008                504  PRINT_8         MOVE.B      #8,D1
0000156C  4EB9 00001D32            505                  JSR         PRINTNUM
00001572  4E75                     506                  RTS   
00001574                           507         
00001574                           508  *---------------SUB opcode---------------------- 
00001574  3200                     509  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
00001576  C27C F000                510                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000157A  B27C 9000                511                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000157E  6600 0084                512                  BNE         CASE_LEA
00001582                           513                 
00001582  4EB8 131A                514                  JSR         ADD_SUB_HELP
00001586  4EB8 1160                515                  JSR         PRINT_ADDR                          ; print address               
0000158A                           516                  
0000158A  6000 0002                517                  BRA         PRINTSUB                            ; Branches to print move
0000158E                           518  
0000158E  4BF9 000020CC            519  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
00001594  4EB9 00001E7C            520                  JSR         PRINTNULL
0000159A  3200                     521                  MOVE.W      D0,D1                               ; bits 6-7 contain size
0000159C  4EB8 1378                522                  JSR         ADD_SUB_SIZE
000015A0  3200                     523                  MOVE.W      D0,D1
000015A2  E149                     524                  LSL.W       #8,D1
000015A4  E049                     525                  LSR.W       #8,D1
000015A6  EC49                     526                  LSR.W       #6,D1
000015A8  B27C 0003                527                  CMP.W       #3,D1
000015AC  6600 0006                528                  BNE         FINISH_SUB
000015B0  6000 0008                529                  BRA         FINISH_SUBA                         ; same as ADDA
000015B4                           530                  
000015B4  4EB8 13CE                531  FINISH_SUB      JSR     ADD_SUB_OPERAND
000015B8  4E75                     532                  RTS
000015BA                           533                    
000015BA  3404                     534  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015BC  3605                     535                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015BE  4EB9 00001BB6            536                  JSR         EA_TO_STRING             ; outputs it into a string
000015C4                           537                
000015C4                           538                  ; prints a comma to seperate
000015C4  4BF9 00002198            539                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015CA  4EB9 00001E7C            540                  JSR         PRINTNULL                ; prints out MOVE
000015D0                           541          
000015D0  4BF9 0000218A            542                  LEA         MSG_AR,A5                ; print address register
000015D6  4EB9 00001E7C            543                  JSR         PRINTNULL
000015DC  3200                     544                  MOVE.W      D0,D1
000015DE  E949                     545                  LSL.W       #4,D1
000015E0  E849                     546                  LSR.W       #4,D1
000015E2  E049                     547                  LSR.W       #8,D1
000015E4  E249                     548                  LSR.W       #1,D1
000015E6  4EB9 00001D32            549                  JSR         PRINTNUM             
000015EC  4E75                     550                  RTS                              ; exits subroutine
000015EE                           551  
000015EE                           552  
000015EE                           553  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
000015EE  3200                     554  CASE_SUBA       MOVE.W      D0,D1
000015F0  EF49                     555                  LSL.W       #7,D1
000015F2  EE49                     556                  LSR.W       #7,D1
000015F4  E049                     557                  LSR.W       #8,D1
000015F6  B23C 0000                558                  CMP.B       #0,D1
000015FA  6700 FDAE                559                  BEQ         ADD_SUB_WORD
000015FE  6000 FDB8                560                  BRA         ADD_SUB_LONG
00001602  4E75                     561                  RTS         
00001604                           562                   
00001604  3200                     563  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001606  C27C F000                564                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000160A  B27C 4000                565                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000160E  6600 0086                566                  BNE.W   CASE_AND                             ; If its not, check AND
00001612  3200                     567                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001614  C27C 01C0                568                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001618  B27C 01C0                569                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000161C  6600 0078                570                  BNE.W   CASE_AND                             ; If its not, check AND
00001620                           571                  
00001620                           572                  ; Check source
00001620  4BF9 00001F48            573                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001626  4DF9 00001F62            574                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000162C  3E3C 0000                575                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001630  4EB9 00001AEA            576                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001636  3802                     577                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001638  3A03                     578                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000163A                           579                  
0000163A                           580                  ; Check destination
0000163A  4BF9 00001F48            581                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001640  4DF9 00001F62            582                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001646  3E3C 0001                583                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000164A  4EB9 00001AEA            584                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001650  3C02                     585                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001652  3E03                     586                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001654                           587  
00001654  4BF9 000020DD            588                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000165A  4EB9 00001E7C            589                  JSR     PRINTNULL                            ; prints LEA
00001660                           590                  
00001660                           591                  ; print source
00001660  3404                     592                  MOVE.W  D4,D2
00001662  3605                     593                  MOVE.W  D5,D3
00001664  4EB9 00001BB6            594                  JSR     EA_TO_STRING                         ; Prints out the EA
0000166A                           595                  
0000166A                           596                  ; comma
0000166A  4BF9 00002198            597                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001670  4EB9 00001E7C            598                  JSR     PRINTNULL                       
00001676                           599                   
00001676                           600                  ; register
00001676  4BF9 0000218A            601                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
0000167C  4EB9 00001E7C            602                  JSR     PRINTNULL 
00001682  3401                     603                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
00001684  323C 0001                604                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
00001688  4EB9 00001AC0            605                  JSR     GET_XN                               ; Gets Xn, puts it into D1
0000168E  4EB9 00001D32            606                  JSR     PRINTNUM                             ; Prints the number in D1
00001694  4E75                     607                  RTS
00001696                           608  
00001696                           609  *---------------AND opcode----------------------
00001696  3200                     610  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001698  C27C F000                611                  AND.W       #$F000,D1       
0000169C  B27C C000                612                  CMP.W       #$C000,D1
000016A0  6600 0086                613                  BNE         CASE_OR
000016A4                           614                  
000016A4  3200                     615                  MOVE.W      D0,D1
000016A6  E149                     616                  LSL.W       #8,D1
000016A8  E049                     617                  LSR.W       #8,D1
000016AA  EC49                     618                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000016AC  3C01                     619                  MOVE.W      D1,D6
000016AE  BC7C 0003                620                  CMP.W       #3,D6
000016B2  6700 0066                621                  BEQ         INV_INSTR
000016B6                           622                  
000016B6  4EB8 1160                623                  JSR         PRINT_ADDR                      ; print address
000016BA  4BF9 000020E5            624                  LEA         MSG_AND,A5                      ; print AND
000016C0  4EB9 00001E7C            625                  JSR         PRINTNULL
000016C6                           626                  
000016C6  3206                     627                  MOVE.W      D6,D1
000016C8  B27C 0000                628                  CMP.W       #0,D1
000016CC  6700 0012                629                  BEQ         AND_BYTE
000016D0  B27C 0001                630                  CMP.W       #1,D1                   ; if 1, it is a word
000016D4  6700 001A                631                  BEQ         AND_WORD
000016D8  B27C 0002                632                  CMP.W       #2,D1                   ; if 2, it is a long
000016DC  6700 0022                633                  BEQ         AND_LONG
000016E0                           634                  
000016E0  4BF9 0000219F            635  AND_BYTE        LEA         MSG_B,A5
000016E6  4EB9 00001E7C            636                  JSR         PRINTNULL
000016EC  6000 0022                637                  BRA         FINISH_AND
000016F0                           638                                    
000016F0  4BF9 000021A5            639  AND_WORD        LEA         MSG_W,A5
000016F6  4EB9 00001E7C            640                  JSR         PRINTNULL
000016FC  6000 0012                641                  BRA         FINISH_AND
00001700                           642    
00001700  4BF9 000021AB            643  AND_LONG        LEA         MSG_L,A5
00001706  4EB9 00001E7C            644                  JSR         PRINTNULL
0000170C  6000 0002                645                  BRA         FINISH_AND
00001710                           646        
00001710  4EB8 131A                647  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001714  4EB8 13CE                648                  JSR         ADD_SUB_OPERAND
00001718  4E75                     649                  RTS
0000171A                           650                  
0000171A  4BF9 00002086            651  INV_INSTR       LEA         INVALID_INSTR,A5
00001720  4EB9 00001E7C            652                  JSR         PRINTNULL
00001726                           653                  ;MOVE.W      D0,A1
00001726  4E75                     654                  RTS               
00001728                           655                  
00001728                           656  *---------------OR opcode----------------------            
00001728  3200                     657  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
0000172A  C27C F000                658                  AND.W       #$F000,D1       
0000172E  B27C 8000                659                  CMP.W       #$8000,D1
00001732  6600 004C                660                  BNE         CASE_NOT
00001736                           661                                                
00001736  3200                     662                  MOVE.W      D0,D1
00001738  E149                     663                  LSL.W       #8,D1
0000173A  E049                     664                  LSR.W       #8,D1
0000173C  EC49                     665                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000173E  B27C 0003                666                  CMP.W       #3,D1
00001742  3C01                     667                  MOVE.W      D1,D6
00001744  67D4                     668                  BEQ         INV_INSTR
00001746                           669                  
00001746  4EB8 1160                670                  JSR         PRINT_ADDR                      ; print address
0000174A                           671                  
0000174A  4BF9 000020EA            672                  LEA         MSG_OR,A5
00001750  4EB9 00001E7C            673                  JSR         PRINTNULL                       ; print "OR"
00001756                           674                  
00001756  3206                     675                  MOVE.W      D6,D1
00001758  4EB9 00001768            676                  JSR         OR_SIZE                         ; print ".B",".W",".L"
0000175E  4EB8 131A                677                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001762  4EB8 13CE                678                  JSR         ADD_SUB_OPERAND                 ; print 
00001766  4E75                     679                  RTS
00001768                           680  
00001768  B27C 0000                681  OR_SIZE         CMP.W       #0,D1
0000176C  6700 FC2E                682                  BEQ         ADD_SUB_BYTE
00001770  B27C 0001                683                  CMP.W       #1,D1                   ; if 1, it is a word
00001774  6700 FC34                684                  BEQ         ADD_SUB_WORD
00001778  B27C 0002                685                  CMP.W       #2,D1                   ; if 2, it is a long
0000177C  6700 FC3A                686                  BEQ         ADD_SUB_LONG
00001780                           687                  ; no need for rts, since ADD_SUB_ already has                
00001780                           688  
00001780                           689  *---------------NOT opcode----------------------
00001780  3200                     690  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001782  C27C FF00                691                  AND.W       #$FF00,D1       
00001786  B27C 4600                692                  CMP.W       #$4600,D1
0000178A  6600 0050                693                  BNE         CASE_LSDASD
0000178E                           694                 
0000178E                           695                  ; get bits 6-7 (size)
0000178E  3200                     696                  MOVE.W      D0,D1
00001790  E149                     697                  LSL.W       #8,D1
00001792  E049                     698                  LSR.W       #8,D1
00001794  EC49                     699                  LSR.W       #6,D1 
00001796  3C01                     700                  MOVE.W      D1,D6                         
00001798  BC7C 0003                701                  CMP.W       #3,D6
0000179C  6700 FF7C                702                  BEQ         INV_INSTR
000017A0                           703                  
000017A0  4EB8 1160                704                  JSR         PRINT_ADDR
000017A4                           705                  
000017A4  4BF9 000020EE            706                  LEA         MSG_NOT,A5
000017AA  4EB9 00001E7C            707                  JSR         PRINTNULL                       ; print "NOT"
000017B0                           708                                 
000017B0  3206                     709                  MOVE.W      D6,D1
000017B2                           710  
000017B2  4EB8 1768                711                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000017B6                           712                  
000017B6                           713                  ; get bits 0-5 
000017B6  4BF9 00001F28            714                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000017BC  4DF9 00001F5E            715                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000017C2  3E3C 0000                716                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000017C6  4EB9 00001AEA            717                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000017CC  B27C 0001                718                  CMP.W       #1,D1                    ; checks if invalid
000017D0  6700 02C0                719                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000017D4  4EB9 00001BB6            720                  JSR         EA_TO_STRING             ; outputs it into a string
000017DA                           721    
000017DA  4E75                     722                  RTS
000017DC                           723  
000017DC  3200                     724  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
000017DE  C27C F000                725                  AND.W       #$F000, D1                       ; gets first 4 bits
000017E2  B27C E000                726                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000017E6  6600 0210                727                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000017EA  3400                     728                  MOVE.W      D0,D2                            ; copies D0 to D2
000017EC  4EB9 00001B72            729                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000017F2  B47C 0003                730                  CMP.W       #$3, D2                          ; checks if it is memory or register option
000017F6  6600 00C8                731                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
000017FA                           732                  
000017FA  3400                     733  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
000017FC  4EB9 00001B60            734                  JSR         GETROTATION                      ; gets rotation value of D2
00001802  B47C 0000                735                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001806  6700 0014                736                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
0000180A  B47C 0003                737                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
0000180E  6700 0016                738                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001812                           739                  
00001812  4BF9 000020F3            740  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001818  6000 0012                741                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000181C                           742  
0000181C  4BF9 000020F7            743  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001822  6000 0008                744                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001826                           745  
00001826  4BF9 000020FB            746  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000182C                           747                  
0000182C  4EB9 00001E7C            748  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
00001832  3400                     749                  MOVE.W      D0,D2                            ; copies D0 to D2
00001834  4EB9 00001B6A            750                  JSR         GETDIRECTION                     ; gets direction
0000183A  B47C 0000                751                  CMP.W       #0,D2                            ; checking if its right
0000183E  6700 000C                752                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001842                           753  
00001842  4BF9 00002186            754  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001848  6000 0008                755                  BRA         PRINT_MEMDIR                     ; branches for printing
0000184C                           756          
0000184C  4BF9 00002184            757  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001852                           758  
00001852  4EB9 00001E7C            759  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001858  4BF9 000021A5            760                  LEA         MSG_W,A5                         ; loads .W into A5
0000185E  4EB9 00001E7C            761                  JSR         PRINTNULL                        ; Prints .W
00001864  6000 0002                762                  BRA         GETMEMSOURCE                     ; checks the source 
00001868                           763                  
00001868                           764  ; get source addressing mode       
00001868                           765  GETMEMSOURCE                                                 
00001868  323C 0000                766                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000186C  4EB9 00001A96            767                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001872  3801                     768                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001874  323C 0000                769                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001878  4EB9 00001AC0            770                  JSR         GET_XN                           ; Gets Xn, puts it into D1
0000187E  3A01                     771                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001880                           772  
00001880  4BF9 00001F56            773  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001886  3204                     774                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001888  4EB9 00001B82            775                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
0000188E  B27C 0002                776                  CMP.W       #2,D1                            ; checks if it is Xn
00001892  6700 0016                777                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001896  B27C 0001                778                  CMP.W       #1,D1                            ; Checks if it is invalid
0000189A  6700 01F6                779                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
0000189E                           780  
0000189E  3404                     781  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000018A0  3605                     782                  MOVE.W      D5,D3                            ; moves EA to D3
000018A2  4EB9 00001BB6            783                  JSR         EA_TO_STRING                     ; prints out the EA
000018A8  4E75                     784                  RTS                
000018AA                           785                  
000018AA                           786                  
000018AA  4BF9 00001F62            787  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000018B0  3205                     788                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000018B2  4EB9 00001B82            789                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000018B8  4A41                     790                  TST.W       D1                               ; checks if it is valid
000018BA  67E2                     791                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000018BC  6000 01D4                792                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000018C0                           793  
000018C0                           794  
000018C0  3602                     795  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000018C2  3200                     796                  MOVE.W      D0,D1                            ; copies D0 to D1
000018C4  C27C 0018                797                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000018C8  E649                     798                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000018CA  B27C 0000                799                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000018CE  6700 0014                800                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000018D2  B27C 0003                801                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000018D6  6700 0016                802                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000018DA                           803                  
000018DA  4BF9 000020F3            804  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
000018E0  6000 0012                805                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000018E4                           806  
000018E4  4BF9 000020F7            807  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
000018EA  6000 0008                808                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000018EE                           809  
000018EE  4BF9 000020FB            810  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
000018F4                           811                  
000018F4  4EB9 00001E7C            812  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
000018FA  3400                     813                  MOVE.W      D0,D2                            ; copies D0 to D2
000018FC  4EB9 00001B6A            814                  JSR         GETDIRECTION                     ; gets direction
00001902  B47C 0000                815                  CMP.W       #0,D2                            ; checking if its right
00001906  6700 000C                816                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
0000190A                           817  
0000190A  4BF9 00002186            818  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001910  6000 000C                819                  BRA         PRINT_REGDIR                     ; branches for printing
00001914                           820          
00001914  4BF9 00002184            821  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
0000191A  6000 0002                822                  BRA         PRINT_REGDIR                     ; branches for printing
0000191E                           823                  
0000191E  4EB9 00001E7C            824  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001924                           825  
00001924  3400                     826  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001926  4EB9 00001B72            827                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000192C  B47C 0001                828                  CMP.W       #1,D2                            ; Checks if it is word size
00001930  6700 0014                829                  BEQ         REG_WORD                         ; Prints .W
00001934  B47C 0002                830                  CMP.W       #2,D2                            ; Checks if it is long size
00001938  6700 0016                831                  BEQ         REG_LONG                         ; Prints .L
0000193C                           832  
0000193C  4BF9 0000219F            833  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001942  6000 0012                834                  BRA         PRINTREGEA      
00001946                           835  
00001946  4BF9 000021A5            836  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
0000194C  6000 0008                837                  BRA         PRINTREGEA      
00001950                           838                             
00001950  4BF9 000021AB            839  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001956                           840  
00001956  4EB9 00001E7C            841  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
0000195C  3400                     842                  MOVE.W      D0,D2                            ; copies D0 to D1
0000195E  4EB9 00001B7A            843                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001964  B27C 0001                844                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001968  6700 0048                845                  BEQ         REG_REGISTER                     ; goes to ASd case if so
0000196C                           846                                  
0000196C  3400                     847  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
0000196E  4EB9 00001B72            848                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001974  3202                     849                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001976  4BF9 00002194            850                  LEA         MSG_POUND, A5                    ; loads # into A5
0000197C  4EB9 00001E7C            851                  JSR         PRINTNULL                        ; prints #
00001982  4EB9 00001D32            852                  JSR         PRINTNUM                         ; prints shift count
00001988  4BF9 00002198            853                  LEA         MSG_COMMA, A5                    ; loads , into A5
0000198E  4EB9 00001E7C            854                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001994  4BF9 00002188            855                  LEA         MSG_DR, A5                       ; loads D into A5
0000199A  4EB9 00001E7C            856                  JSR         PRINTNULL                        ; prints out D 
000019A0  323C 0000                857                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000019A4  4EB9 00001AC0            858                  JSR         GET_XN                           ; gets the data register number, stores in D1
000019AA  4EB9 00001D32            859                  JSR         PRINTNUM                         ; prints data register number in D1          
000019B0  4E75                     860                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000019B2                           861                  
000019B2  3400                     862  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
000019B4  4EB9 00001B72            863                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000019BA  3202                     864                  MOVE.W      D2, D1                           ; moves rotation size to D1
000019BC  4BF9 00002188            865                  LEA         MSG_DR, A5                       ; loads D into A5
000019C2  4EB9 00001E7C            866                  JSR         PRINTNULL                        ; prints D
000019C8  4EB9 00001D32            867                  JSR         PRINTNUM                         ; prints register number
000019CE  4BF9 00002198            868                  LEA         MSG_COMMA, A5                    ; loads , into A5
000019D4  4EB9 00001E7C            869                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000019DA  4BF9 00002188            870                  LEA         MSG_DR, A5                       ; loads D into A5
000019E0  4EB9 00001E7C            871                  JSR         PRINTNULL                        ; prints out D 
000019E6  323C 0000                872                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000019EA  4EB9 00001AC0            873                  JSR         GET_XN                           ; gets the data register number, stores in D1
000019F0  4EB9 00001D32            874                  JSR         PRINTNUM                         ; prints data register number in D1          
000019F6  4E75                     875                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000019F8                           876               
000019F8  3200                     877  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000019FA  C27C FF00                878                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
000019FE  B27C 6000                879                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001A02  6600 0018                880                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001A06                           881                  
00001A06  4BF9 0000217C            882                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001A0C  4EB9 00001E7C            883                  JSR     PRINTNULL                            ; prints BRA
00001A12                           884  
00001A12  3400                     885                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001A14  4EB9 00001B32            886                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001A1A  4E75                     887                  RTS
00001A1C                           888                  
00001A1C                           889  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001A1C                           890  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001A1C  3200                     891  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001A1E  C27C F000                892                  AND.W   #$F000,D1                            ; get top 4 bits
00001A22  B27C 6000                893                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001A26  6600 0054                894                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001A2A  3200                     895                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001A2C  C27C 0F00                896                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001A30  E049                     897                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001A32                           898                  
00001A32  B27C 000E                899                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001A36  6700 002A                900                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001A3A                           901                  
00001A3A  B27C 000F                902                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001A3E  6700 0018                903                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001A42                           904                      
00001A42  B27C 0007                905                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001A46  6700 0006                906                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001A4A  6000 0046                907                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001A4E                           908     
00001A4E  4BF9 0000210F            909  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001A54  6000 0016                910                  BRA     PRINTBCC
00001A58                           911  
00001A58  4BF9 00002137            912  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001A5E  6000 000C                913                  BRA     PRINTBCC
00001A62                           914                  
00001A62  4BF9 00002127            915  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001A68  6000 0002                916                  BRA     PRINTBCC
00001A6C                           917  
00001A6C  4EB9 00001E7C            918  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001A72  3400                     919                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001A74  4EB9 00001B32            920                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001A7A  4E75                     921                  RTS              
00001A7C                           922                  
00001A7C                           923  
00001A7C                           924  CASE_JSR       
00001A7C                           925  
00001A7C  B07C 4E75                926  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001A80  6600 F708                927                  BNE     CASE_MOVE           ; checks the next case if not equal
00001A84  4BF9 00002177            928                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001A8A  4EB9 00001E7C            929                  JSR     PRINTNULL           ; prints RTS                
00001A90  4E75                     930                  RTS                         ; returns from the subroutine
00001A92                           931  
00001A92                           932                  
00001A92                           933  
00001A92                           934  CASE_DATA           
00001A92  4E75                     935                      RTS               
00001A94                           936  
00001A94  4E75                     937  CASE_EPICFAIL       RTS
00001A96                           938  
00001A96                           939  
00001A96                           940  * Finds the EA type
00001A96                           941  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001A96                           942  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001A96  48E7 3000                943  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001A9A  4A41                     944                      TST.W     D1                    ; compares D1 to 0
00001A9C  6700 000E                945                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001AA0                           946                      
00001AA0  343C 01C0                947  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001AA4  363C 0006                948                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001AA8  6000 000A                949                      BRA       FINDTYPEEA            
00001AAC                           950  
00001AAC  343C 0038                951  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001AB0  363C 0003                952                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001AB4                           953  
00001AB4                           954  
00001AB4  3200                     955  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001AB6  C242                     956                      AND.W     D2,D1                 ; applies bitmask to D1
00001AB8  E669                     957                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001ABA  4CDF 000C                958                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001ABE  4E75                     959                      RTS                             ; returns from subroutine    
00001AC0                           960                      
00001AC0                           961  * Finds Xn type
00001AC0                           962  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001AC0                           963  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001AC0  48E7 3000                964  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001AC4  4A41                     965                      TST.W     D1                    ; compares D1 to 0
00001AC6  6700 000E                966                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001ACA                           967  
00001ACA  343C 0E00                968  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001ACE  363C 0009                969                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001AD2  6000 000A                970                      BRA       FINDTYPEXN            ; finds the type of Xn
00001AD6                           971  
00001AD6  343C 0007                972  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001ADA  363C 0000                973                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001ADE                           974                      
00001ADE  3200                     975  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001AE0  C242                     976                      AND.W     D2,D1                 ; applies bitmask to D1
00001AE2  E669                     977                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001AE4  4CDF 000C                978                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001AE8  4E75                     979                      RTS                             ; returns from subroutine 
00001AEA                           980                      
00001AEA                           981  * Checks and gets the EA and Xn
00001AEA                           982  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001AEA                           983  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001AEA  3207                     984  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001AEC  4EB8 1A96                985                  JSR     GET_EA                  ; Gets EA
00001AF0  3401                     986                  MOVE.W  D1,D2                   ; Stores EA in D2
00001AF2  3207                     987                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001AF4  4EB8 1AC0                988                  JSR     GET_XN                  ; Gets Xn
00001AF8  3601                     989                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001AFA  3202                     990                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001AFC                           991                  
00001AFC  4EB9 00001B82            992                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001B02  B27C 0002                993                  CMP.W   #2,D1                   ; checks if it is Xn
00001B06  6700 0012                994                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001B0A  B27C 0001                995                  CMP.W   #1,D1                   ; Checks if it is invalid
00001B0E  6700 001C                996                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001B12                           997                  
00001B12                           998                  
00001B12  323C 0000                999  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001B16  6000 0018               1000                  BRA     END_CHECKGET
00001B1A                          1001        
00001B1A                          1002  ; need XN
00001B1A  2A4E                    1003  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001B1C  3203                    1004                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001B1E  4EB9 00001B82           1005                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001B24  4A41                    1006                  TST.W   D1                      ; checks if it is valid
00001B26  67EA                    1007                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001B28  6000 0002               1008                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001B2C                          1009   
00001B2C  323C 0001               1010  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001B30                          1011  
00001B30  4E75                    1012  END_CHECKGET    RTS          
00001B32                          1013                                            
00001B32                          1014                                            
00001B32                          1015  * Gets the displacement and pritns it 
00001B32                          1016  * Inputs: D2 = instruction word, A2 = address of next word
00001B32                          1017  * Outputs: prints out displacement
00001B32  48E7 4004               1018  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001B36  3A4A                    1019                      MOVE.W    A2,A5                 ; copies A2 to A5
00001B38  C47C 00FF               1020                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001B3C  6600 0004               1021                      BNE       PRINTADDRESS          ; prints address if not 0
00001B40  341A                    1022                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001B42                          1023                      
00001B42  D44D                    1024  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001B44  3202                    1025                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001B46  183C 0000               1026                      MOVE.B    #0,D4                 ; marks address as word  length
00001B4A  4BF9 00002196           1027                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001B50  4EB9 00001E7C           1028                      JSR       PRINTNULL             ; prints null
00001B56  4EB9 00001D56           1029                      JSR       PRINTSHORTLONGNUM     ; prints address
00001B5C                          1030                      
00001B5C  4CDF 2002               1031                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001B60                          1032                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001B60                          1033  
00001B60                          1034  * Gets the rotation value for ASd and LSd
00001B60                          1035  * Input: D2 = instruction word copy (of D0)                                    
00001B60                          1036  * Output: rotation  value in D2             
00001B60  C47C 0E00               1037  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001B64  E04A                    1038                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001B66  E24A                    1039                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001B68  4E75                    1040                      RTS                             ; return from subroutine
00001B6A                          1041  
00001B6A                          1042  * Gets the direction value for ASd and LSd
00001B6A                          1043  * Input: D2 = instruction word copy (of D0)                                    
00001B6A                          1044  * Output: direction value in D2             
00001B6A  C47C 0100               1045  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001B6E  E04A                    1046                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001B70  4E75                    1047                      RTS                             ; return from subroutine
00001B72                          1048  
00001B72                          1049  * Gets the rotation size value for ASd and LSd
00001B72                          1050  * Input: D2 = instruction word copy (of D0)                                    
00001B72                          1051  * Output: rotation size value in D2             
00001B72  C47C 00C0               1052  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001B76  EC4A                    1053                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001B78  4E75                    1054                      RTS                             ; return from subroutine
00001B7A                          1055  
00001B7A                          1056  * Gets the rotation location  value for ASd and LSd
00001B7A                          1057  * Input: D2 = instruction word copy (of D0)                                    
00001B7A                          1058  * Output: rotation location value in D2             
00001B7A  C47C 0020               1059  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001B7E  EA4A                    1060                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001B80  4E75                    1061                      RTS                             ; return from subroutine
00001B82                          1062  
00001B82                          1063                          
00001B82                          1064  * Checks if EA or Xn is valid
00001B82                          1065  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001B82                          1066  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001B82  2F02                    1067  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001B84                          1068  
00001B84  141D                    1069  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001B86  B43C 00FF               1070                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001B8A  6700 000A               1071                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001B8E  B202                    1072                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001B90  6700 000C               1073                     BEQ        VALIDEA               ; branches to valid EA
00001B94  60EE                    1074                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001B96                          1075                     
00001B96  323C 0001               1076  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001B9A  6000 0016               1077                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001B9E                          1078                    
00001B9E  B43C 0007               1079  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001BA2  6700 000A               1080                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001BA6  323C 0000               1081                     MOVE.W     #$0,D1                ; marks that it is valid
00001BAA  6000 0006               1082                     BRA        CHECKEAEXIT           ; exits the subroutine
00001BAE                          1083  
00001BAE  323C 0002               1084  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001BB2                          1085  
00001BB2  241F                    1086  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001BB4  4E75                    1087                     RTS                              ; returns from subroutine
00001BB6                          1088  
00001BB6                          1089  * Converts EA and Xn into a string                                
00001BB6                          1090  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001BB6                          1091  * Outputs: Prints out EA and Xn into a string
00001BB6  48E7 C004               1092  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001BBA  B47C 0001               1093                     CMP.W    #An,D2                  ; checks if it is An
00001BBE  6700 003A               1094                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001BC2                          1095                     
00001BC2  B47C 0002               1096                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001BC6  6700 004A               1097                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001BCA                          1098                     
00001BCA  B47C 0003               1099                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001BCE  6700 0072               1100                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001BD2                          1101                     
00001BD2  B47C 0004               1102                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001BD6  6700 00A6               1103                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001BDA                          1104                     
00001BDA  B47C 0007               1105                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001BDE  6700 00DA               1106                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001BE2                          1107                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001BE2                          1108  
00001BE2                          1109  * data register, Dn
00001BE2  4BF9 00002188           1110  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001BE8  4EB9 00001E7C           1111                     JSR      PRINTNULL               ; Prints D
00001BEE  3203                    1112                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001BF0  4EB9 00001D32           1113                     JSR      PRINTNUM                ; Prints the Xn
00001BF6  6000 0134               1114                     BRA      EA_TO_STRING_EXIT       ; exits           
00001BFA                          1115  
00001BFA                          1116  
00001BFA                          1117  * address register
00001BFA  4BF9 0000218A           1118  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001C00  4EB9 00001E7C           1119                     JSR      PRINTNULL               ; Prints A
00001C06  3203                    1120                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C08  4EB9 00001D32           1121                     JSR      PRINTNUM                ; Prints the Xn
00001C0E  6000 011C               1122                     BRA      EA_TO_STRING_EXIT       ; exits
00001C12                          1123  
00001C12                          1124  * address register indirect
00001C12  4BF9 0000218C           1125  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001C18  4EB9 00001E7C           1126                     JSR      PRINTNULL               ; Prints (
00001C1E  4BF9 0000218A           1127                     LEA      MSG_AR,A5               ; Loads A into A5
00001C24  4EB9 00001E7C           1128                     JSR      PRINTNULL               ; Prints A
00001C2A  3203                    1129                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C2C  4EB9 00001D32           1130                     JSR      PRINTNUM                ; Prints the Xn
00001C32  4BF9 0000218E           1131                     LEA      MSG_RB,A5               ; Loads ) into A5
00001C38  4EB9 00001E7C           1132                     JSR      PRINTNULL               ; Prints )
00001C3E  6000 00EC               1133                     BRA      EA_TO_STRING_EXIT       ; exits
00001C42                          1134  
00001C42                          1135  * address register indirect post increment
00001C42  4BF9 0000218C           1136  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001C48  4EB9 00001E7C           1137                     JSR      PRINTNULL               ; Prints (
00001C4E  4BF9 0000218A           1138                     LEA      MSG_AR,A5               ; Loads A into A5
00001C54  4EB9 00001E7C           1139                     JSR      PRINTNULL               ; Prints A
00001C5A  3203                    1140                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C5C  4EB9 00001D32           1141                     JSR      PRINTNUM                ; Prints the Xn
00001C62  4BF9 0000218E           1142                     LEA      MSG_RB,A5               ; Loads ) into A5
00001C68  4EB9 00001E7C           1143                     JSR      PRINTNULL               ; Prints )
00001C6E  4BF9 00002190           1144                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001C74  4EB9 00001E7C           1145                     JSR      PRINTNULL               ; Prints +
00001C7A  6000 00B0               1146                     BRA      EA_TO_STRING_EXIT       ; exits
00001C7E                          1147  
00001C7E                          1148  
00001C7E                          1149  * address register indirect pre increment
00001C7E  4BF9 00002192           1150  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001C84  4EB9 00001E7C           1151                     JSR      PRINTNULL               ; Prints -
00001C8A  4BF9 0000218C           1152                     LEA      MSG_LB,A5               ; Loads ( into A5
00001C90  4EB9 00001E7C           1153                     JSR      PRINTNULL               ; Prints (
00001C96  4BF9 0000218A           1154                     LEA      MSG_AR,A5               ; Loads A into A5
00001C9C  4EB9 00001E7C           1155                     JSR      PRINTNULL               ; Prints A
00001CA2  3203                    1156                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001CA4  4EB9 00001D32           1157                     JSR      PRINTNUM                ; Prints the Xn
00001CAA  4BF9 0000218E           1158                     LEA      MSG_RB,A5               ; Loads ) into A5
00001CB0  4EB9 00001E7C           1159                     JSR      PRINTNULL               ; Prints )
00001CB6  6000 0074               1160                     BRA      EA_TO_STRING_EXIT       ; exits
00001CBA                          1161  
00001CBA                          1162  * other (long, short, immediate) with Xn yes
00001CBA  301A                    1163  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001CBC  B67C 0000               1164                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001CC0  6700 002E               1165                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001CC4                          1166                     
00001CC4  B67C 0001               1167                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001CC8  6700 0042               1168                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001CCC                          1169  
00001CCC                          1170  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001CCC                          1171  * immediate
00001CCC  4BF9 00002194           1172  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001CD2  4EB9 00001E7C           1173                     JSR      PRINTNULL               ; Prints #  
00001CD8  4BF9 00002196           1174                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001CDE  4EB9 00001E7C           1175                     JSR      PRINTNULL               ; Prints $
00001CE4  3200                    1176                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001CE6  4EB9 00001D42           1177                     JSR      PRINTHEXNUM 
00001CEC  6000 003E               1178                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001CF0                          1179                     
00001CF0                          1180  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001CF0                          1181  
00001CF0                          1182  * word address
00001CF0                          1183  CASE_WORD          
00001CF0  4BF9 00002196           1184                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001CF6  4EB9 00001E7C           1185                     JSR      PRINTNULL               ; Prints $
00001CFC  3200                    1186                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001CFE  383C 0000               1187                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001D02  4EB9 00001D56           1188                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001D08  6000 0022               1189                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001D0C                          1190  
00001D0C                          1191  * long address 
00001D0C                          1192  CASE_LONG          
00001D0C  4BF9 00002196           1193                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001D12  4EB9 00001E7C           1194                     JSR      PRINTNULL               ; Prints $
00001D18  3200                    1195                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001D1A  383C 0001               1196                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001D1E  4EB9 00001D56           1197                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001D24  321A                    1198                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001D26  4EB9 00001D32           1199                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001D2C                          1200  
00001D2C                          1201  
00001D2C                          1202  * exits subroutine
00001D2C  4CDF 2003               1203  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001D30  4E75                    1204                      RTS                              ; returns from subroutine
00001D32                          1205  
00001D32                          1206  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001D32                          1207  
00001D32                          1208  * Prints out the content of D1 as a decimal number
00001D32                          1209  * Input: number in D1 to be printed
00001D32                          1210  * Output: contents of D1 printed
00001D32  48E7 C000               1211  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001D36  103C 0003               1212                   MOVE.B      #3,D0               ; prints D1
00001D3A  4E4F                    1213                   TRAP        #15                 ; is trap task 3
00001D3C                          1214              
00001D3C  4CDF 0003               1215                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001D40  4E75                    1216                   RTS                             ; returns from subroutine
00001D42                          1217                   
00001D42                          1218  * Prints out the content of D1 as a hex number
00001D42                          1219  * Input: number in D1 to be printed
00001D42                          1220  * Output: contents of D1 printed
00001D42  48E7 C000               1221  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001D46  143C 0010               1222                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001D4A  103C 000F               1223                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001D4E  4E4F                    1224                   TRAP        #15                 ; is trap task 15
00001D50  4CDF 0003               1225                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001D54  4E75                    1226                   RTS                             ; returns from subroutine
00001D56                          1227                   
00001D56                          1228  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001D56                          1229  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001D56                          1230  * Output: contents of D1 printed
00001D56  48E7 E000               1231  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001D5A  B83C 0001               1232                            CMP.B       #1,D4               ; checks size of number
00001D5E  6700 0042               1233                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001D62                          1234  
00001D62  3401                    1235  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001D64  C47C F000               1236                            AND.W       #$F000,D2           ; gets the first digit
00001D68  B47C 0000               1237                            CMP.W       #0, D2              ; checks if it is 0
00001D6C  6600 00DC               1238                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D70  4EB9 00001E5A           1239                            JSR         PRINTZERO           ; prints a zero
00001D76                          1240                            
00001D76  3401                    1241                            MOVE.W      D1,D2               ; copies number to D2
00001D78  C47C 0F00               1242                            AND.W       #$0F00,D2           ; gets the second digit
00001D7C  B47C 0000               1243                            CMP.W       #0, D2              ; checks if it is 0
00001D80  6600 00C8               1244                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D84  4EB9 00001E5A           1245                            JSR         PRINTZERO           ; prints a zero
00001D8A                          1246                            
00001D8A  3401                    1247                            MOVE.W      D1,D2               ; copies number to D2
00001D8C  C47C 00F0               1248                            AND.W       #$00F0,D2           ; gets the third digit
00001D90  B47C 0000               1249                            CMP.W       #0, D2              ; checks if it is 0
00001D94  6600 00B4               1250                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D98  4EB9 00001E5A           1251                            JSR         PRINTZERO           ; prints a zero
00001D9E  6000 00AA               1252                            BRA         PRINTASHEX          ; prints last digit
00001DA2                          1253                            
00001DA2  2401                    1254  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001DA4  C4BC F0000000           1255                            AND.L       #$F0000000,D2       ; gets the first digit
00001DAA  B4BC 00000000           1256                            CMP.L       #0, D2              ; checks if it is 0
00001DB0  6600 0098               1257                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DB4  4EB9 00001E5A           1258                            JSR         PRINTZERO           ; prints a zero
00001DBA                          1259                            
00001DBA  2401                    1260                            MOVE.L      D1,D2               ; copies number to D2
00001DBC  C4BC 0F000000           1261                            AND.L       #$0F000000,D2       ; gets the second digit
00001DC2  B4BC 00000000           1262                            CMP.L       #0, D2              ; checks if it is 0
00001DC8  6600 0080               1263                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DCC  4EB9 00001E5A           1264                            JSR         PRINTZERO           ; prints a zero
00001DD2                          1265                            
00001DD2  2401                    1266                            MOVE.L      D1,D2               ; copies number to D2
00001DD4  C4BC 00F00000           1267                            AND.L       #$00F00000,D2       ; gets the third digit
00001DDA  B4BC 00000000           1268                            CMP.L       #0, D2              ; checks if it is 0
00001DE0  6600 0068               1269                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DE4  4EB9 00001E5A           1270                            JSR         PRINTZERO           ; prints a zero
00001DEA                          1271                            
00001DEA  2401                    1272                            MOVE.L      D1,D2               ; copies number to D2
00001DEC  C4BC 000F0000           1273                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001DF2  B4BC 00000000           1274                            CMP.L       #0, D2              ; checks if it is 0
00001DF8  6600 0050               1275                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DFC  4EB9 00001E5A           1276                            JSR         PRINTZERO           ; prints a zero
00001E02                          1277                            
00001E02  2401                    1278                            MOVE.L      D1,D2               ; copies number to D2
00001E04  C4BC 0000F000           1279                            AND.L       #$0000F000,D2       ; gets the fith digit
00001E0A  B4BC 00000000           1280                            CMP.L       #0, D2              ; checks if it is 0
00001E10  6600 0038               1281                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E14  4EB9 00001E5A           1282                            JSR         PRINTZERO           ; prints a zero
00001E1A                          1283                            
00001E1A  2401                    1284                            MOVE.L      D1,D2               ; copies number to D2
00001E1C  C4BC 00000F00           1285                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001E22  B4BC 00000000           1286                            CMP.L       #0, D2              ; checks if it is 0
00001E28  6600 0020               1287                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E2C  4EB9 00001E5A           1288                            JSR         PRINTZERO           ; prints a zero
00001E32                          1289                            
00001E32  2401                    1290                            MOVE.L      D1,D2               ; copies number to D2
00001E34  C4BC 000000F0           1291                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001E3A  B4BC 00000000           1292                            CMP.L       #0, D2              ; checks if it is 0
00001E40  6600 0008               1293                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E44  4EB9 00001E5A           1294                            JSR         PRINTZERO           ; prints a zero
00001E4A                          1295  
00001E4A  143C 0010               1296  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001E4E  103C 000F               1297                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001E52  4E4F                    1298                            TRAP        #15                 ; is trap task 15
00001E54  4CDF 0007               1299                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001E58  4E75                    1300                            RTS                             ; returns from subroutine    
00001E5A                          1301  * Prints a zero
00001E5A                          1302  * Input: nothing
00001E5A                          1303  * Output: 0 printed out to the console
00001E5A  2F01                    1304  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001E5C  7200                    1305                            MOVE.L      #0,D1               ; moves 0 to D1
00001E5E  4EB8 1D32               1306                            JSR         PRINTNUM            ; prints the number
00001E62  221F                    1307                            MOVE.L      (SP)+,D1            ; restores D1
00001E64  4E75                    1308                            RTS                             ; returns from subroutine
00001E66                          1309              
00001E66                          1310  * Prints contents of things between a range
00001E66                          1311  * input: A5, A6 (the range)
00001E66                          1312  * output: prints memory contents from A5 to A6 as strings   
00001E66  48E7 C040               1313  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001E6A  224D                    1314                  MOVEA.L     A5, A1           ; loads A5 into A1
00001E6C  9DCD                    1315                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001E6E  320E                    1316                  MOVE.W      A6, D1           ; move n into D1
00001E70  103C 0001               1317                  MOVE.B      #1, D0           ; display n characters of string at A1
00001E74  4E4F                    1318                  TRAP        #15              ; is trap task 1
00001E76  4CDF 0203               1319                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001E7A  4E75                    1320                  RTS                          ; returns
00001E7C                          1321      
00001E7C                          1322  * Prints null terminated string
00001E7C                          1323  * input: string pointed to by A5
00001E7C                          1324  * output: prints out the null terminated string
00001E7C  48E7 8040               1325  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001E80  224D                    1326                  MOVE.L      A5,A1           ; loads A5 into A1
00001E82  103C 000E               1327                  MOVE.B      #14,D0          ; prints null terminated string
00001E86  4E4F                    1328                  TRAP        #15             ; is trap task 10
00001E88  4CDF 0201               1329                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001E8C  4E75                    1330                  RTS                         ; returns from subroutine
00001E8E                          1331                  
00001E8E  2F0D                    1332  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001E90  4BF9 00002094           1333                  LEA         NEW_LINE,A5     ; Prints null
00001E96  4EB8 1E7C               1334                  JSR         PRINTNULL       ; prints the new line
00001E9A  2A5F                    1335                  MOVE.L      (SP)+,A5        ; returns A5
00001E9C  4E75                    1336                  RTS
00001E9E                          1337  
00001E9E                          1338  * Prints the size of the MOVE or MOVEA operation  
00001E9E                          1339  * input: D0
00001E9E                          1340  * output: prints out the size of a MOVE or MOVEA operation        
00001E9E  48E7 8004               1341  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001EA2  3200                    1342                  MOVE.W  D0,D1               ; stores d0 in d1
00001EA4  C07C 3000               1343                  AND.W   #$3000,D0           ; gets the size
00001EA8  B07C 2000               1344                  CMP.W   #$2000,D0           ; checks if is long
00001EAC  6700 001E               1345                  BEQ     MOVE_LONG
00001EB0  B07C 3000               1346                  CMP.W   #$3000,D0           ; checks if is word
00001EB4  6700 000C               1347                  BEQ     MOVE_WORD      
00001EB8                          1348                  
00001EB8  4BF9 0000219F           1349  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001EBE  6000 0012               1350                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001EC2                          1351  
00001EC2  4BF9 000021A5           1352  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001EC8  6000 0008               1353                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001ECC                          1354  
00001ECC  4BF9 000021AB           1355  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001ED2                          1356                  
00001ED2  4EB8 1E7C               1357  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001ED6  4CDF 2001               1358                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001EDA  4E75                    1359                  RTS
00001EDC                          1360  
00001EDC  43F9 0000206A           1361  ERROR           LEA     ERROR_MSG,A1
00001EE2  103C 000E               1362                  MOVE.B  #14,D0
00001EE6  4E4F                    1363                  TRAP    #15 
00001EE8                          1364         
00001EE8                          1365  * DELETE THIS: Test                
00001EE8  2661                    1366  DELETEME        MOVEA.L  -(A1),A3
00001EEA  6700 0038               1367                  BEQ      DELETEMEAGAIN  
00001EEE  6F00 0034               1368                  BLE      DELETEMEAGAIN
00001EF2  6E00 0030               1369                  BGT      DELETEMEAGAIN
00001EF6                          1370  
00001EF6  E40A                    1371                  LSR.B      #2,D2
00001EF8  E2E2                    1372                  LSR.W      -(A2)
00001EFA  E2DA                    1373                  LSR.W      (A2)+
00001EFC  E4AA                    1374                  LSR.L      D2,D2 
00001EFE  E50A                    1375                  LSL.B      #2,D2
00001F00  E3E2                    1376                  LSL.W      -(A2)
00001F02  E3DA                    1377                  LSL.W      (A2)+
00001F04  E5AA                    1378                  LSL.L      D2,D2
00001F06  E51A                    1379                  ROL.B      #2,D2
00001F08  E7E2                    1380                  ROL.W      -(A2)
00001F0A  E7DA                    1381                  ROL.W      (A2)+
00001F0C  E5BA                    1382                  ROL.L      D2,D2
00001F0E  E41A                    1383                  ROR.B      #2,D2
00001F10  E6E2                    1384                  ROR.W      -(A2)
00001F12  E6DA                    1385                  ROR.W      (A2)+
00001F14  E4BA                    1386                  ROR.L      D2,D2
00001F16                          1387                  
00001F16  504D                    1388                  ADDQ.W      #8,A5
00001F18  D6C2                    1389                  ADDA.W      D2,A3
00001F1A  9BCB                    1390                  SUB.L       A3,A5        
00001F1C  8A43                    1391                  OR.W        D3,D5
00001F1E  4642                    1392                  NOT.W       D2
00001F20                          1393                  
00001F20  C5FC 0010               1394                  MULS.W    #$0010,D2
00001F24                          1395                  
00001F24                          1396  DELETEMEAGAIN                 
00001F24                          1397            
00001F24  FFFF FFFF               1398      SIMHALT             ; halt simulator
00001F28                          1399  
00001F28                          1400  * Put variables and constants here
00001F28                          1401  
00001F28  =0000000D               1402  CR                              EQU     $0D
00001F28  =0000000A               1403  LF                              EQU     $0A 
00001F28  =00000009               1404  TAB                             EQU     $09  
00001F28                          1405  
00001F28                          1406  * Addressing Modes
00001F28  =00000000               1407  Dn                              EQU     0
00001F28  =00000001               1408  An                              EQU     1
00001F28  =00000002               1409  AnIndirect                      EQU     2
00001F28  =00000003               1410  AnPost                          EQU     3
00001F28  =00000004               1411  AnPre                           EQU     4
00001F28  =00000007               1412  Other                           EQU     7           ; short, long, immediate
00001F28                          1413  
00001F28                          1414  * Xn
00001F28  =00000000               1415  ABSShort                        EQU     0
00001F28  =00000001               1416  ABSLong                         EQU     1
00001F28  =00000004               1417  XnImmediate                     EQU     4
00001F28                          1418  
00001F28                          1419  * Valid Addressing Modes
00001F28= 00 01 02 03 04 07 FF    1420  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001F2F                          1421  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001F2F= 00 02 03 04 07 FF       1422  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001F35= 02 04 07 FF             1423  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001F39= 02 03 07 FF             1424  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001F3D= 02 03 04 07 FF          1425  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001F42= 00 02 03 04 07 FF       1426  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001F48= 01 07 FF                1427  VALIDEA_LEA                     DC.B    An,Other,-1
00001F4B= 00 02 03 04 07 FF       1428  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001F51= 02 03 04 07 FF          1429  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001F56= 02 03 04 07 FF          1430  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001F5B= 02 07 FF                1431  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001F5E                          1432  
00001F5E                          1433  * Valid Xn
00001F5E= 00 01 04 FF             1434  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001F62                          1435  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001F62= 00 01 FF                1436  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001F65                          1437  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001F65                          1438  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001F65                          1439  
00001F65                          1440  * posible memory ASd/LSd rotation values
00001F65  =00000000               1441  ASd_MEM                         EQU     0   
00001F65  =00000001               1442  LSd_MEM                         EQU     1 
00001F65  =00000003               1443  ROd_MEM                         EQU     3
00001F65                          1444   
00001F65  =00000000               1445  ASd_REG                         EQU     0   
00001F65  =00000001               1446  LSd_REG                         EQU     1 
00001F65  =00000003               1447  ROd_REG                         EQU     3
00001F65                          1448  
00001F65                          1449  * Starting messages
00001F65= 57 65 6C 63 6F 6D ...   1450  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001F8C= 46 6F 72 6D 61 74 ...   1451                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001FDB= 50 6C 65 61 73 65 ...   1452  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002012= 50 6C 65 61 73 65 ...   1453  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00002048= 49 6E 76 61 6C 69 ...   1454  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
0000206A= 45 72 72 6F 72 20 ...   1455  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00002086= 31 30 30 30 09 44 ...   1456  INVALID_INSTR                   DC.B    '1000',TAB,'DATA',TAB,'$',CR,LF,0
00002094= 0D 0A 00                1457  NEW_LINE                        DC.B    CR,LF,0
00002097= 09 09 09 00             1458  THREE_TAB                       DC.B    TAB,TAB,TAB,0
0000209B                          1459  
0000209B                          1460  * Opcode Messages
0000209B= 09 4E 4F 50 00          1461  MSG_NOP                         DC.B    TAB,'NOP',0
000020A0= 09 4D 4F 56 45 00       1462  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000020A6= 09 4D 4F 56 45 41 00    1463  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000020AD= 09 4D 4F 56 45 51 00    1464  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000020B4= 09 4D 4F 56 45 4D 00    1465  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000020BB= 09 41 44 44 00          1466  MSG_ADD                         DC.B    TAB,'ADD',0
000020C0= 09 41 44 44 41 00       1467  MSG_ADDA                        DC.B    TAB,'ADDA',0
000020C6= 09 41 44 44 51 00       1468  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
000020CC= 09 53 55 42 00          1469  MSG_SUB                         DC.B    TAB,'SUB',0
000020D1= 09 4D 55 4C 53 00       1470  MSG_MULS                        DC.B    TAB,'MULS',0
000020D7= 09 44 49 56 55 00       1471  MSG_DIVU                        DC.B    TAB,'DIVU',0
000020DD= 09 4C 45 41 09 09 ...   1472  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
000020E5= 09 41 4E 44 00          1473  MSG_AND                         DC.B    TAB,'AND',0
000020EA= 09 4F 52 00             1474  MSG_OR                          DC.B    TAB,'OR',0
000020EE= 09 4E 4F 54 00          1475  MSG_NOT                         DC.B    TAB,'NOT',0
000020F3= 09 4C 53 00             1476  MSG_LSd                         DC.B    TAB,'LS',0
000020F7= 09 41 53 00             1477  MSG_ASd                         DC.B    TAB,'AS',0
000020FB= 09 52 4F 00             1478  MSG_ROd                         DC.B    TAB,'RO',0
000020FF= 09 42 43 43 09 09 ...   1479  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00002107= 09 42 43 53 09 09 ...   1480  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
0000210F= 09 42 45 51 09 09 ...   1481  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00002117= 09 42 4E 45 09 09 ...   1482  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
0000211F= 09 42 47 45 09 09 ...   1483  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00002127= 09 42 47 54 09 09 ...   1484  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
0000212F= 09 42 48 49 09 09 ...   1485  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00002137= 09 42 4C 45 09 09 ...   1486  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
0000213F= 09 42 4C 53 09 09 ...   1487  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00002147= 09 42 4C 54 09 09 ...   1488  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
0000214F= 09 42 4D 49 09 09 ...   1489  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00002157= 09 42 50 4C 09 09 ...   1490  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
0000215F= 09 42 56 43 09 09 ...   1491  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00002167= 09 42 56 53 09 09 ...   1492  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
0000216F= 09 4A 53 52 09 09 ...   1493  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00002177= 09 52 54 53 00          1494  MSG_RTS                         DC.B    TAB,'RTS',0
0000217C= 09 42 52 41 09 09 ...   1495  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00002184                          1496  
00002184                          1497  * Direction for LSd and ASd
00002184= 52 00                   1498  MSG_RIGHT                       DC.B    'R',0
00002186= 4C 00                   1499  MSG_LEFT                        DC.B    'L',0
00002188                          1500  
00002188                          1501  * Effective Addresses Messages
00002188= 44 00                   1502  MSG_DR                          DC.B    'D',0
0000218A= 41 00                   1503  MSG_AR                          DC.B    'A',0
0000218C= 28 00                   1504  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
0000218E= 29 00                   1505  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00002190= 2B 00                   1506  MSG_PLUS                        DC.B    '+',0
00002192= 2D 00                   1507  MSG_MINUS                       DC.B    '-',0
00002194= 23 00                   1508  MSG_POUND                       DC.B    '#',0 
00002196= 24 00                   1509  MSG_HEX                         DC.B    '$',0 
00002198= 2C 20 00                1510  MSG_COMMA                       DC.B    ', ',0 
0000219B= 20 00                   1511  MSG_SPACE                       DC.B    ' ',0
0000219D= 09 00                   1512  MSG_TAB                         DC.B    TAB,0
0000219F                          1513  
0000219F                          1514  * Size Messages
0000219F= 2E 42 09 09 09 00       1515  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
000021A5= 2E 57 09 09 09 00       1516  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
000021AB= 2E 4C 09 09 09 00       1517  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
000021B1                          1518  
000021B1                          1519  * Variables
000021B1  =00000100               1520  STARTING_ADDRESS                EQU     $100
000021B1  =00000150               1521  ENDING_ADDRESS                  EQU     $150
000021B1  =00000200               1522  CURRENT_INSTR                   EQU     $200
000021B1  =00000250               1523  REG_VAR                         EQU     $250 * Hold bits 11-9
000021B1  =00000300               1524  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000021B1  =00000350               1525  EA_MODE                         EQU     $350 * Hold bits 5-3
000021B1  =00000400               1526  EA_REG                          EQU     $400 * Hold bits 2-0
000021B1                          1527  
000021B1                          1528              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1460
ADDQ_BYTE           14F6
ADDQ_LONG           1516
ADDQ_WORD           1506
ADD_SUB_BYTE        139C
ADD_SUB_HELP        131A
ADD_SUB_LONG        13B8
ADD_SUB_OPERAND     13CE
ADD_SUB_SIZE        1378
ADD_SUB_WORD        13AA
AN                  1
AND_BYTE            16E0
AND_LONG            1700
AND_WORD            16F0
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           2048
CASE_ADD            12EE
CASE_ADDA           1434
CASE_ADDQ           149C
CASE_AND            1696
CASE_AR             1BFA
CASE_ARI            1C12
CASE_ARIPOST        1C42
CASE_ARIPRE         1C7E
CASE_ASDMEM         181C
CASE_ASDREG         18E4
CASE_BCC            1A1C
CASE_BEQ            1A4E
CASE_BGT            1A62
CASE_BLE            1A58
CASE_BRA            19F8
CASE_DATA           1A92
CASE_DR             1BE2
CASE_EPICFAIL       1A94
CASE_IMMEDIATE      1CCC
CASE_JSR            1A7C
CASE_LEA            1604
CASE_LEFTMEM        1842
CASE_LEFTREG        190A
CASE_LONG           1D0C
CASE_LSDASD         17DC
CASE_LSDMEM         1812
CASE_LSDREG         18DA
CASE_MOVE           118A
CASE_MOVEM          1230
CASE_MOVEQ          1296
CASE_NOP            1170
CASE_NOT            1780
CASE_OR             1728
CASE_OTHER          1CBA
CASE_RIGHTMEM       184C
CASE_RIGHTREG       1914
CASE_RODMEM         1826
CASE_RODREG         18EE
CASE_RTS            1A7C
CASE_SHIFTMEM       17FA
CASE_SHIFTREG       18C0
CASE_SUB            1574
CASE_SUBA           15EE
CASE_WORD           1CF0
CHECKEAEXIT         1BB2
CHECKEAMLOOP        1B84
CHECKEAXN_IFVALID   1B82
CHECKGET_EAXN       1AEA
CHECKMEMSOURE       1880
CHECKSHIFT_XN       18AA
CHECK_LENGTH        10C2
CHECK_ODD           1158
CHECK_ORDER         109A
CHECK_XN            1B1A
CONCAT              110A
CONVERT             10D4
CR                  D
CURRENT_INSTR       200
DELETEME            1EE8
DELETEMEAGAIN       1F24
DESTEA              1AA0
DESTXN              1ACA
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          1408
EASHIFT_VALID       189E
EAXN_INVALID        1B2C
EAXN_VALID          1B12
EA_MODE             350
EA_REG              400
EA_TO_STRING        1BB6
EA_TO_STRING_EXIT   1D2C
ENDING              2012
ENDING_ADDRESS      150
END_CHECKGET        1B30
ERROR               1EDC
ERROR_MSG           206A
FINDTYPEEA          1AB4
FINDTYPEXN          1ADE
FINISHMOVE          1ED2
FINISH_ADD          13C6
FINISH_ADDA         1470
FINISH_ADDQ         1526
FINISH_AND          1710
FINISH_SUB          15B4
FINISH_SUBA         15BA
GETDIRECTION        1B6A
GETDISPLACEMENT     1B32
GETMEMSOURCE        1868
GETROTATION         1B60
GETROTATIONLOCATION  1B7A
GETROTATIONSIZE     1B72
GET_EA              1A96
GET_XN              1AC0
INPUT1              100C
INPUT2              1052
INSERTA             11FC
INVALID             1122
INVALIDEA           1B96
INVALID_INSTR       2086
INV_INSTR           171A
ISNUMBER            10EA
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       1296
MOVEM_REG2MEM       1266
MOVE_BYTE           1EB8
MOVE_LONG           1ECC
MOVE_WORD           1EC2
MSG_ADD             20BB
MSG_ADDA            20C0
MSG_ADDQ            20C6
MSG_AND             20E5
MSG_AR              218A
MSG_ASD             20F7
MSG_B               219F
MSG_BCC             20FF
MSG_BCS             2107
MSG_BEQ             210F
MSG_BGE             211F
MSG_BGT             2127
MSG_BHI             212F
MSG_BLE             2137
MSG_BLS             213F
MSG_BLT             2147
MSG_BMI             214F
MSG_BNE             2117
MSG_BPL             2157
MSG_BRA             217C
MSG_BVC             215F
MSG_BVS             2167
MSG_COMMA           2198
MSG_DIVU            20D7
MSG_DR              2188
MSG_HEX             2196
MSG_JSR             216F
MSG_L               21AB
MSG_LB              218C
MSG_LEA             20DD
MSG_LEFT            2186
MSG_LSD             20F3
MSG_MINUS           2192
MSG_MOVE            20A0
MSG_MOVEA           20A6
MSG_MOVEM           20B4
MSG_MOVEQ           20AD
MSG_MULS            20D1
MSG_NOP             209B
MSG_NOT             20EE
MSG_OR              20EA
MSG_PLUS            2190
MSG_POUND           2194
MSG_RB              218E
MSG_RIGHT           2184
MSG_ROD             20FB
MSG_RTS             2177
MSG_SPACE           219B
MSG_SUB             20CC
MSG_TAB             219D
MSG_W               21A5
NEW_LINE            2094
NOTNUMBER           10F2
OPCODE_DECODE       116C
OPMODE_VAR          300
OR_SIZE             1768
OTHER               7
OTHEREA             1BAE
PRINTADD            1360
PRINTADDRESS        1B42
PRINTASHEX          1E4A
PRINTBCC            1A6C
PRINTENTER          1E8E
PRINTHEXNUM         1D42
PRINTLONGZERO       1DA2
PRINTMOVE           1202
PRINTMOVESIZE       1E9E
PRINTNULL           1E7C
PRINTNUM            1D32
PRINTRANGE          1E66
PRINTREGEA          1956
PRINTREGSIZE        1924
PRINTSHIFTMEM       182C
PRINTSHIFTREG       18F4
PRINTSHORTLONGNUM   1D56
PRINTSHORTZERO      1D62
PRINTSUB            158E
PRINTZERO           1E5A
PRINT_8             1568
PRINT_ADDQ_DATA     1544
PRINT_ADDR          1160
PRINT_MEMDIR        1852
PRINT_MOVEQ         12B8
PRINT_REGDIR        191E
REG2MEMXNCHECK      1280
REG_BYTE            193C
REG_IMMEDIATE       196C
REG_LONG            1950
REG_REGISTER        19B2
REG_VAR             250
REG_WORD            1946
RESET_INPUT         10BA
RETURN              1120
ROD_MEM             3
ROD_REG             3
SOURCEEA            1AAC
SOURCEXN            1AD6
START               1000
STARTING            1FDB
STARTING_ADDRESS    100
STOP                10B4
TAB                 9
TEST_RANGE          1140
THREE_TAB           2097
VALIDEA             1B9E
VALIDEA_ADDSUB_DESTOPERAND  1F3D
VALIDEA_ALL         1F28
VALIDEA_ANDORNOT    1F4B
VALIDEA_ANDOR_DESTOPERAND  1F51
VALIDEA_JSR         1F5B
VALIDEA_LEA         1F48
VALIDEA_MOVEM_MEMTOREG  1F39
VALIDEA_MOVEM_REGTOMEM  1F35
VALIDEA_MOVEQ       1F2F
VALIDEA_MULSDIVU    1F42
VALIDEA_SHIFT       1F56
VALIDXN_ALL         1F5E
VALIDXN_SHORTLONG   1F62
WELCOME             1F65
XNIMMEDIATE         4
