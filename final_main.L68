00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/6/2020 11:31:28 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001D33             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001DA9             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001DE0             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 00001B30             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001C68             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6E00 0052                 78                  BGT     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 00001E16            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C                           138                  
0000116C  B07C 4E71                139  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001170  6600 0010                140                  BNE     CASE_MOVE               ; checks the next case if not equal
00001174  4BF9 00001E5B            141                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117A  4EB9 00001C56            142                  JSR     PRINTNULL               ; prints NOP                
00001180  4E75                     143                  RTS                             ; returns from the subroutine
00001182                           144                  
00001182                           145                  * if first two bits are 00, next two are not 00
00001182  3200                     146  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001184  C27C C000                147                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001188  6600 009A                148                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
0000118C  B07C 0FFF                149                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001190  6F00 0092                150                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001194                           151                  
00001194                           152                  ; Check source
00001194  4BF9 00001CF6            153                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119A  4DF9 00001D2C            154                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A0  3E3C 0000                155                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A4  4EB9 000018C4            156                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AA  B27C 0001                157                  CMP.W   #1,D1                    ; checks if invalid
000011AE  6700 06BC                158                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B2  3802                     159                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B4  3A03                     160                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011B6                           161                  
000011B6                           162                  ; Check destination
000011B6  4BF9 00001CF6            163                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011BC  4DF9 00001D30            164                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C2  3E3C 0001                165                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011C6  4EB9 000018C4            166                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011CC  B27C 0001                167                  CMP.W   #1,D1                    ; checks if invalid
000011D0  6700 069A                168                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D4  3C02                     169                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011D6  3E03                     170                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011D8                           171                  
000011D8                           172                  ; Checking if it is MOVEA
000011D8  3200                     173                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DA  C27C 01C0                174                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011DE  B27C 0040                175                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E2  6700 000C                176                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011E6                           177   
000011E6  4BF9 00001E60            178                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011EC  6000 0008                179                  BRA     PRINTMOVE                ; Branches to print move
000011F0                           180                  
000011F0  4BF9 00001E66            181  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011F6                           182   
000011F6  4EB9 00001C56            183  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
000011FC  4EB9 00001C78            184                  JSR     PRINTMOVESIZE            ; prints out the size  
00001202  3404                     185                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001204  3605                     186                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001206  4EB9 00001990            187                  JSR     EA_TO_STRING             ; outputs it into a string
0000120C                           188                  
0000120C                           189                  ; prints a comma to seperate
0000120C  4BF9 00001F58            190                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001212  4EB9 00001C56            191                  JSR     PRINTNULL                ; prints out MOVE
00001218                           192                  
00001218                           193                  ; print destination
00001218  3406                     194                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121A  3607                     195                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000121C  4EB9 00001990            196                  JSR     EA_TO_STRING             ; outputs it into a string
00001222  4E75                     197                  RTS                              ; exits subroutine                 
00001224                           198                
00001224                           199                  
00001224  3200                     200  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001226  C27C FB80                201                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122A  B27C 4880                202                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000122E  6600 005A                203                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001232                           204                  
00001232                           205                  ; loads EA and XN
00001232  323C 0000                206                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001236  4EB9 00001870            207                  JSR     GET_EA                          ; gets EA and puts in D1
0000123C  3401                     208                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
0000123E  323C 0000                209                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001242  4EB9 0000189A            210                  JSR     GET_XN                          ; gets XN and puts in D1
00001248  3601                     211                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
0000124A                           212                  
0000124A                           213                  ; Check D
0000124A  3200                     214                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000124C  C27C 0400                215                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001250  3E01                     216                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001252  B27C 0400                217                  CMP.W   #$0400,D1                       ; checks if value is 1
00001256  6700 0032                218                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000125A                           219  
0000125A  4BF9 00001D03            220  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001260  3202                     221                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001262  4EB9 0000195C            222                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001268  B27C 0001                223                  CMP.W   #1,D1                           ; checks if D1 invalid
0000126C  6700 05FE                224                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001270  B27C 0002                225                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001274                           226                  
00001274  4BF9 00001D03            227  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127A  3203                     228                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
0000127C  4EB9 0000195C            229                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001282  B27C 0001                230                  CMP.W   #1,D1                           ; checks if D1 invalid
00001286  6700 05E4                231                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128A                           232  
0000128A                           233                  
0000128A                           234  
0000128A                           235  MOVEM_MEM2REG    
0000128A                           236                          
0000128A                           237  
0000128A                           238  
0000128A  3200                     239  CASE_MOVEQ      MOVE.W  D0,D1
0000128C  C27C F100                240                  AND.W   #$F100,D1
00001290  B27C 7000                241                  CMP.W   #$7000,D1
00001294  6600 0048                242                  BNE     CASE_ADD
00001298                           243                  
00001298                           244                  ;loads Register
00001298  323C 0001                245                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000129C  4EB9 0000189A            246                  JSR     GET_XN                          ; gets XN and puts in D1
000012A2  3401                     247                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012A4                           248                  
000012A4                           249                  ;loads DATA
000012A4  3200                     250                  MOVE.W  D0,D1
000012A6  C27C 00FF                251                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012AA  3601                     252                  MOVE.W  D1,D3                          ;copy data into D3
000012AC                           253                                                          ;must convert bits to hex
000012AC                           254                  
000012AC                           255                  
000012AC  4BF9 00001E6D            256  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B2  4EB9 00001C56            257                  JSR     PRINTNULL  
000012B8                           258                  
000012B8  4BF9 00001F6B            259                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012BE  4EB9 00001C56            260                  JSR     PRINTNULL
000012C4                           261      
000012C4  4BF9 00001E57            262                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000012CA  4EB9 00001C56            263                  JSR     PRINTNULL
000012D0                           264                  
000012D0  4BF9 00001F54            265                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012D6  4EB9 00001C56            266                  JSR     PRINTNULL
000012DC  4E75                     267                  RTS
000012DE                           268                  
000012DE                           269  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000012DE  3200                     270  CASE_ADD        MOVE.W  D0,D1
000012E0  C27C F000                271                  AND.W   #$F000,D1
000012E4  B27C D000                272                  CMP.W   #$D000,D1
000012E8  6600 0166                273                  BNE     CASE_ADDQ
000012EC                           274                  
000012EC                           275                  ; Check bits 0-5 
000012EC  4BF9 00001CF6            276                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012F2  4DF9 00001D2C            277                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012F8  3E3C 0000                278                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012FC  4EB9 000018C4            279                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001302  B27C 0001                280                  CMP.W   #1,D1                    ; checks if invalid
00001306  6700 0564                281                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000130A  3802                     282                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000130C  3A03                     283                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000130E                           284                  
0000130E                           285                  ; get bits 9-11
0000130E  3200                     286                  MOVE.W  D0,D1
00001310  E949                     287                  LSL.W   #4,D1                   ; get rid of left 4 bits
00001312  E849                     288                  LSR.W   #4,D1
00001314  E049                     289                  LSR.W   #8,D1                   ; get rid of right 6 bits
00001316  E249                     290                  LSR.W   #1,D1                   ; get rid of right 6 bits
00001318  3C01                     291                  MOVE.W  D1,D6
0000131A                           292                  
0000131A                           293                  ; bits 7-8 determine if it is ADDA or ADD
0000131A  3200                     294                  MOVE.W  D0,D1
0000131C  E149                     295                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000131E  E049                     296                  LSR.W   #8,D1
00001320  EC49                     297                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001322  B27C 0003                298                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001326  6700 00C0                299                  BEQ     CASE_ADDA
0000132A                           300                  
0000132A  4BF9 00001E7B            301                  LEA     MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001330  6000 0002                302                  BRA     PRINTADD                ; Branches to print move
00001334                           303                  
00001334  4EB9 00001C56            304  PRINTADD        JSR     PRINTNULL
0000133A  3200                     305                  MOVE.W  D0,D1                   ; bits 7-8 contain size
0000133C  E149                     306                  LSL.W   #8,D1
0000133E  E049                     307                  LSR.W   #8,D1
00001340  EC49                     308                  LSR.W   #6,D1                   ; gets bits 7-8
00001342                           309                  
00001342  B27C 0001                310                  CMP.W   #1,D1                   ; if 1, it is a word
00001346  6700 001A                311                  BEQ     ADD_WORD
0000134A  B27C 0002                312                  CMP.W   #2,D1                   ; if 2, it is a long
0000134E  6700 0022                313                  BEQ     ADD_LONG
00001352                           314                  
00001352  4BF9 00001F5F            315  ADD_BYTE        LEA     MSG_B,A5
00001358  4EB9 00001C56            316                  JSR     PRINTNULL
0000135E  6000 0022                317                  BRA     FINISH_ADD  
00001362                           318  
00001362  4BF9 00001F65            319  ADD_WORD        LEA     MSG_W,A5
00001368  4EB9 00001C56            320                  JSR     PRINTNULL
0000136E  6000 0012                321                  BRA     FINISH_ADD  
00001372                           322                  
00001372                           323  
00001372  4BF9 00001F6B            324  ADD_LONG        LEA     MSG_L,A5
00001378  4EB9 00001C56            325                  JSR     PRINTNULL
0000137E  6000 0002                326                  BRA     FINISH_ADD  
00001382                           327  
00001382  EF49                     328  FINISH_ADD      LSL.W   #7,D1
00001384  EE49                     329                  LSR.W   #7,D1
00001386  E049                     330                  LSR.W   #8,D1
00001388                           331  
00001388  B27C 0001                332                  CMP.W   #1,D1
0000138C  6000 002E                333                  BRA     Dn_PLUS_EA          
00001390                           334                  
00001390                           335                  ; print Data Register
00001390  4BF9 00001F48            336                  LEA     MSG_DR,A5
00001396  4EB9 00001C56            337                  JSR     PRINTNULL
0000139C  3206                     338                  MOVE.W  D6,D1
0000139E  4EB9 00001B0C            339                  JSR     PRINTNUM                
000013A4                           340                  
000013A4                           341                  ; prints a comma to seperate
000013A4  4BF9 00001F58            342                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000013AA  4EB9 00001C56            343                  JSR     PRINTNULL                ; prints out MOVE
000013B0                           344                  
000013B0                           345                  ; below is EA+Dn->Dn  
000013B0  3404                     346                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013B2  3605                     347                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013B4  4EB9 00001990            348                  JSR     EA_TO_STRING             ; outputs it into a string
000013BA  4E75                     349                  RTS                              ; exits subroutine 
000013BC                           350  
000013BC                           351  Dn_PLUS_EA      ; below is Dn+EA->EA  
000013BC  3404                     352                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013BE  3605                     353                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013C0  4EB9 00001990            354                  JSR     EA_TO_STRING             ; outputs it into a string   
000013C6                           355                  
000013C6                           356                  ; prints a comma to seperate
000013C6  4BF9 00001F58            357                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000013CC  4EB9 00001C56            358                  JSR     PRINTNULL                ; prints out MOVE
000013D2                           359                  
000013D2                           360                  ; below is Dn+EA->EA
000013D2  4BF9 00001F48            361                  LEA     MSG_DR,A5                  ; print data register
000013D8  4EB9 00001C56            362                  JSR     PRINTNULL
000013DE  3206                     363                  MOVE.W  D6,D1
000013E0  4EB9 00001B0C            364                  JSR     PRINTNUM             
000013E6  4E75                     365                  RTS                              ; exits subroutine                
000013E8                           366                   
000013E8                           367  
000013E8  3200                     368  CASE_ADDA       MOVE.W  D0,D1
000013EA  EF49                     369                  LSL.W   #7,D1
000013EC  EE49                     370                  LSR.W   #7,D1
000013EE  E049                     371                  LSR     #8,D1                               ; gets bit 8 (size bit)
000013F0                           372                  
000013F0  4BF9 00001E80            373                  LEA     MSG_ADDA,A5
000013F6  4EB9 00001C56            374                  JSR     PRINTNULL
000013FC                           375                  
000013FC  B27C 0001                376                  CMP.W   #1,D1
00001400  6700 0012                377                  BEQ     ADDA_LONG
00001404                           378                  
00001404  4BF9 00001F65            379                  LEA     MSG_W,A5
0000140A  4EB9 00001C56            380                  JSR     PRINTNULL
00001410  6000 0012                381                  BRA     FINISH_ADDA   
00001414                           382                  
00001414  4BF9 00001F6B            383  ADDA_LONG       LEA     MSG_L,A5
0000141A  4EB9 00001C56            384                  JSR     PRINTNULL
00001420  6000 0002                385                  BRA     FINISH_ADDA
00001424                           386                  
00001424  3404                     387  FINISH_ADDA     MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001426  3605                     388                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001428  4EB9 00001990            389                  JSR     EA_TO_STRING             ; outputs it into a string
0000142E                           390                  
0000142E                           391                  ; prints a comma to seperate
0000142E  4BF9 00001F58            392                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001434  4EB9 00001C56            393                  JSR     PRINTNULL                ; prints out MOVE
0000143A                           394          
0000143A  4BF9 00001F4A            395                  LEA     MSG_AR,A5                ; print address register
00001440  4EB9 00001C56            396                  JSR     PRINTNULL
00001446  3206                     397                  MOVE.W  D6,D1
00001448  4EB9 00001B0C            398                  JSR     PRINTNUM             
0000144E  4E75                     399                  RTS                              ; exits subroutine
00001450                           400                  
00001450                           401  
00001450  3200                     402  CASE_ADDQ       MOVE.W  D0,D1
00001452  C27C F000                403                  AND.W   #$F000,D1       
00001456  B27C 5000                404                  CMP.W   #$5000,D1
0000145A  6600 00C8                405                  BNE     CASE_SUB
0000145E                           406                  
0000145E                           407                  ; Check bits 0-5 
0000145E  4BF9 00001CF6            408                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001464  4DF9 00001D2C            409                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000146A  3E3C 0000                410                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000146E  4EB9 000018C4            411                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001474  B27C 0001                412                  CMP.W   #1,D1                    ; checks if invalid
00001478  6700 03F2                413                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000147C  3802                     414                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000147E  3A03                     415                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001480                           416                  
00001480                           417                  ; get bits 6-7 (size bits)
00001480  3200                     418                  MOVE.W  D0,D1
00001482  E149                     419                  LSL.W   #8,D1
00001484  E049                     420                  LSR.W   #8,D1
00001486  EC49                     421                  LSR.W   #6,D1
00001488  3401                     422                  MOVE.W  D1,D2
0000148A                           423  
0000148A                           424                  ; gets bits 9-11 (data bits)
0000148A  E949                     425                  LSL.W   #4,D1
0000148C  E849                     426                  LSR.W   #4,D1                               ; get rid of left 4 bits
0000148E  E049                     427                  LSR.W   #8,D1
00001490  E249                     428                  LSR.W   #1,D1                               ; get rid of right 9 bits
00001492                           429                  
00001492  4BF9 00001E86            430                  LEA     MSG_ADDQ,A5
00001498  4EB9 00001C56            431                  JSR     PRINTNULL
0000149E                           432                  
0000149E  B47C 0001                433                  CMP.W   #1,D2
000014A2  6700 001A                434                  BEQ     ADDQ_WORD
000014A6  B47C 0002                435                  CMP.W   #2,D2
000014AA  6700 0022                436                  BEQ     ADDQ_LONG
000014AE                           437                  
000014AE  4BF9 00001F5F            438  ADDQ_BYTE       LEA     MSG_B,A5
000014B4  4EB9 00001C56            439                  JSR     PRINTNULL
000014BA  6000 0022                440                  BRA     FINISH_ADDQ  
000014BE                           441  
000014BE  4BF9 00001F65            442  ADDQ_WORD       LEA     MSG_W,A5
000014C4  4EB9 00001C56            443                  JSR     PRINTNULL
000014CA  6000 0012                444                  BRA     FINISH_ADDQ                 
000014CE                           445  
000014CE  4BF9 00001F6B            446  ADDQ_LONG       LEA     MSG_L,A5
000014D4  4EB9 00001C56            447                  JSR     PRINTNULL
000014DA  6000 0002                448                  BRA     FINISH_ADDQ                  
000014DE                           449                  
000014DE  4EB9 000014FC            450  FINISH_ADDQ     JSR     PRINT_ADDQ_DATA
000014E4                           451  
000014E4                           452                  ; prints a comma to seperate
000014E4  4BF9 00001F58            453                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000014EA  4EB9 00001C56            454                  JSR     PRINTNULL                ; prints out MOVE
000014F0                           455                  
000014F0                           456                  ; prints destination
000014F0  3404                     457                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000014F2  3605                     458                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000014F4  4EB9 00001990            459                  JSR     EA_TO_STRING             ; outputs it into a string
000014FA                           460                  
000014FA  4E75                     461                  RTS
000014FC                           462  
000014FC                           463  
000014FC  4BF9 00001F54            464  PRINT_ADDQ_DATA LEA     MSG_POUND,A5
00001502  4EB9 00001C56            465                  JSR     PRINTNULL
00001508  B27C 0000                466                  CMP.W   #0,D1
0000150C  6700 000A                467                  BEQ     PRINT_8
00001510  4EB9 00001B0C            468                  JSR     PRINTNUM
00001516  4E75                     469                  RTS 
00001518                           470  
00001518  123C 0008                471  PRINT_8         MOVE.B  #8,D1
0000151C  4EB9 00001B0C            472                  JSR     PRINTNUM
00001522  4E75                     473                  RTS           
00001524                           474                  
00001524                           475  
00001524                           476  CASE_SUB
00001524                           477  
00001524  3200                     478  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001526  C27C F000                479                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000152A  B27C 4000                480                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000152E  6600 0086                481                  BNE.W   CASE_AND                             ; If its not, check AND
00001532  3200                     482                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001534  C27C 01C0                483                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001538  B27C 01C0                484                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000153C  6600 0078                485                  BNE.W   CASE_AND                             ; If its not, check AND
00001540                           486                  
00001540                           487                  ; Check source
00001540  4BF9 00001D16            488                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001546  4DF9 00001D30            489                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000154C  3E3C 0000                490                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001550  4EB9 000018C4            491                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001556  3802                     492                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001558  3A03                     493                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000155A                           494                  
0000155A                           495                  ; Check destination
0000155A  4BF9 00001D16            496                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001560  4DF9 00001D30            497                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001566  3E3C 0001                498                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000156A  4EB9 000018C4            499                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001570  3C02                     500                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001572  3E03                     501                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001574                           502  
00001574  4BF9 00001E9D            503                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000157A  4EB9 00001C56            504                  JSR     PRINTNULL                            ; prints LEA
00001580                           505                  
00001580                           506                  ; print source
00001580  3404                     507                  MOVE.W  D4,D2
00001582  3605                     508                  MOVE.W  D5,D3
00001584  4EB9 00001990            509                  JSR     EA_TO_STRING                         ; Prints out the EA
0000158A                           510                  
0000158A                           511                  ; comma
0000158A  4BF9 00001F58            512                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001590  4EB9 00001C56            513                  JSR     PRINTNULL                       
00001596                           514                   
00001596                           515                  ; register
00001596  4BF9 00001F4A            516                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
0000159C  4EB9 00001C56            517                  JSR     PRINTNULL 
000015A2  3401                     518                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000015A4  323C 0001                519                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000015A8  4EB9 0000189A            520                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000015AE  4EB9 00001B0C            521                  JSR     PRINTNUM                             ; Prints the number in D1
000015B4  4E75                     522                  RTS
000015B6                           523  
000015B6                           524  **---------------AND opcode----------------------
000015B6                           525  CASE_AND
000015B6                           526  *CASE_AND        LEA         MSG_AND,A1
000015B6                           527  *                MOVE.B      #14,D0
000015B6                           528  *                TRAP        #15 
000015B6                           529  *                JSR         GET_VARS
000015B6                           530  *                JSR         AND_SIZE                        ; .B, .W, or .L  
000015B6                           531  *                MOVE.W      CURRENT_INSTR, D5                         
000015B6                           532  *                LSL.W       #7, D5                        
000015B6                           533  *                LSR.W       #8, D5                   
000015B6                           534  *                LSR.W       #7, D5                     
000015B6                           535  *                CMP.B       #00, D5                         ; check if destination is a Dn?
000015B6                           536  *                BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
000015B6                           537  *                CMP.B       #$01,D5                         ; Is the destination not a Dn?
000015B6                           538  *                BEQ         DEST_EA                         ; branch to DEST_EA            
000015B6                           539  *                RTS
000015B6                           540     
000015B6                           541  *AND_SIZE        CMP.B       #%00,OPMODE_VAR       
000015B6                           542  *                BEQ         PRINT_BYTE
000015B6                           543  *                CMP.B       #$01, OPMODE_VAR
000015B6                           544  *                BEQ         PRINT_WORD
000015B6                           545  *                CMP.B       #$02, OPMODE_VAR
000015B6                           546  *                BEQ         PRINT_LONG    
000015B6                           547  *    
000015B6                           548  *DEST_DN         MOVE.W      CURRENT_INSTR, D5               
000015B6                           549  *                LSL.W       #6,D5
000015B6                           550  *                LSL.W       #4,D5
000015B6                           551  *                LSR.W       #6,D5
000015B6                           552  *                LSR.W       #4,D5
000015B6                           553  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000015B6                           554  *                  
000015B6                           555  *                MOVE.W      CURRENT_INSTR, D6               
000015B6                           556  *                LSL.W       #6,D5
000015B6                           557  *                LSL.W       #4,D5
000015B6                           558  *                LSL.W       #3,D6
000015B6                           559  *                LSR.W       #6,D6
000015B6                           560  *                LSR.W       #4,D6
000015B6                           561  *                LSR.W       #3,D6                           ; d6 stores EA register
000015B6                           562  *                JSR         FIND_EA
000015B6                           563  *
000015B6                           564  *                
000015B6                           565  *                MOVE.W      CURRENT_INSTR, D5               
000015B6                           566  *                LSL.W       #4, D5                         
000015B6                           567  *                LSR.W       #8, D5                          ; shift bits to get register
000015B6                           568  *                LSR.W       #5, D5                          ; D5 contains register
000015B6                           569  *                LEA         MSG_COMMA, A1                   
000015B6                           570  *                MOVE.B      #14,D0
000015B6                           571  *                TRAP        #15                             ; print comma
000015B6                           572  *                LEA         MSG_DR, A1                      ; print D
000015B6                           573  *                MOVE.B      #14,D0
000015B6                           574  *                TRAP        #15
000015B6                           575  *                MOVEA.L     D5,A1
000015B6                           576  *                MOVE.B      #14,D0
000015B6                           577  *                TRAP        #15                              
000015B6                           578  *                RTS        
000015B6                           579  *
000015B6                           580  *FIND_EA        CMP.W       #%010,D5
000015B6                           581  *                BEQ         CASE_ARI
000015B6                           582  *                CMP.W       #%011,D5
000015B6                           583  *                BEQ         CASE_ARIPOST
000015B6                           584  *                CMP.W       #%100,D5
000015B6                           585  *                BEQ         CASE_ARIPRE
000015B6                           586  *                CMP.W       #%111,D5
000015B6                           587  *                BEQ         CASE_OTHER
000015B6                           588  *                BRA         ERROR    
000015B6                           589  *                                     
000015B6                           590  *DEST_EA         MOVE.W      CURRENT_INSTR, D5               
000015B6                           591  *                LSL.W       #4, D5                         
000015B6                           592  *                LSR.W       #8, D5                          ; shift bits to get register
000015B6                           593  *                LSR.W       #5, D5                          ; D5 contains register
000015B6                           594  *
000015B6                           595  *                LEA         MSG_DR, A1                   
000015B6                           596  *                MOVE.B      #14,D0
000015B6                           597  *                TRAP        #15                             ; print D
000015B6                           598  *                MOVEA.L     D5,A1  
000015B6                           599  *                MOVE.B      #14,D0                          ; print register
000015B6                           600  *                TRAP        #15
000015B6                           601  *                
000015B6                           602  *                LEA         MSG_COMMA, A1                   
000015B6                           603  *                MOVE.B      #14,D0
000015B6                           604  *                TRAP        #15                             ; print comma
000015B6                           605  *                
000015B6                           606  *                MOVE.W      CURRENT_INSTR, D5               
000015B6                           607  *                LSL.W       #6,D5
000015B6                           608  *                LSL.W       #4,D5
000015B6                           609  *                LSR.W       #6,D5
000015B6                           610  *                LSR.W       #4,D5
000015B6                           611  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000015B6                           612  *                  
000015B6                           613  *                MOVE.W      CURRENT_INSTR, D6               
000015B6                           614  *                LSL.W       #6,D6
000015B6                           615  *                LSL.W       #4,D6
000015B6                           616  *                LSL.W       #3,D6
000015B6                           617  *                LSR.W       #6,D6
000015B6                           618  *                LSR.W       #4,D6
000015B6                           619  *                LSR.W       #3,D6                           ; d6 stores EA register
000015B6                           620  *                JSR         FIND_EA                          
000015B6                           621  *                RTS                                     Return full instruction   
000015B6                           622              
000015B6                           623  CASE_OR
000015B6                           624  
000015B6                           625  CASE_NOT
000015B6                           626  
000015B6  3200                     627  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
000015B8  C27C F000                628                  AND.W       #$F000, D1                       ; gets first 4 bits
000015BC  B27C E000                629                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000015C0  6600 0210                630                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000015C4  3400                     631                  MOVE.W      D0,D2                            ; copies D0 to D2
000015C6  4EB9 0000194C            632                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000015CC  B47C 0003                633                  CMP.W       #$3, D2                          ; checks if it is memory or register option
000015D0  6600 00C8                634                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
000015D4                           635                  
000015D4  3400                     636  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
000015D6  4EB9 0000193A            637                  JSR         GETROTATION                      ; gets rotation value of D2
000015DC  B47C 0000                638                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
000015E0  6700 0014                639                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
000015E4  B47C 0003                640                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
000015E8  6700 0016                641                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
000015EC                           642                  
000015EC  4BF9 00001EB3            643  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
000015F2  6000 0012                644                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000015F6                           645  
000015F6  4BF9 00001EB7            646  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
000015FC  6000 0008                647                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001600                           648  
00001600  4BF9 00001EBB            649  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001606                           650                  
00001606  4EB9 00001C56            651  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
0000160C  3400                     652                  MOVE.W      D0,D2                            ; copies D0 to D2
0000160E  4EB9 00001944            653                  JSR         GETDIRECTION                     ; gets direction
00001614  B47C 0000                654                  CMP.W       #0,D2                            ; checking if its right
00001618  6700 000C                655                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
0000161C                           656  
0000161C  4BF9 00001F46            657  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001622  6000 0008                658                  BRA         PRINT_MEMDIR                     ; branches for printing
00001626                           659          
00001626  4BF9 00001F44            660  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
0000162C                           661  
0000162C  4EB9 00001C56            662  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001632  4BF9 00001F65            663                  LEA         MSG_W,A5                         ; loads .W into A5
00001638  4EB9 00001C56            664                  JSR         PRINTNULL                        ; Prints .W
0000163E  6000 0002                665                  BRA         GETMEMSOURCE                     ; checks the source 
00001642                           666                  
00001642                           667  ; get source addressing mode       
00001642                           668  GETMEMSOURCE                                                 
00001642  323C 0000                669                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001646  4EB9 00001870            670                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
0000164C  3801                     671                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
0000164E  323C 0000                672                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001652  4EB9 0000189A            673                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001658  3A01                     674                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
0000165A                           675  
0000165A  4BF9 00001D24            676  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001660  3204                     677                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001662  4EB9 0000195C            678                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001668  B27C 0002                679                  CMP.W       #2,D1                            ; checks if it is Xn
0000166C  6700 0016                680                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001670  B27C 0001                681                  CMP.W       #1,D1                            ; Checks if it is invalid
00001674  6700 01F6                682                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001678                           683  
00001678  3404                     684  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
0000167A  3605                     685                  MOVE.W      D5,D3                            ; moves EA to D3
0000167C  4EB9 00001990            686                  JSR         EA_TO_STRING                     ; prints out the EA
00001682  4E75                     687                  RTS                
00001684                           688                  
00001684                           689                  
00001684  4BF9 00001D30            690  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
0000168A  3205                     691                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
0000168C  4EB9 0000195C            692                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001692  4A41                     693                  TST.W       D1                               ; checks if it is valid
00001694  67E2                     694                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001696  6000 01D4                695                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
0000169A                           696  
0000169A                           697  
0000169A  3602                     698  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
0000169C  3200                     699                  MOVE.W      D0,D1                            ; copies D0 to D1
0000169E  C27C 0018                700                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000016A2  E649                     701                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000016A4  B27C 0000                702                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000016A8  6700 0014                703                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000016AC  B27C 0003                704                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000016B0  6700 0016                705                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000016B4                           706                  
000016B4  4BF9 00001EB3            707  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
000016BA  6000 0012                708                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000016BE                           709  
000016BE  4BF9 00001EB7            710  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
000016C4  6000 0008                711                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000016C8                           712  
000016C8  4BF9 00001EBB            713  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
000016CE                           714                  
000016CE  4EB9 00001C56            715  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
000016D4  3400                     716                  MOVE.W      D0,D2                            ; copies D0 to D2
000016D6  4EB9 00001944            717                  JSR         GETDIRECTION                     ; gets direction
000016DC  B47C 0000                718                  CMP.W       #0,D2                            ; checking if its right
000016E0  6700 000C                719                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
000016E4                           720  
000016E4  4BF9 00001F46            721  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
000016EA  6000 000C                722                  BRA         PRINT_REGDIR                     ; branches for printing
000016EE                           723          
000016EE  4BF9 00001F44            724  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
000016F4  6000 0002                725                  BRA         PRINT_REGDIR                     ; branches for printing
000016F8                           726                  
000016F8  4EB9 00001C56            727  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
000016FE                           728  
000016FE  3400                     729  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001700  4EB9 0000194C            730                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001706  B47C 0001                731                  CMP.W       #1,D2                            ; Checks if it is word size
0000170A  6700 0014                732                  BEQ         REG_WORD                         ; Prints .W
0000170E  B47C 0002                733                  CMP.W       #2,D2                            ; Checks if it is long size
00001712  6700 0016                734                  BEQ         REG_LONG                         ; Prints .L
00001716                           735  
00001716  4BF9 00001F5F            736  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
0000171C  6000 0012                737                  BRA         PRINTREGEA      
00001720                           738  
00001720  4BF9 00001F65            739  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001726  6000 0008                740                  BRA         PRINTREGEA      
0000172A                           741                             
0000172A  4BF9 00001F6B            742  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001730                           743  
00001730  4EB9 00001C56            744  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001736  3400                     745                  MOVE.W      D0,D2                            ; copies D0 to D1
00001738  4EB9 00001954            746                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
0000173E  B27C 0001                747                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001742  6700 0048                748                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001746                           749                                  
00001746  3400                     750  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001748  4EB9 0000194C            751                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000174E  3202                     752                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001750  4BF9 00001F54            753                  LEA         MSG_POUND, A5                    ; loads # into A5
00001756  4EB9 00001C56            754                  JSR         PRINTNULL                        ; prints #
0000175C  4EB9 00001B0C            755                  JSR         PRINTNUM                         ; prints shift count
00001762  4BF9 00001F58            756                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001768  4EB9 00001C56            757                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
0000176E  4BF9 00001F48            758                  LEA         MSG_DR, A5                       ; loads D into A5
00001774  4EB9 00001C56            759                  JSR         PRINTNULL                        ; prints out D 
0000177A  323C 0000                760                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
0000177E  4EB9 0000189A            761                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001784  4EB9 00001B0C            762                  JSR         PRINTNUM                         ; prints data register number in D1          
0000178A  4E75                     763                  RTS                                          ; ends subroutine to go onto the next instruction opcode
0000178C                           764                  
0000178C  3400                     765  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
0000178E  4EB9 0000194C            766                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001794  3202                     767                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001796  4BF9 00001F48            768                  LEA         MSG_DR, A5                       ; loads D into A5
0000179C  4EB9 00001C56            769                  JSR         PRINTNULL                        ; prints D
000017A2  4EB9 00001B0C            770                  JSR         PRINTNUM                         ; prints register number
000017A8  4BF9 00001F58            771                  LEA         MSG_COMMA, A5                    ; loads , into A5
000017AE  4EB9 00001C56            772                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000017B4  4BF9 00001F48            773                  LEA         MSG_DR, A5                       ; loads D into A5
000017BA  4EB9 00001C56            774                  JSR         PRINTNULL                        ; prints out D 
000017C0  323C 0000                775                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000017C4  4EB9 0000189A            776                  JSR         GET_XN                           ; gets the data register number, stores in D1
000017CA  4EB9 00001B0C            777                  JSR         PRINTNUM                         ; prints data register number in D1          
000017D0  4E75                     778                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000017D2                           779               
000017D2  3200                     780  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000017D4  C27C FF00                781                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
000017D8  B27C 6000                782                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
000017DC  6600 0018                783                  BNE.W   CASE_BCC                             ; If its not, check BCC
000017E0                           784                  
000017E0  4BF9 00001F3C            785                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
000017E6  4EB9 00001C56            786                  JSR     PRINTNULL                            ; prints BRA
000017EC                           787  
000017EC  3400                     788                  MOVE.W  D0,D2                                ; Copies instruction word to D1
000017EE  4EB9 0000190C            789                  JSR     GETDISPLACEMENT                      ; finds the displacement
000017F4  4E75                     790                  RTS
000017F6                           791                  
000017F6                           792  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
000017F6                           793  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
000017F6  3200                     794  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
000017F8  C27C F000                795                  AND.W   #$F000,D1                            ; get top 4 bits
000017FC  B27C 6000                796                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001800  6600 0054                797                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001804  3200                     798                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001806  C27C 0F00                799                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
0000180A  E049                     800                  LSR.W   #8,D1                                ; shifts 8 bits to the right
0000180C                           801                  
0000180C  B27C 000E                802                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001810  6700 002A                803                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001814                           804                  
00001814  B27C 000F                805                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001818  6700 0018                806                  BEQ     CASE_BLE                             ; branches to BLE if it is
0000181C                           807                      
0000181C  B27C 0007                808                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001820  6700 0006                809                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001824  6000 0046                810                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001828                           811     
00001828  4BF9 00001ECF            812  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
0000182E  6000 0016                813                  BRA     PRINTBCC
00001832                           814  
00001832  4BF9 00001EF7            815  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001838  6000 000C                816                  BRA     PRINTBCC
0000183C                           817                  
0000183C  4BF9 00001EE7            818  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001842  6000 0002                819                  BRA     PRINTBCC
00001846                           820  
00001846  4EB9 00001C56            821  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
0000184C  3400                     822                  MOVE.W  D0,D2                                ; Copies instruction word to D1
0000184E  4EB9 0000190C            823                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001854  4E75                     824                  RTS              
00001856                           825                  
00001856                           826  
00001856                           827  CASE_JSR       
00001856                           828  
00001856  B07C 4E75                829  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
0000185A  6600 F926                830                  BNE     CASE_MOVE           ; checks the next case if not equal
0000185E  4BF9 00001F37            831                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001864  4EB9 00001C56            832                  JSR     PRINTNULL           ; prints RTS                
0000186A  4E75                     833                  RTS                         ; returns from the subroutine
0000186C                           834  
0000186C                           835                  
0000186C                           836  
0000186C                           837  CASE_DATA           
0000186C  4E75                     838                      RTS               
0000186E                           839  
0000186E  4E75                     840  CASE_EPICFAIL       RTS
00001870                           841  
00001870                           842  
00001870                           843  * Finds the EA type
00001870                           844  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001870                           845  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001870  48E7 3000                846  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001874  4A41                     847                      TST.W     D1                    ; compares D1 to 0
00001876  6700 000E                848                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
0000187A                           849                      
0000187A  343C 01C0                850  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
0000187E  363C 0006                851                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001882  6000 000A                852                      BRA       FINDTYPEEA            
00001886                           853  
00001886  343C 0038                854  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
0000188A  363C 0003                855                      MOVE.W    #3,D3                 ; stores the shift amount to D3
0000188E                           856  
0000188E                           857  
0000188E  3200                     858  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001890  C242                     859                      AND.W     D2,D1                 ; applies bitmask to D1
00001892  E669                     860                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001894  4CDF 000C                861                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001898  4E75                     862                      RTS                             ; returns from subroutine    
0000189A                           863                      
0000189A                           864  * Finds Xn type
0000189A                           865  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
0000189A                           866  * Output: Addressing Mode (3 bits, 0 to 7) in D1
0000189A  48E7 3000                867  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
0000189E  4A41                     868                      TST.W     D1                    ; compares D1 to 0
000018A0  6700 000E                869                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
000018A4                           870  
000018A4  343C 0E00                871  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
000018A8  363C 0009                872                      MOVE.W    #9,D3                 ; stores the shift amount to D3
000018AC  6000 000A                873                      BRA       FINDTYPEXN            ; finds the type of Xn
000018B0                           874  
000018B0  343C 0007                875  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
000018B4  363C 0000                876                      MOVE.W    #0,D3                 ; stores the shift amount to D3
000018B8                           877                      
000018B8  3200                     878  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
000018BA  C242                     879                      AND.W     D2,D1                 ; applies bitmask to D1
000018BC  E669                     880                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000018BE  4CDF 000C                881                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000018C2  4E75                     882                      RTS                             ; returns from subroutine 
000018C4                           883                      
000018C4                           884  * Checks and gets the EA and Xn
000018C4                           885  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
000018C4                           886  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
000018C4  3207                     887  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
000018C6  4EB8 1870                888                  JSR     GET_EA                  ; Gets EA
000018CA  3401                     889                  MOVE.W  D1,D2                   ; Stores EA in D2
000018CC  3207                     890                  MOVE.W  D7,D1                   ; loads value representing position of EA   
000018CE  4EB8 189A                891                  JSR     GET_XN                  ; Gets Xn
000018D2  3601                     892                  MOVE.W  D1,D3                   ; Stores Xn in D3
000018D4  3202                     893                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
000018D6                           894                  
000018D6  4EB9 0000195C            895                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
000018DC  B27C 0002                896                  CMP.W   #2,D1                   ; checks if it is Xn
000018E0  6700 0012                897                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
000018E4  B27C 0001                898                  CMP.W   #1,D1                   ; Checks if it is invalid
000018E8  6700 001C                899                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
000018EC                           900                  
000018EC                           901                  
000018EC  323C 0000                902  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
000018F0  6000 0018                903                  BRA     END_CHECKGET
000018F4                           904        
000018F4                           905  ; need XN
000018F4  2A4E                     906  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
000018F6  3203                     907                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
000018F8  4EB9 0000195C            908                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
000018FE  4A41                     909                  TST.W   D1                      ; checks if it is valid
00001900  67EA                     910                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001902  6000 0002                911                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001906                           912   
00001906  323C 0001                913  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
0000190A                           914  
0000190A  4E75                     915  END_CHECKGET    RTS          
0000190C                           916                                            
0000190C                           917                                            
0000190C                           918  * Gets the displacement and pritns it 
0000190C                           919  * Inputs: D2 = instruction word, A2 = address of next word
0000190C                           920  * Outputs: prints out displacement
0000190C  48E7 4004                921  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001910  3A4A                     922                      MOVE.W    A2,A5                 ; copies A2 to A5
00001912  C47C 00FF                923                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001916  6600 0004                924                      BNE       PRINTADDRESS          ; prints address if not 0
0000191A  341A                     925                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
0000191C                           926                      
0000191C  D44D                     927  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
0000191E  3202                     928                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001920  183C 0000                929                      MOVE.B    #0,D4                 ; marks address as word  length
00001924  4BF9 00001F56            930                      LEA       MSG_HEX,A5            ; loads hex sign to A5
0000192A  4EB9 00001C56            931                      JSR       PRINTNULL             ; prints null
00001930  4EB9 00001B30            932                      JSR       PRINTSHORTLONGNUM     ; prints address
00001936                           933                      
00001936  4CDF 2002                934                      MOVEM.L    (SP)+,D1/A5              ; restores D1
0000193A                           935                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
0000193A                           936  
0000193A                           937  * Gets the rotation value for ASd and LSd
0000193A                           938  * Input: D2 = instruction word copy (of D0)                                    
0000193A                           939  * Output: rotation  value in D2             
0000193A  C47C 0E00                940  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
0000193E  E04A                     941                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001940  E24A                     942                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001942  4E75                     943                      RTS                             ; return from subroutine
00001944                           944  
00001944                           945  * Gets the direction value for ASd and LSd
00001944                           946  * Input: D2 = instruction word copy (of D0)                                    
00001944                           947  * Output: direction value in D2             
00001944  C47C 0100                948  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001948  E04A                     949                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
0000194A  4E75                     950                      RTS                             ; return from subroutine
0000194C                           951  
0000194C                           952  * Gets the rotation size value for ASd and LSd
0000194C                           953  * Input: D2 = instruction word copy (of D0)                                    
0000194C                           954  * Output: rotation size value in D2             
0000194C  C47C 00C0                955  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001950  EC4A                     956                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001952  4E75                     957                      RTS                             ; return from subroutine
00001954                           958  
00001954                           959  * Gets the rotation location  value for ASd and LSd
00001954                           960  * Input: D2 = instruction word copy (of D0)                                    
00001954                           961  * Output: rotation location value in D2             
00001954  C47C 0020                962  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001958  EA4A                     963                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
0000195A  4E75                     964                      RTS                             ; return from subroutine
0000195C                           965  
0000195C                           966                          
0000195C                           967  * Checks if EA or Xn is valid
0000195C                           968  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
0000195C                           969  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
0000195C  2F02                     970  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
0000195E                           971  
0000195E  141D                     972  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001960  B43C 00FF                973                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001964  6700 000A                974                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001968  B202                     975                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
0000196A  6700 000C                976                     BEQ        VALIDEA               ; branches to valid EA
0000196E  60EE                     977                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001970                           978                     
00001970  323C 0001                979  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001974  6000 0016                980                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001978                           981                    
00001978  B43C 0007                982  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
0000197C  6700 000A                983                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001980  323C 0000                984                     MOVE.W     #$0,D1                ; marks that it is valid
00001984  6000 0006                985                     BRA        CHECKEAEXIT           ; exits the subroutine
00001988                           986  
00001988  323C 0002                987  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
0000198C                           988  
0000198C  241F                     989  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
0000198E  4E75                     990                     RTS                              ; returns from subroutine
00001990                           991  
00001990                           992  * Converts EA and Xn into a string                                
00001990                           993  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001990                           994  * Outputs: Prints out EA and Xn into a string
00001990  48E7 C004                995  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001994  B47C 0001                996                     CMP.W    #An,D2                  ; checks if it is An
00001998  6700 003A                997                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
0000199C                           998                     
0000199C  B47C 0002                999                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
000019A0  6700 004A               1000                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
000019A4                          1001                     
000019A4  B47C 0003               1002                     CMP.W    #AnPost,D2              ; checks if it is (An)+
000019A8  6700 0072               1003                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
000019AC                          1004                     
000019AC  B47C 0004               1005                     CMP.W    #AnPre,D2               ; checks if it is -(An)
000019B0  6700 00A6               1006                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
000019B4                          1007                     
000019B4  B47C 0007               1008                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
000019B8  6700 00DA               1009                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
000019BC                          1010                     ; otherwise assumes D2 = #Dn which means its a data register                   
000019BC                          1011  
000019BC                          1012  * data register, Dn
000019BC  4BF9 00001F48           1013  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
000019C2  4EB9 00001C56           1014                     JSR      PRINTNULL               ; Prints D
000019C8  3203                    1015                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000019CA  4EB9 00001B0C           1016                     JSR      PRINTNUM                ; Prints the Xn
000019D0  6000 0134               1017                     BRA      EA_TO_STRING_EXIT       ; exits           
000019D4                          1018  
000019D4                          1019  
000019D4                          1020  * address register
000019D4  4BF9 00001F4A           1021  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
000019DA  4EB9 00001C56           1022                     JSR      PRINTNULL               ; Prints A
000019E0  3203                    1023                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000019E2  4EB9 00001B0C           1024                     JSR      PRINTNUM                ; Prints the Xn
000019E8  6000 011C               1025                     BRA      EA_TO_STRING_EXIT       ; exits
000019EC                          1026  
000019EC                          1027  * address register indirect
000019EC  4BF9 00001F4C           1028  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
000019F2  4EB9 00001C56           1029                     JSR      PRINTNULL               ; Prints (
000019F8  4BF9 00001F4A           1030                     LEA      MSG_AR,A5               ; Loads A into A5
000019FE  4EB9 00001C56           1031                     JSR      PRINTNULL               ; Prints A
00001A04  3203                    1032                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001A06  4EB9 00001B0C           1033                     JSR      PRINTNUM                ; Prints the Xn
00001A0C  4BF9 00001F4E           1034                     LEA      MSG_RB,A5               ; Loads ) into A5
00001A12  4EB9 00001C56           1035                     JSR      PRINTNULL               ; Prints )
00001A18  6000 00EC               1036                     BRA      EA_TO_STRING_EXIT       ; exits
00001A1C                          1037  
00001A1C                          1038  * address register indirect post increment
00001A1C  4BF9 00001F4C           1039  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001A22  4EB9 00001C56           1040                     JSR      PRINTNULL               ; Prints (
00001A28  4BF9 00001F4A           1041                     LEA      MSG_AR,A5               ; Loads A into A5
00001A2E  4EB9 00001C56           1042                     JSR      PRINTNULL               ; Prints A
00001A34  3203                    1043                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001A36  4EB9 00001B0C           1044                     JSR      PRINTNUM                ; Prints the Xn
00001A3C  4BF9 00001F4E           1045                     LEA      MSG_RB,A5               ; Loads ) into A5
00001A42  4EB9 00001C56           1046                     JSR      PRINTNULL               ; Prints )
00001A48  4BF9 00001F50           1047                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001A4E  4EB9 00001C56           1048                     JSR      PRINTNULL               ; Prints +
00001A54  6000 00B0               1049                     BRA      EA_TO_STRING_EXIT       ; exits
00001A58                          1050  
00001A58                          1051  
00001A58                          1052  * address register indirect pre increment
00001A58  4BF9 00001F52           1053  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001A5E  4EB9 00001C56           1054                     JSR      PRINTNULL               ; Prints -
00001A64  4BF9 00001F4C           1055                     LEA      MSG_LB,A5               ; Loads ( into A5
00001A6A  4EB9 00001C56           1056                     JSR      PRINTNULL               ; Prints (
00001A70  4BF9 00001F4A           1057                     LEA      MSG_AR,A5               ; Loads A into A5
00001A76  4EB9 00001C56           1058                     JSR      PRINTNULL               ; Prints A
00001A7C  3203                    1059                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001A7E  4EB9 00001B0C           1060                     JSR      PRINTNUM                ; Prints the Xn
00001A84  4BF9 00001F4E           1061                     LEA      MSG_RB,A5               ; Loads ) into A5
00001A8A  4EB9 00001C56           1062                     JSR      PRINTNULL               ; Prints )
00001A90  6000 0074               1063                     BRA      EA_TO_STRING_EXIT       ; exits
00001A94                          1064  
00001A94                          1065  * other (long, short, immediate) with Xn yes
00001A94  301A                    1066  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001A96  B67C 0000               1067                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001A9A  6700 002E               1068                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001A9E                          1069                     
00001A9E  B67C 0001               1070                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001AA2  6700 0042               1071                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001AA6                          1072  
00001AA6                          1073  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001AA6                          1074  * immediate
00001AA6  4BF9 00001F54           1075  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001AAC  4EB9 00001C56           1076                     JSR      PRINTNULL               ; Prints #  
00001AB2  4BF9 00001F56           1077                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001AB8  4EB9 00001C56           1078                     JSR      PRINTNULL               ; Prints $
00001ABE  3200                    1079                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001AC0  4EB9 00001B1C           1080                     JSR      PRINTHEXNUM 
00001AC6  6000 003E               1081                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001ACA                          1082                     
00001ACA                          1083  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001ACA                          1084  
00001ACA                          1085  * word address
00001ACA                          1086  CASE_WORD          
00001ACA  4BF9 00001F56           1087                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001AD0  4EB9 00001C56           1088                     JSR      PRINTNULL               ; Prints $
00001AD6  3200                    1089                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001AD8  383C 0000               1090                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001ADC  4EB9 00001B30           1091                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001AE2  6000 0022               1092                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001AE6                          1093  
00001AE6                          1094  * long address 
00001AE6                          1095  CASE_LONG          
00001AE6  4BF9 00001F56           1096                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001AEC  4EB9 00001C56           1097                     JSR      PRINTNULL               ; Prints $
00001AF2  3200                    1098                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001AF4  383C 0001               1099                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001AF8  4EB9 00001B30           1100                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001AFE  321A                    1101                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001B00  4EB9 00001B0C           1102                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001B06                          1103  
00001B06                          1104  
00001B06                          1105  * exits subroutine
00001B06  4CDF 2003               1106  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001B0A  4E75                    1107                      RTS                              ; returns from subroutine
00001B0C                          1108  
00001B0C                          1109  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001B0C                          1110  
00001B0C                          1111  * Prints out the content of D1 as a decimal number
00001B0C                          1112  * Input: number in D1 to be printed
00001B0C                          1113  * Output: contents of D1 printed
00001B0C  48E7 C000               1114  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001B10  103C 0003               1115                   MOVE.B      #3,D0               ; prints D1
00001B14  4E4F                    1116                   TRAP        #15                 ; is trap task 3
00001B16                          1117              
00001B16  4CDF 0003               1118                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001B1A  4E75                    1119                   RTS                             ; returns from subroutine
00001B1C                          1120                   
00001B1C                          1121  * Prints out the content of D1 as a hex number
00001B1C                          1122  * Input: number in D1 to be printed
00001B1C                          1123  * Output: contents of D1 printed
00001B1C  48E7 C000               1124  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001B20  143C 0010               1125                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001B24  103C 000F               1126                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001B28  4E4F                    1127                   TRAP        #15                 ; is trap task 15
00001B2A  4CDF 0003               1128                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001B2E  4E75                    1129                   RTS                             ; returns from subroutine
00001B30                          1130                   
00001B30                          1131  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001B30                          1132  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001B30                          1133  * Output: contents of D1 printed
00001B30  48E7 E000               1134  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001B34  B83C 0001               1135                            CMP.B       #1,D4               ; checks size of number
00001B38  6700 0042               1136                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001B3C                          1137  
00001B3C  3401                    1138  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001B3E  C47C F000               1139                            AND.W       #$F000,D2           ; gets the first digit
00001B42  B47C 0000               1140                            CMP.W       #0, D2              ; checks if it is 0
00001B46  6600 00DC               1141                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B4A  4EB9 00001C34           1142                            JSR         PRINTZERO           ; prints a zero
00001B50                          1143                            
00001B50  3401                    1144                            MOVE.W      D1,D2               ; copies number to D2
00001B52  C47C 0F00               1145                            AND.W       #$0F00,D2           ; gets the second digit
00001B56  B47C 0000               1146                            CMP.W       #0, D2              ; checks if it is 0
00001B5A  6600 00C8               1147                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B5E  4EB9 00001C34           1148                            JSR         PRINTZERO           ; prints a zero
00001B64                          1149                            
00001B64  3401                    1150                            MOVE.W      D1,D2               ; copies number to D2
00001B66  C47C 00F0               1151                            AND.W       #$00F0,D2           ; gets the third digit
00001B6A  B47C 0000               1152                            CMP.W       #0, D2              ; checks if it is 0
00001B6E  6600 00B4               1153                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B72  4EB9 00001C34           1154                            JSR         PRINTZERO           ; prints a zero
00001B78  6000 00AA               1155                            BRA         PRINTASHEX          ; prints last digit
00001B7C                          1156                            
00001B7C  2401                    1157  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001B7E  C4BC F0000000           1158                            AND.L       #$F0000000,D2       ; gets the first digit
00001B84  B4BC 00000000           1159                            CMP.L       #0, D2              ; checks if it is 0
00001B8A  6600 0098               1160                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B8E  4EB9 00001C34           1161                            JSR         PRINTZERO           ; prints a zero
00001B94                          1162                            
00001B94  2401                    1163                            MOVE.L      D1,D2               ; copies number to D2
00001B96  C4BC 0F000000           1164                            AND.L       #$0F000000,D2       ; gets the second digit
00001B9C  B4BC 00000000           1165                            CMP.L       #0, D2              ; checks if it is 0
00001BA2  6600 0080               1166                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001BA6  4EB9 00001C34           1167                            JSR         PRINTZERO           ; prints a zero
00001BAC                          1168                            
00001BAC  2401                    1169                            MOVE.L      D1,D2               ; copies number to D2
00001BAE  C4BC 00F00000           1170                            AND.L       #$00F00000,D2       ; gets the third digit
00001BB4  B4BC 00000000           1171                            CMP.L       #0, D2              ; checks if it is 0
00001BBA  6600 0068               1172                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001BBE  4EB9 00001C34           1173                            JSR         PRINTZERO           ; prints a zero
00001BC4                          1174                            
00001BC4  2401                    1175                            MOVE.L      D1,D2               ; copies number to D2
00001BC6  C4BC 000F0000           1176                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001BCC  B4BC 00000000           1177                            CMP.L       #0, D2              ; checks if it is 0
00001BD2  6600 0050               1178                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001BD6  4EB9 00001C34           1179                            JSR         PRINTZERO           ; prints a zero
00001BDC                          1180                            
00001BDC  2401                    1181                            MOVE.L      D1,D2               ; copies number to D2
00001BDE  C4BC 0000F000           1182                            AND.L       #$0000F000,D2       ; gets the fith digit
00001BE4  B4BC 00000000           1183                            CMP.L       #0, D2              ; checks if it is 0
00001BEA  6600 0038               1184                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001BEE  4EB9 00001C34           1185                            JSR         PRINTZERO           ; prints a zero
00001BF4                          1186                            
00001BF4  2401                    1187                            MOVE.L      D1,D2               ; copies number to D2
00001BF6  C4BC 00000F00           1188                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001BFC  B4BC 00000000           1189                            CMP.L       #0, D2              ; checks if it is 0
00001C02  6600 0020               1190                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C06  4EB9 00001C34           1191                            JSR         PRINTZERO           ; prints a zero
00001C0C                          1192                            
00001C0C  2401                    1193                            MOVE.L      D1,D2               ; copies number to D2
00001C0E  C4BC 000000F0           1194                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001C14  B4BC 00000000           1195                            CMP.L       #0, D2              ; checks if it is 0
00001C1A  6600 0008               1196                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C1E  4EB9 00001C34           1197                            JSR         PRINTZERO           ; prints a zero
00001C24                          1198  
00001C24  143C 0010               1199  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001C28  103C 000F               1200                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001C2C  4E4F                    1201                            TRAP        #15                 ; is trap task 15
00001C2E  4CDF 0007               1202                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001C32  4E75                    1203                            RTS                             ; returns from subroutine    
00001C34                          1204  * Prints a zero
00001C34                          1205  * Input: nothing
00001C34                          1206  * Output: 0 printed out to the console
00001C34  2F01                    1207  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001C36  7200                    1208                            MOVE.L      #0,D1               ; moves 0 to D1
00001C38  4EB8 1B0C               1209                            JSR         PRINTNUM            ; prints the number
00001C3C  221F                    1210                            MOVE.L      (SP)+,D1            ; restores D1
00001C3E  4E75                    1211                            RTS                             ; returns from subroutine
00001C40                          1212              
00001C40                          1213  * Prints contents of things between a range
00001C40                          1214  * input: A5, A6 (the range)
00001C40                          1215  * output: prints memory contents from A5 to A6 as strings   
00001C40  48E7 C040               1216  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001C44  224D                    1217                  MOVEA.L     A5, A1           ; loads A5 into A1
00001C46  9DCD                    1218                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001C48  320E                    1219                  MOVE.W      A6, D1           ; move n into D1
00001C4A  103C 0001               1220                  MOVE.B      #1, D0           ; display n characters of string at A1
00001C4E  4E4F                    1221                  TRAP        #15              ; is trap task 1
00001C50  4CDF 0203               1222                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001C54  4E75                    1223                  RTS                          ; returns
00001C56                          1224      
00001C56                          1225  * Prints null terminated string
00001C56                          1226  * input: string pointed to by A5
00001C56                          1227  * output: prints out the null terminated string
00001C56  48E7 8040               1228  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001C5A  224D                    1229                  MOVE.L      A5,A1           ; loads A5 into A1
00001C5C  103C 000E               1230                  MOVE.B      #14,D0          ; prints null terminated string
00001C60  4E4F                    1231                  TRAP        #15             ; is trap task 10
00001C62  4CDF 0201               1232                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001C66  4E75                    1233                  RTS                         ; returns from subroutine
00001C68                          1234                  
00001C68  2F0D                    1235  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001C6A  4BF9 00001E54           1236                  LEA         NEW_LINE,A5     ; Prints null
00001C70  4EB8 1C56               1237                  JSR         PRINTNULL       ; prints the new line
00001C74  2A5F                    1238                  MOVE.L      (SP)+,A5        ; returns A5
00001C76  4E75                    1239                  RTS
00001C78                          1240  
00001C78                          1241  * Prints the size of the MOVE or MOVEA operation  
00001C78                          1242  * input: D0
00001C78                          1243  * output: prints out the size of a MOVE or MOVEA operation        
00001C78  48E7 8004               1244  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001C7C  3200                    1245                  MOVE.W  D0,D1               ; stores d0 in d1
00001C7E  C07C 3000               1246                  AND.W   #$3000,D0           ; gets the size
00001C82  B07C 2000               1247                  CMP.W   #$2000,D0           ; checks if is long
00001C86  6700 001E               1248                  BEQ     MOVE_LONG
00001C8A  B07C 3000               1249                  CMP.W   #$3000,D0           ; checks if is word
00001C8E  6700 000C               1250                  BEQ     MOVE_WORD      
00001C92                          1251                  
00001C92  4BF9 00001F5F           1252  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001C98  6000 0012               1253                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001C9C                          1254  
00001C9C  4BF9 00001F65           1255  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001CA2  6000 0008               1256                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001CA6                          1257  
00001CA6  4BF9 00001F6B           1258  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001CAC                          1259                  
00001CAC  4EB8 1C56               1260  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001CB0  4CDF 2001               1261                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001CB4  4E75                    1262                  RTS
00001CB6                          1263  
00001CB6  43F9 00001E38           1264  ERROR           LEA     ERROR_MSG,A1
00001CBC  103C 000E               1265                  MOVE.B  #14,D0
00001CC0  4E4F                    1266                  TRAP    #15 
00001CC2                          1267         
00001CC2                          1268  * DELETE THIS: Test                
00001CC2  2661                    1269  DELETEME        MOVEA.L  -(A1),A3
00001CC4  6700 002C               1270                  BEQ      DELETEMEAGAIN  
00001CC8  6F00 0028               1271                  BLE      DELETEMEAGAIN
00001CCC  6E00 0024               1272                  BGT      DELETEMEAGAIN
00001CD0                          1273  
00001CD0  E40A                    1274                  LSR.B      #2,D2
00001CD2  E2E2                    1275                  LSR.W      -(A2)
00001CD4  E2DA                    1276                  LSR.W      (A2)+
00001CD6  E4AA                    1277                  LSR.L      D2,D2 
00001CD8  E50A                    1278                  LSL.B      #2,D2
00001CDA  E3E2                    1279                  LSL.W      -(A2)
00001CDC  E3DA                    1280                  LSL.W      (A2)+
00001CDE  E5AA                    1281                  LSL.L      D2,D2
00001CE0  E51A                    1282                  ROL.B      #2,D2
00001CE2  E7E2                    1283                  ROL.W      -(A2)
00001CE4  E7DA                    1284                  ROL.W      (A2)+
00001CE6  E5BA                    1285                  ROL.L      D2,D2
00001CE8  E41A                    1286                  ROR.B      #2,D2
00001CEA  E6E2                    1287                  ROR.W      -(A2)
00001CEC  E6DA                    1288                  ROR.W      (A2)+
00001CEE  E4BA                    1289                  ROR.L      D2,D2
00001CF0                          1290                  
00001CF0  504D                    1291                  ADDQ.W      #8,A5
00001CF2                          1292                         
00001CF2                          1293                  
00001CF2                          1294  DELETEMEAGAIN                 
00001CF2                          1295            
00001CF2  FFFF FFFF               1296      SIMHALT             ; halt simulator
00001CF6                          1297  
00001CF6                          1298  * Put variables and constants here
00001CF6                          1299  
00001CF6  =0000000D               1300  CR                              EQU     $0D
00001CF6  =0000000A               1301  LF                              EQU     $0A 
00001CF6  =00000009               1302  TAB                             EQU     $09  
00001CF6                          1303  
00001CF6                          1304  * Addressing Modes
00001CF6  =00000000               1305  Dn                              EQU     0
00001CF6  =00000001               1306  An                              EQU     1
00001CF6  =00000002               1307  AnIndirect                      EQU     2
00001CF6  =00000003               1308  AnPost                          EQU     3
00001CF6  =00000004               1309  AnPre                           EQU     4
00001CF6  =00000007               1310  Other                           EQU     7           ; short, long, immediate
00001CF6                          1311  
00001CF6                          1312  * Xn
00001CF6  =00000000               1313  ABSShort                        EQU     0
00001CF6  =00000001               1314  ABSLong                         EQU     1
00001CF6  =00000004               1315  XnImmediate                     EQU     4
00001CF6                          1316  
00001CF6                          1317  * Valid Addressing Modes
00001CF6= 00 01 02 03 04 07 FF    1318  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001CFD                          1319  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001CFD= 00 02 03 04 07 FF       1320  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001D03= 02 04 07 FF             1321  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001D07= 02 03 07 FF             1322  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001D0B= 02 03 04 07 FF          1323  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001D10= 00 02 03 04 07 FF       1324  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001D16= 01 07 FF                1325  VALIDEA_LEA                     DC.B    An,Other,-1
00001D19= 00 02 03 04 07 FF       1326  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001D1F= 02 03 04 07 FF          1327  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001D24= 02 03 04 07 FF          1328  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001D29= 02 07 FF                1329  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001D2C                          1330  
00001D2C                          1331  * Valid Xn
00001D2C= 00 01 04 FF             1332  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001D30                          1333  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001D30= 00 01 FF                1334  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001D33                          1335  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001D33                          1336  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001D33                          1337  
00001D33                          1338  * posible memory ASd/LSd rotation values
00001D33  =00000000               1339  ASd_MEM                         EQU     0   
00001D33  =00000001               1340  LSd_MEM                         EQU     1 
00001D33  =00000003               1341  ROd_MEM                         EQU     3
00001D33                          1342   
00001D33  =00000000               1343  ASd_REG                         EQU     0   
00001D33  =00000001               1344  LSd_REG                         EQU     1 
00001D33  =00000003               1345  ROd_REG                         EQU     3
00001D33                          1346  
00001D33                          1347  * Starting messages
00001D33= 57 65 6C 63 6F 6D ...   1348  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001D5A= 46 6F 72 6D 61 74 ...   1349                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001DA9= 50 6C 65 61 73 65 ...   1350  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001DE0= 50 6C 65 61 73 65 ...   1351  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001E16= 49 6E 76 61 6C 69 ...   1352  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001E38= 45 72 72 6F 72 20 ...   1353  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001E54= 0D 0A 00                1354  NEW_LINE                        DC.B    CR,LF,0
00001E57= 09 09 09 00             1355  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001E5B                          1356  
00001E5B                          1357  * Opcode Messages
00001E5B= 09 4E 4F 50 00          1358  MSG_NOP                         DC.B    TAB,'NOP',0
00001E60= 09 4D 4F 56 45 00       1359  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001E66= 09 4D 4F 56 45 41 00    1360  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001E6D= 09 4D 4F 56 45 51 00    1361  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001E74= 09 4D 4F 56 45 4D 00    1362  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001E7B= 09 41 44 44 00          1363  MSG_ADD                         DC.B    TAB,'ADD',0
00001E80= 09 41 44 44 41 00       1364  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001E86= 09 41 44 44 51 00       1365  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001E8C= 09 53 55 42 00          1366  MSG_SUB                         DC.B    TAB,'SUB',0
00001E91= 09 4D 55 4C 53 00       1367  MSG_MULS                        DC.B    TAB,'MULS',0
00001E97= 09 44 49 56 55 00       1368  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001E9D= 09 4C 45 41 09 09 ...   1369  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001EA5= 09 41 4E 44 00          1370  MSG_AND                         DC.B    TAB,'AND',0
00001EAA= 09 4F 52 00             1371  MSG_OR                          DC.B    TAB,'OR',0
00001EAE= 09 4E 4F 54 00          1372  MSG_NOT                         DC.B    TAB,'NOT',0
00001EB3= 09 4C 53 00             1373  MSG_LSd                         DC.B    TAB,'LS',0
00001EB7= 09 41 53 00             1374  MSG_ASd                         DC.B    TAB,'AS',0
00001EBB= 09 52 4F 00             1375  MSG_ROd                         DC.B    TAB,'RO',0
00001EBF= 09 42 43 43 09 09 ...   1376  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001EC7= 09 42 43 53 09 09 ...   1377  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001ECF= 09 42 45 51 09 09 ...   1378  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001ED7= 09 42 4E 45 09 09 ...   1379  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001EDF= 09 42 47 45 09 09 ...   1380  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001EE7= 09 42 47 54 09 09 ...   1381  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001EEF= 09 42 48 49 09 09 ...   1382  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001EF7= 09 42 4C 45 09 09 ...   1383  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001EFF= 09 42 4C 53 09 09 ...   1384  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001F07= 09 42 4C 54 09 09 ...   1385  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001F0F= 09 42 4D 49 09 09 ...   1386  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001F17= 09 42 50 4C 09 09 ...   1387  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001F1F= 09 42 56 43 09 09 ...   1388  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001F27= 09 42 56 53 09 09 ...   1389  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001F2F= 09 4A 53 52 09 09 ...   1390  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001F37= 09 52 54 53 00          1391  MSG_RTS                         DC.B    TAB,'RTS',0
00001F3C= 09 42 52 41 09 09 ...   1392  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001F44                          1393  
00001F44                          1394  * Direction for LSd and ASd
00001F44= 52 00                   1395  MSG_RIGHT                       DC.B    'R',0
00001F46= 4C 00                   1396  MSG_LEFT                        DC.B    'L',0
00001F48                          1397  
00001F48                          1398  * Effective Addresses Messages
00001F48= 44 00                   1399  MSG_DR                          DC.B    'D',0
00001F4A= 41 00                   1400  MSG_AR                          DC.B    'A',0
00001F4C= 28 00                   1401  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001F4E= 29 00                   1402  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001F50= 2B 00                   1403  MSG_PLUS                        DC.B    '+',0
00001F52= 2D 00                   1404  MSG_MINUS                       DC.B    '-',0
00001F54= 23 00                   1405  MSG_POUND                       DC.B    '#',0 
00001F56= 24 00                   1406  MSG_HEX                         DC.B    '$',0 
00001F58= 2C 20 00                1407  MSG_COMMA                       DC.B    ', ',0 
00001F5B= 20 00                   1408  MSG_SPACE                       DC.B    ' ',0
00001F5D= 09 00                   1409  MSG_TAB                         DC.B    TAB,0
00001F5F                          1410  
00001F5F                          1411  * Size Messages
00001F5F= 2E 42 09 09 09 00       1412  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001F65= 2E 57 09 09 09 00       1413  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001F6B= 2E 4C 09 09 09 00       1414  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001F71                          1415  
00001F71                          1416  * Variables
00001F71  =00000100               1417  STARTING_ADDRESS                EQU     $100
00001F71  =00000150               1418  ENDING_ADDRESS                  EQU     $150
00001F71  =00000200               1419  CURRENT_INSTR                   EQU     $200
00001F71  =00000250               1420  REG_VAR                         EQU     $250 * Hold bits 11-9
00001F71  =00000300               1421  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001F71  =00000350               1422  EA_MODE                         EQU     $350 * Hold bits 5-3
00001F71  =00000400               1423  EA_REG                          EQU     $400 * Hold bits 2-0
00001F71                          1424  
00001F71                          1425              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1414
ADDQ_BYTE           14AE
ADDQ_LONG           14CE
ADDQ_WORD           14BE
ADD_BYTE            1352
ADD_LONG            1372
ADD_WORD            1362
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1E16
CASE_ADD            12DE
CASE_ADDA           13E8
CASE_ADDQ           1450
CASE_AND            15B6
CASE_AR             19D4
CASE_ARI            19EC
CASE_ARIPOST        1A1C
CASE_ARIPRE         1A58
CASE_ASDMEM         15F6
CASE_ASDREG         16BE
CASE_BCC            17F6
CASE_BEQ            1828
CASE_BGT            183C
CASE_BLE            1832
CASE_BRA            17D2
CASE_DATA           186C
CASE_DR             19BC
CASE_EPICFAIL       186E
CASE_IMMEDIATE      1AA6
CASE_JSR            1856
CASE_LEA            1524
CASE_LEFTMEM        161C
CASE_LEFTREG        16E4
CASE_LONG           1AE6
CASE_LSDASD         15B6
CASE_LSDMEM         15EC
CASE_LSDREG         16B4
CASE_MOVE           1182
CASE_MOVEM          1224
CASE_MOVEQ          128A
CASE_NOP            116C
CASE_NOT            15B6
CASE_OR             15B6
CASE_OTHER          1A94
CASE_RIGHTMEM       1626
CASE_RIGHTREG       16EE
CASE_RODMEM         1600
CASE_RODREG         16C8
CASE_RTS            1856
CASE_SHIFTMEM       15D4
CASE_SHIFTREG       169A
CASE_SUB            1524
CASE_WORD           1ACA
CHECKEAEXIT         198C
CHECKEAMLOOP        195E
CHECKEAXN_IFVALID   195C
CHECKGET_EAXN       18C4
CHECKMEMSOURE       165A
CHECKSHIFT_XN       1684
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            18F4
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1CC2
DELETEMEAGAIN       1CF2
DESTEA              187A
DESTXN              18A4
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          13BC
EASHIFT_VALID       1678
EAXN_INVALID        1906
EAXN_VALID          18EC
EA_MODE             350
EA_REG              400
EA_TO_STRING        1990
EA_TO_STRING_EXIT   1B06
ENDING              1DE0
ENDING_ADDRESS      150
END_CHECKGET        190A
ERROR               1CB6
ERROR_MSG           1E38
FINDTYPEEA          188E
FINDTYPEXN          18B8
FINISHMOVE          1CAC
FINISH_ADD          1382
FINISH_ADDA         1424
FINISH_ADDQ         14DE
GETDIRECTION        1944
GETDISPLACEMENT     190C
GETMEMSOURCE        1642
GETROTATION         193A
GETROTATIONLOCATION  1954
GETROTATIONSIZE     194C
GET_EA              1870
GET_XN              189A
INPUT1              100C
INPUT2              1052
INSERTA             11F0
INVALID             112C
INVALIDEA           1970
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128A
MOVEM_REG2MEM       125A
MOVE_BYTE           1C92
MOVE_LONG           1CA6
MOVE_WORD           1C9C
MSG_ADD             1E7B
MSG_ADDA            1E80
MSG_ADDQ            1E86
MSG_AND             1EA5
MSG_AR              1F4A
MSG_ASD             1EB7
MSG_B               1F5F
MSG_BCC             1EBF
MSG_BCS             1EC7
MSG_BEQ             1ECF
MSG_BGE             1EDF
MSG_BGT             1EE7
MSG_BHI             1EEF
MSG_BLE             1EF7
MSG_BLS             1EFF
MSG_BLT             1F07
MSG_BMI             1F0F
MSG_BNE             1ED7
MSG_BPL             1F17
MSG_BRA             1F3C
MSG_BVC             1F1F
MSG_BVS             1F27
MSG_COMMA           1F58
MSG_DIVU            1E97
MSG_DR              1F48
MSG_HEX             1F56
MSG_JSR             1F2F
MSG_L               1F6B
MSG_LB              1F4C
MSG_LEA             1E9D
MSG_LEFT            1F46
MSG_LSD             1EB3
MSG_MINUS           1F52
MSG_MOVE            1E60
MSG_MOVEA           1E66
MSG_MOVEM           1E74
MSG_MOVEQ           1E6D
MSG_MULS            1E91
MSG_NOP             1E5B
MSG_NOT             1EAE
MSG_OR              1EAA
MSG_PLUS            1F50
MSG_POUND           1F54
MSG_RB              1F4E
MSG_RIGHT           1F44
MSG_ROD             1EBB
MSG_RTS             1F37
MSG_SPACE           1F5B
MSG_SUB             1E8C
MSG_TAB             1F5D
MSG_W               1F65
NEW_LINE            1E54
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OTHER               7
OTHEREA             1988
PRINTADD            1334
PRINTADDRESS        191C
PRINTASHEX          1C24
PRINTBCC            1846
PRINTENTER          1C68
PRINTHEXNUM         1B1C
PRINTLONGZERO       1B7C
PRINTMOVE           11F6
PRINTMOVESIZE       1C78
PRINTNULL           1C56
PRINTNUM            1B0C
PRINTRANGE          1C40
PRINTREGEA          1730
PRINTREGSIZE        16FE
PRINTSHIFTMEM       1606
PRINTSHIFTREG       16CE
PRINTSHORTLONGNUM   1B30
PRINTSHORTZERO      1B3C
PRINTZERO           1C34
PRINT_8             1518
PRINT_ADDQ_DATA     14FC
PRINT_MEMDIR        162C
PRINT_MOVEQ         12AC
PRINT_REGDIR        16F8
REG2MEMXNCHECK      1274
REG_BYTE            1716
REG_IMMEDIATE       1746
REG_LONG            172A
REG_REGISTER        178C
REG_VAR             250
REG_WORD            1720
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            1886
SOURCEXN            18B0
START               1000
STARTING            1DA9
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           1E57
VALIDEA             1978
VALIDEA_ADDSUB_DESTOPERAND  1D0B
VALIDEA_ALL         1CF6
VALIDEA_ANDORNOT    1D19
VALIDEA_ANDOR_DESTOPERAND  1D1F
VALIDEA_JSR         1D29
VALIDEA_LEA         1D16
VALIDEA_MOVEM_MEMTOREG  1D07
VALIDEA_MOVEM_REGTOMEM  1D03
VALIDEA_MOVEQ       1CFD
VALIDEA_MULSDIVU    1D10
VALIDEA_SHIFT       1D24
VALIDXN_ALL         1D2C
VALIDXN_SHORTLONG   1D30
WELCOME             1D33
XNIMMEDIATE         4
