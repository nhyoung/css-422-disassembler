00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/6/2020 1:50:55 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001A1F             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001A95             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CA             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DC             28                  JSR     CONVERT
0000103E  4EB9 00001148             29                  JSR     TEST_RANGE
00001044  4EB9 00001160             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001ACC             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CA             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DC             47                  JSR     CONVERT
00001086  4EB9 00001148             48                  JSR     TEST_RANGE
0000108C  4EB9 00001160             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0020                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  4EB9 0000190E             59                  JSR     PRINTNUM            ; prints out address                    
000010AC  4EB9 00001168             60                  JSR     OPCODE_DECODE       ; decode the opcode
000010B2  4EB9 00001956             61                  JSR     PRINTENTER          ; prints a new line
000010B8  B5CB                      62                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BA  6FE8                      63                  BLE     DISASSEMBLE         ; if not, loop
000010BC                            64  
000010BC  103C 0009                 65  STOP            MOVE.B  #9,D0
000010C0  4E4F                      66                  TRAP    #15
000010C2                            67  
000010C2                            68  *--------------------SUBROUTINES------------------    
000010C2                            69  
000010C2  143C 0001                 70  RESET_INPUT     MOVE.B  #1,D2
000010C6  6000 0062                 71                  BRA     INVALID            
000010CA                            72                  
000010CA  7800                      73  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CC  B204                      74                  CMP.B   D4,D1               ; D1 stores length
000010CE  6700 005A                 75                  BEQ     INVALID             ; input is null
000010D2  0C41 0008                 76                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D6  6E00 0052                 77                  BGT     INVALID             ; input is longer than a longword
000010DA  4E75                      78                  RTS
000010DC                            79                              
000010DC  4283                      80  CONVERT         CLR.L   D3
000010DE  4284                      81                  CLR.L   D4
000010E0  1619                      82                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E2  B63C 0039                 83                  CMP.B   #57,D3
000010E6  6E00 0012                 84                  BGT     NOTNUMBER
000010EA                            85                  
000010EA  B63C 002F                 86                  CMP.B   #47,D3
000010EE  6E00 0002                 87                  BGT     ISNUMBER
000010F2                            88                  
000010F2  0603 00D0                 89  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F6  6000 001A                 90                  BRA     CONCAT
000010FA                            91              
000010FA  B63C 0041                 92  NOTNUMBER       CMP.B   #65,D3
000010FE  6D00 002A                 93                  BLT     INVALID
00001102  B63C 0046                 94                  CMP.B   #70,D3
00001106  6E00 0022                 95                  BGT     INVALID  
0000110A  0603 00C9                 96                  ADD.B   #-55,D3             ; is letter             
0000110E  6000 0002                 97                  BRA     CONCAT
00001112                            98              
00001112  BC3C 0000                 99  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001116  6D00 0010                100                  BLT     RETURN
0000111A  1806                     101                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111C  E50C                     102                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
0000111E  E9AB                     103                  LSL.L   D4,D3               ; moves current char to correct position  
00001120  DA83                     104                  ADD.L   D3,D5               ; D5 stores converted input so far
00001122  0606 00FF                105                  ADD.B   #-1,D6  
00001126  60B4                     106                  BRA     CONVERT             ; continue loop for remaining chars
00001128                           107                  
00001128  4E75                     108  RETURN          RTS
0000112A                           109                  
0000112A  227C 00000000            110  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001130  43F9 00001B02            111                  LEA     BAD_INPUT,A1        ; output invalid message
00001136  103C 000E                112                  MOVE.B  #14,D0
0000113A  4E4F                     113                  TRAP    #15
0000113C  B47C 0001                114                  CMP     #1,D2
00001140  6700 FECA                115                  BEQ     INPUT1
00001144  6000 FF0C                116                  BRA     INPUT2
00001148                           117  
00001148  4284                     118  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114A  223C 00001000            119                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001150  BA81                     120                  CMP.L      D1,D5            ; Compare minimum address with input
00001152  6DD6                     121                  BLT        INVALID          ; input is too low. 
00001154  223C 00FFFFFE            122                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115A  BA81                     123                  CMP.L      D1,D5            ; compare maximum address with input
0000115C  6ECC                     124                  BGT        INVALID          ; input too large
0000115E  4E75                     125                  RTS                         ; input is within range
00001160                           126             
00001160  0805 0000                127  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001164  66C4                     128                  BNE        INVALID
00001166  4E75                     129                  RTS
00001168                           130  
00001168                           131  
00001168                           132  * Checks every single possible opcode we could have. Jump table
00001168                           133  * Inputs: (A2) which is a pointer to intruction word to be translated
00001168                           134  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001168                           135  
00001168  301A                     136  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116A  33C0 00000200            137                  MOVE.W  D0,CURRENT_INSTR
00001170                           138                  
00001170  B07C 4E71                139  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001174  6600 0010                140                  BNE     CASE_MOVE               ; checks the next case if not equal
00001178  4BF9 00001B47            141                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117E  4EB9 00001944            142                  JSR     PRINTNULL               ; prints NOP                
00001184  4E75                     143                  RTS                             ; returns from the subroutine
00001186                           144                  
00001186                           145                  * if first two bits are 00, next two are not 00
00001186  3200                     146  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001188  C27C C000                147                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000118C  6600 009A                148                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001190  B07C 0FFF                149                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001194  6F00 0092                150                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001198                           151                  
00001198                           152                  ; Check source
00001198  4BF9 000019E2            153                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119E  4DF9 00001A18            154                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A4  3E3C 0000                155                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A8  4EB9 000016FA            156                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AE  B27C 0001                157                  CMP.W   #1,D1                    ; checks if invalid
000011B2  6700 04EE                158                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B6  3802                     159                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B8  3A03                     160                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011BA                           161                  
000011BA                           162                  ; Check destination
000011BA  4BF9 000019E2            163                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011C0  4DF9 00001A1C            164                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C6  3E3C 0001                165                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011CA  4EB9 000016FA            166                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011D0  B27C 0001                167                  CMP.W   #1,D1                    ; checks if invalid
000011D4  6700 04CC                168                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D8  3C02                     169                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011DA  3E03                     170                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011DC                           171                  
000011DC                           172                  ; Checking if it is MOVEA
000011DC  3200                     173                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DE  C27C 01C0                174                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011E2  B27C 0040                175                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E6  6700 000C                176                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011EA                           177   
000011EA  4BF9 00001B4C            178                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011F0  6000 0008                179                  BRA     PRINTMOVE                ; Branches to print move
000011F4                           180                  
000011F4  4BF9 00001B52            181  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011FA                           182   
000011FA  4EB9 00001944            183  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001200  4EB9 00001966            184                  JSR     PRINTMOVESIZE            ; prints out the size  
00001206  3404                     185                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001208  3605                     186                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000120A  4EB9 000017B6            187                  JSR     EA_TO_STRING             ; outputs it into a string
00001210                           188                  
00001210                           189                  ; prints a comma to seperate
00001210  4BF9 00001C44            190                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001216  4EB9 00001944            191                  JSR     PRINTNULL                ; prints out MOVE
0000121C                           192                  
0000121C                           193                  ; print destination
0000121C  3406                     194                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121E  3607                     195                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001220  4EB9 000017B6            196                  JSR     EA_TO_STRING             ; outputs it into a string
00001226  4E75                     197                  RTS                              ; exits subroutine                 
00001228                           198                
00001228                           199                  
00001228  3200                     200  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000122A  C27C FB80                201                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122E  B27C 4880                202                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001232  6600 005A                203                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001236                           204                  
00001236                           205                  ; loads EA and XN
00001236  323C 0000                206                  MOVE.W  #0,D1                           ; copies instruction word to D1
0000123A  4EB9 000016A6            207                  JSR     GET_EA                          ; gets EA and puts in D1
00001240  3401                     208                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
00001242  323C 0000                209                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001246  4EB9 000016D0            210                  JSR     GET_XN                          ; gets XN and puts in D1
0000124C  3601                     211                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
0000124E                           212                  
0000124E                           213                  ; Check D
0000124E  3200                     214                  MOVE.W  D0,D1                           ; copies instruction word to D1
00001250  C27C 0400                215                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001254  3E01                     216                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001256  B27C 0400                217                  CMP.W   #$0400,D1                       ; checks if value is 1
0000125A  6700 0032                218                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000125E                           219  
0000125E  4BF9 000019EF            220  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001264  3202                     221                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001266  4EB9 00001782            222                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
0000126C  B27C 0001                223                  CMP.W   #1,D1                           ; checks if D1 invalid
00001270  6700 0430                224                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001274  B27C 0002                225                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001278                           226                  
00001278  4BF9 000019EF            227  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127E  3203                     228                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
00001280  4EB9 00001782            229                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001286  B27C 0001                230                  CMP.W   #1,D1                           ; checks if D1 invalid
0000128A  6700 0416                231                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128E                           232  
0000128E                           233                  
0000128E                           234  
0000128E                           235  MOVEM_MEM2REG    
0000128E                           236                          
0000128E                           237  
0000128E                           238  
0000128E  3200                     239  CASE_MOVEQ      MOVE.W  D0,D1
00001290  C27C F100                240                  AND.W   #$F100,D1
00001294  B27C 7000                241                  CMP.W   #$7000,D1
00001298  6600 0046                242                  BNE     CASE_ADD
0000129C                           243                  
0000129C                           244                  ;loads Register
0000129C  323C 0001                245                  MOVE.W  #1,D1                           ; copies instruction word to D1
000012A0  4EB9 000016D0            246                  JSR     GET_XN                          ; gets XN and puts in D1
000012A6  3401                     247                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012A8                           248                  
000012A8                           249                  ;loads DATA
000012A8  3200                     250                  MOVE.W  D0,D1
000012AA  C27C 00FF                251                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012AE  3601                     252                  MOVE.W  D1,D3                          ;copy data into D3
000012B0                           253                                                          ;must convert bits to hex
000012B0                           254                  
000012B0                           255                  
000012B0  4BF9 00001B59            256  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B6  4EB9 00001944            257                  JSR     PRINTNULL  
000012BC                           258                  
000012BC  4BF9 00001C57            259                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012C2  4EB9 00001944            260                  JSR     PRINTNULL
000012C8                           261      
000012C8  4BF9 00001B43            262                  LEA     THREE_TAB,A5                ;PRINT THREE TABS
000012CE  4EB9 00001944            263                  JSR     PRINTNULL
000012D4                           264                  
000012D4  4BF9 00001C40            265                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012DA  4EB9 00001944            266                  JSR     PRINTNULL
000012E0                           267  
000012E0                           268  
000012E0  3200                     269  CASE_ADD        MOVE.W  D0,D1
000012E2  C27C F000                270                  AND.W   #$F000,D1
000012E6  B27C D000                271                  CMP.W   #$D000,D1
000012EA  6600 006E                272                  BNE     CASE_ADDQ
000012EE                           273                   
000012EE  3200                     274                  MOVE.W  D0,D1
000012F0  E149                     275                  LSL.W   #8,D1                   ; get rid of left 8 bits
000012F2  E049                     276                  LSR.W   #8,D1
000012F4  EC49                     277                  LSR.W   #6,D1                   ; get rid of right 6 bits
000012F6  B27C 0003                278                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000012FA  6700 005E                279                  BEQ     CASE_ADDA
000012FE                           280                  
000012FE                           281                  ; Check bits 0-6 
000012FE  4BF9 000019E2            282                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001304  4DF9 00001A18            283                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000130A  3E3C 0001                284                  MOVE.W  #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000130E  4EB9 000016FA            285                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001314  B27C 0001                286                  CMP.W   #1,D1                    ; checks if invalid
00001318  6700 0388                287                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000131C  3802                     288                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000131E  3A03                     289                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001320                           290                  
00001320                           291                  ; Check destination
00001320  4BF9 000019E2            292                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001326  4DF9 00001A1C            293                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000132C  3E3C 0001                294                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001330  4EB9 000016FA            295                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001336  B27C 0001                296                  CMP.W   #1,D1                    ; checks if invalid
0000133A  6700 0366                297                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000133E  3C02                     298                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001340  3E03                     299                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001342                           300                  
00001342                           301                  ; Checking if it is MOVEA
00001342  3200                     302                  MOVE.W  D0,D1                    ; stores d0 in d1
00001344  C27C 01C0                303                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
00001348  B27C 0040                304                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000134C  6700 FEA6                305                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001350                           306   
00001350  4BF9 00001B4C            307                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001356  6000 FEA2                308                  BRA     PRINTMOVE                ; Branches to print move
0000135A                           309   
0000135A                           310  
0000135A                           311  CASE_ADDA 
0000135A                           312  *
0000135A                           313  *CASE_ADDA       LEA         MSG_ADDA,A1
0000135A                           314  *                MOVE.B      #14,D0
0000135A                           315  *                TRAP        #15                 ; print "ADDA"
0000135A                           316  *                MOVE.W      OPMODE_VAR,D3
0000135A                           317  *                JSR         ADDA_SIZE
0000135A                           318  *                JSR         ADDR_MODE_JUMP_TABLE
0000135A                           319  *                    
0000135A                           320  *            
0000135A                           321  *ADDA_SIZE       CMP.W       #%111,D3
0000135A                           322  *                BEQ         PRINT_WORD 
0000135A                           323  *                BRA         PRINT_LONG          
0000135A                           324                  
0000135A                           325  
0000135A                           326  CASE_ADDQ       
0000135A                           327  
0000135A                           328  CASE_SUB
0000135A                           329  
0000135A  3200                     330  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000135C  C27C F000                331                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001360  B27C 4000                332                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001364  6600 0086                333                  BNE.W   CASE_AND                             ; If its not, check AND
00001368  3200                     334                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000136A  C27C 01C0                335                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
0000136E  B27C 01C0                336                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001372  6600 0078                337                  BNE.W   CASE_AND                             ; If its not, check AND
00001376                           338                  
00001376                           339                  ; Check source
00001376  4BF9 00001A02            340                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000137C  4DF9 00001A1C            341                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001382  3E3C 0000                342                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001386  4EB9 000016FA            343                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000138C  3802                     344                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000138E  3A03                     345                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001390                           346                  
00001390                           347                  ; Check destination
00001390  4BF9 00001A02            348                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001396  4DF9 00001A1C            349                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000139C  3E3C 0001                350                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000013A0  4EB9 000016FA            351                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000013A6  3C02                     352                  MOVE.W  D2,D6                                ; Saves D2 in D4
000013A8  3E03                     353                  MOVE.W  D3,D7                                ; Saves D2 in D4
000013AA                           354  
000013AA  4BF9 00001B89            355                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000013B0  4EB9 00001944            356                  JSR     PRINTNULL                            ; prints LEA
000013B6                           357                  
000013B6                           358                  ; print source
000013B6  3404                     359                  MOVE.W  D4,D2
000013B8  3605                     360                  MOVE.W  D5,D3
000013BA  4EB9 000017B6            361                  JSR     EA_TO_STRING                         ; Prints out the EA
000013C0                           362                  
000013C0                           363                  ; comma
000013C0  4BF9 00001C44            364                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000013C6  4EB9 00001944            365                  JSR     PRINTNULL                       
000013CC                           366                   
000013CC                           367                  ; register
000013CC  4BF9 00001C36            368                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000013D2  4EB9 00001944            369                  JSR     PRINTNULL 
000013D8  3401                     370                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000013DA  323C 0001                371                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000013DE  4EB9 000016D0            372                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000013E4  4EB9 0000190E            373                  JSR     PRINTNUM                             ; Prints the number in D1
000013EA  4E75                     374                  RTS
000013EC                           375  
000013EC                           376  **---------------AND opcode----------------------
000013EC                           377  CASE_AND
000013EC                           378  *CASE_AND        LEA         MSG_AND,A1
000013EC                           379  *                MOVE.B      #14,D0
000013EC                           380  *                TRAP        #15 
000013EC                           381  *                JSR         GET_VARS
000013EC                           382  *                JSR         AND_SIZE                        ; .B, .W, or .L  
000013EC                           383  *                MOVE.W      CURRENT_INSTR, D5                         
000013EC                           384  *                LSL.W       #7, D5                        
000013EC                           385  *                LSR.W       #8, D5                   
000013EC                           386  *                LSR.W       #7, D5                     
000013EC                           387  *                CMP.B       #00, D5                         ; check if destination is a Dn?
000013EC                           388  *                BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
000013EC                           389  *                CMP.B       #$01,D5                         ; Is the destination not a Dn?
000013EC                           390  *                BEQ         DEST_EA                         ; branch to DEST_EA            
000013EC                           391  *                RTS
000013EC                           392     
000013EC                           393  *AND_SIZE        CMP.B       #%00,OPMODE_VAR       
000013EC                           394  *                BEQ         PRINT_BYTE
000013EC                           395  *                CMP.B       #$01, OPMODE_VAR
000013EC                           396  *                BEQ         PRINT_WORD
000013EC                           397  *                CMP.B       #$02, OPMODE_VAR
000013EC                           398  *                BEQ         PRINT_LONG    
000013EC                           399  *    
000013EC                           400  *DEST_DN         MOVE.W      CURRENT_INSTR, D5               
000013EC                           401  *                LSL.W       #6,D5
000013EC                           402  *                LSL.W       #4,D5
000013EC                           403  *                LSR.W       #6,D5
000013EC                           404  *                LSR.W       #4,D5
000013EC                           405  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000013EC                           406  *                  
000013EC                           407  *                MOVE.W      CURRENT_INSTR, D6               
000013EC                           408  *                LSL.W       #6,D5
000013EC                           409  *                LSL.W       #4,D5
000013EC                           410  *                LSL.W       #3,D6
000013EC                           411  *                LSR.W       #6,D6
000013EC                           412  *                LSR.W       #4,D6
000013EC                           413  *                LSR.W       #3,D6                           ; d6 stores EA register
000013EC                           414  *                JSR         FIND_EA
000013EC                           415  *
000013EC                           416  *                
000013EC                           417  *                MOVE.W      CURRENT_INSTR, D5               
000013EC                           418  *                LSL.W       #4, D5                         
000013EC                           419  *                LSR.W       #8, D5                          ; shift bits to get register
000013EC                           420  *                LSR.W       #5, D5                          ; D5 contains register
000013EC                           421  *                LEA         MSG_COMMA, A1                   
000013EC                           422  *                MOVE.B      #14,D0
000013EC                           423  *                TRAP        #15                             ; print comma
000013EC                           424  *                LEA         MSG_DR, A1                      ; print D
000013EC                           425  *                MOVE.B      #14,D0
000013EC                           426  *                TRAP        #15
000013EC                           427  *                MOVEA.L     D5,A1
000013EC                           428  *                MOVE.B      #14,D0
000013EC                           429  *                TRAP        #15                              
000013EC                           430  *                RTS        
000013EC                           431  *
000013EC                           432  *FIND_EA        CMP.W       #%010,D5
000013EC                           433  *                BEQ         CASE_ARI
000013EC                           434  *                CMP.W       #%011,D5
000013EC                           435  *                BEQ         CASE_ARIPOST
000013EC                           436  *                CMP.W       #%100,D5
000013EC                           437  *                BEQ         CASE_ARIPRE
000013EC                           438  *                CMP.W       #%111,D5
000013EC                           439  *                BEQ         CASE_OTHER
000013EC                           440  *                BRA         ERROR    
000013EC                           441  *                                     
000013EC                           442  *DEST_EA         MOVE.W      CURRENT_INSTR, D5               
000013EC                           443  *                LSL.W       #4, D5                         
000013EC                           444  *                LSR.W       #8, D5                          ; shift bits to get register
000013EC                           445  *                LSR.W       #5, D5                          ; D5 contains register
000013EC                           446  *
000013EC                           447  *                LEA         MSG_DR, A1                   
000013EC                           448  *                MOVE.B      #14,D0
000013EC                           449  *                TRAP        #15                             ; print D
000013EC                           450  *                MOVEA.L     D5,A1  
000013EC                           451  *                MOVE.B      #14,D0                          ; print register
000013EC                           452  *                TRAP        #15
000013EC                           453  *                
000013EC                           454  *                LEA         MSG_COMMA, A1                   
000013EC                           455  *                MOVE.B      #14,D0
000013EC                           456  *                TRAP        #15                             ; print comma
000013EC                           457  *                
000013EC                           458  *                MOVE.W      CURRENT_INSTR, D5               
000013EC                           459  *                LSL.W       #6,D5
000013EC                           460  *                LSL.W       #4,D5
000013EC                           461  *                LSR.W       #6,D5
000013EC                           462  *                LSR.W       #4,D5
000013EC                           463  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000013EC                           464  *                  
000013EC                           465  *                MOVE.W      CURRENT_INSTR, D6               
000013EC                           466  *                LSL.W       #6,D6
000013EC                           467  *                LSL.W       #4,D6
000013EC                           468  *                LSL.W       #3,D6
000013EC                           469  *                LSR.W       #6,D6
000013EC                           470  *                LSR.W       #4,D6
000013EC                           471  *                LSR.W       #3,D6                           ; d6 stores EA register
000013EC                           472  *                JSR         FIND_EA                          
000013EC                           473  *                RTS                                     Return full instruction   
000013EC                           474              
000013EC                           475  CASE_OR
000013EC                           476  
000013EC                           477  CASE_NOT
000013EC                           478  
000013EC  3200                     479  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
000013EE  C27C F000                480                  AND.W       #$F000, D1                       ; gets first 4 bits
000013F2  B27C E000                481                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000013F6  6600 0210                482                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000013FA  3400                     483                  MOVE.W      D0,D2                            ; copies D0 to D2
000013FC  4EB9 00001772            484                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001402  B47C 0003                485                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001406  6600 00C8                486                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
0000140A                           487                  
0000140A  3400                     488  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000140C  4EB9 00001760            489                  JSR         GETROTATION                      ; gets rotation value of D2
00001412  B47C 0000                490                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001416  6700 0014                491                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
0000141A  B47C 0003                492                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
0000141E  6700 0016                493                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001422                           494                  
00001422  4BF9 00001B9F            495  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001428  6000 0012                496                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000142C                           497  
0000142C  4BF9 00001BA3            498  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001432  6000 0008                499                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001436                           500  
00001436  4BF9 00001BA7            501  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000143C                           502                  
0000143C  4EB9 00001944            503  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
00001442  3400                     504                  MOVE.W      D0,D2                            ; copies D0 to D2
00001444  4EB9 0000176A            505                  JSR         GETDIRECTION                     ; gets direction
0000144A  B47C 0000                506                  CMP.W       #0,D2                            ; checking if its right
0000144E  6700 000C                507                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001452                           508  
00001452  4BF9 00001C32            509  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001458  6000 0008                510                  BRA         PRINT_MEMDIR                     ; branches for printing
0000145C                           511          
0000145C  4BF9 00001C30            512  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001462                           513  
00001462  4EB9 00001944            514  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001468  4BF9 00001C51            515                  LEA         MSG_W,A5                         ; loads .W into A5
0000146E  4EB9 00001944            516                  JSR         PRINTNULL                        ; Prints .W
00001474  6000 0002                517                  BRA         GETMEMSOURCE                     ; checks the source 
00001478                           518                  
00001478                           519  ; get source addressing mode       
00001478                           520  GETMEMSOURCE                                                 
00001478  323C 0000                521                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000147C  4EB9 000016A6            522                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001482  3801                     523                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001484  323C 0000                524                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001488  4EB9 000016D0            525                  JSR         GET_XN                           ; Gets Xn, puts it into D1
0000148E  3A01                     526                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001490                           527  
00001490  4BF9 00001A10            528  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001496  3204                     529                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001498  4EB9 00001782            530                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
0000149E  B27C 0002                531                  CMP.W       #2,D1                            ; checks if it is Xn
000014A2  6700 0016                532                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000014A6  B27C 0001                533                  CMP.W       #1,D1                            ; Checks if it is invalid
000014AA  6700 01F6                534                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000014AE                           535  
000014AE  3404                     536  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000014B0  3605                     537                  MOVE.W      D5,D3                            ; moves EA to D3
000014B2  4EB9 000017B6            538                  JSR         EA_TO_STRING                     ; prints out the EA
000014B8  4E75                     539                  RTS                
000014BA                           540                  
000014BA                           541                  
000014BA  4BF9 00001A1C            542  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000014C0  3205                     543                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000014C2  4EB9 00001782            544                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000014C8  4A41                     545                  TST.W       D1                               ; checks if it is valid
000014CA  67E2                     546                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000014CC  6000 01D4                547                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000014D0                           548  
000014D0                           549  
000014D0  3602                     550  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000014D2  3200                     551                  MOVE.W      D0,D1                            ; copies D0 to D1
000014D4  C27C 0018                552                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000014D8  E649                     553                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000014DA  B27C 0000                554                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000014DE  6700 0014                555                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000014E2  B27C 0003                556                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000014E6  6700 0016                557                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000014EA                           558                  
000014EA  4BF9 00001B9F            559  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
000014F0  6000 0012                560                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000014F4                           561  
000014F4  4BF9 00001BA3            562  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
000014FA  6000 0008                563                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000014FE                           564  
000014FE  4BF9 00001BA7            565  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001504                           566                  
00001504  4EB9 00001944            567  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
0000150A  3400                     568                  MOVE.W      D0,D2                            ; copies D0 to D2
0000150C  4EB9 0000176A            569                  JSR         GETDIRECTION                     ; gets direction
00001512  B47C 0000                570                  CMP.W       #0,D2                            ; checking if its right
00001516  6700 000C                571                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
0000151A                           572  
0000151A  4BF9 00001C32            573  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001520  6000 000C                574                  BRA         PRINT_REGDIR                     ; branches for printing
00001524                           575          
00001524  4BF9 00001C30            576  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
0000152A  6000 0002                577                  BRA         PRINT_REGDIR                     ; branches for printing
0000152E                           578                  
0000152E  4EB9 00001944            579  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001534                           580  
00001534  3400                     581  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001536  4EB9 00001772            582                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000153C  B47C 0001                583                  CMP.W       #1,D2                            ; Checks if it is word size
00001540  6700 0014                584                  BEQ         REG_WORD                         ; Prints .W
00001544  B47C 0002                585                  CMP.W       #2,D2                            ; Checks if it is long size
00001548  6700 0016                586                  BEQ         REG_LONG                         ; Prints .L
0000154C                           587  
0000154C  4BF9 00001C4B            588  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001552  6000 0012                589                  BRA         PRINTREGEA      
00001556                           590  
00001556  4BF9 00001C51            591  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
0000155C  6000 0008                592                  BRA         PRINTREGEA      
00001560                           593                             
00001560  4BF9 00001C57            594  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001566                           595  
00001566  4EB9 00001944            596  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
0000156C  3400                     597                  MOVE.W      D0,D2                            ; copies D0 to D1
0000156E  4EB9 0000177A            598                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001574  B27C 0001                599                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001578  6700 0048                600                  BEQ         REG_REGISTER                     ; goes to ASd case if so
0000157C                           601                                  
0000157C  3400                     602  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
0000157E  4EB9 00001772            603                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001584  3202                     604                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001586  4BF9 00001C40            605                  LEA         MSG_POUND, A5                    ; loads # into A5
0000158C  4EB9 00001944            606                  JSR         PRINTNULL                        ; prints #
00001592  4EB9 0000190E            607                  JSR         PRINTNUM                         ; prints shift count
00001598  4BF9 00001C44            608                  LEA         MSG_COMMA, A5                    ; loads , into A5
0000159E  4EB9 00001944            609                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000015A4  4BF9 00001C34            610                  LEA         MSG_DR, A5                       ; loads D into A5
000015AA  4EB9 00001944            611                  JSR         PRINTNULL                        ; prints out D 
000015B0  323C 0000                612                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000015B4  4EB9 000016D0            613                  JSR         GET_XN                           ; gets the data register number, stores in D1
000015BA  4EB9 0000190E            614                  JSR         PRINTNUM                         ; prints data register number in D1          
000015C0  4E75                     615                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000015C2                           616                  
000015C2  3400                     617  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
000015C4  4EB9 00001772            618                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000015CA  3202                     619                  MOVE.W      D2, D1                           ; moves rotation size to D1
000015CC  4BF9 00001C34            620                  LEA         MSG_DR, A5                       ; loads D into A5
000015D2  4EB9 00001944            621                  JSR         PRINTNULL                        ; prints D
000015D8  4EB9 0000190E            622                  JSR         PRINTNUM                         ; prints register number
000015DE  4BF9 00001C44            623                  LEA         MSG_COMMA, A5                    ; loads , into A5
000015E4  4EB9 00001944            624                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000015EA  4BF9 00001C34            625                  LEA         MSG_DR, A5                       ; loads D into A5
000015F0  4EB9 00001944            626                  JSR         PRINTNULL                        ; prints out D 
000015F6  323C 0000                627                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000015FA  4EB9 000016D0            628                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001600  4EB9 0000190E            629                  JSR         PRINTNUM                         ; prints data register number in D1          
00001606  4E75                     630                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001608                           631               
00001608  3200                     632  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000160A  C27C FF00                633                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
0000160E  B27C 6000                634                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001612  6600 0018                635                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001616                           636                  
00001616  4BF9 00001C28            637                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
0000161C  4EB9 00001944            638                  JSR     PRINTNULL                            ; prints BRA
00001622                           639  
00001622  3400                     640                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001624  4EB9 00001742            641                  JSR     GETDISPLACEMENT                      ; finds the displacement
0000162A  4E75                     642                  RTS
0000162C                           643                  
0000162C                           644  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
0000162C                           645  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
0000162C  3200                     646  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
0000162E  C27C F000                647                  AND.W   #$F000,D1                            ; get top 4 bits
00001632  B27C 6000                648                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001636  6600 0054                649                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
0000163A  3200                     650                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
0000163C  C27C 0F00                651                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001640  E049                     652                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001642                           653                  
00001642  B27C 000E                654                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001646  6700 002A                655                  BEQ     CASE_BGT                             ; branches to BGT if it is
0000164A                           656                  
0000164A  B27C 000F                657                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
0000164E  6700 0018                658                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001652                           659                      
00001652  B27C 0007                660                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001656  6700 0006                661                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
0000165A  6000 0046                662                  BRA     CASE_DATA                            ; BCC condition code not in the system
0000165E                           663     
0000165E  4BF9 00001BBB            664  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001664  6000 0016                665                  BRA     PRINTBCC
00001668                           666  
00001668  4BF9 00001BE3            667  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
0000166E  6000 000C                668                  BRA     PRINTBCC
00001672                           669                  
00001672  4BF9 00001BD3            670  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001678  6000 0002                671                  BRA     PRINTBCC
0000167C                           672  
0000167C  4EB9 00001944            673  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001682  3400                     674                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001684  4EB9 00001742            675                  JSR     GETDISPLACEMENT                      ; finds the displacement
0000168A  4E75                     676                  RTS              
0000168C                           677                  
0000168C                           678  
0000168C                           679  CASE_JSR       
0000168C                           680  
0000168C  B07C 4E75                681  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001690  6600 FAF4                682                  BNE     CASE_MOVE           ; checks the next case if not equal
00001694  4BF9 00001C23            683                  LEA     MSG_RTS,A5          ; loads string pointer into A5
0000169A  4EB9 00001944            684                  JSR     PRINTNULL           ; prints RTS                
000016A0  4E75                     685                  RTS                         ; returns from the subroutine
000016A2                           686  
000016A2                           687                  
000016A2                           688  
000016A2                           689  CASE_DATA           
000016A2  4E75                     690                      RTS               
000016A4                           691  
000016A4  4E75                     692  CASE_EPICFAIL       RTS
000016A6                           693  
000016A6                           694  
000016A6                           695  * Finds the EA type
000016A6                           696  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
000016A6                           697  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000016A6  48E7 3000                698  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000016AA  4A41                     699                      TST.W     D1                    ; compares D1 to 0
000016AC  6700 000E                700                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
000016B0                           701                      
000016B0  343C 01C0                702  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
000016B4  363C 0006                703                      MOVE.W    #6,D3                 ; stores the shift amount to D3
000016B8  6000 000A                704                      BRA       FINDTYPEEA            
000016BC                           705  
000016BC  343C 0038                706  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
000016C0  363C 0003                707                      MOVE.W    #3,D3                 ; stores the shift amount to D3
000016C4                           708  
000016C4                           709  
000016C4  3200                     710  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
000016C6  C242                     711                      AND.W     D2,D1                 ; applies bitmask to D1
000016C8  E669                     712                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000016CA  4CDF 000C                713                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000016CE  4E75                     714                      RTS                             ; returns from subroutine    
000016D0                           715                      
000016D0                           716  * Finds Xn type
000016D0                           717  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
000016D0                           718  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000016D0  48E7 3000                719  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000016D4  4A41                     720                      TST.W     D1                    ; compares D1 to 0
000016D6  6700 000E                721                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
000016DA                           722  
000016DA  343C 0E00                723  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
000016DE  363C 0009                724                      MOVE.W    #9,D3                 ; stores the shift amount to D3
000016E2  6000 000A                725                      BRA       FINDTYPEXN            ; finds the type of Xn
000016E6                           726  
000016E6  343C 0007                727  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
000016EA  363C 0000                728                      MOVE.W    #0,D3                 ; stores the shift amount to D3
000016EE                           729                      
000016EE  3200                     730  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
000016F0  C242                     731                      AND.W     D2,D1                 ; applies bitmask to D1
000016F2  E669                     732                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000016F4  4CDF 000C                733                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000016F8  4E75                     734                      RTS                             ; returns from subroutine 
000016FA                           735                      
000016FA                           736  * Checks and gets the EA and Xn
000016FA                           737  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
000016FA                           738  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
000016FA  3207                     739  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
000016FC  4EB8 16A6                740                  JSR     GET_EA                  ; Gets EA
00001700  3401                     741                  MOVE.W  D1,D2                   ; Stores EA in D2
00001702  3207                     742                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001704  4EB8 16D0                743                  JSR     GET_XN                  ; Gets Xn
00001708  3601                     744                  MOVE.W  D1,D3                   ; Stores Xn in D3
0000170A  3202                     745                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
0000170C                           746                  
0000170C  4EB9 00001782            747                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001712  B27C 0002                748                  CMP.W   #2,D1                   ; checks if it is Xn
00001716  6700 0012                749                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
0000171A  B27C 0001                750                  CMP.W   #1,D1                   ; Checks if it is invalid
0000171E  6700 001C                751                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001722                           752                  
00001722                           753                  
00001722  323C 0000                754  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001726  6000 0018                755                  BRA     END_CHECKGET
0000172A                           756        
0000172A                           757  ; need XN
0000172A  2A4E                     758  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
0000172C  3203                     759                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
0000172E  4EB9 00001782            760                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001734  4A41                     761                  TST.W   D1                      ; checks if it is valid
00001736  67EA                     762                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001738  6000 0002                763                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
0000173C                           764   
0000173C  323C 0001                765  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001740                           766  
00001740  4E75                     767  END_CHECKGET    RTS          
00001742                           768                                            
00001742                           769                                            
00001742                           770  * Gets the displacement and pritns it 
00001742                           771  * Inputs: D2 = instruction word, A2 = address of next word
00001742                           772  * Outputs: prints out displacement
00001742  48E7 4004                773  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001746  3A4A                     774                      MOVE.W    A2,A5                 ; copies A2 to A5
00001748  C47C 00FF                775                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
0000174C  6600 0004                776                      BNE       PRINTADDRESS          ; prints address if not 0
00001750  341A                     777                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001752                           778                      
00001752  D44D                     779  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001754  3202                     780                      MOVE.W    D2,D1                 ; moves address to D1 to print it
00001756  4EB9 0000190E            781                      JSR       PRINTNUM              ; prints address
0000175C                           782                      
0000175C  4CDF 2002                783                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001760                           784                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001760                           785  
00001760                           786  * Gets the rotation value for ASd and LSd
00001760                           787  * Input: D2 = instruction word copy (of D0)                                    
00001760                           788  * Output: rotation  value in D2             
00001760  C47C 0E00                789  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001764  E04A                     790                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001766  E24A                     791                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001768  4E75                     792                      RTS                             ; return from subroutine
0000176A                           793  
0000176A                           794  * Gets the direction value for ASd and LSd
0000176A                           795  * Input: D2 = instruction word copy (of D0)                                    
0000176A                           796  * Output: direction value in D2             
0000176A  C47C 0100                797  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
0000176E  E04A                     798                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001770  4E75                     799                      RTS                             ; return from subroutine
00001772                           800  
00001772                           801  * Gets the rotation size value for ASd and LSd
00001772                           802  * Input: D2 = instruction word copy (of D0)                                    
00001772                           803  * Output: rotation size value in D2             
00001772  C47C 00C0                804  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001776  EC4A                     805                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001778  4E75                     806                      RTS                             ; return from subroutine
0000177A                           807  
0000177A                           808  * Gets the rotation location  value for ASd and LSd
0000177A                           809  * Input: D2 = instruction word copy (of D0)                                    
0000177A                           810  * Output: rotation location value in D2             
0000177A  C47C 0020                811  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
0000177E  EA4A                     812                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001780  4E75                     813                      RTS                             ; return from subroutine
00001782                           814  
00001782                           815                          
00001782                           816  * Checks if EA or Xn is valid
00001782                           817  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001782                           818  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001782  2F02                     819  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001784                           820  
00001784  141D                     821  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001786  B43C 00FF                822                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
0000178A  6700 000A                823                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
0000178E  B202                     824                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001790  6700 000C                825                     BEQ        VALIDEA               ; branches to valid EA
00001794  60EE                     826                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001796                           827                     
00001796  323C 0001                828  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
0000179A  6000 0016                829                     BRA        CHECKEAEXIT           ; exists the subroutine        
0000179E                           830                    
0000179E  B43C 0007                831  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
000017A2  6700 000A                832                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
000017A6  323C 0000                833                     MOVE.W     #$0,D1                ; marks that it is valid
000017AA  6000 0006                834                     BRA        CHECKEAEXIT           ; exits the subroutine
000017AE                           835  
000017AE  323C 0002                836  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
000017B2                           837  
000017B2  241F                     838  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
000017B4  4E75                     839                     RTS                              ; returns from subroutine
000017B6                           840  
000017B6                           841  * Converts EA and Xn into a string                                
000017B6                           842  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
000017B6                           843  * Outputs: Prints out EA and Xn into a string
000017B6  48E7 C004                844  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
000017BA  B47C 0001                845                     CMP.W    #An,D2                  ; checks if it is An
000017BE  6700 003A                846                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
000017C2                           847                     
000017C2  B47C 0002                848                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
000017C6  6700 004A                849                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
000017CA                           850                     
000017CA  B47C 0003                851                     CMP.W    #AnPost,D2              ; checks if it is (An)+
000017CE  6700 0072                852                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
000017D2                           853                     
000017D2  B47C 0004                854                     CMP.W    #AnPre,D2               ; checks if it is -(An)
000017D6  6700 00A6                855                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
000017DA                           856                     
000017DA  B47C 0007                857                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
000017DE  6700 00DA                858                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
000017E2                           859                     ; otherwise assumes D2 = #Dn which means its a data register                   
000017E2                           860  
000017E2                           861  * data register, Dn
000017E2  4BF9 00001C34            862  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
000017E8  4EB9 00001944            863                     JSR      PRINTNULL               ; Prints D
000017EE  3203                     864                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000017F0  4EB9 0000190E            865                     JSR      PRINTNUM                ; Prints the Xn
000017F6  6000 0110                866                     BRA      EA_TO_STRING_EXIT       ; exits           
000017FA                           867  
000017FA                           868  
000017FA                           869  * address register
000017FA  4BF9 00001C36            870  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001800  4EB9 00001944            871                     JSR      PRINTNULL               ; Prints A
00001806  3203                     872                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001808  4EB9 0000190E            873                     JSR      PRINTNUM                ; Prints the Xn
0000180E  6000 00F8                874                     BRA      EA_TO_STRING_EXIT       ; exits
00001812                           875  
00001812                           876  * address register indirect
00001812  4BF9 00001C38            877  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001818  4EB9 00001944            878                     JSR      PRINTNULL               ; Prints (
0000181E  4BF9 00001C36            879                     LEA      MSG_AR,A5               ; Loads A into A5
00001824  4EB9 00001944            880                     JSR      PRINTNULL               ; Prints A
0000182A  3203                     881                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000182C  4EB9 0000190E            882                     JSR      PRINTNUM                ; Prints the Xn
00001832  4BF9 00001C3A            883                     LEA      MSG_RB,A5               ; Loads ) into A5
00001838  4EB9 00001944            884                     JSR      PRINTNULL               ; Prints )
0000183E  6000 00C8                885                     BRA      EA_TO_STRING_EXIT       ; exits
00001842                           886  
00001842                           887  * address register indirect post increment
00001842  4BF9 00001C38            888  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001848  4EB9 00001944            889                     JSR      PRINTNULL               ; Prints (
0000184E  4BF9 00001C36            890                     LEA      MSG_AR,A5               ; Loads A into A5
00001854  4EB9 00001944            891                     JSR      PRINTNULL               ; Prints A
0000185A  3203                     892                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000185C  4EB9 0000190E            893                     JSR      PRINTNUM                ; Prints the Xn
00001862  4BF9 00001C3A            894                     LEA      MSG_RB,A5               ; Loads ) into A5
00001868  4EB9 00001944            895                     JSR      PRINTNULL               ; Prints )
0000186E  4BF9 00001C3C            896                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001874  4EB9 00001944            897                     JSR      PRINTNULL               ; Prints +
0000187A  6000 008C                898                     BRA      EA_TO_STRING_EXIT       ; exits
0000187E                           899  
0000187E                           900  
0000187E                           901  * address register indirect pre increment
0000187E  4BF9 00001C3E            902  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001884  4EB9 00001944            903                     JSR      PRINTNULL               ; Prints -
0000188A  4BF9 00001C38            904                     LEA      MSG_LB,A5               ; Loads ( into A5
00001890  4EB9 00001944            905                     JSR      PRINTNULL               ; Prints (
00001896  4BF9 00001C36            906                     LEA      MSG_AR,A5               ; Loads A into A5
0000189C  4EB9 00001944            907                     JSR      PRINTNULL               ; Prints A
000018A2  3203                     908                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000018A4  4EB9 0000190E            909                     JSR      PRINTNUM                ; Prints the Xn
000018AA  4BF9 00001C3A            910                     LEA      MSG_RB,A5               ; Loads ) into A5
000018B0  4EB9 00001944            911                     JSR      PRINTNULL               ; Prints )
000018B6  6000 0050                912                     BRA      EA_TO_STRING_EXIT       ; exits
000018BA                           913  
000018BA                           914  * other (long, short, immediate) with Xn yes
000018BA  301A                     915  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000018BC  B67C 0000                916                     CMP.W    #ABSShort,D3            ; checks if it is a word
000018C0  6700 0022                917                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000018C4                           918                     
000018C4  B67C 0001                919                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000018C8  6700 002A                920                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000018CC                           921  
000018CC                           922  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
000018CC                           923  * immediate
000018CC  4BF9 00001C40            924  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000018D2  4EB9 00001944            925                     JSR      PRINTNULL               ; Prints #  
000018D8                           926                     * uncomment after converting to hex 
000018D8                           927                     *LEA      MSG_HEX,A5              ; Loads $ into A5
000018D8                           928                     *JSR      PRINTNULL               ; Prints $
000018D8  3200                     929                     MOVE.W   D0, D1                  ; moves instruction word into d1
000018DA  4EB9 0000190E            930                     JSR      PRINTNUM 
000018E0  6000 0026                931                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
000018E4                           932                     
000018E4                           933  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
000018E4                           934  
000018E4                           935  * word address
000018E4                           936  CASE_WORD          
000018E4                           937                     *LEA      MSG_HEX,A5              ; Loads $ into A5
000018E4                           938                     *JSR      PRINTNULL               ; Prints $
000018E4  3200                     939                     MOVE.W   D0, D1                  ; moves instruction word into d1
000018E6  383C 0000                940                     MOVE.W   #0, D4                  ; moves length size (word) into d4
000018EA  4EB9 0000190E            941                     JSR      PRINTNUM               ; reformats the number to the proper length and prints out the number
000018F0  6000 0016                942                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
000018F4                           943  
000018F4                           944  * long address 
000018F4                           945  CASE_LONG          
000018F4                           946                     *LEA      MSG_HEX,A5              ; Loads $ into A5
000018F4                           947                     *JSR      PRINTNULL               ; Prints $
000018F4  3200                     948                     MOVE.W   D0, D1                  ; moves instruction word into d1
000018F6  383C 0001                949                     MOVE.W   #1, D4                  ; moves length size (long) into d4
000018FA  4EB9 0000190E            950                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001900  321A                     951                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001902  4EB9 0000190E            952                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001908                           953  
00001908                           954  
00001908                           955  * exits subroutine
00001908  4CDF 2003                956  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
0000190C  4E75                     957                      RTS                              ; returns from subroutine
0000190E                           958  
0000190E                           959  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
0000190E                           960  
0000190E                           961  * Prints out the content of D1
0000190E                           962  * Input: number in D1 to be printed
0000190E                           963  * Output: contents of D1 printed
0000190E  48E7 C000                964  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001912  103C 0003                965                   MOVE.B      #3,D0               ; prints D1
00001916  4E4F                     966                   TRAP        #15                 ; is trap task 3
00001918                           967              
00001918  4CDF 0003                968                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000191C  4E75                     969                   RTS                             ; returns from subroutine
0000191E                           970                   
0000191E                           971  * DELETE LATER: THIS IS A  WIP AND DOESNT ACHIEVE PROPER FUNCTIONALITY YET
0000191E                           972                   
0000191E                           973  * Prints out the content of D1 and formats it to have the length of WORD or a LONG
0000191E                           974  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
0000191E                           975  * Output: contents of D1 printed
0000191E  48E7 6000                976  PRINTSHORTLONGNUM         MOVEM.L     D1-D2, -(SP)        ; saves D0 and D1
00001922  103C 0003                977                            MOVE.B      #3,D0               ; prints D1
00001926  4E4F                     978                            TRAP        #15                 ; is trap task 3
00001928  4CDF 0003                979                            MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000192C  4E75                     980                  RTS                                       ; returns from subroutine    
0000192E                           981               
0000192E                           982              
0000192E                           983  * Prints contents of things between a range
0000192E                           984  * input: A5, A6 (the range)
0000192E                           985  * output: prints memory contents from A5 to A6 as strings   
0000192E  48E7 C040                986  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001932  224D                     987                  MOVEA.L     A5, A1           ; loads A5 into A1
00001934  9DCD                     988                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001936  320E                     989                  MOVE.W      A6, D1           ; move n into D1
00001938  103C 0001                990                  MOVE.B      #1, D0           ; display n characters of string at A1
0000193C  4E4F                     991                  TRAP        #15              ; is trap task 1
0000193E  4CDF 0203                992                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001942  4E75                     993                  RTS                          ; returns
00001944                           994      
00001944                           995  * Prints null terminated string
00001944                           996  * input: string pointed to by A5
00001944                           997  * output: prints out the null terminated string
00001944  48E7 8040                998  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001948  224D                     999                  MOVE.L      A5,A1           ; loads A5 into A1
0000194A  103C 000E               1000                  MOVE.B      #14,D0          ; prints null terminated string
0000194E  4E4F                    1001                  TRAP        #15             ; is trap task 10
00001950  4CDF 0201               1002                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001954  4E75                    1003                  RTS                         ; returns from subroutine
00001956                          1004                  
00001956  2F0D                    1005  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001958  4BF9 00001B40           1006                  LEA         NEW_LINE,A5     ; Prints null
0000195E  4EB8 1944               1007                  JSR         PRINTNULL       ; prints the new line
00001962  2A5F                    1008                  MOVE.L      (SP)+,A5        ; returns A5
00001964  4E75                    1009                  RTS
00001966                          1010  
00001966                          1011  * Prints the size of the MOVE or MOVEA operation  
00001966                          1012  * input: D0
00001966                          1013  * output: prints out the size of a MOVE or MOVEA operation        
00001966  48E7 8004               1014  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
0000196A  3200                    1015                  MOVE.W  D0,D1               ; stores d0 in d1
0000196C  C07C 3000               1016                  AND.W   #$3000,D0           ; gets the size
00001970  B07C 2000               1017                  CMP.W   #$2000,D0           ; checks if is long
00001974  6700 001E               1018                  BEQ     MOVE_LONG
00001978  B07C 3000               1019                  CMP.W   #$3000,D0           ; checks if is word
0000197C  6700 000C               1020                  BEQ     MOVE_WORD      
00001980                          1021                  
00001980  4BF9 00001C4B           1022  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001986  6000 0012               1023                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000198A                          1024  
0000198A  4BF9 00001C51           1025  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001990  6000 0008               1026                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001994                          1027  
00001994  4BF9 00001C57           1028  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
0000199A                          1029                  
0000199A  4EB8 1944               1030  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
0000199E  4CDF 2001               1031                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000019A2  4E75                    1032                  RTS
000019A4                          1033  
000019A4  43F9 00001B24           1034  ERROR           LEA     ERROR_MSG,A1
000019AA  103C 000E               1035                  MOVE.B  #14,D0
000019AE  4E4F                    1036                  TRAP    #15 
000019B0                          1037         
000019B0                          1038  * DELETE THIS: Test                
000019B0  2661                    1039  DELETEME        MOVEA.L  -(A1),A3
000019B2  6700 002A               1040                  BEQ      DELETEMEAGAIN  
000019B6  6F00 0026               1041                  BLE      DELETEMEAGAIN
000019BA  6E00 0022               1042                  BGT      DELETEMEAGAIN
000019BE                          1043  
000019BE  E40A                    1044                  LSR.B      #2,D2
000019C0  E2E2                    1045                  LSR.W      -(A2)
000019C2  E2DA                    1046                  LSR.W      (A2)+
000019C4  E4AA                    1047                  LSR.L      D2,D2 
000019C6  E50A                    1048                  LSL.B      #2,D2
000019C8  E3E2                    1049                  LSL.W      -(A2)
000019CA  E3DA                    1050                  LSL.W      (A2)+
000019CC  E5AA                    1051                  LSL.L      D2,D2
000019CE  E51A                    1052                  ROL.B      #2,D2
000019D0  E7E2                    1053                  ROL.W      -(A2)
000019D2  E7DA                    1054                  ROL.W      (A2)+
000019D4  E5BA                    1055                  ROL.L      D2,D2
000019D6  E41A                    1056                  ROR.B      #2,D2
000019D8  E6E2                    1057                  ROR.W      -(A2)
000019DA  E6DA                    1058                  ROR.W      (A2)+
000019DC  E4BA                    1059                  ROR.L      D2,D2
000019DE                          1060                         
000019DE                          1061                  
000019DE                          1062  DELETEMEAGAIN                 
000019DE                          1063            
000019DE  FFFF FFFF               1064      SIMHALT             ; halt simulator
000019E2                          1065  
000019E2                          1066  * Put variables and constants here
000019E2                          1067  
000019E2  =0000000D               1068  CR                              EQU     $0D
000019E2  =0000000A               1069  LF                              EQU     $0A 
000019E2  =00000009               1070  TAB                             EQU     $09  
000019E2                          1071  
000019E2                          1072  * Addressing Modes
000019E2  =00000000               1073  Dn                              EQU     0
000019E2  =00000001               1074  An                              EQU     1
000019E2  =00000002               1075  AnIndirect                      EQU     2
000019E2  =00000003               1076  AnPost                          EQU     3
000019E2  =00000004               1077  AnPre                           EQU     4
000019E2  =00000007               1078  Other                           EQU     7           ; short, long, immediate
000019E2                          1079  
000019E2                          1080  * Xn
000019E2  =00000000               1081  ABSShort                        EQU     0
000019E2  =00000001               1082  ABSLong                         EQU     1
000019E2  =00000004               1083  XnImmediate                     EQU     4
000019E2                          1084  
000019E2                          1085  * Valid Addressing Modes
000019E2= 00 01 02 03 04 07 FF    1086  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
000019E9                          1087  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
000019E9= 00 02 03 04 07 FF       1088  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000019EF= 02 04 07 FF             1089  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
000019F3= 02 03 07 FF             1090  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
000019F7= 02 03 04 07 FF          1091  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
000019FC= 00 02 03 04 07 FF       1092  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001A02= 01 07 FF                1093  VALIDEA_LEA                     DC.B    An,Other,-1
00001A05= 00 02 03 04 07 FF       1094  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001A0B= 02 03 04 07 FF          1095  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001A10= 02 03 04 07 FF          1096  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001A15= 02 07 FF                1097  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001A18                          1098  
00001A18                          1099  * Valid Xn
00001A18= 00 01 04 FF             1100  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001A1C                          1101  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001A1C= 00 01 FF                1102  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001A1F                          1103  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001A1F                          1104  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001A1F                          1105  
00001A1F                          1106  * posible memory ASd/LSd rotation values
00001A1F  =00000000               1107  ASd_MEM                         EQU     0   
00001A1F  =00000001               1108  LSd_MEM                         EQU     1 
00001A1F  =00000003               1109  ROd_MEM                         EQU     3
00001A1F                          1110   
00001A1F  =00000000               1111  ASd_REG                         EQU     0   
00001A1F  =00000001               1112  LSd_REG                         EQU     1 
00001A1F  =00000003               1113  ROd_REG                         EQU     3
00001A1F                          1114  
00001A1F                          1115  * Starting messages
00001A1F= 57 65 6C 63 6F 6D ...   1116  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001A46= 46 6F 72 6D 61 74 ...   1117                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001A95= 50 6C 65 61 73 65 ...   1118  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001ACC= 50 6C 65 61 73 65 ...   1119  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001B02= 49 6E 76 61 6C 69 ...   1120  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001B24= 45 72 72 6F 72 20 ...   1121  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001B40= 0D 0A 00                1122  NEW_LINE                        DC.B    CR,LF,0
00001B43= 09 09 09 00             1123  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001B47                          1124  
00001B47                          1125  * Opcode Messages
00001B47= 09 4E 4F 50 00          1126  MSG_NOP                         DC.B    TAB,'NOP',0
00001B4C= 09 4D 4F 56 45 00       1127  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001B52= 09 4D 4F 56 45 41 00    1128  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001B59= 09 4D 4F 56 45 51 00    1129  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001B60= 09 4D 4F 56 45 4D 00    1130  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001B67= 09 41 44 44 00          1131  MSG_ADD                         DC.B    TAB,'ADD',0
00001B6C= 09 41 44 44 41 00       1132  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001B72= 09 41 44 44 51 00       1133  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001B78= 09 53 55 42 00          1134  MSG_SUB                         DC.B    TAB,'SUB',0
00001B7D= 09 4D 55 4C 53 00       1135  MSG_MULS                        DC.B    TAB,'MULS',0
00001B83= 09 44 49 56 55 00       1136  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001B89= 09 4C 45 41 09 09 ...   1137  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001B91= 09 41 4E 44 00          1138  MSG_AND                         DC.B    TAB,'AND',0
00001B96= 09 4F 52 00             1139  MSG_OR                          DC.B    TAB,'OR',0
00001B9A= 09 4E 4F 54 00          1140  MSG_NOT                         DC.B    TAB,'NOT',0
00001B9F= 09 4C 53 00             1141  MSG_LSd                         DC.B    TAB,'LS',0
00001BA3= 09 41 53 00             1142  MSG_ASd                         DC.B    TAB,'AS',0
00001BA7= 09 52 4F 00             1143  MSG_ROd                         DC.B    TAB,'RO',0
00001BAB= 09 42 43 43 09 09 ...   1144  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001BB3= 09 42 43 53 09 09 ...   1145  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001BBB= 09 42 45 51 09 09 ...   1146  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001BC3= 09 42 4E 45 09 09 ...   1147  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001BCB= 09 42 47 45 09 09 ...   1148  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001BD3= 09 42 47 54 09 09 ...   1149  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001BDB= 09 42 48 49 09 09 ...   1150  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001BE3= 09 42 4C 45 09 09 ...   1151  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001BEB= 09 42 4C 53 09 09 ...   1152  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001BF3= 09 42 4C 54 09 09 ...   1153  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001BFB= 09 42 4D 49 09 09 ...   1154  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001C03= 09 42 50 4C 09 09 ...   1155  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001C0B= 09 42 56 43 09 09 ...   1156  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001C13= 09 42 56 53 09 09 ...   1157  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001C1B= 09 4A 53 52 09 09 ...   1158  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001C23= 09 52 54 53 00          1159  MSG_RTS                         DC.B    TAB,'RTS',0
00001C28= 09 42 52 41 09 09 ...   1160  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001C30                          1161  
00001C30                          1162  * Direction for LSd and ASd
00001C30= 52 00                   1163  MSG_RIGHT                       DC.B    'R',0
00001C32= 4C 00                   1164  MSG_LEFT                        DC.B    'L',0
00001C34                          1165  
00001C34                          1166  * Effective Addresses Messages
00001C34= 44 00                   1167  MSG_DR                          DC.B    'D',0
00001C36= 41 00                   1168  MSG_AR                          DC.B    'A',0
00001C38= 28 00                   1169  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001C3A= 29 00                   1170  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001C3C= 2B 00                   1171  MSG_PLUS                        DC.B    '+',0
00001C3E= 2D 00                   1172  MSG_MINUS                       DC.B    '-',0
00001C40= 23 00                   1173  MSG_POUND                       DC.B    '#',0 
00001C42= 24 00                   1174  MSG_HEX                         DC.B    '$',0 
00001C44= 2C 20 00                1175  MSG_COMMA                       DC.B    ', ',0 
00001C47= 20 00                   1176  MSG_SPACE                       DC.B    ' ',0
00001C49= 09 00                   1177  MSG_TAB                         DC.B    TAB,0
00001C4B                          1178  
00001C4B                          1179  * Size Messages
00001C4B= 2E 42 09 09 09 00       1180  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001C51= 2E 57 09 09 09 00       1181  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001C57= 2E 4C 09 09 09 00       1182  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001C5D                          1183  
00001C5D                          1184  * Variables
00001C5D  =00000100               1185  STARTING_ADDRESS                EQU     $100
00001C5D  =00000150               1186  ENDING_ADDRESS                  EQU     $150
00001C5D  =00000200               1187  CURRENT_INSTR                   EQU     $200
00001C5D  =00000250               1188  REG_VAR                         EQU     $250 * Hold bits 11-9
00001C5D  =00000300               1189  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001C5D  =00000350               1190  EA_MODE                         EQU     $350 * Hold bits 5-3
00001C5D  =00000400               1191  EA_REG                          EQU     $400 * Hold bits 2-0
00001C5D                          1192  
00001C5D                          1193              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1B02
CASE_ADD            12E0
CASE_ADDA           135A
CASE_ADDQ           135A
CASE_AND            13EC
CASE_AR             17FA
CASE_ARI            1812
CASE_ARIPOST        1842
CASE_ARIPRE         187E
CASE_ASDMEM         142C
CASE_ASDREG         14F4
CASE_BCC            162C
CASE_BEQ            165E
CASE_BGT            1672
CASE_BLE            1668
CASE_BRA            1608
CASE_DATA           16A2
CASE_DR             17E2
CASE_EPICFAIL       16A4
CASE_IMMEDIATE      18CC
CASE_JSR            168C
CASE_LEA            135A
CASE_LEFTMEM        1452
CASE_LEFTREG        151A
CASE_LONG           18F4
CASE_LSDASD         13EC
CASE_LSDMEM         1422
CASE_LSDREG         14EA
CASE_MOVE           1186
CASE_MOVEM          1228
CASE_MOVEQ          128E
CASE_NOP            1170
CASE_NOT            13EC
CASE_OR             13EC
CASE_OTHER          18BA
CASE_RIGHTMEM       145C
CASE_RIGHTREG       1524
CASE_RODMEM         1436
CASE_RODREG         14FE
CASE_RTS            168C
CASE_SHIFTMEM       140A
CASE_SHIFTREG       14D0
CASE_SUB            135A
CASE_WORD           18E4
CHECKEAEXIT         17B2
CHECKEAMLOOP        1784
CHECKEAXN_IFVALID   1782
CHECKGET_EAXN       16FA
CHECKMEMSOURE       1490
CHECKSHIFT_XN       14BA
CHECK_LENGTH        10CA
CHECK_ODD           1160
CHECK_ORDER         109A
CHECK_XN            172A
CONCAT              1112
CONVERT             10DC
CR                  D
CURRENT_INSTR       200
DELETEME            19B0
DELETEMEAGAIN       19DE
DESTEA              16B0
DESTXN              16DA
DISASSEMBLE         10A4
DN                  0
EASHIFT_VALID       14AE
EAXN_INVALID        173C
EAXN_VALID          1722
EA_MODE             350
EA_REG              400
EA_TO_STRING        17B6
EA_TO_STRING_EXIT   1908
ENDING              1ACC
ENDING_ADDRESS      150
END_CHECKGET        1740
ERROR               19A4
ERROR_MSG           1B24
FINDTYPEEA          16C4
FINDTYPEXN          16EE
FINISHMOVE          199A
GETDIRECTION        176A
GETDISPLACEMENT     1742
GETMEMSOURCE        1478
GETROTATION         1760
GETROTATIONLOCATION  177A
GETROTATIONSIZE     1772
GET_EA              16A6
GET_XN              16D0
INPUT1              100C
INPUT2              1052
INSERTA             11F4
INVALID             112A
INVALIDEA           1796
ISNUMBER            10F2
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128E
MOVEM_REG2MEM       125E
MOVE_BYTE           1980
MOVE_LONG           1994
MOVE_WORD           198A
MSG_ADD             1B67
MSG_ADDA            1B6C
MSG_ADDQ            1B72
MSG_AND             1B91
MSG_AR              1C36
MSG_ASD             1BA3
MSG_B               1C4B
MSG_BCC             1BAB
MSG_BCS             1BB3
MSG_BEQ             1BBB
MSG_BGE             1BCB
MSG_BGT             1BD3
MSG_BHI             1BDB
MSG_BLE             1BE3
MSG_BLS             1BEB
MSG_BLT             1BF3
MSG_BMI             1BFB
MSG_BNE             1BC3
MSG_BPL             1C03
MSG_BRA             1C28
MSG_BVC             1C0B
MSG_BVS             1C13
MSG_COMMA           1C44
MSG_DIVU            1B83
MSG_DR              1C34
MSG_HEX             1C42
MSG_JSR             1C1B
MSG_L               1C57
MSG_LB              1C38
MSG_LEA             1B89
MSG_LEFT            1C32
MSG_LSD             1B9F
MSG_MINUS           1C3E
MSG_MOVE            1B4C
MSG_MOVEA           1B52
MSG_MOVEM           1B60
MSG_MOVEQ           1B59
MSG_MULS            1B7D
MSG_NOP             1B47
MSG_NOT             1B9A
MSG_OR              1B96
MSG_PLUS            1C3C
MSG_POUND           1C40
MSG_RB              1C3A
MSG_RIGHT           1C30
MSG_ROD             1BA7
MSG_RTS             1C23
MSG_SPACE           1C47
MSG_SUB             1B78
MSG_TAB             1C49
MSG_W               1C51
NEW_LINE            1B40
NOTNUMBER           10FA
OPCODE_DECODE       1168
OPMODE_VAR          300
OTHER               7
OTHEREA             17AE
PRINTADDRESS        1752
PRINTBCC            167C
PRINTENTER          1956
PRINTMOVE           11FA
PRINTMOVESIZE       1966
PRINTNULL           1944
PRINTNUM            190E
PRINTRANGE          192E
PRINTREGEA          1566
PRINTREGSIZE        1534
PRINTSHIFTMEM       143C
PRINTSHIFTREG       1504
PRINTSHORTLONGNUM   191E
PRINT_MEMDIR        1462
PRINT_MOVEQ         12B0
PRINT_REGDIR        152E
REG2MEMXNCHECK      1278
REG_BYTE            154C
REG_IMMEDIATE       157C
REG_LONG            1560
REG_REGISTER        15C2
REG_VAR             250
REG_WORD            1556
RESET_INPUT         10C2
RETURN              1128
ROD_MEM             3
ROD_REG             3
SOURCEEA            16BC
SOURCEXN            16E6
START               1000
STARTING            1A95
STARTING_ADDRESS    100
STOP                10BC
TAB                 9
TEST_RANGE          1148
THREE_TAB           1B43
VALIDEA             179E
VALIDEA_ADDSUB_DESTOPERAND  19F7
VALIDEA_ALL         19E2
VALIDEA_ANDORNOT    1A05
VALIDEA_ANDOR_DESTOPERAND  1A0B
VALIDEA_JSR         1A15
VALIDEA_LEA         1A02
VALIDEA_MOVEM_MEMTOREG  19F3
VALIDEA_MOVEM_REGTOMEM  19EF
VALIDEA_MOVEQ       19E9
VALIDEA_MULSDIVU    19FC
VALIDEA_SHIFT       1A10
VALIDXN_ALL         1A18
VALIDXN_SHORTLONG   1A1C
WELCOME             1A1F
XNIMMEDIATE         4
