00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/6/2020 10:59:59 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001C5F             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001CD5             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001D0C             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 00001A5C             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001B94             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6E00 0052                 78                  BGT     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 00001D42            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C                           138                  
0000116C  B07C 4E71                139  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001170  6600 0010                140                  BNE     CASE_MOVE               ; checks the next case if not equal
00001174  4BF9 00001D87            141                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117A  4EB9 00001B82            142                  JSR     PRINTNULL               ; prints NOP                
00001180  4E75                     143                  RTS                             ; returns from the subroutine
00001182                           144                  
00001182                           145                  * if first two bits are 00, next two are not 00
00001182  3200                     146  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001184  C27C C000                147                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001188  6600 009A                148                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
0000118C  B07C 0FFF                149                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001190  6F00 0092                150                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001194                           151                  
00001194                           152                  ; Check source
00001194  4BF9 00001C22            153                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119A  4DF9 00001C58            154                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A0  3E3C 0000                155                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A4  4EB9 000017F0            156                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AA  B27C 0001                157                  CMP.W   #1,D1                    ; checks if invalid
000011AE  6700 05E8                158                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B2  3802                     159                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B4  3A03                     160                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011B6                           161                  
000011B6                           162                  ; Check destination
000011B6  4BF9 00001C22            163                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011BC  4DF9 00001C5C            164                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C2  3E3C 0001                165                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011C6  4EB9 000017F0            166                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011CC  B27C 0001                167                  CMP.W   #1,D1                    ; checks if invalid
000011D0  6700 05C6                168                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D4  3C02                     169                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011D6  3E03                     170                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011D8                           171                  
000011D8                           172                  ; Checking if it is MOVEA
000011D8  3200                     173                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DA  C27C 01C0                174                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011DE  B27C 0040                175                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E2  6700 000C                176                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011E6                           177   
000011E6  4BF9 00001D8C            178                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011EC  6000 0008                179                  BRA     PRINTMOVE                ; Branches to print move
000011F0                           180                  
000011F0  4BF9 00001D92            181  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011F6                           182   
000011F6  4EB9 00001B82            183  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
000011FC  4EB9 00001BA4            184                  JSR     PRINTMOVESIZE            ; prints out the size  
00001202  3404                     185                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001204  3605                     186                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001206  4EB9 000018BC            187                  JSR     EA_TO_STRING             ; outputs it into a string
0000120C                           188                  
0000120C                           189                  ; prints a comma to seperate
0000120C  4BF9 00001E84            190                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001212  4EB9 00001B82            191                  JSR     PRINTNULL                ; prints out MOVE
00001218                           192                  
00001218                           193                  ; print destination
00001218  3406                     194                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121A  3607                     195                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000121C  4EB9 000018BC            196                  JSR     EA_TO_STRING             ; outputs it into a string
00001222  4E75                     197                  RTS                              ; exits subroutine                 
00001224                           198                
00001224                           199                  
00001224  3200                     200  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001226  C27C FB80                201                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122A  B27C 4880                202                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000122E  6600 005A                203                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001232                           204                  
00001232                           205                  ; loads EA and XN
00001232  323C 0000                206                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001236  4EB9 0000179C            207                  JSR     GET_EA                          ; gets EA and puts in D1
0000123C  3401                     208                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
0000123E  323C 0000                209                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001242  4EB9 000017C6            210                  JSR     GET_XN                          ; gets XN and puts in D1
00001248  3601                     211                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
0000124A                           212                  
0000124A                           213                  ; Check D
0000124A  3200                     214                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000124C  C27C 0400                215                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001250  3E01                     216                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001252  B27C 0400                217                  CMP.W   #$0400,D1                       ; checks if value is 1
00001256  6700 0032                218                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000125A                           219  
0000125A  4BF9 00001C2F            220  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001260  3202                     221                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001262  4EB9 00001888            222                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001268  B27C 0001                223                  CMP.W   #1,D1                           ; checks if D1 invalid
0000126C  6700 052A                224                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001270  B27C 0002                225                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001274                           226                  
00001274  4BF9 00001C2F            227  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127A  3203                     228                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
0000127C  4EB9 00001888            229                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001282  B27C 0001                230                  CMP.W   #1,D1                           ; checks if D1 invalid
00001286  6700 0510                231                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128A                           232  
0000128A                           233                  
0000128A                           234  
0000128A                           235  MOVEM_MEM2REG    
0000128A                           236                          
0000128A                           237  
0000128A                           238  
0000128A  3200                     239  CASE_MOVEQ      MOVE.W  D0,D1
0000128C  C27C F100                240                  AND.W   #$F100,D1
00001290  B27C 7000                241                  CMP.W   #$7000,D1
00001294  6600 0048                242                  BNE     CASE_ADD
00001298                           243                  
00001298                           244                  ;loads Register
00001298  323C 0001                245                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000129C  4EB9 000017C6            246                  JSR     GET_XN                          ; gets XN and puts in D1
000012A2  3401                     247                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012A4                           248                  
000012A4                           249                  ;loads DATA
000012A4  3200                     250                  MOVE.W  D0,D1
000012A6  C27C 00FF                251                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012AA  3601                     252                  MOVE.W  D1,D3                          ;copy data into D3
000012AC                           253                                                          ;must convert bits to hex
000012AC                           254                  
000012AC                           255                  
000012AC  4BF9 00001D99            256  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B2  4EB9 00001B82            257                  JSR     PRINTNULL  
000012B8                           258                  
000012B8  4BF9 00001E97            259                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012BE  4EB9 00001B82            260                  JSR     PRINTNULL
000012C4                           261      
000012C4  4BF9 00001D83            262                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000012CA  4EB9 00001B82            263                  JSR     PRINTNULL
000012D0                           264                  
000012D0  4BF9 00001E80            265                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012D6  4EB9 00001B82            266                  JSR     PRINTNULL
000012DC  4E75                     267                  RTS
000012DE                           268                  
000012DE                           269  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000012DE  3200                     270  CASE_ADD        MOVE.W  D0,D1
000012E0  C27C F000                271                  AND.W   #$F000,D1
000012E4  B27C D000                272                  CMP.W   #$D000,D1
000012E8  6600 0166                273                  BNE     CASE_ADDQ
000012EC                           274                  
000012EC                           275                  ; Check bits 0-6 
000012EC  4BF9 00001C22            276                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012F2  4DF9 00001C58            277                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012F8  3E3C 0000                278                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012FC  4EB9 000017F0            279                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001302  B27C 0001                280                  CMP.W   #1,D1                    ; checks if invalid
00001306  6700 0490                281                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000130A  3802                     282                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000130C  3A03                     283                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000130E                           284                  
0000130E                           285                  ; get bits 9-11
0000130E  3200                     286                  MOVE.W  D0,D1
00001310  E949                     287                  LSL.W   #4,D1                   ; get rid of left 4 bits
00001312  E849                     288                  LSR.W   #4,D1
00001314  E049                     289                  LSR.W   #8,D1                   ; get rid of right 6 bits
00001316  E249                     290                  LSR.W   #1,D1                   ; get rid of right 6 bits
00001318  3C01                     291                  MOVE.W  D1,D6
0000131A                           292                  
0000131A                           293                  ; bits 7-8 determine if it is ADDA or ADD
0000131A  3200                     294                  MOVE.W  D0,D1
0000131C  E149                     295                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000131E  E049                     296                  LSR.W   #8,D1
00001320  EC49                     297                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001322  B27C 0003                298                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001326  6700 00C0                299                  BEQ     CASE_ADDA
0000132A                           300                  
0000132A  4BF9 00001DA7            301                  LEA     MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001330  6000 0002                302                  BRA     PRINTADD                ; Branches to print move
00001334                           303                  
00001334  4EB9 00001B82            304  PRINTADD        JSR     PRINTNULL
0000133A  3200                     305                  MOVE.W  D0,D1                   ; bits 7-8 contain size
0000133C  E149                     306                  LSL.W   #8,D1
0000133E  E049                     307                  LSR.W   #8,D1
00001340  EC49                     308                  LSR.W   #6,D1                   ; gets bits 7-8
00001342                           309                  
00001342  B27C 0001                310                  CMP.W   #1,D1                   ; if 1, it is a word
00001346  6700 001A                311                  BEQ     ADD_WORD
0000134A  B27C 0002                312                  CMP.W   #2,D1                   ; if 2, it is a long
0000134E  6700 0022                313                  BEQ     ADD_LONG
00001352                           314                  
00001352  4BF9 00001E8B            315  ADD_BYTE        LEA     MSG_B,A5
00001358  4EB9 00001B82            316                  JSR     PRINTNULL
0000135E  6000 0022                317                  BRA     FINISH_ADD  
00001362                           318  
00001362  4BF9 00001E91            319  ADD_WORD        LEA     MSG_W,A5
00001368  4EB9 00001B82            320                  JSR     PRINTNULL
0000136E  6000 0012                321                  BRA     FINISH_ADD  
00001372                           322                  
00001372                           323  
00001372  4BF9 00001E97            324  ADD_LONG        LEA     MSG_L,A5
00001378  4EB9 00001B82            325                  JSR     PRINTNULL
0000137E  6000 0002                326                  BRA     FINISH_ADD  
00001382                           327  
00001382  EF49                     328  FINISH_ADD      LSL.W   #7,D1
00001384  EE49                     329                  LSR.W   #7,D1
00001386  E049                     330                  LSR.W   #8,D1
00001388                           331  
00001388  B27C 0001                332                  CMP.W   #1,D1
0000138C  6000 002E                333                  BRA     Dn_PLUS_EA          
00001390                           334                  
00001390                           335                  ; print Data Register
00001390  4BF9 00001E74            336                  LEA     MSG_DR,A5
00001396  4EB9 00001B82            337                  JSR     PRINTNULL
0000139C  3206                     338                  MOVE.W  D6,D1
0000139E  4EB9 00001A38            339                  JSR     PRINTNUM                
000013A4                           340                  
000013A4                           341                  ; prints a comma to seperate
000013A4  4BF9 00001E84            342                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000013AA  4EB9 00001B82            343                  JSR     PRINTNULL                ; prints out MOVE
000013B0                           344                  
000013B0                           345                  ; below is EA+Dn->Dn  
000013B0  3404                     346                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013B2  3605                     347                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013B4  4EB9 000018BC            348                  JSR     EA_TO_STRING             ; outputs it into a string
000013BA  4E75                     349                  RTS                              ; exits subroutine 
000013BC                           350  
000013BC                           351  Dn_PLUS_EA      ; below is Dn+EA->EA  
000013BC  3404                     352                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013BE  3605                     353                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013C0  4EB9 000018BC            354                  JSR     EA_TO_STRING             ; outputs it into a string   
000013C6                           355                  
000013C6                           356                  ; prints a comma to seperate
000013C6  4BF9 00001E84            357                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000013CC  4EB9 00001B82            358                  JSR     PRINTNULL                ; prints out MOVE
000013D2                           359                  
000013D2                           360                  ; below is Dn+EA->EA
000013D2  4BF9 00001E74            361                  LEA     MSG_DR,A5                  ; print data register
000013D8  4EB9 00001B82            362                  JSR     PRINTNULL
000013DE  3206                     363                  MOVE.W  D6,D1
000013E0  4EB9 00001A38            364                  JSR     PRINTNUM             
000013E6  4E75                     365                  RTS                              ; exits subroutine                
000013E8                           366                   
000013E8                           367  
000013E8  3200                     368  CASE_ADDA       MOVE.W  D0,D1
000013EA  EF49                     369                  LSL.W   #7,D1
000013EC  EE49                     370                  LSR.W   #7,D1
000013EE  E049                     371                  LSR     #8,D1                               ; gets bit 8 (size bit)
000013F0                           372                  
000013F0  4BF9 00001DAC            373                  LEA     MSG_ADDA,A5
000013F6  4EB9 00001B82            374                  JSR     PRINTNULL
000013FC                           375                  
000013FC  B27C 0001                376                  CMP.W   #1,D1
00001400  6700 0012                377                  BEQ     ADDA_LONG
00001404                           378                  
00001404  4BF9 00001E91            379                  LEA     MSG_W,A5
0000140A  4EB9 00001B82            380                  JSR     PRINTNULL
00001410  6000 0012                381                  BRA     FINISH_ADDA   
00001414                           382                  
00001414  4BF9 00001E97            383  ADDA_LONG       LEA     MSG_L,A5
0000141A  4EB9 00001B82            384                  JSR     PRINTNULL
00001420  6000 0002                385                  BRA     FINISH_ADDA
00001424                           386                  
00001424  3404                     387  FINISH_ADDA     MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001426  3605                     388                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001428  4EB9 000018BC            389                  JSR     EA_TO_STRING             ; outputs it into a string
0000142E                           390                  
0000142E                           391                  ; prints a comma to seperate
0000142E  4BF9 00001E84            392                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001434  4EB9 00001B82            393                  JSR     PRINTNULL                ; prints out MOVE
0000143A                           394          
0000143A  4BF9 00001E76            395                  LEA     MSG_AR,A5                ; print address register
00001440  4EB9 00001B82            396                  JSR     PRINTNULL
00001446  3206                     397                  MOVE.W  D6,D1
00001448  4EB9 00001A38            398                  JSR     PRINTNUM             
0000144E  4E75                     399                  RTS                              ; exits subroutine
00001450                           400                  
00001450                           401  
00001450                           402  CASE_ADDQ       
00001450                           403  
00001450                           404  CASE_SUB
00001450                           405  
00001450  3200                     406  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001452  C27C F000                407                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001456  B27C 4000                408                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000145A  6600 0086                409                  BNE.W   CASE_AND                             ; If its not, check AND
0000145E  3200                     410                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001460  C27C 01C0                411                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001464  B27C 01C0                412                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001468  6600 0078                413                  BNE.W   CASE_AND                             ; If its not, check AND
0000146C                           414                  
0000146C                           415                  ; Check source
0000146C  4BF9 00001C42            416                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001472  4DF9 00001C5C            417                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001478  3E3C 0000                418                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
0000147C  4EB9 000017F0            419                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001482  3802                     420                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001484  3A03                     421                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001486                           422                  
00001486                           423                  ; Check destination
00001486  4BF9 00001C42            424                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000148C  4DF9 00001C5C            425                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001492  3E3C 0001                426                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
00001496  4EB9 000017F0            427                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000149C  3C02                     428                  MOVE.W  D2,D6                                ; Saves D2 in D4
0000149E  3E03                     429                  MOVE.W  D3,D7                                ; Saves D2 in D4
000014A0                           430  
000014A0  4BF9 00001DC9            431                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000014A6  4EB9 00001B82            432                  JSR     PRINTNULL                            ; prints LEA
000014AC                           433                  
000014AC                           434                  ; print source
000014AC  3404                     435                  MOVE.W  D4,D2
000014AE  3605                     436                  MOVE.W  D5,D3
000014B0  4EB9 000018BC            437                  JSR     EA_TO_STRING                         ; Prints out the EA
000014B6                           438                  
000014B6                           439                  ; comma
000014B6  4BF9 00001E84            440                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000014BC  4EB9 00001B82            441                  JSR     PRINTNULL                       
000014C2                           442                   
000014C2                           443                  ; register
000014C2  4BF9 00001E76            444                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000014C8  4EB9 00001B82            445                  JSR     PRINTNULL 
000014CE  3401                     446                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000014D0  323C 0001                447                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000014D4  4EB9 000017C6            448                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000014DA  4EB9 00001A38            449                  JSR     PRINTNUM                             ; Prints the number in D1
000014E0  4E75                     450                  RTS
000014E2                           451  
000014E2                           452  **---------------AND opcode----------------------
000014E2                           453  CASE_AND
000014E2                           454  *CASE_AND        LEA         MSG_AND,A1
000014E2                           455  *                MOVE.B      #14,D0
000014E2                           456  *                TRAP        #15 
000014E2                           457  *                JSR         GET_VARS
000014E2                           458  *                JSR         AND_SIZE                        ; .B, .W, or .L  
000014E2                           459  *                MOVE.W      CURRENT_INSTR, D5                         
000014E2                           460  *                LSL.W       #7, D5                        
000014E2                           461  *                LSR.W       #8, D5                   
000014E2                           462  *                LSR.W       #7, D5                     
000014E2                           463  *                CMP.B       #00, D5                         ; check if destination is a Dn?
000014E2                           464  *                BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
000014E2                           465  *                CMP.B       #$01,D5                         ; Is the destination not a Dn?
000014E2                           466  *                BEQ         DEST_EA                         ; branch to DEST_EA            
000014E2                           467  *                RTS
000014E2                           468     
000014E2                           469  *AND_SIZE        CMP.B       #%00,OPMODE_VAR       
000014E2                           470  *                BEQ         PRINT_BYTE
000014E2                           471  *                CMP.B       #$01, OPMODE_VAR
000014E2                           472  *                BEQ         PRINT_WORD
000014E2                           473  *                CMP.B       #$02, OPMODE_VAR
000014E2                           474  *                BEQ         PRINT_LONG    
000014E2                           475  *    
000014E2                           476  *DEST_DN         MOVE.W      CURRENT_INSTR, D5               
000014E2                           477  *                LSL.W       #6,D5
000014E2                           478  *                LSL.W       #4,D5
000014E2                           479  *                LSR.W       #6,D5
000014E2                           480  *                LSR.W       #4,D5
000014E2                           481  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000014E2                           482  *                  
000014E2                           483  *                MOVE.W      CURRENT_INSTR, D6               
000014E2                           484  *                LSL.W       #6,D5
000014E2                           485  *                LSL.W       #4,D5
000014E2                           486  *                LSL.W       #3,D6
000014E2                           487  *                LSR.W       #6,D6
000014E2                           488  *                LSR.W       #4,D6
000014E2                           489  *                LSR.W       #3,D6                           ; d6 stores EA register
000014E2                           490  *                JSR         FIND_EA
000014E2                           491  *
000014E2                           492  *                
000014E2                           493  *                MOVE.W      CURRENT_INSTR, D5               
000014E2                           494  *                LSL.W       #4, D5                         
000014E2                           495  *                LSR.W       #8, D5                          ; shift bits to get register
000014E2                           496  *                LSR.W       #5, D5                          ; D5 contains register
000014E2                           497  *                LEA         MSG_COMMA, A1                   
000014E2                           498  *                MOVE.B      #14,D0
000014E2                           499  *                TRAP        #15                             ; print comma
000014E2                           500  *                LEA         MSG_DR, A1                      ; print D
000014E2                           501  *                MOVE.B      #14,D0
000014E2                           502  *                TRAP        #15
000014E2                           503  *                MOVEA.L     D5,A1
000014E2                           504  *                MOVE.B      #14,D0
000014E2                           505  *                TRAP        #15                              
000014E2                           506  *                RTS        
000014E2                           507  *
000014E2                           508  *FIND_EA        CMP.W       #%010,D5
000014E2                           509  *                BEQ         CASE_ARI
000014E2                           510  *                CMP.W       #%011,D5
000014E2                           511  *                BEQ         CASE_ARIPOST
000014E2                           512  *                CMP.W       #%100,D5
000014E2                           513  *                BEQ         CASE_ARIPRE
000014E2                           514  *                CMP.W       #%111,D5
000014E2                           515  *                BEQ         CASE_OTHER
000014E2                           516  *                BRA         ERROR    
000014E2                           517  *                                     
000014E2                           518  *DEST_EA         MOVE.W      CURRENT_INSTR, D5               
000014E2                           519  *                LSL.W       #4, D5                         
000014E2                           520  *                LSR.W       #8, D5                          ; shift bits to get register
000014E2                           521  *                LSR.W       #5, D5                          ; D5 contains register
000014E2                           522  *
000014E2                           523  *                LEA         MSG_DR, A1                   
000014E2                           524  *                MOVE.B      #14,D0
000014E2                           525  *                TRAP        #15                             ; print D
000014E2                           526  *                MOVEA.L     D5,A1  
000014E2                           527  *                MOVE.B      #14,D0                          ; print register
000014E2                           528  *                TRAP        #15
000014E2                           529  *                
000014E2                           530  *                LEA         MSG_COMMA, A1                   
000014E2                           531  *                MOVE.B      #14,D0
000014E2                           532  *                TRAP        #15                             ; print comma
000014E2                           533  *                
000014E2                           534  *                MOVE.W      CURRENT_INSTR, D5               
000014E2                           535  *                LSL.W       #6,D5
000014E2                           536  *                LSL.W       #4,D5
000014E2                           537  *                LSR.W       #6,D5
000014E2                           538  *                LSR.W       #4,D5
000014E2                           539  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000014E2                           540  *                  
000014E2                           541  *                MOVE.W      CURRENT_INSTR, D6               
000014E2                           542  *                LSL.W       #6,D6
000014E2                           543  *                LSL.W       #4,D6
000014E2                           544  *                LSL.W       #3,D6
000014E2                           545  *                LSR.W       #6,D6
000014E2                           546  *                LSR.W       #4,D6
000014E2                           547  *                LSR.W       #3,D6                           ; d6 stores EA register
000014E2                           548  *                JSR         FIND_EA                          
000014E2                           549  *                RTS                                     Return full instruction   
000014E2                           550              
000014E2                           551  CASE_OR
000014E2                           552  
000014E2                           553  CASE_NOT
000014E2                           554  
000014E2  3200                     555  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
000014E4  C27C F000                556                  AND.W       #$F000, D1                       ; gets first 4 bits
000014E8  B27C E000                557                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000014EC  6600 0210                558                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000014F0  3400                     559                  MOVE.W      D0,D2                            ; copies D0 to D2
000014F2  4EB9 00001878            560                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000014F8  B47C 0003                561                  CMP.W       #$3, D2                          ; checks if it is memory or register option
000014FC  6600 00C8                562                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001500                           563                  
00001500  3400                     564  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001502  4EB9 00001866            565                  JSR         GETROTATION                      ; gets rotation value of D2
00001508  B47C 0000                566                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
0000150C  6700 0014                567                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001510  B47C 0003                568                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001514  6700 0016                569                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001518                           570                  
00001518  4BF9 00001DDF            571  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
0000151E  6000 0012                572                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001522                           573  
00001522  4BF9 00001DE3            574  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001528  6000 0008                575                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000152C                           576  
0000152C  4BF9 00001DE7            577  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001532                           578                  
00001532  4EB9 00001B82            579  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
00001538  3400                     580                  MOVE.W      D0,D2                            ; copies D0 to D2
0000153A  4EB9 00001870            581                  JSR         GETDIRECTION                     ; gets direction
00001540  B47C 0000                582                  CMP.W       #0,D2                            ; checking if its right
00001544  6700 000C                583                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001548                           584  
00001548  4BF9 00001E72            585  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000154E  6000 0008                586                  BRA         PRINT_MEMDIR                     ; branches for printing
00001552                           587          
00001552  4BF9 00001E70            588  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001558                           589  
00001558  4EB9 00001B82            590  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000155E  4BF9 00001E91            591                  LEA         MSG_W,A5                         ; loads .W into A5
00001564  4EB9 00001B82            592                  JSR         PRINTNULL                        ; Prints .W
0000156A  6000 0002                593                  BRA         GETMEMSOURCE                     ; checks the source 
0000156E                           594                  
0000156E                           595  ; get source addressing mode       
0000156E                           596  GETMEMSOURCE                                                 
0000156E  323C 0000                597                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001572  4EB9 0000179C            598                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001578  3801                     599                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
0000157A  323C 0000                600                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
0000157E  4EB9 000017C6            601                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001584  3A01                     602                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001586                           603  
00001586  4BF9 00001C50            604  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
0000158C  3204                     605                  MOVE.W      D4,D1                            ; marks down that we are checking EA
0000158E  4EB9 00001888            606                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001594  B27C 0002                607                  CMP.W       #2,D1                            ; checks if it is Xn
00001598  6700 0016                608                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
0000159C  B27C 0001                609                  CMP.W       #1,D1                            ; Checks if it is invalid
000015A0  6700 01F6                610                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000015A4                           611  
000015A4  3404                     612  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000015A6  3605                     613                  MOVE.W      D5,D3                            ; moves EA to D3
000015A8  4EB9 000018BC            614                  JSR         EA_TO_STRING                     ; prints out the EA
000015AE  4E75                     615                  RTS                
000015B0                           616                  
000015B0                           617                  
000015B0  4BF9 00001C5C            618  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000015B6  3205                     619                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000015B8  4EB9 00001888            620                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000015BE  4A41                     621                  TST.W       D1                               ; checks if it is valid
000015C0  67E2                     622                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000015C2  6000 01D4                623                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000015C6                           624  
000015C6                           625  
000015C6  3602                     626  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000015C8  3200                     627                  MOVE.W      D0,D1                            ; copies D0 to D1
000015CA  C27C 0018                628                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000015CE  E649                     629                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000015D0  B27C 0000                630                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000015D4  6700 0014                631                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000015D8  B27C 0003                632                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000015DC  6700 0016                633                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000015E0                           634                  
000015E0  4BF9 00001DDF            635  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
000015E6  6000 0012                636                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000015EA                           637  
000015EA  4BF9 00001DE3            638  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
000015F0  6000 0008                639                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000015F4                           640  
000015F4  4BF9 00001DE7            641  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
000015FA                           642                  
000015FA  4EB9 00001B82            643  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
00001600  3400                     644                  MOVE.W      D0,D2                            ; copies D0 to D2
00001602  4EB9 00001870            645                  JSR         GETDIRECTION                     ; gets direction
00001608  B47C 0000                646                  CMP.W       #0,D2                            ; checking if its right
0000160C  6700 000C                647                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001610                           648  
00001610  4BF9 00001E72            649  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001616  6000 000C                650                  BRA         PRINT_REGDIR                     ; branches for printing
0000161A                           651          
0000161A  4BF9 00001E70            652  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001620  6000 0002                653                  BRA         PRINT_REGDIR                     ; branches for printing
00001624                           654                  
00001624  4EB9 00001B82            655  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
0000162A                           656  
0000162A  3400                     657  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
0000162C  4EB9 00001878            658                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001632  B47C 0001                659                  CMP.W       #1,D2                            ; Checks if it is word size
00001636  6700 0014                660                  BEQ         REG_WORD                         ; Prints .W
0000163A  B47C 0002                661                  CMP.W       #2,D2                            ; Checks if it is long size
0000163E  6700 0016                662                  BEQ         REG_LONG                         ; Prints .L
00001642                           663  
00001642  4BF9 00001E8B            664  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001648  6000 0012                665                  BRA         PRINTREGEA      
0000164C                           666  
0000164C  4BF9 00001E91            667  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001652  6000 0008                668                  BRA         PRINTREGEA      
00001656                           669                             
00001656  4BF9 00001E97            670  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
0000165C                           671  
0000165C  4EB9 00001B82            672  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001662  3400                     673                  MOVE.W      D0,D2                            ; copies D0 to D1
00001664  4EB9 00001880            674                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
0000166A  B27C 0001                675                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
0000166E  6700 0048                676                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001672                           677                                  
00001672  3400                     678  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001674  4EB9 00001878            679                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000167A  3202                     680                  MOVE.W      D2, D1                           ; moves rotation size to D1
0000167C  4BF9 00001E80            681                  LEA         MSG_POUND, A5                    ; loads # into A5
00001682  4EB9 00001B82            682                  JSR         PRINTNULL                        ; prints #
00001688  4EB9 00001A38            683                  JSR         PRINTNUM                         ; prints shift count
0000168E  4BF9 00001E84            684                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001694  4EB9 00001B82            685                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
0000169A  4BF9 00001E74            686                  LEA         MSG_DR, A5                       ; loads D into A5
000016A0  4EB9 00001B82            687                  JSR         PRINTNULL                        ; prints out D 
000016A6  323C 0000                688                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000016AA  4EB9 000017C6            689                  JSR         GET_XN                           ; gets the data register number, stores in D1
000016B0  4EB9 00001A38            690                  JSR         PRINTNUM                         ; prints data register number in D1          
000016B6  4E75                     691                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000016B8                           692                  
000016B8  3400                     693  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
000016BA  4EB9 00001878            694                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000016C0  3202                     695                  MOVE.W      D2, D1                           ; moves rotation size to D1
000016C2  4BF9 00001E74            696                  LEA         MSG_DR, A5                       ; loads D into A5
000016C8  4EB9 00001B82            697                  JSR         PRINTNULL                        ; prints D
000016CE  4EB9 00001A38            698                  JSR         PRINTNUM                         ; prints register number
000016D4  4BF9 00001E84            699                  LEA         MSG_COMMA, A5                    ; loads , into A5
000016DA  4EB9 00001B82            700                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000016E0  4BF9 00001E74            701                  LEA         MSG_DR, A5                       ; loads D into A5
000016E6  4EB9 00001B82            702                  JSR         PRINTNULL                        ; prints out D 
000016EC  323C 0000                703                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000016F0  4EB9 000017C6            704                  JSR         GET_XN                           ; gets the data register number, stores in D1
000016F6  4EB9 00001A38            705                  JSR         PRINTNUM                         ; prints data register number in D1          
000016FC  4E75                     706                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000016FE                           707               
000016FE  3200                     708  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001700  C27C FF00                709                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001704  B27C 6000                710                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001708  6600 0018                711                  BNE.W   CASE_BCC                             ; If its not, check BCC
0000170C                           712                  
0000170C  4BF9 00001E68            713                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001712  4EB9 00001B82            714                  JSR     PRINTNULL                            ; prints BRA
00001718                           715  
00001718  3400                     716                  MOVE.W  D0,D2                                ; Copies instruction word to D1
0000171A  4EB9 00001838            717                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001720  4E75                     718                  RTS
00001722                           719                  
00001722                           720  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001722                           721  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001722  3200                     722  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001724  C27C F000                723                  AND.W   #$F000,D1                            ; get top 4 bits
00001728  B27C 6000                724                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
0000172C  6600 0054                725                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001730  3200                     726                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001732  C27C 0F00                727                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001736  E049                     728                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001738                           729                  
00001738  B27C 000E                730                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
0000173C  6700 002A                731                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001740                           732                  
00001740  B27C 000F                733                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001744  6700 0018                734                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001748                           735                      
00001748  B27C 0007                736                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
0000174C  6700 0006                737                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001750  6000 0046                738                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001754                           739     
00001754  4BF9 00001DFB            740  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
0000175A  6000 0016                741                  BRA     PRINTBCC
0000175E                           742  
0000175E  4BF9 00001E23            743  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001764  6000 000C                744                  BRA     PRINTBCC
00001768                           745                  
00001768  4BF9 00001E13            746  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
0000176E  6000 0002                747                  BRA     PRINTBCC
00001772                           748  
00001772  4EB9 00001B82            749  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001778  3400                     750                  MOVE.W  D0,D2                                ; Copies instruction word to D1
0000177A  4EB9 00001838            751                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001780  4E75                     752                  RTS              
00001782                           753                  
00001782                           754  
00001782                           755  CASE_JSR       
00001782                           756  
00001782  B07C 4E75                757  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001786  6600 F9FA                758                  BNE     CASE_MOVE           ; checks the next case if not equal
0000178A  4BF9 00001E63            759                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001790  4EB9 00001B82            760                  JSR     PRINTNULL           ; prints RTS                
00001796  4E75                     761                  RTS                         ; returns from the subroutine
00001798                           762  
00001798                           763                  
00001798                           764  
00001798                           765  CASE_DATA           
00001798  4E75                     766                      RTS               
0000179A                           767  
0000179A  4E75                     768  CASE_EPICFAIL       RTS
0000179C                           769  
0000179C                           770  
0000179C                           771  * Finds the EA type
0000179C                           772  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
0000179C                           773  * Output: Addressing Mode (3 bits, 0 to 7) in D1
0000179C  48E7 3000                774  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000017A0  4A41                     775                      TST.W     D1                    ; compares D1 to 0
000017A2  6700 000E                776                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
000017A6                           777                      
000017A6  343C 01C0                778  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
000017AA  363C 0006                779                      MOVE.W    #6,D3                 ; stores the shift amount to D3
000017AE  6000 000A                780                      BRA       FINDTYPEEA            
000017B2                           781  
000017B2  343C 0038                782  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
000017B6  363C 0003                783                      MOVE.W    #3,D3                 ; stores the shift amount to D3
000017BA                           784  
000017BA                           785  
000017BA  3200                     786  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
000017BC  C242                     787                      AND.W     D2,D1                 ; applies bitmask to D1
000017BE  E669                     788                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000017C0  4CDF 000C                789                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000017C4  4E75                     790                      RTS                             ; returns from subroutine    
000017C6                           791                      
000017C6                           792  * Finds Xn type
000017C6                           793  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
000017C6                           794  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000017C6  48E7 3000                795  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000017CA  4A41                     796                      TST.W     D1                    ; compares D1 to 0
000017CC  6700 000E                797                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
000017D0                           798  
000017D0  343C 0E00                799  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
000017D4  363C 0009                800                      MOVE.W    #9,D3                 ; stores the shift amount to D3
000017D8  6000 000A                801                      BRA       FINDTYPEXN            ; finds the type of Xn
000017DC                           802  
000017DC  343C 0007                803  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
000017E0  363C 0000                804                      MOVE.W    #0,D3                 ; stores the shift amount to D3
000017E4                           805                      
000017E4  3200                     806  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
000017E6  C242                     807                      AND.W     D2,D1                 ; applies bitmask to D1
000017E8  E669                     808                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000017EA  4CDF 000C                809                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000017EE  4E75                     810                      RTS                             ; returns from subroutine 
000017F0                           811                      
000017F0                           812  * Checks and gets the EA and Xn
000017F0                           813  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
000017F0                           814  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
000017F0  3207                     815  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
000017F2  4EB8 179C                816                  JSR     GET_EA                  ; Gets EA
000017F6  3401                     817                  MOVE.W  D1,D2                   ; Stores EA in D2
000017F8  3207                     818                  MOVE.W  D7,D1                   ; loads value representing position of EA   
000017FA  4EB8 17C6                819                  JSR     GET_XN                  ; Gets Xn
000017FE  3601                     820                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001800  3202                     821                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001802                           822                  
00001802  4EB9 00001888            823                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001808  B27C 0002                824                  CMP.W   #2,D1                   ; checks if it is Xn
0000180C  6700 0012                825                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001810  B27C 0001                826                  CMP.W   #1,D1                   ; Checks if it is invalid
00001814  6700 001C                827                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001818                           828                  
00001818                           829                  
00001818  323C 0000                830  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
0000181C  6000 0018                831                  BRA     END_CHECKGET
00001820                           832        
00001820                           833  ; need XN
00001820  2A4E                     834  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001822  3203                     835                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001824  4EB9 00001888            836                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
0000182A  4A41                     837                  TST.W   D1                      ; checks if it is valid
0000182C  67EA                     838                  BEQ     EAXN_VALID              ; go to EA_VALID to print
0000182E  6000 0002                839                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001832                           840   
00001832  323C 0001                841  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001836                           842  
00001836  4E75                     843  END_CHECKGET    RTS          
00001838                           844                                            
00001838                           845                                            
00001838                           846  * Gets the displacement and pritns it 
00001838                           847  * Inputs: D2 = instruction word, A2 = address of next word
00001838                           848  * Outputs: prints out displacement
00001838  48E7 4004                849  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
0000183C  3A4A                     850                      MOVE.W    A2,A5                 ; copies A2 to A5
0000183E  C47C 00FF                851                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001842  6600 0004                852                      BNE       PRINTADDRESS          ; prints address if not 0
00001846  341A                     853                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001848                           854                      
00001848  D44D                     855  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
0000184A  3202                     856                      MOVE.W    D2,D1                 ; moves address to D1 for printing
0000184C  183C 0000                857                      MOVE.B    #0,D4                 ; marks address as word  length
00001850  4BF9 00001E82            858                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001856  4EB9 00001B82            859                      JSR       PRINTNULL             ; prints null
0000185C  4EB9 00001A5C            860                      JSR       PRINTSHORTLONGNUM     ; prints address
00001862                           861                      
00001862  4CDF 2002                862                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001866                           863                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001866                           864  
00001866                           865  * Gets the rotation value for ASd and LSd
00001866                           866  * Input: D2 = instruction word copy (of D0)                                    
00001866                           867  * Output: rotation  value in D2             
00001866  C47C 0E00                868  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
0000186A  E04A                     869                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
0000186C  E24A                     870                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
0000186E  4E75                     871                      RTS                             ; return from subroutine
00001870                           872  
00001870                           873  * Gets the direction value for ASd and LSd
00001870                           874  * Input: D2 = instruction word copy (of D0)                                    
00001870                           875  * Output: direction value in D2             
00001870  C47C 0100                876  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001874  E04A                     877                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001876  4E75                     878                      RTS                             ; return from subroutine
00001878                           879  
00001878                           880  * Gets the rotation size value for ASd and LSd
00001878                           881  * Input: D2 = instruction word copy (of D0)                                    
00001878                           882  * Output: rotation size value in D2             
00001878  C47C 00C0                883  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
0000187C  EC4A                     884                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
0000187E  4E75                     885                      RTS                             ; return from subroutine
00001880                           886  
00001880                           887  * Gets the rotation location  value for ASd and LSd
00001880                           888  * Input: D2 = instruction word copy (of D0)                                    
00001880                           889  * Output: rotation location value in D2             
00001880  C47C 0020                890  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001884  EA4A                     891                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001886  4E75                     892                      RTS                             ; return from subroutine
00001888                           893  
00001888                           894                          
00001888                           895  * Checks if EA or Xn is valid
00001888                           896  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001888                           897  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001888  2F02                     898  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
0000188A                           899  
0000188A  141D                     900  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
0000188C  B43C 00FF                901                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001890  6700 000A                902                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001894  B202                     903                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001896  6700 000C                904                     BEQ        VALIDEA               ; branches to valid EA
0000189A  60EE                     905                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
0000189C                           906                     
0000189C  323C 0001                907  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
000018A0  6000 0016                908                     BRA        CHECKEAEXIT           ; exists the subroutine        
000018A4                           909                    
000018A4  B43C 0007                910  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
000018A8  6700 000A                911                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
000018AC  323C 0000                912                     MOVE.W     #$0,D1                ; marks that it is valid
000018B0  6000 0006                913                     BRA        CHECKEAEXIT           ; exits the subroutine
000018B4                           914  
000018B4  323C 0002                915  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
000018B8                           916  
000018B8  241F                     917  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
000018BA  4E75                     918                     RTS                              ; returns from subroutine
000018BC                           919  
000018BC                           920  * Converts EA and Xn into a string                                
000018BC                           921  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
000018BC                           922  * Outputs: Prints out EA and Xn into a string
000018BC  48E7 C004                923  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
000018C0  B47C 0001                924                     CMP.W    #An,D2                  ; checks if it is An
000018C4  6700 003A                925                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
000018C8                           926                     
000018C8  B47C 0002                927                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
000018CC  6700 004A                928                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
000018D0                           929                     
000018D0  B47C 0003                930                     CMP.W    #AnPost,D2              ; checks if it is (An)+
000018D4  6700 0072                931                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
000018D8                           932                     
000018D8  B47C 0004                933                     CMP.W    #AnPre,D2               ; checks if it is -(An)
000018DC  6700 00A6                934                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
000018E0                           935                     
000018E0  B47C 0007                936                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
000018E4  6700 00DA                937                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
000018E8                           938                     ; otherwise assumes D2 = #Dn which means its a data register                   
000018E8                           939  
000018E8                           940  * data register, Dn
000018E8  4BF9 00001E74            941  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
000018EE  4EB9 00001B82            942                     JSR      PRINTNULL               ; Prints D
000018F4  3203                     943                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000018F6  4EB9 00001A38            944                     JSR      PRINTNUM                ; Prints the Xn
000018FC  6000 0134                945                     BRA      EA_TO_STRING_EXIT       ; exits           
00001900                           946  
00001900                           947  
00001900                           948  * address register
00001900  4BF9 00001E76            949  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001906  4EB9 00001B82            950                     JSR      PRINTNULL               ; Prints A
0000190C  3203                     951                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000190E  4EB9 00001A38            952                     JSR      PRINTNUM                ; Prints the Xn
00001914  6000 011C                953                     BRA      EA_TO_STRING_EXIT       ; exits
00001918                           954  
00001918                           955  * address register indirect
00001918  4BF9 00001E78            956  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
0000191E  4EB9 00001B82            957                     JSR      PRINTNULL               ; Prints (
00001924  4BF9 00001E76            958                     LEA      MSG_AR,A5               ; Loads A into A5
0000192A  4EB9 00001B82            959                     JSR      PRINTNULL               ; Prints A
00001930  3203                     960                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001932  4EB9 00001A38            961                     JSR      PRINTNUM                ; Prints the Xn
00001938  4BF9 00001E7A            962                     LEA      MSG_RB,A5               ; Loads ) into A5
0000193E  4EB9 00001B82            963                     JSR      PRINTNULL               ; Prints )
00001944  6000 00EC                964                     BRA      EA_TO_STRING_EXIT       ; exits
00001948                           965  
00001948                           966  * address register indirect post increment
00001948  4BF9 00001E78            967  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
0000194E  4EB9 00001B82            968                     JSR      PRINTNULL               ; Prints (
00001954  4BF9 00001E76            969                     LEA      MSG_AR,A5               ; Loads A into A5
0000195A  4EB9 00001B82            970                     JSR      PRINTNULL               ; Prints A
00001960  3203                     971                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001962  4EB9 00001A38            972                     JSR      PRINTNUM                ; Prints the Xn
00001968  4BF9 00001E7A            973                     LEA      MSG_RB,A5               ; Loads ) into A5
0000196E  4EB9 00001B82            974                     JSR      PRINTNULL               ; Prints )
00001974  4BF9 00001E7C            975                     LEA      MSG_PLUS,A5             ; Loads + into A5
0000197A  4EB9 00001B82            976                     JSR      PRINTNULL               ; Prints +
00001980  6000 00B0                977                     BRA      EA_TO_STRING_EXIT       ; exits
00001984                           978  
00001984                           979  
00001984                           980  * address register indirect pre increment
00001984  4BF9 00001E7E            981  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
0000198A  4EB9 00001B82            982                     JSR      PRINTNULL               ; Prints -
00001990  4BF9 00001E78            983                     LEA      MSG_LB,A5               ; Loads ( into A5
00001996  4EB9 00001B82            984                     JSR      PRINTNULL               ; Prints (
0000199C  4BF9 00001E76            985                     LEA      MSG_AR,A5               ; Loads A into A5
000019A2  4EB9 00001B82            986                     JSR      PRINTNULL               ; Prints A
000019A8  3203                     987                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000019AA  4EB9 00001A38            988                     JSR      PRINTNUM                ; Prints the Xn
000019B0  4BF9 00001E7A            989                     LEA      MSG_RB,A5               ; Loads ) into A5
000019B6  4EB9 00001B82            990                     JSR      PRINTNULL               ; Prints )
000019BC  6000 0074                991                     BRA      EA_TO_STRING_EXIT       ; exits
000019C0                           992  
000019C0                           993  * other (long, short, immediate) with Xn yes
000019C0  301A                     994  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000019C2  B67C 0000                995                     CMP.W    #ABSShort,D3            ; checks if it is a word
000019C6  6700 002E                996                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000019CA                           997                     
000019CA  B67C 0001                998                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000019CE  6700 0042                999                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000019D2                          1000  
000019D2                          1001  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
000019D2                          1002  * immediate
000019D2  4BF9 00001E80           1003  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000019D8  4EB9 00001B82           1004                     JSR      PRINTNULL               ; Prints #  
000019DE  4BF9 00001E82           1005                     LEA      MSG_HEX,A5              ; Loads $ into A5
000019E4  4EB9 00001B82           1006                     JSR      PRINTNULL               ; Prints $
000019EA  3200                    1007                     MOVE.W   D0, D1                  ; moves instruction word into d1
000019EC  4EB9 00001A48           1008                     JSR      PRINTHEXNUM 
000019F2  6000 003E               1009                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
000019F6                          1010                     
000019F6                          1011  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
000019F6                          1012  
000019F6                          1013  * word address
000019F6                          1014  CASE_WORD          
000019F6  4BF9 00001E82           1015                     LEA      MSG_HEX,A5              ; Loads $ into A5
000019FC  4EB9 00001B82           1016                     JSR      PRINTNULL               ; Prints $
00001A02  3200                    1017                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001A04  383C 0000               1018                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001A08  4EB9 00001A5C           1019                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001A0E  6000 0022               1020                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001A12                          1021  
00001A12                          1022  * long address 
00001A12                          1023  CASE_LONG          
00001A12  4BF9 00001E82           1024                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001A18  4EB9 00001B82           1025                     JSR      PRINTNULL               ; Prints $
00001A1E  3200                    1026                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001A20  383C 0001               1027                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001A24  4EB9 00001A5C           1028                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001A2A  321A                    1029                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001A2C  4EB9 00001A38           1030                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001A32                          1031  
00001A32                          1032  
00001A32                          1033  * exits subroutine
00001A32  4CDF 2003               1034  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001A36  4E75                    1035                      RTS                              ; returns from subroutine
00001A38                          1036  
00001A38                          1037  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001A38                          1038  
00001A38                          1039  * Prints out the content of D1 as a decimal number
00001A38                          1040  * Input: number in D1 to be printed
00001A38                          1041  * Output: contents of D1 printed
00001A38  48E7 C000               1042  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001A3C  103C 0003               1043                   MOVE.B      #3,D0               ; prints D1
00001A40  4E4F                    1044                   TRAP        #15                 ; is trap task 3
00001A42                          1045              
00001A42  4CDF 0003               1046                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001A46  4E75                    1047                   RTS                             ; returns from subroutine
00001A48                          1048                   
00001A48                          1049  * Prints out the content of D1 as a hex number
00001A48                          1050  * Input: number in D1 to be printed
00001A48                          1051  * Output: contents of D1 printed
00001A48  48E7 C000               1052  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001A4C  143C 0010               1053                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001A50  103C 000F               1054                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001A54  4E4F                    1055                   TRAP        #15                 ; is trap task 15
00001A56  4CDF 0003               1056                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001A5A  4E75                    1057                   RTS                             ; returns from subroutine
00001A5C                          1058                   
00001A5C                          1059  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001A5C                          1060  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001A5C                          1061  * Output: contents of D1 printed
00001A5C  48E7 E000               1062  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001A60  B83C 0001               1063                            CMP.B       #1,D4               ; checks size of number
00001A64  6700 0042               1064                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001A68                          1065  
00001A68  3401                    1066  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001A6A  C47C F000               1067                            AND.W       #$F000,D2           ; gets the first digit
00001A6E  B47C 0000               1068                            CMP.W       #0, D2              ; checks if it is 0
00001A72  6600 00DC               1069                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A76  4EB9 00001B60           1070                            JSR         PRINTZERO           ; prints a zero
00001A7C                          1071                            
00001A7C  3401                    1072                            MOVE.W      D1,D2               ; copies number to D2
00001A7E  C47C 0F00               1073                            AND.W       #$0F00,D2           ; gets the second digit
00001A82  B47C 0000               1074                            CMP.W       #0, D2              ; checks if it is 0
00001A86  6600 00C8               1075                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A8A  4EB9 00001B60           1076                            JSR         PRINTZERO           ; prints a zero
00001A90                          1077                            
00001A90  3401                    1078                            MOVE.W      D1,D2               ; copies number to D2
00001A92  C47C 00F0               1079                            AND.W       #$00F0,D2           ; gets the third digit
00001A96  B47C 0000               1080                            CMP.W       #0, D2              ; checks if it is 0
00001A9A  6600 00B4               1081                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A9E  4EB9 00001B60           1082                            JSR         PRINTZERO           ; prints a zero
00001AA4  6000 00AA               1083                            BRA         PRINTASHEX          ; prints last digit
00001AA8                          1084                            
00001AA8  2401                    1085  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001AAA  C4BC F0000000           1086                            AND.L       #$F0000000,D2       ; gets the first digit
00001AB0  B4BC 00000000           1087                            CMP.L       #0, D2              ; checks if it is 0
00001AB6  6600 0098               1088                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001ABA  4EB9 00001B60           1089                            JSR         PRINTZERO           ; prints a zero
00001AC0                          1090                            
00001AC0  2401                    1091                            MOVE.L      D1,D2               ; copies number to D2
00001AC2  C4BC 0F000000           1092                            AND.L       #$0F000000,D2       ; gets the second digit
00001AC8  B4BC 00000000           1093                            CMP.L       #0, D2              ; checks if it is 0
00001ACE  6600 0080               1094                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001AD2  4EB9 00001B60           1095                            JSR         PRINTZERO           ; prints a zero
00001AD8                          1096                            
00001AD8  2401                    1097                            MOVE.L      D1,D2               ; copies number to D2
00001ADA  C4BC 00F00000           1098                            AND.L       #$00F00000,D2       ; gets the third digit
00001AE0  B4BC 00000000           1099                            CMP.L       #0, D2              ; checks if it is 0
00001AE6  6600 0068               1100                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001AEA  4EB9 00001B60           1101                            JSR         PRINTZERO           ; prints a zero
00001AF0                          1102                            
00001AF0  2401                    1103                            MOVE.L      D1,D2               ; copies number to D2
00001AF2  C4BC 000F0000           1104                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001AF8  B4BC 00000000           1105                            CMP.L       #0, D2              ; checks if it is 0
00001AFE  6600 0050               1106                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B02  4EB9 00001B60           1107                            JSR         PRINTZERO           ; prints a zero
00001B08                          1108                            
00001B08  2401                    1109                            MOVE.L      D1,D2               ; copies number to D2
00001B0A  C4BC 0000F000           1110                            AND.L       #$0000F000,D2       ; gets the fith digit
00001B10  B4BC 00000000           1111                            CMP.L       #0, D2              ; checks if it is 0
00001B16  6600 0038               1112                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B1A  4EB9 00001B60           1113                            JSR         PRINTZERO           ; prints a zero
00001B20                          1114                            
00001B20  2401                    1115                            MOVE.L      D1,D2               ; copies number to D2
00001B22  C4BC 00000F00           1116                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001B28  B4BC 00000000           1117                            CMP.L       #0, D2              ; checks if it is 0
00001B2E  6600 0020               1118                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B32  4EB9 00001B60           1119                            JSR         PRINTZERO           ; prints a zero
00001B38                          1120                            
00001B38  2401                    1121                            MOVE.L      D1,D2               ; copies number to D2
00001B3A  C4BC 000000F0           1122                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001B40  B4BC 00000000           1123                            CMP.L       #0, D2              ; checks if it is 0
00001B46  6600 0008               1124                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001B4A  4EB9 00001B60           1125                            JSR         PRINTZERO           ; prints a zero
00001B50                          1126  
00001B50  143C 0010               1127  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001B54  103C 000F               1128                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001B58  4E4F                    1129                            TRAP        #15                 ; is trap task 15
00001B5A  4CDF 0007               1130                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001B5E  4E75                    1131                            RTS                             ; returns from subroutine    
00001B60                          1132  * Prints a zero
00001B60                          1133  * Input: nothing
00001B60                          1134  * Output: 0 printed out to the console
00001B60  2F01                    1135  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001B62  7200                    1136                            MOVE.L      #0,D1               ; moves 0 to D1
00001B64  4EB8 1A38               1137                            JSR         PRINTNUM            ; prints the number
00001B68  221F                    1138                            MOVE.L      (SP)+,D1            ; restores D1
00001B6A  4E75                    1139                            RTS                             ; returns from subroutine
00001B6C                          1140              
00001B6C                          1141  * Prints contents of things between a range
00001B6C                          1142  * input: A5, A6 (the range)
00001B6C                          1143  * output: prints memory contents from A5 to A6 as strings   
00001B6C  48E7 C040               1144  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001B70  224D                    1145                  MOVEA.L     A5, A1           ; loads A5 into A1
00001B72  9DCD                    1146                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001B74  320E                    1147                  MOVE.W      A6, D1           ; move n into D1
00001B76  103C 0001               1148                  MOVE.B      #1, D0           ; display n characters of string at A1
00001B7A  4E4F                    1149                  TRAP        #15              ; is trap task 1
00001B7C  4CDF 0203               1150                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001B80  4E75                    1151                  RTS                          ; returns
00001B82                          1152      
00001B82                          1153  * Prints null terminated string
00001B82                          1154  * input: string pointed to by A5
00001B82                          1155  * output: prints out the null terminated string
00001B82  48E7 8040               1156  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001B86  224D                    1157                  MOVE.L      A5,A1           ; loads A5 into A1
00001B88  103C 000E               1158                  MOVE.B      #14,D0          ; prints null terminated string
00001B8C  4E4F                    1159                  TRAP        #15             ; is trap task 10
00001B8E  4CDF 0201               1160                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001B92  4E75                    1161                  RTS                         ; returns from subroutine
00001B94                          1162                  
00001B94  2F0D                    1163  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001B96  4BF9 00001D80           1164                  LEA         NEW_LINE,A5     ; Prints null
00001B9C  4EB8 1B82               1165                  JSR         PRINTNULL       ; prints the new line
00001BA0  2A5F                    1166                  MOVE.L      (SP)+,A5        ; returns A5
00001BA2  4E75                    1167                  RTS
00001BA4                          1168  
00001BA4                          1169  * Prints the size of the MOVE or MOVEA operation  
00001BA4                          1170  * input: D0
00001BA4                          1171  * output: prints out the size of a MOVE or MOVEA operation        
00001BA4  48E7 8004               1172  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001BA8  3200                    1173                  MOVE.W  D0,D1               ; stores d0 in d1
00001BAA  C07C 3000               1174                  AND.W   #$3000,D0           ; gets the size
00001BAE  B07C 2000               1175                  CMP.W   #$2000,D0           ; checks if is long
00001BB2  6700 001E               1176                  BEQ     MOVE_LONG
00001BB6  B07C 3000               1177                  CMP.W   #$3000,D0           ; checks if is word
00001BBA  6700 000C               1178                  BEQ     MOVE_WORD      
00001BBE                          1179                  
00001BBE  4BF9 00001E8B           1180  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001BC4  6000 0012               1181                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001BC8                          1182  
00001BC8  4BF9 00001E91           1183  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001BCE  6000 0008               1184                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001BD2                          1185  
00001BD2  4BF9 00001E97           1186  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001BD8                          1187                  
00001BD8  4EB8 1B82               1188  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001BDC  4CDF 2001               1189                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001BE0  4E75                    1190                  RTS
00001BE2                          1191  
00001BE2  43F9 00001D64           1192  ERROR           LEA     ERROR_MSG,A1
00001BE8  103C 000E               1193                  MOVE.B  #14,D0
00001BEC  4E4F                    1194                  TRAP    #15 
00001BEE                          1195         
00001BEE                          1196  * DELETE THIS: Test                
00001BEE  2661                    1197  DELETEME        MOVEA.L  -(A1),A3
00001BF0  6700 002C               1198                  BEQ      DELETEMEAGAIN  
00001BF4  6F00 0028               1199                  BLE      DELETEMEAGAIN
00001BF8  6E00 0024               1200                  BGT      DELETEMEAGAIN
00001BFC                          1201  
00001BFC  E40A                    1202                  LSR.B      #2,D2
00001BFE  E2E2                    1203                  LSR.W      -(A2)
00001C00  E2DA                    1204                  LSR.W      (A2)+
00001C02  E4AA                    1205                  LSR.L      D2,D2 
00001C04  E50A                    1206                  LSL.B      #2,D2
00001C06  E3E2                    1207                  LSL.W      -(A2)
00001C08  E3DA                    1208                  LSL.W      (A2)+
00001C0A  E5AA                    1209                  LSL.L      D2,D2
00001C0C  E51A                    1210                  ROL.B      #2,D2
00001C0E  E7E2                    1211                  ROL.W      -(A2)
00001C10  E7DA                    1212                  ROL.W      (A2)+
00001C12  E5BA                    1213                  ROL.L      D2,D2
00001C14  E41A                    1214                  ROR.B      #2,D2
00001C16  E6E2                    1215                  ROR.W      -(A2)
00001C18  E6DA                    1216                  ROR.W      (A2)+
00001C1A  E4BA                    1217                  ROR.L      D2,D2
00001C1C                          1218                  
00001C1C  DAC5                    1219                  ADDA.W      D5,A5
00001C1E                          1220                         
00001C1E                          1221                  
00001C1E                          1222  DELETEMEAGAIN                 
00001C1E                          1223            
00001C1E  FFFF FFFF               1224      SIMHALT             ; halt simulator
00001C22                          1225  
00001C22                          1226  * Put variables and constants here
00001C22                          1227  
00001C22  =0000000D               1228  CR                              EQU     $0D
00001C22  =0000000A               1229  LF                              EQU     $0A 
00001C22  =00000009               1230  TAB                             EQU     $09  
00001C22                          1231  
00001C22                          1232  * Addressing Modes
00001C22  =00000000               1233  Dn                              EQU     0
00001C22  =00000001               1234  An                              EQU     1
00001C22  =00000002               1235  AnIndirect                      EQU     2
00001C22  =00000003               1236  AnPost                          EQU     3
00001C22  =00000004               1237  AnPre                           EQU     4
00001C22  =00000007               1238  Other                           EQU     7           ; short, long, immediate
00001C22                          1239  
00001C22                          1240  * Xn
00001C22  =00000000               1241  ABSShort                        EQU     0
00001C22  =00000001               1242  ABSLong                         EQU     1
00001C22  =00000004               1243  XnImmediate                     EQU     4
00001C22                          1244  
00001C22                          1245  * Valid Addressing Modes
00001C22= 00 01 02 03 04 07 FF    1246  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001C29                          1247  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001C29= 00 02 03 04 07 FF       1248  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001C2F= 02 04 07 FF             1249  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001C33= 02 03 07 FF             1250  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001C37= 02 03 04 07 FF          1251  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001C3C= 00 02 03 04 07 FF       1252  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001C42= 01 07 FF                1253  VALIDEA_LEA                     DC.B    An,Other,-1
00001C45= 00 02 03 04 07 FF       1254  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001C4B= 02 03 04 07 FF          1255  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001C50= 02 03 04 07 FF          1256  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001C55= 02 07 FF                1257  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001C58                          1258  
00001C58                          1259  * Valid Xn
00001C58= 00 01 04 FF             1260  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001C5C                          1261  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001C5C= 00 01 FF                1262  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001C5F                          1263  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001C5F                          1264  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001C5F                          1265  
00001C5F                          1266  * posible memory ASd/LSd rotation values
00001C5F  =00000000               1267  ASd_MEM                         EQU     0   
00001C5F  =00000001               1268  LSd_MEM                         EQU     1 
00001C5F  =00000003               1269  ROd_MEM                         EQU     3
00001C5F                          1270   
00001C5F  =00000000               1271  ASd_REG                         EQU     0   
00001C5F  =00000001               1272  LSd_REG                         EQU     1 
00001C5F  =00000003               1273  ROd_REG                         EQU     3
00001C5F                          1274  
00001C5F                          1275  * Starting messages
00001C5F= 57 65 6C 63 6F 6D ...   1276  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001C86= 46 6F 72 6D 61 74 ...   1277                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001CD5= 50 6C 65 61 73 65 ...   1278  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001D0C= 50 6C 65 61 73 65 ...   1279  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001D42= 49 6E 76 61 6C 69 ...   1280  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001D64= 45 72 72 6F 72 20 ...   1281  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001D80= 0D 0A 00                1282  NEW_LINE                        DC.B    CR,LF,0
00001D83= 09 09 09 00             1283  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001D87                          1284  
00001D87                          1285  * Opcode Messages
00001D87= 09 4E 4F 50 00          1286  MSG_NOP                         DC.B    TAB,'NOP',0
00001D8C= 09 4D 4F 56 45 00       1287  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001D92= 09 4D 4F 56 45 41 00    1288  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001D99= 09 4D 4F 56 45 51 00    1289  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001DA0= 09 4D 4F 56 45 4D 00    1290  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001DA7= 09 41 44 44 00          1291  MSG_ADD                         DC.B    TAB,'ADD',0
00001DAC= 09 41 44 44 41 00       1292  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001DB2= 09 41 44 44 51 00       1293  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001DB8= 09 53 55 42 00          1294  MSG_SUB                         DC.B    TAB,'SUB',0
00001DBD= 09 4D 55 4C 53 00       1295  MSG_MULS                        DC.B    TAB,'MULS',0
00001DC3= 09 44 49 56 55 00       1296  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001DC9= 09 4C 45 41 09 09 ...   1297  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001DD1= 09 41 4E 44 00          1298  MSG_AND                         DC.B    TAB,'AND',0
00001DD6= 09 4F 52 00             1299  MSG_OR                          DC.B    TAB,'OR',0
00001DDA= 09 4E 4F 54 00          1300  MSG_NOT                         DC.B    TAB,'NOT',0
00001DDF= 09 4C 53 00             1301  MSG_LSd                         DC.B    TAB,'LS',0
00001DE3= 09 41 53 00             1302  MSG_ASd                         DC.B    TAB,'AS',0
00001DE7= 09 52 4F 00             1303  MSG_ROd                         DC.B    TAB,'RO',0
00001DEB= 09 42 43 43 09 09 ...   1304  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001DF3= 09 42 43 53 09 09 ...   1305  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001DFB= 09 42 45 51 09 09 ...   1306  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001E03= 09 42 4E 45 09 09 ...   1307  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001E0B= 09 42 47 45 09 09 ...   1308  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001E13= 09 42 47 54 09 09 ...   1309  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001E1B= 09 42 48 49 09 09 ...   1310  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001E23= 09 42 4C 45 09 09 ...   1311  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001E2B= 09 42 4C 53 09 09 ...   1312  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001E33= 09 42 4C 54 09 09 ...   1313  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001E3B= 09 42 4D 49 09 09 ...   1314  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001E43= 09 42 50 4C 09 09 ...   1315  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001E4B= 09 42 56 43 09 09 ...   1316  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001E53= 09 42 56 53 09 09 ...   1317  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001E5B= 09 4A 53 52 09 09 ...   1318  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001E63= 09 52 54 53 00          1319  MSG_RTS                         DC.B    TAB,'RTS',0
00001E68= 09 42 52 41 09 09 ...   1320  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001E70                          1321  
00001E70                          1322  * Direction for LSd and ASd
00001E70= 52 00                   1323  MSG_RIGHT                       DC.B    'R',0
00001E72= 4C 00                   1324  MSG_LEFT                        DC.B    'L',0
00001E74                          1325  
00001E74                          1326  * Effective Addresses Messages
00001E74= 44 00                   1327  MSG_DR                          DC.B    'D',0
00001E76= 41 00                   1328  MSG_AR                          DC.B    'A',0
00001E78= 28 00                   1329  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001E7A= 29 00                   1330  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001E7C= 2B 00                   1331  MSG_PLUS                        DC.B    '+',0
00001E7E= 2D 00                   1332  MSG_MINUS                       DC.B    '-',0
00001E80= 23 00                   1333  MSG_POUND                       DC.B    '#',0 
00001E82= 24 00                   1334  MSG_HEX                         DC.B    '$',0 
00001E84= 2C 20 00                1335  MSG_COMMA                       DC.B    ', ',0 
00001E87= 20 00                   1336  MSG_SPACE                       DC.B    ' ',0
00001E89= 09 00                   1337  MSG_TAB                         DC.B    TAB,0
00001E8B                          1338  
00001E8B                          1339  * Size Messages
00001E8B= 2E 42 09 09 09 00       1340  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001E91= 2E 57 09 09 09 00       1341  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001E97= 2E 4C 09 09 09 00       1342  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001E9D                          1343  
00001E9D                          1344  * Variables
00001E9D  =00000100               1345  STARTING_ADDRESS                EQU     $100
00001E9D  =00000150               1346  ENDING_ADDRESS                  EQU     $150
00001E9D  =00000200               1347  CURRENT_INSTR                   EQU     $200
00001E9D  =00000250               1348  REG_VAR                         EQU     $250 * Hold bits 11-9
00001E9D  =00000300               1349  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001E9D  =00000350               1350  EA_MODE                         EQU     $350 * Hold bits 5-3
00001E9D  =00000400               1351  EA_REG                          EQU     $400 * Hold bits 2-0
00001E9D                          1352  
00001E9D                          1353              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1414
ADD_BYTE            1352
ADD_LONG            1372
ADD_WORD            1362
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1D42
CASE_ADD            12DE
CASE_ADDA           13E8
CASE_ADDQ           1450
CASE_AND            14E2
CASE_AR             1900
CASE_ARI            1918
CASE_ARIPOST        1948
CASE_ARIPRE         1984
CASE_ASDMEM         1522
CASE_ASDREG         15EA
CASE_BCC            1722
CASE_BEQ            1754
CASE_BGT            1768
CASE_BLE            175E
CASE_BRA            16FE
CASE_DATA           1798
CASE_DR             18E8
CASE_EPICFAIL       179A
CASE_IMMEDIATE      19D2
CASE_JSR            1782
CASE_LEA            1450
CASE_LEFTMEM        1548
CASE_LEFTREG        1610
CASE_LONG           1A12
CASE_LSDASD         14E2
CASE_LSDMEM         1518
CASE_LSDREG         15E0
CASE_MOVE           1182
CASE_MOVEM          1224
CASE_MOVEQ          128A
CASE_NOP            116C
CASE_NOT            14E2
CASE_OR             14E2
CASE_OTHER          19C0
CASE_RIGHTMEM       1552
CASE_RIGHTREG       161A
CASE_RODMEM         152C
CASE_RODREG         15F4
CASE_RTS            1782
CASE_SHIFTMEM       1500
CASE_SHIFTREG       15C6
CASE_SUB            1450
CASE_WORD           19F6
CHECKEAEXIT         18B8
CHECKEAMLOOP        188A
CHECKEAXN_IFVALID   1888
CHECKGET_EAXN       17F0
CHECKMEMSOURE       1586
CHECKSHIFT_XN       15B0
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            1820
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1BEE
DELETEMEAGAIN       1C1E
DESTEA              17A6
DESTXN              17D0
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          13BC
EASHIFT_VALID       15A4
EAXN_INVALID        1832
EAXN_VALID          1818
EA_MODE             350
EA_REG              400
EA_TO_STRING        18BC
EA_TO_STRING_EXIT   1A32
ENDING              1D0C
ENDING_ADDRESS      150
END_CHECKGET        1836
ERROR               1BE2
ERROR_MSG           1D64
FINDTYPEEA          17BA
FINDTYPEXN          17E4
FINISHMOVE          1BD8
FINISH_ADD          1382
FINISH_ADDA         1424
GETDIRECTION        1870
GETDISPLACEMENT     1838
GETMEMSOURCE        156E
GETROTATION         1866
GETROTATIONLOCATION  1880
GETROTATIONSIZE     1878
GET_EA              179C
GET_XN              17C6
INPUT1              100C
INPUT2              1052
INSERTA             11F0
INVALID             112C
INVALIDEA           189C
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128A
MOVEM_REG2MEM       125A
MOVE_BYTE           1BBE
MOVE_LONG           1BD2
MOVE_WORD           1BC8
MSG_ADD             1DA7
MSG_ADDA            1DAC
MSG_ADDQ            1DB2
MSG_AND             1DD1
MSG_AR              1E76
MSG_ASD             1DE3
MSG_B               1E8B
MSG_BCC             1DEB
MSG_BCS             1DF3
MSG_BEQ             1DFB
MSG_BGE             1E0B
MSG_BGT             1E13
MSG_BHI             1E1B
MSG_BLE             1E23
MSG_BLS             1E2B
MSG_BLT             1E33
MSG_BMI             1E3B
MSG_BNE             1E03
MSG_BPL             1E43
MSG_BRA             1E68
MSG_BVC             1E4B
MSG_BVS             1E53
MSG_COMMA           1E84
MSG_DIVU            1DC3
MSG_DR              1E74
MSG_HEX             1E82
MSG_JSR             1E5B
MSG_L               1E97
MSG_LB              1E78
MSG_LEA             1DC9
MSG_LEFT            1E72
MSG_LSD             1DDF
MSG_MINUS           1E7E
MSG_MOVE            1D8C
MSG_MOVEA           1D92
MSG_MOVEM           1DA0
MSG_MOVEQ           1D99
MSG_MULS            1DBD
MSG_NOP             1D87
MSG_NOT             1DDA
MSG_OR              1DD6
MSG_PLUS            1E7C
MSG_POUND           1E80
MSG_RB              1E7A
MSG_RIGHT           1E70
MSG_ROD             1DE7
MSG_RTS             1E63
MSG_SPACE           1E87
MSG_SUB             1DB8
MSG_TAB             1E89
MSG_W               1E91
NEW_LINE            1D80
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OTHER               7
OTHEREA             18B4
PRINTADD            1334
PRINTADDRESS        1848
PRINTASHEX          1B50
PRINTBCC            1772
PRINTENTER          1B94
PRINTHEXNUM         1A48
PRINTLONGZERO       1AA8
PRINTMOVE           11F6
PRINTMOVESIZE       1BA4
PRINTNULL           1B82
PRINTNUM            1A38
PRINTRANGE          1B6C
PRINTREGEA          165C
PRINTREGSIZE        162A
PRINTSHIFTMEM       1532
PRINTSHIFTREG       15FA
PRINTSHORTLONGNUM   1A5C
PRINTSHORTZERO      1A68
PRINTZERO           1B60
PRINT_MEMDIR        1558
PRINT_MOVEQ         12AC
PRINT_REGDIR        1624
REG2MEMXNCHECK      1274
REG_BYTE            1642
REG_IMMEDIATE       1672
REG_LONG            1656
REG_REGISTER        16B8
REG_VAR             250
REG_WORD            164C
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            17B2
SOURCEXN            17DC
START               1000
STARTING            1CD5
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           1D83
VALIDEA             18A4
VALIDEA_ADDSUB_DESTOPERAND  1C37
VALIDEA_ALL         1C22
VALIDEA_ANDORNOT    1C45
VALIDEA_ANDOR_DESTOPERAND  1C4B
VALIDEA_JSR         1C55
VALIDEA_LEA         1C42
VALIDEA_MOVEM_MEMTOREG  1C33
VALIDEA_MOVEM_REGTOMEM  1C2F
VALIDEA_MOVEQ       1C29
VALIDEA_MULSDIVU    1C3C
VALIDEA_SHIFT       1C50
VALIDXN_ALL         1C58
VALIDXN_SHORTLONG   1C5C
WELCOME             1C5F
XNIMMEDIATE         4
