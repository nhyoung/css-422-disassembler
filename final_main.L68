00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 2:21:49 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00002301             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 00002329             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 00002374             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 00002394             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011CE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011E0             36                  JSR     CONVERT
00001052  4EB9 0000124C             37                  JSR     TEST_RANGE
00001058  4EB9 00001264             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 000023CB             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011CE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011E0             55                  JSR     CONVERT
0000109A  4EB9 0000124C             56                  JSR     TEST_RANGE
000010A0  4EB9 00001264             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0110                 64                  BLT     RESET_INPUT
000010B8  4BF9 000024B4             65                  LEA     NEW_LINE,A5
000010BE  4EB9 00002244             66                  JSR     PRINTNULL
000010C4                            67                                 
000010C4                            68  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010C4                            69                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010C4                            70                  ; JSR     PRINTSHORTLONGNUM   ; prints out address
000010C4                            71                  
000010C4  1439 000025B5             72                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010CC  13C2 000025B5             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010D2                            75                  
000010D2  4EB9 00001278             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010D8                            77                  
000010D8  4EB9 00001176             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010DE                            79                  
000010DE  4EB9 00002256             80                  JSR     PRINTENTER          ; prints a new line
000010E4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010E6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010E8                            83                  
000010E8                            84  
000010E8  4BF9 00002445             85  FINISHED        LEA     DONE,A5
000010EE  4EB9 00002244             86                  JSR     PRINTNULL
000010F4  103C 0005                 87                  MOVE.B  #5,D0
000010F8  4E4F                      88                  TRAP    #15
000010FA                            89                  
000010FA  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
000010FE  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001102                            92                  
00001102  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001106  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000110A                            95  
0000110A  103C 0009                 96                  MOVE.B  #9,D0
0000110E  4E4F                      97                  TRAP    #15
00001110                            98                  
00001110  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001114  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001118  4E4F                     101                  TRAP    #15                 Call Trap
0000111A                           102                  
0000111A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000111E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001122  4E4F                     105                  TRAP    #15
00001124                           106                  
00001124  1439 000025B5            107                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
0000112A  143C 0000                108                  MOVE.B  #0,D2               ; set variable to 0
0000112E  13C2 000025B5            109                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
00001134                           110   
00001134  207C 00000000            111                  MOVE.L  #$0000000, A0       ; Reset A1
0000113A  227C 00000000            112                  MOVE.L  #$0000000, A1       ; Reset A1
00001140  247C 00000000            113                  MOVE.L  #$0000000, A2       ; Reset A2
00001146  267C 00000000            114                  MOVE.L  #$0000000, A3       ; Reset A3
0000114C  287C 00000000            115                  MOVE.L  #$0000000, A4       ; Reset A4
00001152  2A7C 00000000            116                  MOVE.L  #$0000000, A5       ; Reset A5
00001158  2C7C 00000000            117                  MOVE.L  #$0000000, A6       ; Reset A6
0000115E  2E7C 01000000            118                  MOVEA.L #$01000000,A7       ; Reset A7
00001164  4281                     119                  CLR.L   D1                  ; Reset D1
00001166  4281                     120                  CLR.L   D1                  ; Reset D1
00001168  4282                     121                  CLR.L   D2                  ; Reset D2
0000116A  4283                     122                  CLR.L   D3                  ; Reset D3
0000116C  4284                     123                  CLR.L   D4                  ; Reset D4
0000116E  4285                     124                  CLR.L   D5                  ; Reset D5
00001170  4286                     125                  CLR.L   D6                  ; Reset D6
00001172  6000 FE8C                126                  BRA     START               ; branch to start of program
00001176                           127  
00001176                           128  *--------------------SUBROUTINES------------------
00001176  1439 000025B5            129  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000117C  1639 000025B6            130                  MOVE.B  LINE_MAX,D3                
00001182  B602                     131                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001184  6F00 0004                132                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001188  4E75                     133                  RTS
0000118A                           134  
0000118A  4BF9 00002489            135  NEXT_SCREEN     LEA     CONTINUE,A5
00001190  4EB9 00002244            136                  JSR     PRINTNULL
00001196  6000 0002                137                  BRA     READ_KEY
0000119A                           138                  
0000119A  103C 0005                139  READ_KEY        MOVE.B  #5,D0
0000119E  4E4F                     140                  TRAP    #15
000011A0                           141                  
000011A0  B23C 000D                142                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000011A4  6700 0004                143                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
000011A8  60F0                     144                  BRA     READ_KEY
000011AA                           145                  
000011AA  103C 000B                146  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
000011AE  323C FF00                147                  MOVE.W  #$FF00, D1          Clear Screen
000011B2  4E4F                     148                  TRAP    #15                 Call Trap
000011B4                           149                  
000011B4                           150                  ; reset line counter
000011B4  1439 000025B5            151                  MOVE.B  LINE_COUNT,D2
000011BA  143C 0000                152                  MOVE.B  #$0,D2
000011BE  13C2 000025B5            153                  MOVE.B  D2,LINE_COUNT
000011C4  4E75                     154                  RTS       
000011C6                           155      
000011C6                           156  
000011C6  143C 0001                157  RESET_INPUT     MOVE.B  #1,D2
000011CA  6000 0062                158                  BRA     INVALID            
000011CE                           159                  
000011CE  7800                     160  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011D0  B204                     161                  CMP.B   D4,D1               ; D1 stores length
000011D2  6700 005A                162                  BEQ     INVALID             ; input is null
000011D6  0C41 0008                163                  CMPI    #$8,D1              ; check if input is longer than a longword
000011DA  6600 0052                164                  BNE     INVALID             ; input is longer than a longword
000011DE  4E75                     165                  RTS
000011E0                           166                              
000011E0  4283                     167  CONVERT         CLR.L   D3
000011E2  4284                     168                  CLR.L   D4
000011E4  1619                     169                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011E6  B63C 0039                170                  CMP.B   #57,D3
000011EA  6E00 0012                171                  BGT     NOTNUMBER
000011EE                           172                  
000011EE  B63C 002F                173                  CMP.B   #47,D3
000011F2  6E00 0002                174                  BGT     ISNUMBER
000011F6                           175                  
000011F6  0603 00D0                176  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000011FA  6000 001A                177                  BRA     CONCAT
000011FE                           178              
000011FE  B63C 0041                179  NOTNUMBER       CMP.B   #65,D3
00001202  6D00 002A                180                  BLT     INVALID
00001206  B63C 0046                181                  CMP.B   #70,D3
0000120A  6E00 0022                182                  BGT     INVALID  
0000120E  0603 00C9                183                  ADD.B   #-55,D3             ; is letter             
00001212  6000 0002                184                  BRA     CONCAT
00001216                           185              
00001216  BC3C 0000                186  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000121A  6D00 0010                187                  BLT     RETURN
0000121E  1806                     188                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001220  E50C                     189                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001222  E9AB                     190                  LSL.L   D4,D3               ; moves current char to correct position  
00001224  DA83                     191                  ADD.L   D3,D5               ; D5 stores converted input so far
00001226  0606 00FF                192                  ADD.B   #-1,D6  
0000122A  60B4                     193                  BRA     CONVERT             ; continue loop for remaining chars
0000122C                           194                  
0000122C  4E75                     195  RETURN          RTS
0000122E                           196                  
0000122E  227C 00000000            197  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001234  43F9 00002401            198                  LEA     BAD_INPUT,A1        ; output invalid message
0000123A  103C 000E                199                  MOVE.B  #14,D0
0000123E  4E4F                     200                  TRAP    #15
00001240  B47C 0001                201                  CMP     #1,D2
00001244  6700 FDDA                202                  BEQ     INPUT1
00001248  6000 FE1C                203                  BRA     INPUT2
0000124C                           204  
0000124C  4284                     205  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000124E  223C 00001000            206                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001254  BA81                     207                  CMP.L      D1,D5            ; Compare minimum address with input
00001256  6DD6                     208                  BLT        INVALID          ; input is too low. 
00001258  223C 00FFFFFE            209                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000125E  BA81                     210                  CMP.L      D1,D5            ; compare maximum address with input
00001260  6ECC                     211                  BGT        INVALID          ; input too large
00001262  4E75                     212                  RTS                         ; input is within range
00001264                           213             
00001264  0805 0000                214  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001268  66C4                     215                  BNE        INVALID
0000126A  4E75                     216                  RTS
0000126C                           217  
0000126C                           218  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
0000126C                           219  *                MOVE.L  A6,D1                   ; loads current address in D1
0000126C                           220  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
0000126C                           221  *                JSR     PRINTSHORTLONGNUM       ; prints out address
0000126C                           222  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
0000126C                           223  *                RTS
0000126C  220E                     224                  MOVE.L  A6,D1                   ; loads current address in D1
0000126E  7801                     225                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001270  4EB9 0000211E            226                  JSR     PRINTSHORTLONGNUM       ; prints out address
00001276  4E75                     227                  RTS
00001278                           228  
00001278                           229  
00001278                           230  
00001278                           231  * Checks every single possible opcode we could have. Jump table
00001278                           232  * Inputs: (A2) which is a pointer to intruction word to be translated
00001278                           233  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001278                           234  
00001278  3C4A                     235  OPCODE_DECODE   MOVE.W  A2,A6
0000127A  301A                     236                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000127C  4EB8 126C                237                  JSR     PRINT_ADDR
00001280                           238                  
00001280                           239  
00001280                           240  *---------------NOP opcode----------------------                
00001280  B07C 4E71                241  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001284  6600 0010                242                  BNE     CASE_MOVE               ; checks the next case if not equal
00001288                           243                  
00001288  4BF9 000024BB            244                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000128E  4EB9 00002244            245                  JSR     PRINTNULL               ; prints NOP                
00001294  4E75                     246                  RTS                             ; returns from the subroutine
00001296                           247  
00001296                           248  *---------------MOVE opcode----------------------              
00001296                           249                  * if first two bits are 00, next two are not 00
00001296  3200                     250  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001298  C27C C000                251                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000129C  6600 00BE                252                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
000012A0  B07C 0FFF                253                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000012A4  6F00 00B6                254                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
000012A8                           255                  
000012A8                           256                  ; Check source
000012A8  4BF9 000022C4            257                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012AE  4DF9 000022FA            258                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012B4  3E3C 0000                259                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012B8  4EB9 00001E10            260                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012BE  B27C 0001                261                  CMP.W   #1,D1                    ; checks if invalid
000012C2  6700 0AF0                262                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012C6  3802                     263                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012C8  3A03                     264                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012CA                           265                  
000012CA                           266                  ; Check destination
000012CA  4BF9 000022C4            267                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012D0  4DF9 000022FE            268                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012D6  3E3C 0001                269                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012DA  4EB9 00001E10            270                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012E0  B27C 0001                271                  CMP.W   #1,D1                    ; checks if invalid
000012E4  6700 0ACE                272                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012E8  3C02                     273                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012EA  3E03                     274                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012EC                           275                  
000012EC                           276                  ; Checking if it is MOVEA
000012EC  3200                     277                  MOVE.W  D0,D1                    ; stores d0 in d1
000012EE  C27C 01C0                278                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000012F2  B27C 0040                279                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000012F6  6700 0024                280                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000012FA                           281                  
000012FA  4BF9 000024C0            282                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001300  4EB9 00002244            283                  JSR     PRINTNULL                ; prints out MOVE
00001306  4EB9 00002266            284                  JSR     PRINTMOVESIZE            ; prints out the size 
0000130C  4BF9 00002592            285                  LEA     MSG_4SPACES,A5           ; loads spaces
00001312  4EB9 00002244            286                  JSR     PRINTNULL                ; prints out spaces
00001318  6000 0020                287                  BRA     PRINTMOVE                ; Branches to print move
0000131C                           288                  
0000131C  4BF9 000024C6            289  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001322  4EB9 00002244            290                  JSR     PRINTNULL                ; prints out MOVEA
00001328  4EB9 00002266            291                  JSR     PRINTMOVESIZE            ; prints out the size 
0000132E  4BF9 0000258E            292                  LEA     MSG_3SPACES,A5           ; loads spaces
00001334  4EB9 00002244            293                  JSR     PRINTNULL                ; prints out spaces
0000133A                           294   
0000133A  3404                     295  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000133C  3605                     296                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000133E  4EB9 00001F7E            297                  JSR     EA_TO_STRING             ; outputs it into a string
00001344                           298                  
00001344                           299                  ; prints a comma to seperate
00001344  4BF9 00002585            300                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000134A  4EB9 00002244            301                  JSR     PRINTNULL                ; prints out MOVE
00001350                           302                  
00001350                           303                  ; print destination
00001350  3406                     304                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001352  3607                     305                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001354  4EB9 00001F7E            306                  JSR     EA_TO_STRING             ; outputs it into a string
0000135A  4E75                     307                  RTS                              ; exits subroutine                 
0000135C                           308                
0000135C                           309  *---------------MOVEM opcode----------------------                
0000135C  3200                     310  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000135E  C27C FB80                311                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001362  B27C 4880                312                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001366  6600 0106                313                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000136A                           314                  
0000136A                           315                  ; Check D
0000136A  3200                     316                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000136C  C27C 0400                317                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001370  3E01                     318                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001372  B27C 0400                319                  CMP.W   #$0400,D1                       ; checks if value is 1
00001376  6700 0076                320                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000137A                           321  
0000137A                           322  MOVEM_REG2MEM   ; loads EA and XN
0000137A  3E3C 0000                323                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000137E  4BF9 000022D1            324                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001384  4DF9 000022FE            325                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000138A  4EB9 00001E10            326                  JSR     CHECKGET_EAXN
00001390  B27C 0001                327                  CMP.W   #1,D1                           ; checks if D1 invalid
00001394  6700 0A1E                328                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001398  4BF9 000024D4            329                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000139E  4EB9 00002244            330                  JSR     PRINTNULL                       ; prints MOVEM
000013A4                           331                  
000013A4                           332                  ; finds and prints size
000013A4  3200                     333                  MOVE.W  D0,D1                           ; copies D0
000013A6  C27C 0040                334                  AND.W   #$0040,D1                       ; gets the size bit
000013AA  6600 000C                335                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000013AE                           336  
000013AE  4BF9 000025AF            337  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013B4  6000 0008                338                  BRA     PRINTREG2MEM                    ; prints the registers           
000013B8                           339                  
000013B8  4BF9 000025B2            340  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013BE                           341             
000013BE  4EB9 00002244            342  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013C4  4BF9 0000258E            343                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013CA  4EB9 00002244            344                  JSR     PRINTNULL                       ; prints out spaces
000013D0  383C 0001                345                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013D4  4EB9 00001EA8            346                  JSR     PRINTREGISTERS                  ; prints registers
000013DA  4BF9 00002585            347                  LEA     MSG_COMMA,A5                    ; loads comma
000013E0  4EB9 00002244            348                  JSR     PRINTNULL                       ; prints comma
000013E6  4EB9 00001F7E            349                  JSR     EA_TO_STRING                    ; prints EA
000013EC  4E75                     350                  RTS
000013EE                           351  
000013EE                           352  MOVEM_MEM2REG  ; loads EA and XN
000013EE  3E3C 0000                353                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000013F2  4BF9 000022D5            354                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
000013F8  4DF9 000022FE            355                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000013FE  4EB9 00001E10            356                  JSR     CHECKGET_EAXN
00001404  B27C 0001                357                  CMP.W   #1,D1                           ; checks if D1 invalid
00001408  6700 09AA                358                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000140C  4BF9 000024D4            359                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001412  4EB9 00002244            360                  JSR     PRINTNULL                       ; prints MOVEM
00001418                           361                  
00001418                           362                  ; finds and prints size
00001418  3200                     363                  MOVE.W  D0,D1                           ; copies D0
0000141A  C27C 0040                364                  AND.W   #$0040,D1                       ; gets the size bit
0000141E  6600 0012                365                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001422                           366  
00001422  4BF9 000025AF            367  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001428  4EB9 00002244            368                  JSR     PRINTNULL                       ; prints MOVEM
0000142E  6000 000E                369                  BRA     PRINTMEM2REG                    ; prints the registers           
00001432                           370                  
00001432  4BF9 000025B2            371  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001438  4EB9 00002244            372                  JSR     PRINTNULL                       ; prints MOVEM 
0000143E                           373             
0000143E  4EB9 00002244            374  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
00001444  4BF9 0000258E            375                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000144A  4EB9 00002244            376                  JSR     PRINTNULL                       ; prints out spaces
00001450  4EB9 00001F7E            377                  JSR     EA_TO_STRING                    ; prints EA
00001456  4BF9 00002585            378                  LEA     MSG_COMMA,A5                    ; loads comma
0000145C  4EB9 00002244            379                  JSR     PRINTNULL                       ; prints comma
00001462  383C FFFF                380                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001466  4EB9 00001EA8            381                  JSR     PRINTREGISTERS                  ; prints registers
0000146C  4E75                     382                  RTS
0000146E                           383                          
0000146E                           384  
0000146E                           385  *---------------MOVEQ opcode----------------------
0000146E  3200                     386  CASE_MOVEQ      MOVE.W  D0,D1
00001470  C27C F100                387                  AND.W   #$F100,D1
00001474  B27C 7000                388                  CMP.W   #$7000,D1
00001478  6600 007C                389                  BNE     CASE_ADD
0000147C                           390                  
0000147C                           391                  ;loads Register
0000147C  323C 0001                392                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001480  4EB9 00001DE6            393                  JSR     GET_XN                          ; gets XN and puts in D1
00001486  3601                     394                  MOVE.W  D1,D3                           ; copies Xn to D3 so it won't be overwritten
00001488                           395                  
00001488                           396                  ;loads DATA
00001488  3200                     397                  MOVE.W  D0,D1
0000148A  C27C 00FF                398                  AND.W   #$00FF,D1                       ;bit mask to get DATA
0000148E  3801                     399                  MOVE.W  D1,D4                           ;copy data into D4
00001490                           400                                                          ;must convert bits to hex
00001490                           401                                  
00001490  4BF9 000024CD            402  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
00001496  4EB9 00002244            403                  JSR     PRINTNULL  
0000149C                           404                                  
0000149C  4BF9 000025B2            405                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014A2  4EB9 00002244            406                  JSR     PRINTNULL
000014A8                           407      
000014A8  4BF9 0000258E            408                  LEA     MSG_3SPACES,A5                  ;PRINT THREE TABS
000014AE  4EB9 00002244            409                  JSR     PRINTNULL
000014B4                           410                  
000014B4  4BF9 00002581            411                  LEA     MSG_POUND, A5                   ;PRINT HASHTAG
000014BA  4EB9 00002244            412                  JSR     PRINTNULL
000014C0                           413                  
000014C0  4BF9 00002583            414                  LEA     MSG_HEX, A5                     ;PRINT DOLLAR SIGN
000014C6  4EB9 00002244            415                  JSR     PRINTNULL
000014CC                           416                  
000014CC  3204                     417                  MOVE.W  D4,D1                           ;PRINT DATA
000014CE  4EB9 0000210A            418                  JSR     PRINTHEXNUM                           
000014D4                           419                  
000014D4  4BF9 00002585            420                  LEA     MSG_COMMA, A5                   ;PRINT COMMA
000014DA  4EB9 00002244            421                  JSR     PRINTNULL
000014E0                           422                  
000014E0  4BF9 00002575            423                  LEA     MSG_DR,A5                       ;PRINT D
000014E6  4EB9 00002244            424                  JSR     PRINTNULL
000014EC                           425            
000014EC  3203                     426                  MOVE.W  D3,D1                           ;PRINT REGISTER NUMBER
000014EE  4EB9 000020FA            427                  JSR     PRINTNUM                         
000014F4                           428                  
000014F4  4E75                     429                  RTS
000014F6                           430                  
000014F6                           431  *---------------ADD opcode----------------------                
000014F6                           432  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000014F6  3200                     433  CASE_ADD        MOVE.W  D0,D1
000014F8  C27C F000                434                  AND.W   #$F000,D1
000014FC  B27C D000                435                  CMP.W   #$D000,D1
00001500  6600 01BA                436                  BNE     CASE_ADDQ
00001504                           437                   
00001504  4EB9 0000151E            438                  JSR     ADD_SUB_HELP
0000150A                           439                  
0000150A                           440                  ; bits 7-8 determine if it is ADDA or ADD
0000150A  3200                     441                  MOVE.W  D0,D1
0000150C  E149                     442                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000150E  E049                     443                  LSR.W   #8,D1
00001510  EC49                     444                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001512  B27C 0003                445                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001516  6700 0124                446                  BEQ     CASE_ADDA
0000151A                           447                  
0000151A  6000 0040                448                  BRA     PRINTADD                ; Branches to print add
0000151E                           449                  
0000151E                           450                  ; Check bits 0-5 
0000151E  4BF9 000022C4            451  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001524  4DF9 000022FA            452                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000152A  3E3C 0000                453                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000152E  4EB9 00001E10            454                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001534  B27C 0001                455                  CMP.W       #1,D1                    ; checks if invalid
00001538  6700 087A                456                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000153C  3802                     457                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
0000153E  3A03                     458                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001540                           459                  
00001540                           460                  ; Check 6-11
00001540  4BF9 000022C4            461                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001546  4DF9 000022FE            462                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000154C  3E3C 0001                463                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001550  4EB9 00001E10            464                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001556  3C02                     465                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001558  3E03                     466                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
0000155A                           467    
0000155A  4E75                     468                  RTS                
0000155C                           469                    
0000155C  4BF9 000024DB            470  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001562  4EB9 00002244            471                  JSR         PRINTNULL               ; print ADD
00001568  3200                     472                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000156A  4EB9 00001580            473                  JSR         ADD_SUB_SIZE
00001570  4BF9 00002597            474                  LEA         MSG_5SPACES,A5          ; loads spaces
00001576  4EB9 00002244            475                  JSR         PRINTNULL               ; prints out spaces
0000157C  6000 0050                476                  BRA         FINISH_ADD
00001580                           477                    
00001580  3200                     478  ADD_SUB_SIZE    MOVE.W      D0,D1
00001582  E149                     479                  LSL.W       #8,D1
00001584  E049                     480                  LSR.W       #8,D1
00001586  EC49                     481                  LSR.W       #6,D1                   ; gets bits 6-7
00001588                           482                    
00001588  B27C 0000                483                  CMP.W       #0,D1
0000158C  6700 0016                484                  BEQ         ADD_SUB_BYTE
00001590  B27C 0001                485                  CMP.W       #1,D1                   ; if 1, it is a word
00001594  6700 001C                486                  BEQ         ADD_SUB_WORD
00001598  B27C 0002                487                  CMP.W       #2,D1                   ; if 2, it is a long
0000159C  6700 0022                488                  BEQ         ADD_SUB_LONG
000015A0  6000 0294                489                  BRA         CASE_SUBA               ; error
000015A4                           490                    
000015A4  4BF9 000025AC            491  ADD_SUB_BYTE    LEA         MSG_B,A5
000015AA  4EB9 00002244            492                  JSR         PRINTNULL
000015B0  4E75                     493                  RTS
000015B2                           494                    
000015B2  4BF9 000025AF            495  ADD_SUB_WORD    LEA         MSG_W,A5
000015B8  4EB9 00002244            496                  JSR         PRINTNULL
000015BE  4E75                     497                  RTS
000015C0                           498    
000015C0  4BF9 000025B2            499  ADD_SUB_LONG    LEA         MSG_L,A5
000015C6  4EB9 00002244            500                  JSR         PRINTNULL
000015CC  4E75                     501                  RTS
000015CE                           502        
000015CE  4EB9 000015D6            503  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015D4  4E75                     504                  RTS
000015D6                           505    
000015D6  EF49                     506  ADD_SUB_OPERAND LSL.W       #7,D1
000015D8  EE49                     507                  LSR.W       #7,D1
000015DA  E049                     508                  LSR.W       #8,D1
000015DC  B27C 0001                509                  CMP.W       #1,D1
000015E0  6600 002E                510                  BNE         Dn_PLUS_EA          
000015E4                           511                    
000015E4                           512                  ; print Data Register
000015E4  4BF9 00002575            513                  LEA         MSG_DR,A5
000015EA  4EB9 00002244            514                  JSR         PRINTNULL
000015F0  3207                     515                  MOVE.W      D7,D1
000015F2  4EB9 000020FA            516                  JSR         PRINTNUM                
000015F8                           517                  
000015F8                           518                  ; prints a comma to seperate
000015F8  4BF9 00002585            519                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015FE  4EB9 00002244            520                  JSR         PRINTNULL                ; prints out MOVE
00001604                           521                 
00001604                           522                  ; below is EA+Dn->Dn  
00001604  3404                     523                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001606  3605                     524                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001608  4EB9 00001F7E            525                  JSR         EA_TO_STRING             ; outputs it into a string
0000160E  4E75                     526                  RTS                                 ; exits subroutine 
00001610                           527  
00001610                           528  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001610  3404                     529                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001612  3605                     530                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001614  4EB9 00001F7E            531                  JSR         EA_TO_STRING             ; outputs it into a string   
0000161A                           532                  
0000161A                           533                  ; prints a comma to seperate
0000161A  4BF9 00002585            534                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001620  4EB9 00002244            535                  JSR         PRINTNULL                ; prints out MOVE
00001626                           536                  
00001626                           537                  ; below is Dn+EA->EA
00001626  4BF9 00002575            538                  LEA         MSG_DR,A5                ; print data register
0000162C  4EB9 00002244            539                  JSR         PRINTNULL
00001632  3207                     540                  MOVE.W      D7,D1
00001634  4EB9 000020FA            541                  JSR         PRINTNUM             
0000163A  4E75                     542                  RTS                                  ; exits subroutine          
0000163C                           543                        
0000163C                           544  *---------------ADDA opcode----------------------
0000163C                           545  CASE_ADDA       ; gets bit 8 (size bit)
0000163C  3200                     546                  MOVE.W      D0,D1
0000163E  EF49                     547                  LSL.W       #7,D1
00001640  EE49                     548                  LSR.W       #7,D1
00001642  E049                     549                  LSR         #8,D1                   
00001644                           550                  
00001644  4BF9 000024E0            551                  LEA         MSG_ADDA,A5             ; print ADDA
0000164A  4EB9 00002244            552                  JSR         PRINTNULL
00001650                           553                   
00001650  B27C 0001                554                  CMP.W       #1,D1
00001654  6700 001E                555                  BEQ         ADDA_LONG
00001658                           556                    
00001658  4BF9 000025AF            557                  LEA         MSG_W,A5
0000165E  4EB9 00002244            558                  JSR         PRINTNULL
00001664  4BF9 00002592            559                  LEA         MSG_4SPACES,A5          ; loads spaces
0000166A  4EB9 00002244            560                  JSR         PRINTNULL               ; prints out spaces
00001670  6000 001E                561                  BRA         FINISH_ADDA   
00001674                           562                    
00001674  4BF9 000025B2            563  ADDA_LONG       LEA         MSG_L,A5
0000167A  4EB9 00002244            564                  JSR         PRINTNULL
00001680  4BF9 00002592            565                  LEA         MSG_4SPACES,A5          ; loads spaces
00001686  4EB9 00002244            566                  JSR         PRINTNULL               ; prints out spaces
0000168C  6000 0002                567                  BRA         FINISH_ADDA
00001690                           568                    
00001690  3404                     569  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001692  3605                     570                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001694  4EB9 00001F7E            571                  JSR         EA_TO_STRING             ; outputs it into a string
0000169A                           572                    
0000169A                           573                  ; prints a comma to seperate
0000169A  4BF9 00002585            574                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016A0  4EB9 00002244            575                  JSR         PRINTNULL                ; prints out MOVE
000016A6                           576            
000016A6  4BF9 00002577            577                  LEA         MSG_AR,A5                ; print address register
000016AC  4EB9 00002244            578                  JSR         PRINTNULL
000016B2  3207                     579                  MOVE.W      D7,D1
000016B4  4EB9 000020FA            580                  JSR         PRINTNUM             
000016BA  4E75                     581                  RTS                              ; exits subroutine
000016BC                           582                  
000016BC                           583  *---------------ADDQ opcode----------------------                  
000016BC  3200                     584  CASE_ADDQ       MOVE.W      D0,D1
000016BE  C27C F000                585                  AND.W       #$F000,D1       
000016C2  B27C 5000                586                  CMP.W       #$5000,D1
000016C6  6600 00EC                587                  BNE         CASE_SUB
000016CA                           588                                                   
000016CA  4BF9 000024E6            589                  LEA         MSG_ADDQ,A5             ; print ADDQ
000016D0  4EB9 00002244            590                  JSR         PRINTNULL
000016D6                           591                  
000016D6                           592                  ; get bits 6-7 (size bits)
000016D6  3200                     593                  MOVE.W      D0,D1
000016D8  E149                     594                  LSL.W       #8,D1
000016DA  E049                     595                  LSR.W       #8,D1
000016DC  EC49                     596                  LSR.W       #6,D1
000016DE  3401                     597                  MOVE.W      D1,D2
000016E0                           598                  
000016E0                           599                  ; Check bits 0-5 
000016E0  4BF9 000022C4            600                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016E6  4DF9 000022FA            601                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016EC  3E3C 0000                602                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016F0  4EB9 00001E10            603                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000016F6  B27C 0001                604                  CMP.W       #1,D1                    ; checks if invalid
000016FA  6700 06B8                605                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000016FE  3802                     606                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001700  3A03                     607                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001702                           608                  
00001702  B47C 0001                609                  CMP.W       #1,D2
00001706  6700 0026                610                  BEQ         ADDQ_WORD
0000170A  B47C 0002                611                  CMP.W       #2,D2
0000170E  6700 003A                612                  BEQ         ADDQ_LONG
00001712                           613                    
00001712  4BF9 000025AC            614  ADDQ_BYTE       LEA         MSG_B,A5
00001718  4EB9 00002244            615                  JSR         PRINTNULL
0000171E  4BF9 00002592            616                  LEA         MSG_4SPACES,A5          ; loads spaces
00001724  4EB9 00002244            617                  JSR         PRINTNULL               ; prints out spaces
0000172A  6000 003A                618                  BRA         FINISH_ADDQ  
0000172E                           619   
0000172E  4BF9 000025AF            620  ADDQ_WORD       LEA         MSG_W,A5
00001734  4EB9 00002244            621                  JSR         PRINTNULL
0000173A  4BF9 00002592            622                  LEA         MSG_4SPACES,A5          ; loads spaces
00001740  4EB9 00002244            623                  JSR         PRINTNULL               ; prints out spaces
00001746  6000 001E                624                  BRA         FINISH_ADDQ                 
0000174A                           625    
0000174A  4BF9 000025B2            626  ADDQ_LONG       LEA         MSG_L,A5
00001750  4EB9 00002244            627                  JSR         PRINTNULL
00001756  4BF9 00002592            628                  LEA         MSG_4SPACES,A5          ; loads spaces
0000175C  4EB9 00002244            629                  JSR         PRINTNULL               ; prints out spaces
00001762  6000 0002                630                  BRA         FINISH_ADDQ                  
00001766                           631                    
00001766  4EB9 00001784            632  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000176C                           633   
0000176C                           634                  ; prints a comma to seperate
0000176C  4BF9 00002585            635                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001772  4EB9 00002244            636                  JSR         PRINTNULL                ; prints out MOVE
00001778                           637                    
00001778                           638                  ; prints destination
00001778  3404                     639                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000177A  3605                     640                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000177C  4EB9 00001F7E            641                  JSR         EA_TO_STRING             ; outputs it into a string
00001782                           642                 
00001782  4E75                     643                  RTS
00001784                           644   
00001784  4BF9 00002581            645  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
0000178A  4EB9 00002244            646                  JSR         PRINTNULL
00001790                           647                  ; gets bits 9-11 (data bits)
00001790  E949                     648                  LSL.W       #4,D1
00001792  E849                     649                  LSR.W       #4,D1                               ; get rid of left 4 bits
00001794  E049                     650                  LSR.W       #8,D1
00001796  E249                     651                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001798                           652                  
00001798  B27C 0000                653                  CMP.W       #0,D1
0000179C  6700 000A                654                  BEQ         PRINT_8
000017A0  4EB9 000020FA            655                  JSR         PRINTNUM
000017A6  4E75                     656                  RTS 
000017A8                           657  
000017A8  123C 0008                658  PRINT_8         MOVE.B      #8,D1
000017AC  4EB9 000020FA            659                  JSR         PRINTNUM
000017B2  4E75                     660                  RTS   
000017B4                           661         
000017B4                           662  *---------------SUB opcode---------------------- 
000017B4  3200                     663  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
000017B6  C27C F000                664                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000017BA  B27C 9000                665                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
000017BE  6600 008C                666                  BNE         CASE_LEA
000017C2                           667                 
000017C2  4EB8 151E                668                  JSR         ADD_SUB_HELP
000017C6                           669                  
000017C6  6000 0002                670                  BRA         PRINTSUB                            ; Branches to print sub
000017CA                           671  
000017CA  4BF9 000024EC            672  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017D0  4EB9 00002244            673                  JSR         PRINTNULL
000017D6  3200                     674                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017D8  4EB8 1580                675                  JSR         ADD_SUB_SIZE
000017DC  4BF9 00002597            676                  LEA         MSG_5SPACES,A5                      ; loads spaces
000017E2  4EB9 00002244            677                  JSR         PRINTNULL                           ; prints out spaces
000017E8  3200                     678                  MOVE.W      D0,D1
000017EA  E149                     679                  LSL.W       #8,D1
000017EC  E049                     680                  LSR.W       #8,D1
000017EE  EC49                     681                  LSR.W       #6,D1
000017F0  B27C 0003                682                  CMP.W       #3,D1
000017F4  6600 0006                683                  BNE         FINISH_SUB
000017F8  6000 0008                684                  BRA         FINISH_SUBA                         ; same as ADDA
000017FC                           685                  
000017FC  4EB8 15D6                686  FINISH_SUB      JSR         ADD_SUB_OPERAND
00001800  4E75                     687                  RTS
00001802                           688                    
00001802  3404                     689  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001804  3605                     690                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001806  4EB9 00001F7E            691                  JSR         EA_TO_STRING             ; outputs it into a string
0000180C                           692                
0000180C                           693                  ; prints a comma to seperate
0000180C  4BF9 00002585            694                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001812  4EB9 00002244            695                  JSR         PRINTNULL                ; prints out MOVE
00001818                           696                  
00001818  4BF9 00002577            697                  LEA         MSG_AR,A5                ; print address register
0000181E  4EB9 00002244            698                  JSR         PRINTNULL
00001824  3200                     699                  MOVE.W      D0,D1
00001826  E949                     700                  LSL.W       #4,D1
00001828  E849                     701                  LSR.W       #4,D1
0000182A  E049                     702                  LSR.W       #8,D1
0000182C  E249                     703                  LSR.W       #1,D1
0000182E  4EB9 000020FA            704                  JSR         PRINTNUM             
00001834  4E75                     705                  RTS                              ; exits subroutine
00001836                           706  
00001836                           707  
00001836                           708  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
00001836  3200                     709  CASE_SUBA       MOVE.W      D0,D1
00001838  EF49                     710                  LSL.W       #7,D1
0000183A  EE49                     711                  LSR.W       #7,D1
0000183C  E049                     712                  LSR.W       #8,D1
0000183E  B23C 0000                713                  CMP.B       #0,D1
00001842  6700 FD6E                714                  BEQ         ADD_SUB_WORD
00001846  6000 FD78                715                  BRA         ADD_SUB_LONG
0000184A  4E75                     716                  RTS         
0000184C                           717                   
0000184C  3200                     718  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000184E  C27C F000                719                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001852  B27C 4000                720                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001856  6600 0092                721                  BNE.W   CASE_AND                             ; If its not, check AND
0000185A  3200                     722                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000185C  C27C 01C0                723                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001860  B27C 01C0                724                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001864  6600 0084                725                  BNE.W   CASE_AND                             ; If its not, check AND
00001868                           726                  
00001868                           727                  ; Check source
00001868  4BF9 000022E4            728                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000186E  4DF9 000022FE            729                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001874  3E3C 0000                730                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001878  4EB9 00001E10            731                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000187E  3802                     732                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001880  3A03                     733                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001882                           734                  
00001882                           735                  ; Check destination
00001882  4BF9 000022E4            736                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001888  4DF9 000022FE            737                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000188E  3E3C 0001                738                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
00001892  4EB9 00001E10            739                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001898  3C02                     740                  MOVE.W  D2,D6                                ; Saves D2 in D4
0000189A  3E03                     741                  MOVE.W  D3,D7                                ; Saves D2 in D4
0000189C                           742  
0000189C  4BF9 000024FD            743                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000018A2  4EB9 00002244            744                  JSR     PRINTNULL                            ; prints LEA
000018A8  4BF9 000025A4            745                  LEA     MSG_7SPACES,A5                       ; loads spaces
000018AE  4EB9 00002244            746                  JSR     PRINTNULL                            ; prints out spaces
000018B4                           747                  
000018B4                           748                  ; print source
000018B4  3404                     749                  MOVE.W  D4,D2
000018B6  3605                     750                  MOVE.W  D5,D3
000018B8  4EB9 00001F7E            751                  JSR     EA_TO_STRING                         ; Prints out the EA
000018BE                           752                  
000018BE                           753                  ; comma
000018BE  4BF9 00002585            754                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000018C4  4EB9 00002244            755                  JSR     PRINTNULL                       
000018CA                           756                   
000018CA                           757                  ; register
000018CA  4BF9 00002577            758                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018D0  4EB9 00002244            759                  JSR     PRINTNULL 
000018D6  3401                     760                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018D8  323C 0001                761                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000018DC  4EB9 00001DE6            762                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000018E2  4EB9 000020FA            763                  JSR     PRINTNUM                             ; Prints the number in D1
000018E8  4E75                     764                  RTS
000018EA                           765  
000018EA                           766  *---------------AND opcode----------------------
000018EA  3200                     767  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018EC  C27C F000                768                  AND.W       #$F000,D1       
000018F0  B27C C000                769                  CMP.W       #$C000,D1
000018F4  6600 00D6                770                  BNE         CASE_OR
000018F8                           771                  
000018F8  3200                     772                  MOVE.W      D0,D1
000018FA  E149                     773                  LSL.W       #8,D1
000018FC  E049                     774                  LSR.W       #8,D1
000018FE  EC49                     775                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001900  3C01                     776                  MOVE.W      D1,D6
00001902  BC7C 0003                777                  CMP.W       #3,D6
00001906  6700 0086                778                  BEQ         INV_INSTR
0000190A                           779                  
0000190A  4BF9 00002502            780                  LEA         MSG_AND,A5                      ; print AND
00001910  4EB9 00002244            781                  JSR         PRINTNULL
00001916                           782                  
00001916  3206                     783                  MOVE.W      D6,D1
00001918  B27C 0000                784                  CMP.W       #0,D1
0000191C  6700 0012                785                  BEQ         AND_BYTE
00001920  B27C 0001                786                  CMP.W       #1,D1                   ; if 1, it is a word
00001924  6700 0026                787                  BEQ         AND_WORD
00001928  B27C 0002                788                  CMP.W       #2,D1                   ; if 2, it is a long
0000192C  6700 003A                789                  BEQ         AND_LONG
00001930                           790                  
00001930  4BF9 000025AC            791  AND_BYTE        LEA         MSG_B,A5
00001936  4EB9 00002244            792                  JSR         PRINTNULL
0000193C  4BF9 000025A4            793                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001942  4EB9 00002244            794                  JSR         PRINTNULL                       ; prints out spaces
00001948  6000 003A                795                  BRA         FINISH_AND
0000194C                           796                                    
0000194C  4BF9 000025AF            797  AND_WORD        LEA         MSG_W,A5
00001952  4EB9 00002244            798                  JSR         PRINTNULL
00001958  4BF9 000025A4            799                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000195E  4EB9 00002244            800                  JSR         PRINTNULL                       ; prints out spaces
00001964  6000 001E                801                  BRA         FINISH_AND
00001968                           802    
00001968  4BF9 000025B2            803  AND_LONG        LEA         MSG_L,A5
0000196E  4EB9 00002244            804                  JSR         PRINTNULL
00001974  4BF9 000025A4            805                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000197A  4EB9 00002244            806                  JSR         PRINTNULL                       ; prints out spaces
00001980  6000 0002                807                  BRA         FINISH_AND
00001984                           808        
00001984  4EB8 151E                809  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001988  4EB8 15D6                810                  JSR         ADD_SUB_OPERAND
0000198C  4E75                     811                  RTS
0000198E                           812                  
0000198E  4BF9 0000243F            813  INV_INSTR       LEA         INVALID_INSTR,A5
00001994  4EB9 00002244            814                  JSR         PRINTNULL
0000199A  4BF9 0000259D            815                  LEA         MSG_6SPACES,A5
000019A0  4EB9 00002244            816                  JSR         PRINTNULL
000019A6  4BF9 00002583            817                  LEA         MSG_HEX,A5
000019AC  4EB9 00002244            818                  JSR         PRINTNULL
000019B2  2200                     819                  MOVE.L      D0,D1
000019B4  383C 0000                820                  MOVE.W      #0,D4
000019B8  4EB9 0000211E            821                  JSR         PRINTSHORTLONGNUM
000019BE  4BF9 000024B4            822                  LEA         NEW_LINE,A5
000019C4  4EB9 00002244            823                  JSR         PRINTNULL
000019CA  4E75                     824                  RTS               
000019CC                           825                  
000019CC                           826  *---------------OR opcode----------------------            
000019CC  3200                     827  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019CE  C27C F000                828                  AND.W       #$F000,D1       
000019D2  B27C 8000                829                  CMP.W       #$8000,D1
000019D6  6600 0054                830                  BNE         CASE_NOT
000019DA                           831                                                
000019DA  3200                     832                  MOVE.W      D0,D1
000019DC  E149                     833                  LSL.W       #8,D1
000019DE  E049                     834                  LSR.W       #8,D1
000019E0  EC49                     835                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019E2  B27C 0003                836                  CMP.W       #3,D1
000019E6  3C01                     837                  MOVE.W      D1,D6
000019E8  67A4                     838                  BEQ         INV_INSTR
000019EA                           839                  
000019EA                           840                  
000019EA  4BF9 00002507            841                  LEA         MSG_OR,A5
000019F0  4EB9 00002244            842                  JSR         PRINTNULL                       ; print "OR"
000019F6                           843                  
000019F6  3206                     844                  MOVE.W      D6,D1
000019F8  4EB9 00001A14            845                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000019FE  4BF9 0000259D            846                  LEA         MSG_6SPACES,A5                  ; loads spaces
00001A04  4EB9 00002244            847                  JSR         PRINTNULL                       ; prints out spaces
00001A0A                           848  
00001A0A  4EB8 151E                849                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001A0E  4EB8 15D6                850                  JSR         ADD_SUB_OPERAND                 ; print 
00001A12  4E75                     851                  RTS
00001A14                           852  
00001A14  B27C 0000                853  OR_SIZE         CMP.W       #0,D1
00001A18  6700 FB8A                854                  BEQ         ADD_SUB_BYTE
00001A1C  B27C 0001                855                  CMP.W       #1,D1                   ; if 1, it is a word
00001A20  6700 FB90                856                  BEQ         ADD_SUB_WORD
00001A24  B27C 0002                857                  CMP.W       #2,D1                   ; if 2, it is a long
00001A28  6700 FB96                858                  BEQ         ADD_SUB_LONG
00001A2C                           859                  ; no need for rts, since ADD_SUB_ already has                
00001A2C                           860  
00001A2C                           861  *---------------NOT opcode----------------------
00001A2C  3200                     862  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A2E  C27C FF00                863                  AND.W       #$FF00,D1       
00001A32  B27C 4600                864                  CMP.W       #$4600,D1
00001A36  6600 0058                865                  BNE         CASE_LSDASDROD
00001A3A                           866                 
00001A3A                           867                  ; get bits 6-7 (size)
00001A3A  3200                     868                  MOVE.W      D0,D1
00001A3C  E149                     869                  LSL.W       #8,D1
00001A3E  E049                     870                  LSR.W       #8,D1
00001A40  EC49                     871                  LSR.W       #6,D1 
00001A42  3C01                     872                  MOVE.W      D1,D6                         
00001A44  BC7C 0003                873                  CMP.W       #3,D6
00001A48  6700 FF44                874                  BEQ         INV_INSTR
00001A4C                           875                                  
00001A4C  4BF9 0000250B            876                  LEA         MSG_NOT,A5
00001A52  4EB9 00002244            877                  JSR         PRINTNULL                       ; print "NOT"
00001A58                           878                                 
00001A58  3206                     879                  MOVE.W      D6,D1
00001A5A                           880  
00001A5A  4EB8 1A14                881                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A5E  4BF9 00002597            882                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A64  4EB9 00002244            883                  JSR         PRINTNULL                       ; prints out spaces
00001A6A                           884                  
00001A6A                           885                  ; get bits 0-5 
00001A6A  4BF9 000022C4            886                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A70  4DF9 000022FA            887                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A76  3E3C 0000                888                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A7A  4EB9 00001E10            889                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A80  B27C 0001                890                  CMP.W       #1,D1                    ; checks if invalid
00001A84  6700 032E                891                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001A88  4EB9 00001F7E            892                  JSR         EA_TO_STRING             ; outputs it into a string
00001A8E                           893    
00001A8E  4E75                     894                  RTS
00001A90                           895  
00001A90  3200                     896  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001A92  C27C F000                897                  AND.W       #$F000, D1                       ; gets first 4 bits
00001A96  B27C E000                898                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001A9A  6600 0240                899                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001A9E  3400                     900                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AA0  4EB9 00001E98            901                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AA6  B47C 0003                902                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001AAA  6600 00D4                903                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001AAE                           904                  
00001AAE  3400                     905  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001AB0  4EB9 00001E86            906                  JSR         GETROTATION                      ; gets rotation value of D2
00001AB6  B47C 0000                907                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001ABA  6700 0014                908                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001ABE  B47C 0003                909                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001AC2  6700 0016                910                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001AC6                           911                  
00001AC6  4BF9 00002510            912  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001ACC  6000 0012                913                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AD0                           914  
00001AD0  4BF9 00002514            915  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001AD6  6000 0008                916                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001ADA                           917  
00001ADA  4BF9 00002518            918  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AE0                           919                  
00001AE0  4EB9 00002244            920  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001AE6  3400                     921                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AE8  4EB9 00001E90            922                  JSR         GETDIRECTION                     ; gets direction
00001AEE  B47C 0000                923                  CMP.W       #0,D2                            ; checking if its right
00001AF2  6700 000C                924                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001AF6                           925  
00001AF6  4BF9 00002573            926  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001AFC  6000 0008                927                  BRA         PRINT_MEMDIR                     ; branches for printing
00001B00                           928          
00001B00  4BF9 00002571            929  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001B06                           930  
00001B06  4EB9 00002244            931  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001B0C  4BF9 000025AF            932                  LEA         MSG_W,A5                         ; loads .W into A5
00001B12  4EB9 00002244            933                  JSR         PRINTNULL                        ; Prints .W
00001B18  4BF9 00002597            934                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001B1E  4EB9 00002244            935                  JSR         PRINTNULL                        ; prints out spaces
00001B24  6000 0002                936                  BRA         GETMEMSOURCE                     ; checks the source 
00001B28                           937                  
00001B28                           938  ; get source addressing mode       
00001B28                           939  GETMEMSOURCE                                                 
00001B28  323C 0000                940                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B2C  4EB9 00001DBC            941                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B32  3801                     942                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B34  323C 0000                943                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B38  4EB9 00001DE6            944                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B3E  3A01                     945                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B40                           946  
00001B40  4BF9 000022F2            947  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B46  3204                     948                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B48  4EB9 00001F4A            949                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B4E  B27C 0002                950                  CMP.W       #2,D1                            ; checks if it is Xn
00001B52  6700 0016                951                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B56  B27C 0001                952                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B5A  6700 0258                953                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B5E                           954  
00001B5E  3404                     955  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B60  3605                     956                  MOVE.W      D5,D3                            ; moves EA to D3
00001B62  4EB9 00001F7E            957                  JSR         EA_TO_STRING                     ; prints out the EA
00001B68  4E75                     958                  RTS                
00001B6A                           959                  
00001B6A                           960                  
00001B6A  4BF9 000022FE            961  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B70  3205                     962                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B72  4EB9 00001F4A            963                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B78  4A41                     964                  TST.W       D1                               ; checks if it is valid
00001B7A  67E2                     965                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B7C  6000 0236                966                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B80                           967  
00001B80                           968  
00001B80  3602                     969  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B82  3200                     970                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B84  C27C 0018                971                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001B88  E649                     972                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001B8A  B27C 0000                973                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B8E  6700 0014                974                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001B92  B27C 0003                975                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B96  6700 0016                976                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001B9A                           977                  
00001B9A  4BF9 00002510            978  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001BA0  6000 0012                979                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BA4                           980  
00001BA4  4BF9 00002514            981  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001BAA  6000 0008                982                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BAE                           983  
00001BAE  4BF9 00002518            984  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001BB4                           985                  
00001BB4  4EB9 00002244            986  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001BBA  3400                     987                  MOVE.W      D0,D2                            ; copies D0 to D2
00001BBC  4EB9 00001E90            988                  JSR         GETDIRECTION                     ; gets direction
00001BC2  B47C 0000                989                  CMP.W       #0,D2                            ; checking if its right
00001BC6  6700 000C                990                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BCA                           991  
00001BCA  4BF9 00002573            992  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BD0  6000 000C                993                  BRA         PRINT_REGDIR                     ; branches for printing
00001BD4                           994          
00001BD4  4BF9 00002571            995  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BDA  6000 0002                996                  BRA         PRINT_REGDIR                     ; branches for printing
00001BDE                           997                  
00001BDE  4EB9 00002244            998  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BE4                           999  
00001BE4  3400                    1000  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BE6  4EB9 00001E98           1001                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BEC  B47C 0001               1002                  CMP.W       #1,D2                            ; Checks if it is word size
00001BF0  6700 0014               1003                  BEQ         REG_WORD                         ; Prints .W
00001BF4  B47C 0002               1004                  CMP.W       #2,D2                            ; Checks if it is long size
00001BF8  6700 0016               1005                  BEQ         REG_LONG                         ; Prints .L
00001BFC                          1006  
00001BFC  4BF9 000025AC           1007  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001C02  6000 0012               1008                  BRA         PRINTREGEA      
00001C06                          1009  
00001C06  4BF9 000025AF           1010  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001C0C  6000 0008               1011                  BRA         PRINTREGEA      
00001C10                          1012                             
00001C10  4BF9 000025B2           1013  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001C16                          1014  
00001C16  4EB9 00002244           1015  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001C1C  4BF9 00002597           1016                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001C22  4EB9 00002244           1017                  JSR         PRINTNULL                        ; prints out spaces
00001C28  3400                    1018                  MOVE.W      D0,D2                            ; copies D0 to D2
00001C2A  4EB9 00001EA0           1019                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C30  B47C 0001               1020                  CMP.W       #$1,D2                           ; Compares D1 to 1, if it is 1, it is a data register
00001C34  6700 0060               1021                  BEQ         REG_REGISTER                     ; goes to register case if so
00001C38                          1022                                  
00001C38  3400                    1023  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C3A  4EB9 00001E86           1024                  JSR         GETROTATION                      ; gets the rotation size
00001C40  B47C 0000               1025                  CMP.W       #0,D2                            ; checks if D2 is 0 (shift count of 8)
00001C44  6600 0006               1026                  BNE         COMPLETE_REGIM                   ; if not shigt count of 8, then branch to start printing
00001C48                          1027                  
00001C48  343C 0008               1028  MAKESHIFT8      MOVE.W      #8,D2                            ; sets shift cound to 8 (shift count of 8 is 000 in the opcode)
00001C4C                          1029                  
00001C4C  4BF9 00002581           1030  COMPLETE_REGIM  LEA         MSG_POUND, A5                    ; loads # into A5
00001C52  4EB9 00002244           1031                  JSR         PRINTNULL                        ; prints #
00001C58  4BF9 00002583           1032                  LEA         MSG_HEX, A5                      ; loads $ into A5
00001C5E  4EB9 00002244           1033                  JSR         PRINTNULL                        ; prints $
00001C64  3202                    1034                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C66  4EB9 0000210A           1035                  JSR         PRINTHEXNUM                      ; prints shift count
00001C6C  4BF9 00002585           1036                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C72  4EB9 00002244           1037                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C78  4BF9 00002575           1038                  LEA         MSG_DR, A5                       ; loads D into A5
00001C7E  4EB9 00002244           1039                  JSR         PRINTNULL                        ; prints out D 
00001C84  323C 0000               1040                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C88  4EB9 00001DE6           1041                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C8E  4EB9 000020FA           1042                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C94  4E75                    1043                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C96                          1044                  
00001C96  3400                    1045  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001C98  4EB9 00001E98           1046                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C9E  3202                    1047                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001CA0  4BF9 00002575           1048                  LEA         MSG_DR, A5                       ; loads D into A5
00001CA6  4EB9 00002244           1049                  JSR         PRINTNULL                        ; prints D
00001CAC  4EB9 000020FA           1050                  JSR         PRINTNUM                         ; prints register number
00001CB2  4BF9 00002585           1051                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001CB8  4EB9 00002244           1052                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001CBE  4BF9 00002575           1053                  LEA         MSG_DR, A5                       ; loads D into A5
00001CC4  4EB9 00002244           1054                  JSR         PRINTNULL                        ; prints out D 
00001CCA  323C 0000               1055                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CCE  4EB9 00001DE6           1056                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CD4  4EB9 000020FA           1057                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CDA  4E75                    1058                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CDC                          1059               
00001CDC  3200                    1060  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001CDE  C27C FF00               1061                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001CE2  B27C 6000               1062                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001CE6  6600 0024               1063                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001CEA                          1064                  
00001CEA  4BF9 0000256C           1065                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001CF0  4EB9 00002244           1066                  JSR     PRINTNULL                            ; prints BRA
00001CF6  4BF9 000025A4           1067                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001CFC  4EB9 00002244           1068                  JSR     PRINTNULL                            ; prints out spaces
00001D02                          1069  
00001D02  3400                    1070                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D04  4EB9 00001E58           1071                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D0A  4E75                    1072                  RTS
00001D0C                          1073                  
00001D0C                          1074  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001D0C  3200                    1075  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D0E  C27C F000               1076                  AND.W   #$F000,D1                            ; get top 4 bits
00001D12  B27C 6000               1077                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001D16  6600 0060               1078                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001D1A  3200                    1079                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D1C  C27C 0F00               1080                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001D20  E049                    1081                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001D22                          1082                  
00001D22  B27C 000E               1083                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001D26  6700 002A               1084                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001D2A                          1085                  
00001D2A  B27C 000F               1086                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001D2E  6700 0018               1087                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001D32                          1088                      
00001D32  B27C 0007               1089                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001D36  6700 0006               1090                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001D3A  6000 0078               1091                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001D3E                          1092     
00001D3E  4BF9 00002526           1093  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D44  6000 0016               1094                  BRA     PRINTBCC
00001D48                          1095  
00001D48  4BF9 0000253F           1096  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D4E  6000 000C               1097                  BRA     PRINTBCC
00001D52                          1098                  
00001D52  4BF9 00002535           1099  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D58  6000 0002               1100                  BRA     PRINTBCC
00001D5C                          1101  
00001D5C  4EB9 00002244           1102  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D62  4BF9 000025A4           1103                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D68  4EB9 00002244           1104                  JSR     PRINTNULL                            ; prints out spaces
00001D6E  3400                    1105                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D70  4EB9 00001E58           1106                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D76  4E75                    1107                  RTS              
00001D78                          1108                  
00001D78                          1109  
00001D78  3200                    1110  CASE_JSR        MOVE.W  D0,D1                                ; check if JSR mandatory bits exist
00001D7A  C27C FFC0               1111                  AND.W   #$FFC0,D1
00001D7E  B27C 4E80               1112                  CMP.W   #$4E80,D1
00001D82  6600 001A               1113                  BNE     CASE_RTS
00001D86                          1114                  
00001D86                          1115                  ;loads Register
00001D86  323C 0000               1116                  MOVE.W  #0,D1                               ; copies instruction word to D1
00001D8A  4EB9 00001DE6           1117                  JSR     GET_XN                              ; gets XN and puts in D1
00001D90  3601                    1118                  MOVE.W  D1,D3                               ; copies Xn to D3 so it won't be overwritten
00001D92                          1119                  
00001D92                          1120                  ;loads EA       
00001D92  323C 0000               1121                  MOVE.W #0,D1
00001D96  4EB9 00001DBC           1122                  JSR     GET_EA
00001D9C  3801                    1123                  MOVE.W  D1,D4       
00001D9E                          1124  
00001D9E  B07C 4E75               1125  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001DA2  6600 0010               1126                  BNE     CASE_DATA           ; checks the next case if not equal
00001DA6  4BF9 00002567           1127                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001DAC  4EB9 00002244           1128                  JSR     PRINTNULL           ; prints RTS                
00001DB2  4E75                    1129                  RTS                         ; returns from the subroutine
00001DB4                          1130  
00001DB4                          1131                  
00001DB4                          1132  
00001DB4  4EB8 198E               1133  CASE_DATA           JSR INV_INSTR  
00001DB8  4E75                    1134                      RTS               
00001DBA                          1135  
00001DBA  4E75                    1136  CASE_EPICFAIL       RTS
00001DBC                          1137  
00001DBC                          1138  
00001DBC                          1139  * Finds the EA type
00001DBC                          1140  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001DBC                          1141  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001DBC  48E7 3000               1142  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001DC0  4A41                    1143                      TST.W     D1                    ; compares D1 to 0
00001DC2  6700 000E               1144                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001DC6                          1145                      
00001DC6  343C 01C0               1146  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001DCA  363C 0006               1147                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001DCE  6000 000A               1148                      BRA       FINDTYPEEA            
00001DD2                          1149  
00001DD2  343C 0038               1150  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001DD6  363C 0003               1151                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001DDA                          1152  
00001DDA                          1153  
00001DDA  3200                    1154  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001DDC  C242                    1155                      AND.W     D2,D1                 ; applies bitmask to D1
00001DDE  E669                    1156                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001DE0  4CDF 000C               1157                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001DE4  4E75                    1158                      RTS                             ; returns from subroutine    
00001DE6                          1159                      
00001DE6                          1160  * Finds Xn type
00001DE6                          1161  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001DE6                          1162  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001DE6  48E7 3000               1163  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001DEA  4A41                    1164                      TST.W     D1                    ; compares D1 to 0
00001DEC  6700 000E               1165                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001DF0                          1166  
00001DF0  343C 0E00               1167  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001DF4  363C 0009               1168                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001DF8  6000 000A               1169                      BRA       FINDTYPEXN            ; finds the type of Xn
00001DFC                          1170  
00001DFC  343C 0007               1171  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001E00  363C 0000               1172                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001E04                          1173                      
00001E04  3200                    1174  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001E06  C242                    1175                      AND.W     D2,D1                 ; applies bitmask to D1
00001E08  E669                    1176                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E0A  4CDF 000C               1177                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E0E  4E75                    1178                      RTS                             ; returns from subroutine 
00001E10                          1179                      
00001E10                          1180  * Checks and gets the EA and Xn
00001E10                          1181  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001E10                          1182  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001E10  3207                    1183  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001E12  4EB8 1DBC               1184                  JSR     GET_EA                  ; Gets EA
00001E16  3401                    1185                  MOVE.W  D1,D2                   ; Stores EA in D2
00001E18  3207                    1186                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001E1A  4EB8 1DE6               1187                  JSR     GET_XN                  ; Gets Xn
00001E1E  3601                    1188                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001E20  3202                    1189                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001E22                          1190                  
00001E22  4EB9 00001F4A           1191                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001E28  B27C 0002               1192                  CMP.W   #2,D1                   ; checks if it is Xn
00001E2C  6700 0012               1193                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001E30  B27C 0001               1194                  CMP.W   #1,D1                   ; Checks if it is invalid
00001E34  6700 001C               1195                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001E38                          1196                  
00001E38                          1197                  
00001E38  323C 0000               1198  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001E3C  6000 0018               1199                  BRA     END_CHECKGET
00001E40                          1200        
00001E40                          1201  ; need XN
00001E40  2A4E                    1202  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001E42  3203                    1203                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001E44  4EB9 00001F4A           1204                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001E4A  4A41                    1205                  TST.W   D1                      ; checks if it is valid
00001E4C  67EA                    1206                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001E4E  6000 0002               1207                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001E52                          1208   
00001E52  323C 0001               1209  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001E56                          1210  
00001E56  4E75                    1211  END_CHECKGET    RTS          
00001E58                          1212                                            
00001E58                          1213                                            
00001E58                          1214  * Gets the displacement and pritns it 
00001E58                          1215  * Inputs: D2 = instruction word, A2 = address of next word
00001E58                          1216  * Outputs: prints out displacement
00001E58  48E7 4004               1217  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001E5C  3A4A                    1218                      MOVE.W    A2,A5                 ; copies A2 to A5
00001E5E  C47C 00FF               1219                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001E62  6600 0004               1220                      BNE       PRINTADDRESS          ; prints address if not 0
00001E66  341A                    1221                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001E68                          1222                      
00001E68  D44D                    1223  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001E6A  3202                    1224                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001E6C  183C 0000               1225                      MOVE.B    #0,D4                 ; marks address as word length
00001E70  4BF9 00002583           1226                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001E76  4EB9 00002244           1227                      JSR       PRINTNULL             ; prints null
00001E7C  4EB9 0000211E           1228                      JSR       PRINTSHORTLONGNUM     ; prints address
00001E82                          1229                      
00001E82  4CDF 2002               1230                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001E86                          1231                      
00001E86                          1232  
00001E86                          1233  * Gets the rotation value for ASd and LSd
00001E86                          1234  * Input: D2 = instruction word copy (of D0)                                    
00001E86                          1235  * Output: rotation  value in D2             
00001E86  C47C 0E00               1236  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001E8A  E04A                    1237                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E8C  E24A                    1238                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001E8E  4E75                    1239                      RTS                             ; return from subroutine
00001E90                          1240  
00001E90                          1241  * Gets the direction value for ASd and LSd
00001E90                          1242  * Input: D2 = instruction word copy (of D0)                                    
00001E90                          1243  * Output: direction value in D2             
00001E90  C47C 0100               1244  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001E94  E04A                    1245                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E96  4E75                    1246                      RTS                             ; return from subroutine
00001E98                          1247  
00001E98                          1248  * Gets the rotation size value for ASd and LSd
00001E98                          1249  * Input: D2 = instruction word copy (of D0)                                    
00001E98                          1250  * Output: rotation size value in D2             
00001E98  C47C 00C0               1251  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001E9C  EC4A                    1252                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E9E  4E75                    1253                      RTS                             ; return from subroutine
00001EA0                          1254  
00001EA0                          1255  * Gets the rotation location  value for ASd and LSd
00001EA0                          1256  * Input: D2 = instruction word copy (of D0)                                    
00001EA0                          1257  * Output: rotation location value in D2             
00001EA0  C47C 0020               1258  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001EA4  EA4A                    1259                      LSR.W      #5,D2                ; shifts 5 bits to the right to only have the rotation bits
00001EA6  4E75                    1260                      RTS                             ; return from subroutine
00001EA8                          1261  
00001EA8                          1262  * Prints out registers for MOVEM
00001EA8                          1263  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001EA8                          1264  * Output: printed out registers
00001EA8                          1265  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001EA8  48E7 0706               1266  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001EAC  3A3C 0000               1267                      MOVE.W     #0,D5                ; sets counter to 0
00001EB0  3E1A                    1268                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001EB2  B83C 0001               1269                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EB6  6600 0010               1270                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001EBA                          1271  
00001EBA  3C3C 0000               1272  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001EBE  4BF9 00002575           1273                      LEA        MSG_DR,A5            ; loads D to A5
00001EC4  6000 000C               1274                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001EC8                          1275                      
00001EC8  3C3C 0007               1276  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001ECC  4BF9 00002577           1277                      LEA        MSG_AR,A5            ; loads A to A5
00001ED2                          1278                      
00001ED2  E34F                    1279  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001ED4  6500 0018               1280                      BCS        PRINTREG             ; if pushes out a 1
00001ED8  DC44                    1281                      ADD.W      D4,D6                ; decrements or increments
00001EDA  5245                    1282                      ADD.W      #1,D5                ; increments D5
00001EDC  BA7C 0008               1283                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001EE0  66F0                    1284                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001EE2  B83C 0001               1285                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EE6  6600 0052               1286                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001EEA  6000 0042               1287                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001EEE                          1288                      
00001EEE  4EB9 00002244           1289  PRINTREG            JSR        PRINTNULL
00001EF4  3206                    1290                      MOVE.W     D6,D1
00001EF6  4EB9 000020FA           1291                      JSR        PRINTNUM 
00001EFC                          1292    
00001EFC  BE7C 0000               1293  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001F00  6600 0006               1294                      BNE        PRINTMORE            ; continue if there is more
00001F04  6000 0040               1295                      BRA        DONEPRINTINGREG      ; exit case
00001F08                          1296  
00001F08  2C4D                    1297  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001F0A  4BF9 00002588           1298                      LEA        MSG_SLASH,A5         ; leads / into A5
00001F10  4EB9 00002244           1299                      JSR        PRINTNULL            ; prints the slash
00001F16  2A4E                    1300                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001F18  DC44                    1301                      ADD.W      D4,D6                ; decrements or increments
00001F1A  5245                    1302                      ADD.W      #1,D5                ; increments D5
00001F1C  BA7C 0008               1303                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F20  66B0                    1304                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F22  B83C 0001               1305                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F26  6600 0012               1306                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F2A  6000 0002               1307                      BRA        REGTOMEM2            ; loops
00001F2E                          1308  
00001F2E  3C3C 0000               1309  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001F32  4BF9 00002577           1310                      LEA        MSG_AR,A5            ; loads A to A5
00001F38  6098                    1311                      BRA        PRINTREGISTERLOOP    ; loops
00001F3A                          1312  
00001F3A  3C3C 0007               1313  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001F3E  4BF9 00002575           1314                      LEA        MSG_DR,A5            ; loads D to A5
00001F44  608C                    1315                      BRA        PRINTREGISTERLOOP    ; loops
00001F46                          1316  
00001F46  4CDF 60E0               1317  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001F4A                          1318  
00001F4A                          1319                          
00001F4A                          1320  * Checks if EA or Xn is valid
00001F4A                          1321  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001F4A                          1322  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001F4A  2F02                    1323  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001F4C                          1324  
00001F4C  141D                    1325  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001F4E  B43C 00FF               1326                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001F52  6700 000A               1327                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001F56  B202                    1328                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001F58  6700 000C               1329                     BEQ        VALIDEA               ; branches to valid EA
00001F5C  60EE                    1330                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001F5E                          1331                     
00001F5E  323C 0001               1332  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001F62  6000 0016               1333                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001F66                          1334                    
00001F66  B43C 0007               1335  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001F6A  6700 000A               1336                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001F6E  323C 0000               1337                     MOVE.W     #$0,D1                ; marks that it is valid
00001F72  6000 0006               1338                     BRA        CHECKEAEXIT           ; exits the subroutine
00001F76                          1339  
00001F76  323C 0002               1340  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001F7A                          1341  
00001F7A  241F                    1342  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001F7C  4E75                    1343                     RTS                              ; returns from subroutine
00001F7E                          1344  
00001F7E                          1345  * Converts EA and Xn into a string                                
00001F7E                          1346  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001F7E                          1347  * Outputs: Prints out EA and Xn into a string
00001F7E  48E7 C004               1348  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001F82  B47C 0001               1349                     CMP.W    #An,D2                  ; checks if it is An
00001F86  6700 003A               1350                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001F8A                          1351                     
00001F8A  B47C 0002               1352                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001F8E  6700 004A               1353                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001F92                          1354                     
00001F92  B47C 0003               1355                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001F96  6700 0072               1356                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001F9A                          1357                     
00001F9A  B47C 0004               1358                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001F9E  6700 00A6               1359                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001FA2                          1360                     
00001FA2  B47C 0007               1361                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001FA6  6700 00DA               1362                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001FAA                          1363                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001FAA                          1364  
00001FAA                          1365  * data register, Dn
00001FAA  4BF9 00002575           1366  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001FB0  4EB9 00002244           1367                     JSR      PRINTNULL               ; Prints D
00001FB6  3203                    1368                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FB8  4EB9 000020FA           1369                     JSR      PRINTNUM                ; Prints the Xn
00001FBE  6000 0134               1370                     BRA      EA_TO_STRING_EXIT       ; exits           
00001FC2                          1371  
00001FC2                          1372  
00001FC2                          1373  * address register
00001FC2  4BF9 00002577           1374  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001FC8  4EB9 00002244           1375                     JSR      PRINTNULL               ; Prints A
00001FCE  3203                    1376                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FD0  4EB9 000020FA           1377                     JSR      PRINTNUM                ; Prints the Xn
00001FD6  6000 011C               1378                     BRA      EA_TO_STRING_EXIT       ; exits
00001FDA                          1379  
00001FDA                          1380  * address register indirect
00001FDA  4BF9 00002579           1381  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001FE0  4EB9 00002244           1382                     JSR      PRINTNULL               ; Prints (
00001FE6  4BF9 00002577           1383                     LEA      MSG_AR,A5               ; Loads A into A5
00001FEC  4EB9 00002244           1384                     JSR      PRINTNULL               ; Prints A
00001FF2  3203                    1385                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FF4  4EB9 000020FA           1386                     JSR      PRINTNUM                ; Prints the Xn
00001FFA  4BF9 0000257B           1387                     LEA      MSG_RB,A5               ; Loads ) into A5
00002000  4EB9 00002244           1388                     JSR      PRINTNULL               ; Prints )
00002006  6000 00EC               1389                     BRA      EA_TO_STRING_EXIT       ; exits
0000200A                          1390  
0000200A                          1391  * address register indirect post increment
0000200A  4BF9 00002579           1392  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00002010  4EB9 00002244           1393                     JSR      PRINTNULL               ; Prints (
00002016  4BF9 00002577           1394                     LEA      MSG_AR,A5               ; Loads A into A5
0000201C  4EB9 00002244           1395                     JSR      PRINTNULL               ; Prints A
00002022  3203                    1396                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002024  4EB9 000020FA           1397                     JSR      PRINTNUM                ; Prints the Xn
0000202A  4BF9 0000257B           1398                     LEA      MSG_RB,A5               ; Loads ) into A5
00002030  4EB9 00002244           1399                     JSR      PRINTNULL               ; Prints )
00002036  4BF9 0000257D           1400                     LEA      MSG_PLUS,A5             ; Loads + into A5
0000203C  4EB9 00002244           1401                     JSR      PRINTNULL               ; Prints +
00002042  6000 00B0               1402                     BRA      EA_TO_STRING_EXIT       ; exits
00002046                          1403  
00002046                          1404  
00002046                          1405  * address register indirect pre increment
00002046  4BF9 0000257F           1406  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
0000204C  4EB9 00002244           1407                     JSR      PRINTNULL               ; Prints -
00002052  4BF9 00002579           1408                     LEA      MSG_LB,A5               ; Loads ( into A5
00002058  4EB9 00002244           1409                     JSR      PRINTNULL               ; Prints (
0000205E  4BF9 00002577           1410                     LEA      MSG_AR,A5               ; Loads A into A5
00002064  4EB9 00002244           1411                     JSR      PRINTNULL               ; Prints A
0000206A  3203                    1412                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000206C  4EB9 000020FA           1413                     JSR      PRINTNUM                ; Prints the Xn
00002072  4BF9 0000257B           1414                     LEA      MSG_RB,A5               ; Loads ) into A5
00002078  4EB9 00002244           1415                     JSR      PRINTNULL               ; Prints )
0000207E  6000 0074               1416                     BRA      EA_TO_STRING_EXIT       ; exits
00002082                          1417  
00002082                          1418  * other (long, short, immediate) with Xn yes
00002082  301A                    1419  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00002084  B67C 0000               1420                     CMP.W    #ABSShort,D3            ; checks if it is a word
00002088  6700 002E               1421                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
0000208C                          1422                     
0000208C  B67C 0001               1423                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00002090  6700 0042               1424                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00002094                          1425  
00002094                          1426  * immediate
00002094  4BF9 00002581           1427  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
0000209A  4EB9 00002244           1428                     JSR      PRINTNULL               ; Prints #  
000020A0  4BF9 00002583           1429                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020A6  4EB9 00002244           1430                     JSR      PRINTNULL               ; Prints $
000020AC  3200                    1431                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020AE  4EB9 0000210A           1432                     JSR      PRINTHEXNUM 
000020B4  6000 003E               1433                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
000020B8                          1434                     
000020B8                          1435  * word address
000020B8                          1436  CASE_WORD          
000020B8  4BF9 00002583           1437                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020BE  4EB9 00002244           1438                     JSR      PRINTNULL               ; Prints $
000020C4  3200                    1439                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020C6  383C 0000               1440                     MOVE.W   #0, D4                  ; moves length size (word) into d4
000020CA  4EB9 0000211E           1441                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000020D0  6000 0022               1442                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
000020D4                          1443  
000020D4                          1444  * long address 
000020D4                          1445  CASE_LONG          
000020D4  4BF9 00002583           1446                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020DA  4EB9 00002244           1447                     JSR      PRINTNULL               ; Prints $
000020E0  3200                    1448                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020E2  383C 0001               1449                     MOVE.W   #1, D4                  ; moves length size (long) into d4
000020E6  4EB9 0000211E           1450                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000020EC  321A                    1451                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
000020EE  4EB9 000020FA           1452                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
000020F4                          1453  
000020F4                          1454  
000020F4                          1455  * exits subroutine
000020F4  4CDF 2003               1456  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
000020F8  4E75                    1457                      RTS                              ; returns from subroutine
000020FA                          1458  
000020FA                          1459  * Prints out the content of D1 as a decimal number
000020FA                          1460  * Input: number in D1 to be printed
000020FA                          1461  * Output: contents of D1 printed
000020FA  48E7 C000               1462  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000020FE  103C 0003               1463                   MOVE.B      #3,D0               ; prints D1
00002102  4E4F                    1464                   TRAP        #15                 ; is trap task 3
00002104                          1465              
00002104  4CDF 0003               1466                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00002108  4E75                    1467                   RTS                             ; returns from subroutine
0000210A                          1468                   
0000210A                          1469  * Prints out the content of D1 as a hex number
0000210A                          1470  * Input: number in D1 to be printed
0000210A                          1471  * Output: contents of D1 printed
0000210A  48E7 C000               1472  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000210E  143C 0010               1473                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002112  103C 000F               1474                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002116  4E4F                    1475                   TRAP        #15                 ; is trap task 15
00002118  4CDF 0003               1476                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000211C  4E75                    1477                   RTS                             ; returns from subroutine
0000211E                          1478                   
0000211E                          1479  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
0000211E                          1480  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
0000211E                          1481  * Output: contents of D1 printed
0000211E  48E7 E000               1482  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00002122  B83C 0001               1483                            CMP.B       #1,D4               ; checks size of number
00002126  6700 0042               1484                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
0000212A                          1485  
0000212A  3401                    1486  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
0000212C  C47C F000               1487                            AND.W       #$F000,D2           ; gets the first digit
00002130  B47C 0000               1488                            CMP.W       #0, D2              ; checks if it is 0
00002134  6600 00DC               1489                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002138  4EB9 00002222           1490                            JSR         PRINTZERO           ; prints a zero
0000213E                          1491                            
0000213E  3401                    1492                            MOVE.W      D1,D2               ; copies number to D2
00002140  C47C 0F00               1493                            AND.W       #$0F00,D2           ; gets the second digit
00002144  B47C 0000               1494                            CMP.W       #0, D2              ; checks if it is 0
00002148  6600 00C8               1495                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000214C  4EB9 00002222           1496                            JSR         PRINTZERO           ; prints a zero
00002152                          1497                            
00002152  3401                    1498                            MOVE.W      D1,D2               ; copies number to D2
00002154  C47C 00F0               1499                            AND.W       #$00F0,D2           ; gets the third digit
00002158  B47C 0000               1500                            CMP.W       #0, D2              ; checks if it is 0
0000215C  6600 00B4               1501                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002160  4EB9 00002222           1502                            JSR         PRINTZERO           ; prints a zero
00002166  6000 00AA               1503                            BRA         PRINTASHEX          ; prints last digit
0000216A                          1504                            
0000216A  2401                    1505  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
0000216C  C4BC F0000000           1506                            AND.L       #$F0000000,D2       ; gets the first digit
00002172  B4BC 00000000           1507                            CMP.L       #0, D2              ; checks if it is 0
00002178  6600 0098               1508                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000217C  4EB9 00002222           1509                            JSR         PRINTZERO           ; prints a zero
00002182                          1510                            
00002182  2401                    1511                            MOVE.L      D1,D2               ; copies number to D2
00002184  C4BC 0F000000           1512                            AND.L       #$0F000000,D2       ; gets the second digit
0000218A  B4BC 00000000           1513                            CMP.L       #0, D2              ; checks if it is 0
00002190  6600 0080               1514                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002194  4EB9 00002222           1515                            JSR         PRINTZERO           ; prints a zero
0000219A                          1516                            
0000219A  2401                    1517                            MOVE.L      D1,D2               ; copies number to D2
0000219C  C4BC 00F00000           1518                            AND.L       #$00F00000,D2       ; gets the third digit
000021A2  B4BC 00000000           1519                            CMP.L       #0, D2              ; checks if it is 0
000021A8  6600 0068               1520                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021AC  4EB9 00002222           1521                            JSR         PRINTZERO           ; prints a zero
000021B2                          1522                            
000021B2  2401                    1523                            MOVE.L      D1,D2               ; copies number to D2
000021B4  C4BC 000F0000           1524                            AND.L       #$000F0000,D2       ; gets the fourth digit
000021BA  B4BC 00000000           1525                            CMP.L       #0, D2              ; checks if it is 0
000021C0  6600 0050               1526                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021C4  4EB9 00002222           1527                            JSR         PRINTZERO           ; prints a zero
000021CA                          1528                            
000021CA  2401                    1529                            MOVE.L      D1,D2               ; copies number to D2
000021CC  C4BC 0000F000           1530                            AND.L       #$0000F000,D2       ; gets the fith digit
000021D2  B4BC 00000000           1531                            CMP.L       #0, D2              ; checks if it is 0
000021D8  6600 0038               1532                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021DC  4EB9 00002222           1533                            JSR         PRINTZERO           ; prints a zero
000021E2                          1534                            
000021E2  2401                    1535                            MOVE.L      D1,D2               ; copies number to D2
000021E4  C4BC 00000F00           1536                            AND.L       #$00000F00,D2       ; gets the sixth digit
000021EA  B4BC 00000000           1537                            CMP.L       #0, D2              ; checks if it is 0
000021F0  6600 0020               1538                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021F4  4EB9 00002222           1539                            JSR         PRINTZERO           ; prints a zero
000021FA                          1540                            
000021FA  2401                    1541                            MOVE.L      D1,D2               ; copies number to D2
000021FC  C4BC 000000F0           1542                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002202  B4BC 00000000           1543                            CMP.L       #0, D2              ; checks if it is 0
00002208  6600 0008               1544                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000220C  4EB9 00002222           1545                            JSR         PRINTZERO           ; prints a zero
00002212                          1546  
00002212  143C 0010               1547  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002216  103C 000F               1548                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000221A  4E4F                    1549                            TRAP        #15                 ; is trap task 15
0000221C  4CDF 0007               1550                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002220  4E75                    1551                            RTS                             ; returns from subroutine    
00002222                          1552  * Prints a zero
00002222                          1553  * Input: nothing
00002222                          1554  * Output: 0 printed out to the console
00002222  2F01                    1555  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002224  7200                    1556                            MOVE.L      #0,D1               ; moves 0 to D1
00002226  4EB8 20FA               1557                            JSR         PRINTNUM            ; prints the number
0000222A  221F                    1558                            MOVE.L      (SP)+,D1            ; restores D1
0000222C  4E75                    1559                            RTS                             ; returns from subroutine
0000222E                          1560              
0000222E                          1561  * Prints contents of things between a range
0000222E                          1562  * input: A5, A6 (the range)
0000222E                          1563  * output: prints memory contents from A5 to A6 as strings   
0000222E  48E7 C040               1564  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00002232  224D                    1565                  MOVEA.L     A5, A1           ; loads A5 into A1
00002234  9DCD                    1566                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00002236  320E                    1567                  MOVE.W      A6, D1           ; move n into D1
00002238  103C 0001               1568                  MOVE.B      #1, D0           ; display n characters of string at A1
0000223C  4E4F                    1569                  TRAP        #15              ; is trap task 1
0000223E  4CDF 0203               1570                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00002242  4E75                    1571                  RTS                          ; returns
00002244                          1572      
00002244                          1573  * Prints null terminated string
00002244                          1574  * input: string pointed to by A5
00002244                          1575  * output: prints out the null terminated string
00002244  48E7 8040               1576  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002248  224D                    1577                  MOVE.L      A5,A1           ; loads A5 into A1
0000224A  103C 000E               1578                  MOVE.B      #14,D0          ; prints null terminated string
0000224E  4E4F                    1579                  TRAP        #15             ; is trap task 10
00002250  4CDF 0201               1580                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00002254  4E75                    1581                  RTS                         ; returns from subroutine
00002256                          1582                  
00002256  2F0D                    1583  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002258  4BF9 000024B4           1584                  LEA         NEW_LINE,A5     ; Prints null
0000225E  4EB8 2244               1585                  JSR         PRINTNULL       ; prints the new line
00002262  2A5F                    1586                  MOVE.L      (SP)+,A5        ; returns A5
00002264  4E75                    1587                  RTS
00002266                          1588  
00002266                          1589  * Prints the size of the MOVE or MOVEA operation  
00002266                          1590  * input: D0
00002266                          1591  * output: prints out the size of a MOVE or MOVEA operation        
00002266  48E7 8004               1592  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
0000226A  3200                    1593                  MOVE.W  D0,D1               ; stores d0 in d1
0000226C  C07C 3000               1594                  AND.W   #$3000,D0           ; gets the size
00002270  B07C 2000               1595                  CMP.W   #$2000,D0           ; checks if is long
00002274  6700 001E               1596                  BEQ     MOVE_LONG
00002278  B07C 3000               1597                  CMP.W   #$3000,D0           ; checks if is word
0000227C  6700 000C               1598                  BEQ     MOVE_WORD      
00002280                          1599                  
00002280  4BF9 000025AC           1600  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00002286  6000 0012               1601                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000228A                          1602  
0000228A  4BF9 000025AF           1603  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00002290  6000 0008               1604                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002294                          1605  
00002294  4BF9 000025B2           1606  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
0000229A                          1607                  
0000229A  4EB8 2244               1608  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
0000229E  4CDF 2001               1609                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000022A2  4E75                    1610                  RTS
000022A4                          1611  
000022A4  43F9 00002423           1612  ERROR           LEA     ERROR_MSG,A1
000022AA  103C 000E               1613                  MOVE.B  #14,D0
000022AE  4E4F                    1614                  TRAP    #15 
000022B0                          1615  
000022B0  7069                    1616  DELETEME        MOVEQ   #$69, D0
000022B2  7212                    1617                  MOVEQ   #$12, D1
000022B4  7450                    1618                  MOVEQ   #$50, D2
000022B6  760F                    1619                  MOVEQ   #$0F, D3
000022B8  787D                    1620                  MOVEQ   #$7D, D4  
000022BA  7A8E                    1621                  MOVEQ   #$8E, D5
000022BC  7C4C                    1622                  MOVEQ   #$4C, D6
000022BE  7EAB                    1623                  MOVEQ   #$AB, D7
000022C0                          1624            
000022C0  FFFF FFFF               1625      SIMHALT             ; halt simulator
000022C4                          1626  
000022C4                          1627  * Put variables and constants here
000022C4                          1628  
000022C4  =0000000D               1629  CR                              EQU     $0D
000022C4  =0000000A               1630  LF                              EQU     $0A 
000022C4  =00000009               1631  TAB                             EQU     $09  
000022C4                          1632  
000022C4                          1633  * Addressing Modes
000022C4  =00000000               1634  Dn                              EQU     0
000022C4  =00000001               1635  An                              EQU     1
000022C4  =00000002               1636  AnIndirect                      EQU     2
000022C4  =00000003               1637  AnPost                          EQU     3
000022C4  =00000004               1638  AnPre                           EQU     4
000022C4  =00000007               1639  Other                           EQU     7           ; short, long, immediate
000022C4                          1640  
000022C4                          1641  * Xn
000022C4  =00000000               1642  ABSShort                        EQU     0
000022C4  =00000001               1643  ABSLong                         EQU     1
000022C4  =00000004               1644  XnImmediate                     EQU     4
000022C4                          1645  
000022C4                          1646  * Valid Addressing Modes
000022C4= 00 01 02 03 04 07 FF    1647  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
000022CB                          1648  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
000022CB= 00 02 03 04 07 FF       1649  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022D1= 02 04 07 FF             1650  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
000022D5= 02 03 07 FF             1651  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
000022D9= 02 03 04 07 FF          1652  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022DE= 00 02 03 04 07 FF       1653  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022E4= 01 07 FF                1654  VALIDEA_LEA                     DC.B    An,Other,-1
000022E7= 00 02 03 04 07 FF       1655  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022ED= 02 03 04 07 FF          1656  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022F2= 02 03 04 07 FF          1657  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
000022F7= 02 07 FF                1658  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
000022FA                          1659  
000022FA                          1660  * Valid Xn
000022FA= 00 01 04 FF             1661  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
000022FE                          1662  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
000022FE= 00 01 FF                1663  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00002301                          1664  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00002301                          1665  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00002301                          1666  
00002301                          1667  * posible memory ASd/LSd rotation values
00002301  =00000000               1668  ASd_MEM                         EQU     0   
00002301  =00000001               1669  LSd_MEM                         EQU     1 
00002301  =00000003               1670  ROd_MEM                         EQU     3
00002301                          1671   
00002301  =00000000               1672  ASd_REG                         EQU     0   
00002301  =00000001               1673  LSd_REG                         EQU     1 
00002301  =00000003               1674  ROd_REG                         EQU     3
00002301                          1675  
00002301                          1676  * Messages
00002301= 57 65 6C 63 6F 6D ...   1677  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
00002329= 46 6F 72 6D 61 74 ...   1678  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
00002374= 4C 65 74 74 65 72 ...   1679  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
00002394= 50 6C 65 61 73 65 ...   1680  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
000023CB= 50 6C 65 61 73 65 ...   1681  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00002401= 49 6E 76 61 6C 69 ...   1682  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002423= 45 72 72 6F 72 20 ...   1683  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
0000243F= 09 44 41 54 41 00       1684  INVALID_INSTR                   DC.B    TAB,'DATA',0
00002445= 46 69 6E 69 73 68 ...   1685  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
00002489= 0D 0A 50 72 65 73 ...   1686  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
000024B4= 0D 0A 00                1687  NEW_LINE                        DC.B    CR,LF,0
000024B7= 09 09 09 00             1688  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000024BB                          1689  
000024BB                          1690  * Opcode Messages
000024BB= 09 4E 4F 50 00          1691  MSG_NOP                         DC.B    TAB,'NOP',0
000024C0= 09 4D 4F 56 45 00       1692  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000024C6= 09 4D 4F 56 45 41 00    1693  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000024CD= 09 4D 4F 56 45 51 00    1694  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000024D4= 09 4D 4F 56 45 4D 00    1695  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000024DB= 09 41 44 44 00          1696  MSG_ADD                         DC.B    TAB,'ADD',0
000024E0= 09 41 44 44 41 00       1697  MSG_ADDA                        DC.B    TAB,'ADDA',0
000024E6= 09 41 44 44 51 00       1698  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
000024EC= 09 53 55 42 00          1699  MSG_SUB                         DC.B    TAB,'SUB',0
000024F1= 09 4D 55 4C 53 00       1700  MSG_MULS                        DC.B    TAB,'MULS',0
000024F7= 09 44 49 56 55 00       1701  MSG_DIVU                        DC.B    TAB,'DIVU',0
000024FD= 09 4C 45 41 00          1702  MSG_LEA                         DC.B    TAB,'LEA',0
00002502= 09 41 4E 44 00          1703  MSG_AND                         DC.B    TAB,'AND',0
00002507= 09 4F 52 00             1704  MSG_OR                          DC.B    TAB,'OR',0
0000250B= 09 4E 4F 54 00          1705  MSG_NOT                         DC.B    TAB,'NOT',0
00002510= 09 4C 53 00             1706  MSG_LSd                         DC.B    TAB,'LS',0
00002514= 09 41 53 00             1707  MSG_ASd                         DC.B    TAB,'AS',0
00002518= 09 52 4F 00             1708  MSG_ROd                         DC.B    TAB,'RO',0
0000251C= 09 42 43 43 00          1709  MSG_BCC                         DC.B    TAB,'BCC',0
00002521= 09 42 43 53 00          1710  MSG_BCS                         DC.B    TAB,'BCS',0
00002526= 09 42 45 51 00          1711  MSG_BEQ                         DC.B    TAB,'BEQ',0
0000252B= 09 42 4E 45 00          1712  MSG_BNE                         DC.B    TAB,'BNE',0
00002530= 09 42 47 45 00          1713  MSG_BGE                         DC.B    TAB,'BGE',0
00002535= 09 42 47 54 00          1714  MSG_BGT                         DC.B    TAB,'BGT',0
0000253A= 09 42 48 49 00          1715  MSG_BHI                         DC.B    TAB,'BHI',0
0000253F= 09 42 4C 45 00          1716  MSG_BLE                         DC.B    TAB,'BLE',0
00002544= 09 42 4C 53 00          1717  MSG_BLS                         DC.B    TAB,'BLS',0
00002549= 09 42 4C 54 00          1718  MSG_BLT                         DC.B    TAB,'BLT',0
0000254E= 09 42 4D 49 00          1719  MSG_BMI                         DC.B    TAB,'BMI',0
00002553= 09 42 50 4C 00          1720  MSG_BPL                         DC.B    TAB,'BPL',0
00002558= 09 42 56 43 00          1721  MSG_BVC                         DC.B    TAB,'BVC',0
0000255D= 09 42 56 53 00          1722  MSG_BVS                         DC.B    TAB,'BVS',0
00002562= 09 4A 53 52 00          1723  MSG_JSR                         DC.B    TAB,'JSR',0
00002567= 09 52 54 53 00          1724  MSG_RTS                         DC.B    TAB,'RTS',0
0000256C= 09 42 52 41 00          1725  MSG_BRA                         DC.B    TAB,'BRA',0
00002571                          1726  
00002571                          1727  * Direction for LSd and ASd
00002571= 52 00                   1728  MSG_RIGHT                       DC.B    'R',0
00002573= 4C 00                   1729  MSG_LEFT                        DC.B    'L',0
00002575                          1730  
00002575                          1731  * Effective Addresses Messages
00002575= 44 00                   1732  MSG_DR                          DC.B    'D',0
00002577= 41 00                   1733  MSG_AR                          DC.B    'A',0
00002579= 28 00                   1734  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
0000257B= 29 00                   1735  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
0000257D= 2B 00                   1736  MSG_PLUS                        DC.B    '+',0
0000257F= 2D 00                   1737  MSG_MINUS                       DC.B    '-',0
00002581= 23 00                   1738  MSG_POUND                       DC.B    '#',0 
00002583= 24 00                   1739  MSG_HEX                         DC.B    '$',0 
00002585= 2C 20 00                1740  MSG_COMMA                       DC.B    ', ',0
00002588= 2F 00                   1741  MSG_SLASH                       DC.B    '/',0  
0000258A= 20 00                   1742  MSG_SPACE                       DC.B    ' ',0
0000258C= 09 00                   1743  MSG_TAB                         DC.B    TAB,0
0000258E= 20 20 20 00             1744  MSG_3SPACES                     DC.B    '   ',0
00002592= 20 20 20 20 00          1745  MSG_4SPACES                     DC.B    '    ',0
00002597= 20 20 20 20 20 00       1746  MSG_5SPACES                     DC.B    '     ',0
0000259D= 20 20 20 20 20 20 00    1747  MSG_6SPACES                     DC.B    '      ',0
000025A4= 20 20 20 20 20 20 ...   1748  MSG_7SPACES                     DC.B    '       ',0
000025AC                          1749  
000025AC                          1750  * Size Messages
000025AC= 2E 42 00                1751  MSG_B                           DC.B    '.B',0
000025AF= 2E 57 00                1752  MSG_W                           DC.B    '.W',0
000025B2= 2E 4C 00                1753  MSG_L                           DC.B    '.L',0
000025B5                          1754  
000025B5                          1755  * Variables
000025B5  =00000100               1756  STARTING_ADDRESS                EQU     $100
000025B5  =00000150               1757  ENDING_ADDRESS                  EQU     $150
000025B5  =00000200               1758  CURRENT_INSTR                   EQU     $200
000025B5  =00000250               1759  REG_VAR                         EQU     $250 * Hold bits 11-9
000025B5  =00000300               1760  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000025B5  =00000350               1761  EA_MODE                         EQU     $350 * Hold bits 5-3
000025B5  =00000400               1762  EA_REG                          EQU     $400 * Hold bits 2-0
000025B5= 00                      1763  LINE_COUNT                      DC.B     0
000025B6= 14                      1764  LINE_MAX                        DC.B     20
000025B7                          1765              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1674
ADDQ_BYTE           1712
ADDQ_LONG           174A
ADDQ_WORD           172E
ADD_SUB_BYTE        15A4
ADD_SUB_HELP        151E
ADD_SUB_LONG        15C0
ADD_SUB_OPERAND     15D6
ADD_SUB_SIZE        1580
ADD_SUB_WORD        15B2
AN                  1
AND_BYTE            1930
AND_LONG            1968
AND_WORD            194C
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           2401
CASE_ADD            14F6
CASE_ADDA           163C
CASE_ADDQ           16BC
CASE_AND            18EA
CASE_AR             1FC2
CASE_ARI            1FDA
CASE_ARIPOST        200A
CASE_ARIPRE         2046
CASE_ASDMEM         1AD0
CASE_ASDREG         1BA4
CASE_BCC            1D0C
CASE_BEQ            1D3E
CASE_BGT            1D52
CASE_BLE            1D48
CASE_BRA            1CDC
CASE_DATA           1DB4
CASE_DR             1FAA
CASE_EPICFAIL       1DBA
CASE_IMMEDIATE      2094
CASE_JSR            1D78
CASE_LEA            184C
CASE_LEFTMEM        1AF6
CASE_LEFTREG        1BCA
CASE_LONG           20D4
CASE_LSDASDROD      1A90
CASE_LSDMEM         1AC6
CASE_LSDREG         1B9A
CASE_MOVE           1296
CASE_MOVEM          135C
CASE_MOVEQ          146E
CASE_NOP            1280
CASE_NOT            1A2C
CASE_OR             19CC
CASE_OTHER          2082
CASE_RIGHTMEM       1B00
CASE_RIGHTREG       1BD4
CASE_RODMEM         1ADA
CASE_RODREG         1BAE
CASE_RTS            1D9E
CASE_SHIFTMEM       1AAE
CASE_SHIFTREG       1B80
CASE_SUB            17B4
CASE_SUBA           1836
CASE_WORD           20B8
CHECKEAEXIT         1F7A
CHECKEAMLOOP        1F4C
CHECKEAXN_IFVALID   1F4A
CHECKGET_EAXN       1E10
CHECKMEMSOURE       1B40
CHECKMOREBITS       1EFC
CHECKSHIFT_XN       1B6A
CHECK_LENGTH        11CE
CHECK_LINE          1176
CHECK_ODD           1264
CHECK_ORDER         10AE
CHECK_XN            1E40
CLEAR_SCREEN        11AA
COMPLETE_REGIM      1C4C
CONCAT              1216
CONTINUE            2489
CONVERT             11E0
CR                  D
CURRENT_INSTR       200
DELETEME            22B0
DESTEA              1DC6
DESTXN              1DF0
DISASSEMBLE         10C4
DN                  0
DN_PLUS_EA          1610
DONE                2445
DONEPRINTINGREG     1F46
EASHIFT_VALID       1B5E
EAXN_INVALID        1E52
EAXN_VALID          1E38
EA_MODE             350
EA_REG              400
EA_TO_STRING        1F7E
EA_TO_STRING_EXIT   20F4
ENDING              23CB
ENDING_ADDRESS      150
END_CHECKGET        1E56
ERROR               22A4
ERROR_MSG           2423
FINDTYPEEA          1DDA
FINDTYPEXN          1E04
FINISHED            10E8
FINISHMOVE          229A
FINISH_ADD          15CE
FINISH_ADDA         1690
FINISH_ADDQ         1766
FINISH_AND          1984
FINISH_SUB          17FC
FINISH_SUBA         1802
FORMAT1             2329
FORMAT2             2374
GETDIRECTION        1E90
GETDISPLACEMENT     1E58
GETMEMSOURCE        1B28
GETROTATION         1E86
GETROTATIONLOCATION  1EA0
GETROTATIONSIZE     1E98
GET_EA              1DBC
GET_XN              1DE6
INPUT1              1020
INPUT2              1066
INSERTA             131C
INVALID             122E
INVALIDEA           1F5E
INVALID_INSTR       243F
INV_INSTR           198E
ISNUMBER            11F6
LF                  A
LINE_COUNT          25B5
LINE_MAX            25B6
LSD_MEM             1
LSD_REG             1
MAKESHIFT8          1C48
MEM2REGLONG         1432
MEM2REGWORD         1422
MEMTOREG1           1EC8
MEMTOREG2           1F3A
MOVEM_MEM2REG       13EE
MOVEM_REG2MEM       137A
MOVE_BYTE           2280
MOVE_LONG           2294
MOVE_WORD           228A
MSG_3SPACES         258E
MSG_4SPACES         2592
MSG_5SPACES         2597
MSG_6SPACES         259D
MSG_7SPACES         25A4
MSG_ADD             24DB
MSG_ADDA            24E0
MSG_ADDQ            24E6
MSG_AND             2502
MSG_AR              2577
MSG_ASD             2514
MSG_B               25AC
MSG_BCC             251C
MSG_BCS             2521
MSG_BEQ             2526
MSG_BGE             2530
MSG_BGT             2535
MSG_BHI             253A
MSG_BLE             253F
MSG_BLS             2544
MSG_BLT             2549
MSG_BMI             254E
MSG_BNE             252B
MSG_BPL             2553
MSG_BRA             256C
MSG_BVC             2558
MSG_BVS             255D
MSG_COMMA           2585
MSG_DIVU            24F7
MSG_DR              2575
MSG_HEX             2583
MSG_JSR             2562
MSG_L               25B2
MSG_LB              2579
MSG_LEA             24FD
MSG_LEFT            2573
MSG_LSD             2510
MSG_MINUS           257F
MSG_MOVE            24C0
MSG_MOVEA           24C6
MSG_MOVEM           24D4
MSG_MOVEQ           24CD
MSG_MULS            24F1
MSG_NOP             24BB
MSG_NOT             250B
MSG_OR              2507
MSG_PLUS            257D
MSG_POUND           2581
MSG_RB              257B
MSG_RIGHT           2571
MSG_ROD             2518
MSG_RTS             2567
MSG_SLASH           2588
MSG_SPACE           258A
MSG_SUB             24EC
MSG_TAB             258C
MSG_W               25AF
NEW_LINE            24B4
NEXT_SCREEN         118A
NOTNUMBER           11FE
OPCODE_DECODE       1278
OPMODE_VAR          300
OR_SIZE             1A14
OTHER               7
OTHEREA             1F76
PRINTADD            155C
PRINTADDRESS        1E68
PRINTASHEX          2212
PRINTBCC            1D5C
PRINTENTER          2256
PRINTHEXNUM         210A
PRINTLONGZERO       216A
PRINTMEM2REG        143E
PRINTMORE           1F08
PRINTMOVE           133A
PRINTMOVESIZE       2266
PRINTNULL           2244
PRINTNUM            20FA
PRINTRANGE          222E
PRINTREG            1EEE
PRINTREG2MEM        13BE
PRINTREGEA          1C16
PRINTREGISTERLOOP   1ED2
PRINTREGISTERS      1EA8
PRINTREGSIZE        1BE4
PRINTSHIFTMEM       1AE0
PRINTSHIFTREG       1BB4
PRINTSHORTLONGNUM   211E
PRINTSHORTZERO      212A
PRINTSUB            17CA
PRINTZERO           2222
PRINT_8             17A8
PRINT_ADDQ_DATA     1784
PRINT_ADDR          126C
PRINT_MEMDIR        1B06
PRINT_MOVEQ         1490
PRINT_REGDIR        1BDE
READ_KEY            119A
REG2MEMLONG         13B8
REG2MEMWORD         13AE
REGTOMEM1           1EBA
REGTOMEM2           1F2E
REG_BYTE            1BFC
REG_IMMEDIATE       1C38
REG_LONG            1C10
REG_REGISTER        1C96
REG_VAR             250
REG_WORD            1C06
RESET_INPUT         11C6
RESTART             1110
RETURN              122C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1DD2
SOURCEXN            1DFC
START               1000
STARTING            2394
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          124C
THREE_TAB           24B7
VALIDEA             1F66
VALIDEA_ADDSUB_DESTOPERAND  22D9
VALIDEA_ALL         22C4
VALIDEA_ANDORNOT    22E7
VALIDEA_ANDOR_DESTOPERAND  22ED
VALIDEA_JSR         22F7
VALIDEA_LEA         22E4
VALIDEA_MOVEM_MEMTOREG  22D5
VALIDEA_MOVEM_REGTOMEM  22D1
VALIDEA_MOVEQ       22CB
VALIDEA_MULSDIVU    22DE
VALIDEA_SHIFT       22F2
VALIDXN_ALL         22FA
VALIDXN_SHORTLONG   22FE
WELCOME             2301
XNIMMEDIATE         4
