00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 7:28:53 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/10/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00002363             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 0000238B             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 000023D6             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000023F6             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1        ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011DE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011F0             36                  JSR     CONVERT
00001052  4EB9 00001262             37                  JSR     TEST_RANGE
00001058  4EB9 0000127A             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 0000242D             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011DE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011F0             55                  JSR     CONVERT
0000109A  4EB9 00001262             56                  JSR     TEST_RANGE
000010A0  4EB9 0000127A             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0120                 64                  BLT     RESET_INPUT
000010B8  4BF9 00002516             65                  LEA     NEW_LINE,A5
000010BE  4EB9 000022B2             66                  JSR     PRINTNULL
000010C4                            67                  
000010C4  1439 00002617             68                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  143C 0007                 69                  MOVE.B  #7,D2               ; set variable to 0
000010CE  13C2 00002617             70                  MOVE.B  D2,LINE_COUNT       ; store back in the variabl
000010D4                            71                                 
000010D4  1439 00002617             72  DISASSEMBLE     MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010DA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010DC  13C2 00002617             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010E2                            75                  
000010E2  4EB9 0000128E             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010E8                            77                  
000010E8  4EB9 00001186             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010EE                            79                  
000010EE  4EB9 000022C4             80                  JSR     PRINTENTER          ; prints a new line
000010F4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010F6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010F8                            83                  
000010F8                            84  
000010F8  4BF9 000024A7             85  FINISHED        LEA     DONE,A5
000010FE  4EB9 000022B2             86                  JSR     PRINTNULL
00001104  103C 0005                 87                  MOVE.B  #5,D0
00001108  4E4F                      88                  TRAP    #15
0000110A                            89                  
0000110A  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
0000110E  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001112                            92                  
00001112  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001116  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000111A                            95  
0000111A  103C 0009                 96                  MOVE.B  #9,D0
0000111E  4E4F                      97                  TRAP    #15
00001120                            98                  
00001120  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001124  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001128  4E4F                     101                  TRAP    #15                 Call Trap
0000112A                           102                  
0000112A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000112E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001132  4E4F                     105                  TRAP    #15
00001134                           106                  
00001134  1439 00002617            107                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
0000113A  143C 0000                108                  MOVE.B  #0,D2               ; set variable to 0
0000113E  13C2 00002617            109                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
00001144                           110   
00001144  207C 00000000            111                  MOVE.L  #$0000000, A0       ; Reset A1
0000114A  227C 00000000            112                  MOVE.L  #$0000000, A1       ; Reset A1
00001150  247C 00000000            113                  MOVE.L  #$0000000, A2       ; Reset A2
00001156  267C 00000000            114                  MOVE.L  #$0000000, A3       ; Reset A3
0000115C  287C 00000000            115                  MOVE.L  #$0000000, A4       ; Reset A4
00001162  2A7C 00000000            116                  MOVE.L  #$0000000, A5       ; Reset A5
00001168  2C7C 00000000            117                  MOVE.L  #$0000000, A6       ; Reset A6
0000116E  2E7C 01000000            118                  MOVEA.L #$01000000,A7       ; Reset A7
00001174  4281                     119                  CLR.L   D1                  ; Reset D1
00001176  4281                     120                  CLR.L   D1                  ; Reset D1
00001178  4282                     121                  CLR.L   D2                  ; Reset D2
0000117A  4283                     122                  CLR.L   D3                  ; Reset D3
0000117C  4284                     123                  CLR.L   D4                  ; Reset D4
0000117E  4285                     124                  CLR.L   D5                  ; Reset D5
00001180  4286                     125                  CLR.L   D6                  ; Reset D6
00001182  6000 FE7C                126                  BRA     START               ; branch to start of program
00001186                           127  
00001186                           128  *--------------------SUBROUTINES------------------
00001186  1439 00002617            129  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000118C  1639 00002618            130                  MOVE.B  LINE_MAX,D3                
00001192  B602                     131                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001194  6F00 0004                132                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001198  4E75                     133                  RTS
0000119A                           134  
0000119A  4BF9 000024EB            135  NEXT_SCREEN     LEA     CONTINUE,A5
000011A0  4EB9 000022B2            136                  JSR     PRINTNULL
000011A6  6000 0002                137                  BRA     READ_KEY
000011AA                           138                  
000011AA  103C 0005                139  READ_KEY        MOVE.B  #5,D0
000011AE  4E4F                     140                  TRAP    #15
000011B0                           141                  
000011B0  B23C 000D                142                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000011B4  6700 0004                143                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
000011B8  60F0                     144                  BRA     READ_KEY
000011BA                           145                  
000011BA  103C 000B                146  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
000011BE  323C FF00                147                  MOVE.W  #$FF00, D1          Clear Screen
000011C2  4E4F                     148                  TRAP    #15                 Call Trap
000011C4                           149                  
000011C4                           150                  ; reset line counter
000011C4  1439 00002617            151                  MOVE.B  LINE_COUNT,D2
000011CA  143C 0000                152                  MOVE.B  #$0,D2
000011CE  13C2 00002617            153                  MOVE.B  D2,LINE_COUNT
000011D4  4E75                     154                  RTS       
000011D6                           155      
000011D6                           156  
000011D6  143C 0001                157  RESET_INPUT     MOVE.B  #1,D2
000011DA  6000 0062                158                  BRA     INVALID            
000011DE                           159                  
000011DE  7800                     160  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011E0  B204                     161                  CMP.B   D4,D1               ; D1 stores length
000011E2  6700 005A                162                  BEQ     INVALID             ; input is null
000011E6  0C41 0008                163                  CMPI    #$8,D1              ; check if input is longer than a longword
000011EA  6600 0052                164                  BNE     INVALID             ; input is longer than a longword
000011EE  4E75                     165                  RTS
000011F0                           166                              
000011F0  4283                     167  CONVERT         CLR.L   D3
000011F2  4284                     168                  CLR.L   D4
000011F4  1619                     169                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011F6  B63C 0039                170                  CMP.B   #57,D3
000011FA  6E00 0012                171                  BGT     NOTNUMBER
000011FE                           172                  
000011FE  B63C 002F                173                  CMP.B   #47,D3
00001202  6E00 0002                174                  BGT     ISNUMBER
00001206                           175                  
00001206  0603 00D0                176  ISNUMBER        ADD.B   #-48,D3             ; current char is number
0000120A  6000 001A                177                  BRA     CONCAT
0000120E                           178              
0000120E  B63C 0041                179  NOTNUMBER       CMP.B   #65,D3
00001212  6D00 002A                180                  BLT     INVALID
00001216  B63C 0046                181                  CMP.B   #70,D3
0000121A  6E00 0022                182                  BGT     INVALID  
0000121E  0603 00C9                183                  ADD.B   #-55,D3             ; is letter             
00001222  6000 0002                184                  BRA     CONCAT
00001226                           185              
00001226  BC3C 0000                186  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000122A  6D00 0010                187                  BLT     RETURN
0000122E  1806                     188                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001230  E50C                     189                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001232  E9AB                     190                  LSL.L   D4,D3               ; moves current char to correct position  
00001234  DA83                     191                  ADD.L   D3,D5               ; D5 stores converted input so far
00001236  0606 00FF                192                  ADD.B   #-1,D6  
0000123A  60B4                     193                  BRA     CONVERT             ; continue loop for remaining chars
0000123C                           194                  
0000123C  4E75                     195  RETURN          RTS
0000123E                           196                  
0000123E  227C 00000000            197  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001244  4283                     198                  CLR.L   D3
00001246  4284                     199                  CLR.L   D4
00001248  4285                     200                  CLR.L   D5
0000124A  43F9 00002463            201                  LEA     BAD_INPUT,A1        ; output invalid message
00001250  103C 000E                202                  MOVE.B  #14,D0
00001254  4E4F                     203                  TRAP    #15
00001256  B47C 0001                204                  CMP     #1,D2
0000125A  6700 FDC4                205                  BEQ     INPUT1
0000125E  6000 FE06                206                  BRA     INPUT2
00001262                           207  
00001262  4284                     208  TEST_RANGE      CLR.L      D4               ; D4 will store test results
00001264  223C 00001000            209                  MOVE.L     #$1000,D1        ; D1 stores minimum address
0000126A  BA81                     210                  CMP.L      D1,D5            ; Compare minimum address with input
0000126C  6DD0                     211                  BLT        INVALID          ; input is too low. 
0000126E  223C 00FFFFFE            212                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
00001274  BA81                     213                  CMP.L      D1,D5            ; compare maximum address with input
00001276  6EC6                     214                  BGT        INVALID          ; input too large
00001278  4E75                     215                  RTS                         ; input is within range
0000127A                           216             
0000127A  0805 0000                217  CHECK_ODD       BTST       #0,D5            ; check if input is odd
0000127E  66BE                     218                  BNE        INVALID
00001280  4E75                     219                  RTS
00001282                           220  
00001282  220E                     221  PRINT_ADDR      MOVE.L  A6,D1                   ; loads current address in D1
00001284  7801                     222                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001286  4EB9 0000218C            223                  JSR     PRINTSHORTLONGNUM       ; prints out address
0000128C  4E75                     224                  RTS
0000128E                           225  
0000128E                           226  
0000128E                           227  
0000128E                           228  * Checks every single possible opcode we could have. Jump table
0000128E                           229  * Inputs: (A2) which is a pointer to intruction word to be translated
0000128E                           230  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000128E                           231  
0000128E  2C4A                     232  OPCODE_DECODE   MOVE.L  A2,A6
00001290  301A                     233                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
00001292  4EB8 1282                234                  JSR     PRINT_ADDR
00001296                           235                  
00001296                           236  
00001296                           237  *---------------NOP opcode----------------------                
00001296  B07C 4E71                238  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
0000129A  6600 0010                239                  BNE     CASE_MOVE               ; checks the next case if not equal
0000129E                           240                  
0000129E  4BF9 0000251D            241                  LEA     MSG_NOP,A5              ; loads string pointer into A5
000012A4  4EB9 000022B2            242                  JSR     PRINTNULL               ; prints NOP                
000012AA  4E75                     243                  RTS                             ; returns from the subroutine
000012AC                           244  
000012AC                           245  *---------------MOVE opcode----------------------              
000012AC                           246                  * if first two bits are 00, next two are not 00
000012AC  3200                     247  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
000012AE  C27C C000                248                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
000012B2  6600 00BE                249                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
000012B6  B07C 0FFF                250                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000012BA  6F00 00B6                251                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
000012BE                           252                  
000012BE                           253                  ; Check source
000012BE  4BF9 00002326            254                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012C4  4DF9 0000235C            255                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012CA  3E3C 0000                256                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012CE  4EB9 00001E52            257                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012D4  B27C 0001                258                  CMP.W   #1,D1                    ; checks if invalid
000012D8  6700 0B18                259                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012DC  3802                     260                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012DE  3A03                     261                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012E0                           262                  
000012E0                           263                  ; Check destination
000012E0  4BF9 00002326            264                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012E6  4DF9 00002360            265                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012EC  3E3C 0001                266                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012F0  4EB9 00001E52            267                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012F6  B27C 0001                268                  CMP.W   #1,D1                    ; checks if invalid
000012FA  6700 0AF6                269                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012FE  3C02                     270                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001300  3E03                     271                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001302                           272                  
00001302                           273                  ; Checking if it is MOVEA
00001302  3200                     274                  MOVE.W  D0,D1                    ; stores d0 in d1
00001304  C27C 01C0                275                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
00001308  B27C 0040                276                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000130C  6700 0024                277                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001310                           278                  
00001310  4BF9 00002522            279                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001316  4EB9 000022B2            280                  JSR     PRINTNULL                ; prints out MOVE
0000131C  4EB9 000022D4            281                  JSR     PRINTMOVESIZE            ; prints out the size 
00001322  4BF9 000025F4            282                  LEA     MSG_4SPACES,A5           ; loads spaces
00001328  4EB9 000022B2            283                  JSR     PRINTNULL                ; prints out spaces
0000132E  6000 0020                284                  BRA     PRINTMOVE                ; Branches to print move
00001332                           285                  
00001332  4BF9 00002528            286  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001338  4EB9 000022B2            287                  JSR     PRINTNULL                ; prints out MOVEA
0000133E  4EB9 000022D4            288                  JSR     PRINTMOVESIZE            ; prints out the size 
00001344  4BF9 000025F0            289                  LEA     MSG_3SPACES,A5           ; loads spaces
0000134A  4EB9 000022B2            290                  JSR     PRINTNULL                ; prints out spaces
00001350                           291   
00001350  3404                     292  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001352  3605                     293                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001354  4EB9 00001FC0            294                  JSR     EA_TO_STRING             ; outputs it into a string
0000135A                           295                  
0000135A                           296                  ; prints a comma to seperate
0000135A  4BF9 000025E7            297                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001360  4EB9 000022B2            298                  JSR     PRINTNULL                ; prints out MOVE
00001366                           299                  
00001366                           300                  ; print destination
00001366  3406                     301                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001368  3607                     302                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000136A  4EB9 00001FC0            303                  JSR     EA_TO_STRING             ; outputs it into a string
00001370  4E75                     304                  RTS                              ; exits subroutine                 
00001372                           305                
00001372                           306  *---------------MOVEM opcode----------------------                
00001372  3200                     307  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001374  C27C FB80                308                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001378  B27C 4880                309                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000137C  6600 00FA                310                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001380                           311                  
00001380                           312                  ; Check D
00001380  3200                     313                  MOVE.W  D0,D1                           ; copies instruction word to D1
00001382  C27C 0400                314                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001386  3E01                     315                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001388  B27C 0400                316                  CMP.W   #$0400,D1                       ; checks if value is 1
0000138C  6700 0076                317                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
00001390                           318  
00001390                           319  MOVEM_REG2MEM   ; loads EA and XN
00001390  3E3C 0000                320                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001394  4BF9 00002333            321                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
0000139A  4DF9 00002360            322                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000013A0  4EB9 00001E52            323                  JSR     CHECKGET_EAXN
000013A6  B27C 0001                324                  CMP.W   #1,D1                           ; checks if D1 invalid
000013AA  6700 0A46                325                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000013AE  4BF9 00002536            326                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000013B4  4EB9 000022B2            327                  JSR     PRINTNULL                       ; prints MOVEM
000013BA                           328                  
000013BA                           329                  ; finds and prints size
000013BA  3200                     330                  MOVE.W  D0,D1                           ; copies D0
000013BC  C27C 0040                331                  AND.W   #$0040,D1                       ; gets the size bit
000013C0  6600 000C                332                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000013C4                           333  
000013C4  4BF9 00002611            334  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013CA  6000 0008                335                  BRA     PRINTREG2MEM                    ; prints the registers           
000013CE                           336                  
000013CE  4BF9 00002614            337  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013D4                           338             
000013D4  4EB9 000022B2            339  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013DA  4BF9 000025F0            340                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013E0  4EB9 000022B2            341                  JSR     PRINTNULL                       ; prints out spaces
000013E6  383C 0001                342                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013EA  4EB9 00001EEA            343                  JSR     PRINTREGISTERS                  ; prints registers
000013F0  4BF9 000025E7            344                  LEA     MSG_COMMA,A5                    ; loads comma
000013F6  4EB9 000022B2            345                  JSR     PRINTNULL                       ; prints comma
000013FC  4EB9 00001FC0            346                  JSR     EA_TO_STRING                    ; prints EA
00001402  4E75                     347                  RTS
00001404                           348  
00001404                           349  MOVEM_MEM2REG  ; loads EA and XN
00001404  3E3C 0000                350                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001408  4BF9 00002337            351                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
0000140E  4DF9 00002360            352                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001414  4EB9 00001E52            353                  JSR     CHECKGET_EAXN
0000141A  B27C 0001                354                  CMP.W   #1,D1                           ; checks if D1 invalid
0000141E  6700 09D2                355                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001422  4BF9 00002536            356                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001428  4EB9 000022B2            357                  JSR     PRINTNULL                       ; prints MOVEM
0000142E                           358                  
0000142E                           359                  ; finds and prints size
0000142E  3200                     360                  MOVE.W  D0,D1                           ; copies D0
00001430  C27C 0040                361                  AND.W   #$0040,D1                       ; gets the size bit
00001434  6600 000C                362                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001438                           363  
00001438  4BF9 00002611            364  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
0000143E  6000 0008                365                  BRA     PRINTMEM2REG                    ; prints the registers           
00001442                           366                  
00001442  4BF9 00002614            367  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001448                           368             
00001448  4EB9 000022B2            369  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
0000144E  4BF9 000025F0            370                  LEA     MSG_3SPACES,A5                  ; loads spaces
00001454  4EB9 000022B2            371                  JSR     PRINTNULL                       ; prints out spaces
0000145A  4EB9 00001FC0            372                  JSR     EA_TO_STRING                    ; prints EA
00001460  4BF9 000025E7            373                  LEA     MSG_COMMA,A5                    ; loads comma
00001466  4EB9 000022B2            374                  JSR     PRINTNULL                       ; prints comma
0000146C  383C FFFF                375                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001470  4EB9 00001EEA            376                  JSR     PRINTREGISTERS                  ; prints registers
00001476  4E75                     377                  RTS
00001478                           378                          
00001478                           379  
00001478                           380  *---------------MOVEQ opcode----------------------
00001478  3200                     381  CASE_MOVEQ      MOVE.W  D0,D1
0000147A  C27C F100                382                  AND.W   #$F100,D1
0000147E  B27C 7000                383                  CMP.W   #$7000,D1
00001482  6600 007C                384                  BNE     CASE_ADD
00001486                           385                  
00001486                           386                  ;loads Register
00001486  323C 0001                387                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000148A  4EB9 00001E28            388                  JSR     GET_XN                          ; gets XN and puts in D1
00001490  3601                     389                  MOVE.W  D1,D3                           ; copies Xn to D3 so it won't be overwritten
00001492                           390                  
00001492                           391                  ;loads DATA
00001492  3200                     392                  MOVE.W  D0,D1
00001494  C27C 00FF                393                  AND.W   #$00FF,D1                       ;bit mask to get DATA
00001498  3801                     394                  MOVE.W  D1,D4                           ;copy data into D4
0000149A                           395                                                          ;must convert bits to hex
0000149A                           396                                  
0000149A  4BF9 0000252F            397  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000014A0  4EB9 000022B2            398                  JSR     PRINTNULL  
000014A6                           399                                  
000014A6  4BF9 00002614            400                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014AC  4EB9 000022B2            401                  JSR     PRINTNULL
000014B2                           402      
000014B2  4BF9 000025F0            403                  LEA     MSG_3SPACES,A5                  ;PRINT THREE TABS
000014B8  4EB9 000022B2            404                  JSR     PRINTNULL
000014BE                           405                  
000014BE  4BF9 000025E3            406                  LEA     MSG_POUND, A5                   ;PRINT HASHTAG
000014C4  4EB9 000022B2            407                  JSR     PRINTNULL
000014CA                           408                  
000014CA  4BF9 000025E5            409                  LEA     MSG_HEX, A5                     ;PRINT DOLLAR SIGN
000014D0  4EB9 000022B2            410                  JSR     PRINTNULL
000014D6                           411                  
000014D6  3204                     412                  MOVE.W  D4,D1                           ;PRINT DATA
000014D8  4EB9 00002178            413                  JSR     PRINTHEXNUM                           
000014DE                           414                  
000014DE  4BF9 000025E7            415                  LEA     MSG_COMMA, A5                   ;PRINT COMMA
000014E4  4EB9 000022B2            416                  JSR     PRINTNULL
000014EA                           417                  
000014EA  4BF9 000025D7            418                  LEA     MSG_DR,A5                       ;PRINT D
000014F0  4EB9 000022B2            419                  JSR     PRINTNULL
000014F6                           420            
000014F6  3203                     421                  MOVE.W  D3,D1                           ;PRINT REGISTER NUMBER
000014F8  4EB9 00002168            422                  JSR     PRINTNUM                         
000014FE                           423                  
000014FE  4E75                     424                  RTS
00001500                           425                  
00001500                           426  *---------------ADD opcode----------------------                
00001500                           427  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
00001500  3200                     428  CASE_ADD        MOVE.W  D0,D1
00001502  C27C F000                429                  AND.W   #$F000,D1
00001506  B27C D000                430                  CMP.W   #$D000,D1
0000150A  6600 01D0                431                  BNE     CASE_ADDQ
0000150E                           432                   
0000150E  4EB9 00001528            433                  JSR     ADD_SUB_HELP
00001514                           434                  
00001514                           435                  ; bits 7-8 determine if it is ADDA or ADD
00001514  3200                     436                  MOVE.W  D0,D1
00001516  E149                     437                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001518  E049                     438                  LSR.W   #8,D1
0000151A  EC49                     439                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000151C  B27C 0003                440                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001520  6700 0136                441                  BEQ     CASE_ADDA
00001524                           442                  
00001524  6000 0040                443                  BRA     PRINTADD                ; Branches to print add
00001528                           444                  
00001528                           445                  ; Check bits 0-5 
00001528  4BF9 00002326            446  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000152E  4DF9 0000235C            447                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001534  3E3C 0000                448                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001538  4EB9 00001E52            449                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000153E  B27C 0001                450                  CMP.W       #1,D1                    ; checks if invalid
00001542  6700 08AE                451                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001546  3802                     452                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001548  3A03                     453                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000154A                           454                  
0000154A                           455                  ; Check 6-11
0000154A  4BF9 00002326            456                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001550  4DF9 00002360            457                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001556  3E3C 0001                458                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000155A  4EB9 00001E52            459                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001560  3C02                     460                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001562  3E03                     461                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001564                           462    
00001564  4E75                     463                  RTS                
00001566                           464                    
00001566  4BF9 0000253D            465  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
0000156C  4EB9 000022B2            466                  JSR         PRINTNULL               ; print ADD
00001572  3200                     467                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001574  4EB9 0000158A            468                  JSR         ADD_SUB_SIZE            ; D1 = size
0000157A  4BF9 000025F9            469                  LEA         MSG_5SPACES,A5          ; loads spaces
00001580  4EB9 000022B2            470                  JSR         PRINTNULL               ; prints out spaces
00001586  6000 0050                471                  BRA         FINISH_ADD
0000158A                           472                    
0000158A  3200                     473  ADD_SUB_SIZE    MOVE.W      D0,D1
0000158C  E149                     474                  LSL.W       #8,D1
0000158E  E049                     475                  LSR.W       #8,D1
00001590  EC49                     476                  LSR.W       #6,D1                   ; gets bits 6-7
00001592                           477                    
00001592  B27C 0000                478                  CMP.W       #0,D1
00001596  6700 0016                479                  BEQ         ADD_SUB_BYTE
0000159A  B27C 0001                480                  CMP.W       #1,D1                   ; if 1, it is a word
0000159E  6700 001C                481                  BEQ         ADD_SUB_WORD
000015A2  B27C 0002                482                  CMP.W       #2,D1                   ; if 2, it is a long
000015A6  6700 0022                483                  BEQ         ADD_SUB_LONG
000015AA  6000 02AE                484                  BRA         CASE_SUBA               ; error
000015AE                           485                    
000015AE  4BF9 0000260E            486  ADD_SUB_BYTE    LEA         MSG_B,A5
000015B4  4EB9 000022B2            487                  JSR         PRINTNULL
000015BA  4E75                     488                  RTS
000015BC                           489                    
000015BC  4BF9 00002611            490  ADD_SUB_WORD    LEA         MSG_W,A5
000015C2  4EB9 000022B2            491                  JSR         PRINTNULL
000015C8  4E75                     492                  RTS
000015CA                           493    
000015CA  4BF9 00002614            494  ADD_SUB_LONG    LEA         MSG_L,A5
000015D0  4EB9 000022B2            495                  JSR         PRINTNULL
000015D6  4E75                     496                  RTS
000015D8                           497        
000015D8  4EB9 000015E0            498  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015DE  4E75                     499                  RTS
000015E0                           500    
000015E0  3200                     501  ADD_SUB_OPERAND MOVE.W      D0,D1
000015E2  EF49                     502                  LSL.W       #7,D1
000015E4  EE49                     503                  LSR.W       #7,D1
000015E6  E049                     504                  LSR.W       #8,D1
000015E8  B27C 0001                505                  CMP.W       #1,D1
000015EC  6600 0036                506                  BNE         Dn_PLUS_EA          
000015F0                           507                    
000015F0                           508                  ; print Data Register
000015F0  4BF9 000025D7            509                  LEA         MSG_DR,A5
000015F6  4EB9 000022B2            510                  JSR         PRINTNULL
000015FC  3207                     511                  MOVE.W      D7,D1
000015FE  4EB9 00002168            512                  JSR         PRINTNUM                
00001604                           513                  
00001604                           514                  ; prints a comma to seperate
00001604  4BF9 000025E7            515                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000160A  4EB9 000022B2            516                  JSR         PRINTNULL                ; prints out MOVE
00001610                           517                 
00001610                           518                  ; below is EA+Dn->Dn  
00001610  3404                     519                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001612  3605                     520                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3
00001614  3200                     521                  MOVE.W      D0,D1
00001616  E149                     522                  LSL.W       #8,D1
00001618  E049                     523                  LSR.W       #8,D1
0000161A  EC49                     524                  LSR.W       #6,D1                   ; gets bits 6-7 
0000161C  4EB9 00001FC0            525                  JSR         EA_TO_STRING             ; outputs it into a string
00001622  4E75                     526                  RTS                                 ; exits subroutine 
00001624                           527  
00001624                           528  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001624  3404                     529                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001626  3605                     530                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001628  3200                     531                  MOVE.W      D0,D1
0000162A  E149                     532                  LSL.W       #8,D1
0000162C  E049                     533                  LSR.W       #8,D1
0000162E  EC49                     534                  LSR.W       #6,D1                   ; gets bits 6-7
00001630  4EB9 00001FC0            535                  JSR         EA_TO_STRING             ; outputs it into a string   
00001636                           536                  
00001636                           537                  ; prints a comma to seperate
00001636  4BF9 000025E7            538                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000163C  4EB9 000022B2            539                  JSR         PRINTNULL                ; prints out MOVE
00001642                           540                  
00001642                           541                  ; below is Dn+EA->EA
00001642  4BF9 000025D7            542                  LEA         MSG_DR,A5                ; print data register
00001648  4EB9 000022B2            543                  JSR         PRINTNULL
0000164E  3207                     544                  MOVE.W      D7,D1
00001650  4EB9 00002168            545                  JSR         PRINTNUM             
00001656  4E75                     546                  RTS                                  ; exits subroutine          
00001658                           547                        
00001658                           548  *---------------ADDA opcode----------------------
00001658                           549  CASE_ADDA       ; gets bit 8 (size bit)
00001658  3200                     550                  MOVE.W      D0,D1
0000165A  EF49                     551                  LSL.W       #7,D1
0000165C  EE49                     552                  LSR.W       #7,D1
0000165E  E049                     553                  LSR         #8,D1                   
00001660                           554                  
00001660  4BF9 00002542            555                  LEA         MSG_ADDA,A5             ; print ADDA
00001666  4EB9 000022B2            556                  JSR         PRINTNULL
0000166C                           557                   
0000166C  B27C 0001                558                  CMP.W       #1,D1
00001670  6700 001E                559                  BEQ         ADDA_LONG
00001674                           560                    
00001674  4BF9 00002611            561                  LEA         MSG_W,A5
0000167A  4EB9 000022B2            562                  JSR         PRINTNULL
00001680  4BF9 000025F4            563                  LEA         MSG_4SPACES,A5          ; loads spaces
00001686  4EB9 000022B2            564                  JSR         PRINTNULL               ; prints out spaces
0000168C  6000 0022                565                  BRA         FINISH_ADDA   
00001690                           566                    
00001690  323C 0002                567  ADDA_LONG       MOVE.W      #2,D1                   ;sets D1 to be word sized for EA to string
00001694  4BF9 00002614            568                  LEA         MSG_L,A5
0000169A  4EB9 000022B2            569                  JSR         PRINTNULL
000016A0  4BF9 000025F4            570                  LEA         MSG_4SPACES,A5          ; loads spaces
000016A6  4EB9 000022B2            571                  JSR         PRINTNULL               ; prints out spaces
000016AC  6000 0002                572                  BRA         FINISH_ADDA
000016B0                           573                    
000016B0  3404                     574  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016B2  3605                     575                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016B4  4EB9 00001FC0            576                  JSR         EA_TO_STRING             ; outputs it into a string
000016BA                           577                    
000016BA                           578                  ; prints a comma to seperate
000016BA  4BF9 000025E7            579                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016C0  4EB9 000022B2            580                  JSR         PRINTNULL                ; prints out MOVE
000016C6                           581            
000016C6  4BF9 000025D9            582                  LEA         MSG_AR,A5                ; print address register
000016CC  4EB9 000022B2            583                  JSR         PRINTNULL
000016D2  3207                     584                  MOVE.W      D7,D1
000016D4  4EB9 00002168            585                  JSR         PRINTNUM             
000016DA  4E75                     586                  RTS                              ; exits subroutine
000016DC                           587                  
000016DC                           588  *---------------ADDQ opcode----------------------                  
000016DC  3200                     589  CASE_ADDQ       MOVE.W      D0,D1
000016DE  C27C F000                590                  AND.W       #$F000,D1       
000016E2  B27C 5000                591                  CMP.W       #$5000,D1
000016E6  6600 00F0                592                  BNE         CASE_SUB
000016EA                           593                                                      
000016EA                           594                  ; Check bits 0-5 
000016EA  4BF9 00002326            595                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016F0  4DF9 0000235C            596                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016F6  3E3C 0000                597                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016FA  4EB9 00001E52            598                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001700  B27C 0001                599                  CMP.W       #1,D1                    ; checks if invalid
00001704  6700 06EC                600                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001708                           601                  
00001708  4BF9 00002548            602                  LEA         MSG_ADDQ,A5             ; print ADDQ
0000170E  4EB9 000022B2            603                  JSR         PRINTNULL
00001714                           604                  
00001714  3802                     605                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001716  3A03                     606                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001718                           607                  
00001718                           608                   ; get bits 6-7 (size bits)
00001718  3200                     609                  MOVE.W      D0,D1
0000171A  E149                     610                  LSL.W       #8,D1
0000171C  E049                     611                  LSR.W       #8,D1
0000171E  EC49                     612                  LSR.W       #6,D1
00001720  3207                     613                  MOVE.W      D7,D1                  ; stores D1 in D7 so it won't get overwritten
00001722  B27C 0001                614                  CMP.W       #1,D1
00001726  6700 0026                615                  BEQ         ADDQ_WORD
0000172A  B27C 0002                616                  CMP.W       #2,D1
0000172E  6700 003A                617                  BEQ         ADDQ_LONG
00001732                           618                    
00001732  4BF9 0000260E            619  ADDQ_BYTE       LEA         MSG_B,A5
00001738  4EB9 000022B2            620                  JSR         PRINTNULL
0000173E  4BF9 000025F4            621                  LEA         MSG_4SPACES,A5          ; loads spaces
00001744  4EB9 000022B2            622                  JSR         PRINTNULL               ; prints out spaces
0000174A  6000 003A                623                  BRA         FINISH_ADDQ  
0000174E                           624   
0000174E  4BF9 00002611            625  ADDQ_WORD       LEA         MSG_W,A5
00001754  4EB9 000022B2            626                  JSR         PRINTNULL
0000175A  4BF9 000025F4            627                  LEA         MSG_4SPACES,A5          ; loads spaces
00001760  4EB9 000022B2            628                  JSR         PRINTNULL               ; prints out spaces
00001766  6000 001E                629                  BRA         FINISH_ADDQ                 
0000176A                           630    
0000176A  4BF9 00002614            631  ADDQ_LONG       LEA         MSG_L,A5
00001770  4EB9 000022B2            632                  JSR         PRINTNULL
00001776  4BF9 000025F4            633                  LEA         MSG_4SPACES,A5          ; loads spaces
0000177C  4EB9 000022B2            634                  JSR         PRINTNULL               ; prints out spaces
00001782  6000 0002                635                  BRA         FINISH_ADDQ                  
00001786                           636                    
00001786  4EB9 000017A6            637  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000178C                           638   
0000178C                           639                  ; prints a comma to seperate
0000178C  4BF9 000025E7            640                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001792  4EB9 000022B2            641                  JSR         PRINTNULL                ; prints out MOVE
00001798                           642                    
00001798                           643                  ; prints destination
00001798  3404                     644                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000179A  3605                     645                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000179C  3207                     646                  MOVE.W      D7,D1                    ; Moves size bit to D1
0000179E  4EB9 00001FC0            647                  JSR         EA_TO_STRING             ; outputs it into a string
000017A4                           648                 
000017A4  4E75                     649                  RTS
000017A6                           650   
000017A6  4BF9 000025E3            651  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
000017AC  4EB9 000022B2            652                  JSR         PRINTNULL
000017B2                           653                  ; gets bits 9-11 (data bits)
000017B2  3200                     654                  MOVE.W      D0,D1                               ; gets D0
000017B4  E949                     655                  LSL.W       #4,D1
000017B6  E849                     656                  LSR.W       #4,D1                               ; get rid of left 4 bits
000017B8  E049                     657                  LSR.W       #8,D1
000017BA  E249                     658                  LSR.W       #1,D1                               ; get rid of right 9 bits
000017BC                           659                  
000017BC  B27C 0000                660                  CMP.W       #0,D1
000017C0  6700 000A                661                  BEQ         PRINT_8
000017C4  4EB9 00002168            662                  JSR         PRINTNUM
000017CA  4E75                     663                  RTS 
000017CC                           664  
000017CC  123C 0008                665  PRINT_8         MOVE.B      #8,D1
000017D0  4EB9 00002168            666                  JSR         PRINTNUM
000017D6  4E75                     667                  RTS   
000017D8                           668         
000017D8                           669  *---------------SUB opcode---------------------- 
000017D8  3200                     670  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
000017DA  C27C F000                671                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000017DE  B27C 9000                672                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
000017E2  6600 008C                673                  BNE         CASE_LEA
000017E6                           674                 
000017E6  4EB8 1528                675                  JSR         ADD_SUB_HELP
000017EA                           676                  
000017EA  6000 0002                677                  BRA         PRINTSUB                            ; Branches to print sub
000017EE                           678  
000017EE  4BF9 0000254E            679  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017F4  4EB9 000022B2            680                  JSR         PRINTNULL
000017FA  3200                     681                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017FC  4EB8 158A                682                  JSR         ADD_SUB_SIZE
00001800  4BF9 000025F9            683                  LEA         MSG_5SPACES,A5                      ; loads spaces
00001806  4EB9 000022B2            684                  JSR         PRINTNULL                           ; prints out spaces
0000180C  3200                     685                  MOVE.W      D0,D1
0000180E  E149                     686                  LSL.W       #8,D1
00001810  E049                     687                  LSR.W       #8,D1
00001812  EC49                     688                  LSR.W       #6,D1
00001814  B27C 0003                689                  CMP.W       #3,D1
00001818  6600 0006                690                  BNE         FINISH_SUB
0000181C  6000 0008                691                  BRA         FINISH_SUBA                         ; same as ADDA
00001820                           692                  
00001820  4EB8 15E0                693  FINISH_SUB      JSR         ADD_SUB_OPERAND
00001824  4E75                     694                  RTS
00001826                           695                    
00001826  3404                     696  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001828  3605                     697                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000182A  4EB9 00001FC0            698                  JSR         EA_TO_STRING             ; outputs it into a string
00001830                           699                
00001830                           700                  ; prints a comma to seperate
00001830  4BF9 000025E7            701                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001836  4EB9 000022B2            702                  JSR         PRINTNULL                ; prints out MOVE
0000183C                           703                  
0000183C  4BF9 000025D9            704                  LEA         MSG_AR,A5                ; print address register
00001842  4EB9 000022B2            705                  JSR         PRINTNULL
00001848  3200                     706                  MOVE.W      D0,D1
0000184A  E949                     707                  LSL.W       #4,D1
0000184C  E849                     708                  LSR.W       #4,D1
0000184E  E049                     709                  LSR.W       #8,D1
00001850  E249                     710                  LSR.W       #1,D1
00001852  4EB9 00002168            711                  JSR         PRINTNUM             
00001858  4E75                     712                  RTS                              ; exits subroutine
0000185A                           713  
0000185A                           714  
0000185A                           715  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000185A  3200                     716  CASE_SUBA       MOVE.W      D0,D1
0000185C  EF49                     717                  LSL.W       #7,D1
0000185E  EE49                     718                  LSR.W       #7,D1
00001860  E049                     719                  LSR.W       #8,D1
00001862  B23C 0000                720                  CMP.B       #0,D1
00001866  6700 FD54                721                  BEQ         ADD_SUB_WORD
0000186A  6000 FD5E                722                  BRA         ADD_SUB_LONG
0000186E  4E75                     723                  RTS         
00001870                           724                   
00001870  3200                     725  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001872  C27C F000                726                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001876  B27C 4000                727                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000187A  6600 0092                728                  BNE.W   CASE_AND                             ; If its not, check AND
0000187E  3200                     729                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001880  C27C 01C0                730                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001884  B27C 01C0                731                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001888  6600 0084                732                  BNE.W   CASE_AND                             ; If its not, check AND
0000188C                           733                  
0000188C                           734                  ; Check source
0000188C  4BF9 00002346            735                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001892  4DF9 00002360            736                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001898  3E3C 0000                737                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
0000189C  4EB9 00001E52            738                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000018A2  3802                     739                  MOVE.W  D2,D4                                ; Saves D2 in D4
000018A4  3A03                     740                  MOVE.W  D3,D5                                ; Saves D2 in D4
000018A6                           741                  
000018A6                           742                  ; Check destination
000018A6  4BF9 00002346            743                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000018AC  4DF9 00002360            744                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000018B2  3E3C 0001                745                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000018B6  4EB9 00001E52            746                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000018BC  3C02                     747                  MOVE.W  D2,D6                                ; Saves D2 in D4
000018BE  3E03                     748                  MOVE.W  D3,D7                                ; Saves D2 in D4
000018C0                           749  
000018C0  4BF9 0000255F            750                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000018C6  4EB9 000022B2            751                  JSR     PRINTNULL                            ; prints LEA
000018CC  4BF9 00002606            752                  LEA     MSG_7SPACES,A5                       ; loads spaces
000018D2  4EB9 000022B2            753                  JSR     PRINTNULL                            ; prints out spaces
000018D8                           754                  
000018D8                           755                  ; print source
000018D8  3404                     756                  MOVE.W  D4,D2
000018DA  3605                     757                  MOVE.W  D5,D3
000018DC  4EB9 00001FC0            758                  JSR     EA_TO_STRING                         ; Prints out the EA
000018E2                           759                  
000018E2                           760                  ; comma
000018E2  4BF9 000025E7            761                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000018E8  4EB9 000022B2            762                  JSR     PRINTNULL                       
000018EE                           763                   
000018EE                           764                  ; register
000018EE  4BF9 000025D9            765                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018F4  4EB9 000022B2            766                  JSR     PRINTNULL 
000018FA  3401                     767                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018FC  323C 0001                768                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
00001900  4EB9 00001E28            769                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001906  4EB9 00002168            770                  JSR     PRINTNUM                             ; Prints the number in D1
0000190C  4E75                     771                  RTS
0000190E                           772  
0000190E                           773  *---------------AND opcode----------------------
0000190E  3200                     774  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001910  C27C F000                775                  AND.W       #$F000,D1       
00001914  B27C C000                776                  CMP.W       #$C000,D1
00001918  6600 00CA                777                  BNE         CASE_OR
0000191C                           778                  
0000191C  3200                     779                  MOVE.W      D0,D1
0000191E  E149                     780                  LSL.W       #8,D1
00001920  E049                     781                  LSR.W       #8,D1
00001922  EC49                     782                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001924  3C01                     783                  MOVE.W      D1,D6
00001926  BC7C 0003                784                  CMP.W       #3,D6
0000192A  6700 0086                785                  BEQ         INV_INSTR
0000192E                           786                  
0000192E  4BF9 00002564            787                  LEA         MSG_AND,A5                      ; print AND
00001934  4EB9 000022B2            788                  JSR         PRINTNULL
0000193A                           789                  
0000193A  3206                     790                  MOVE.W      D6,D1
0000193C  B27C 0000                791                  CMP.W       #0,D1
00001940  6700 0012                792                  BEQ         AND_BYTE
00001944  B27C 0001                793                  CMP.W       #1,D1                   ; if 1, it is a word
00001948  6700 0026                794                  BEQ         AND_WORD
0000194C  B27C 0002                795                  CMP.W       #2,D1                   ; if 2, it is a long
00001950  6700 003A                796                  BEQ         AND_LONG
00001954                           797                  
00001954  4BF9 0000260E            798  AND_BYTE        LEA         MSG_B,A5
0000195A  4EB9 000022B2            799                  JSR         PRINTNULL
00001960  4BF9 000025F9            800                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001966  4EB9 000022B2            801                  JSR         PRINTNULL                       ; prints out spaces
0000196C  6000 003A                802                  BRA         FINISH_AND
00001970                           803                                    
00001970  4BF9 00002611            804  AND_WORD        LEA         MSG_W,A5
00001976  4EB9 000022B2            805                  JSR         PRINTNULL
0000197C  4BF9 000025F9            806                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001982  4EB9 000022B2            807                  JSR         PRINTNULL                       ; prints out spaces
00001988  6000 001E                808                  BRA         FINISH_AND
0000198C                           809    
0000198C  4BF9 00002614            810  AND_LONG        LEA         MSG_L,A5
00001992  4EB9 000022B2            811                  JSR         PRINTNULL
00001998  4BF9 000025F9            812                  LEA         MSG_5SPACES,A5                  ; loads spaces
0000199E  4EB9 000022B2            813                  JSR         PRINTNULL                       ; prints out spaces
000019A4  6000 0002                814                  BRA         FINISH_AND
000019A8                           815        
000019A8  4EB8 1528                816  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
000019AC  4EB8 15E0                817                  JSR         ADD_SUB_OPERAND
000019B0  4E75                     818                  RTS
000019B2                           819                  
000019B2  4BF9 000024A1            820  INV_INSTR       LEA         INVALID_INSTR,A5
000019B8  4EB9 000022B2            821                  JSR         PRINTNULL
000019BE  4BF9 000025FF            822                  LEA         MSG_6SPACES,A5
000019C4  4EB9 000022B2            823                  JSR         PRINTNULL
000019CA  4BF9 000025E5            824                  LEA         MSG_HEX,A5
000019D0  4EB9 000022B2            825                  JSR         PRINTNULL
000019D6  2200                     826                  MOVE.L      D0,D1
000019D8  383C 0000                827                  MOVE.W      #0,D4
000019DC  4EB9 0000218C            828                  JSR         PRINTSHORTLONGNUM
000019E2  4E75                     829                  RTS               
000019E4                           830                  
000019E4                           831  *---------------OR opcode----------------------            
000019E4  3200                     832  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019E6  C27C F000                833                  AND.W       #$F000,D1       
000019EA  B27C 8000                834                  CMP.W       #$8000,D1
000019EE  6600 0054                835                  BNE         CASE_NOT
000019F2                           836                                                
000019F2  3200                     837                  MOVE.W      D0,D1
000019F4  E149                     838                  LSL.W       #8,D1
000019F6  E049                     839                  LSR.W       #8,D1
000019F8  EC49                     840                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019FA  B27C 0003                841                  CMP.W       #3,D1
000019FE  67B2                     842                  BEQ         INV_INSTR
00001A00  3C01                     843                  MOVE.W      D1,D6
00001A02                           844  
00001A02                           845                  
00001A02  4BF9 00002569            846                  LEA         MSG_OR,A5
00001A08  4EB9 000022B2            847                  JSR         PRINTNULL                       ; print "OR"
00001A0E                           848                  
00001A0E  3206                     849                  MOVE.W      D6,D1
00001A10  4EB9 00001A2C            850                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A16  4BF9 000025FF            851                  LEA         MSG_6SPACES,A5                  ; loads spaces
00001A1C  4EB9 000022B2            852                  JSR         PRINTNULL                       ; prints out spaces
00001A22                           853  
00001A22  4EB8 1528                854                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001A26  4EB8 15E0                855                  JSR         ADD_SUB_OPERAND                 ; print 
00001A2A  4E75                     856                  RTS
00001A2C                           857  
00001A2C  B27C 0000                858  OR_SIZE         CMP.W       #0,D1
00001A30  6700 FB7C                859                  BEQ         ADD_SUB_BYTE
00001A34  B27C 0001                860                  CMP.W       #1,D1                   ; if 1, it is a word
00001A38  6700 FB82                861                  BEQ         ADD_SUB_WORD
00001A3C  B27C 0002                862                  CMP.W       #2,D1                   ; if 2, it is a long
00001A40  6700 FB88                863                  BEQ         ADD_SUB_LONG
00001A44                           864                  ; no need for rts, since ADD_SUB_ already has                
00001A44                           865  
00001A44                           866  *---------------NOT opcode----------------------
00001A44  3200                     867  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A46  C27C FF00                868                  AND.W       #$FF00,D1       
00001A4A  B27C 4600                869                  CMP.W       #$4600,D1
00001A4E  6600 0058                870                  BNE         CASE_LSDASDROD
00001A52                           871                 
00001A52                           872                  ; get bits 6-7 (size)
00001A52  3200                     873                  MOVE.W      D0,D1
00001A54  E149                     874                  LSL.W       #8,D1
00001A56  E049                     875                  LSR.W       #8,D1
00001A58  EC49                     876                  LSR.W       #6,D1 
00001A5A  3C01                     877                  MOVE.W      D1,D6                         
00001A5C  BC7C 0003                878                  CMP.W       #3,D6
00001A60  6700 FF50                879                  BEQ         INV_INSTR
00001A64                           880                                  
00001A64  4BF9 0000256D            881                  LEA         MSG_NOT,A5
00001A6A  4EB9 000022B2            882                  JSR         PRINTNULL                       ; print "NOT"
00001A70                           883                                 
00001A70  3206                     884                  MOVE.W      D6,D1
00001A72                           885  
00001A72  4EB8 1A2C                886                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A76  4BF9 000025F9            887                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A7C  4EB9 000022B2            888                  JSR         PRINTNULL                       ; prints out spaces
00001A82                           889                  
00001A82                           890                  ; get bits 0-5 
00001A82  4BF9 00002326            891                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A88  4DF9 0000235C            892                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A8E  3E3C 0000                893                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A92  4EB9 00001E52            894                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A98  B27C 0001                895                  CMP.W       #1,D1                    ; checks if invalid
00001A9C  6700 0354                896                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001AA0  4EB9 00001FC0            897                  JSR         EA_TO_STRING             ; outputs it into a string
00001AA6                           898    
00001AA6  4E75                     899                  RTS
00001AA8                           900  
00001AA8  3200                     901  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001AAA  C27C F000                902                  AND.W       #$F000, D1                       ; gets first 4 bits
00001AAE  B27C E000                903                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001AB2  6600 0240                904                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001AB6  3400                     905                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AB8  4EB9 00001EDA            906                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001ABE  B47C 0003                907                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001AC2  6600 00D4                908                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001AC6                           909                  
00001AC6  3400                     910  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001AC8  4EB9 00001EC8            911                  JSR         GETROTATION                      ; gets rotation value of D2
00001ACE  B47C 0000                912                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001AD2  6700 0014                913                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001AD6  B47C 0003                914                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001ADA  6700 0016                915                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001ADE                           916                  
00001ADE  4BF9 00002572            917  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001AE4  6000 0012                918                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AE8                           919  
00001AE8  4BF9 00002576            920  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001AEE  6000 0008                921                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AF2                           922  
00001AF2  4BF9 0000257A            923  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AF8                           924                  
00001AF8  4EB9 000022B2            925  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001AFE  3400                     926                  MOVE.W      D0,D2                            ; copies D0 to D2
00001B00  4EB9 00001ED2            927                  JSR         GETDIRECTION                     ; gets direction
00001B06  B47C 0000                928                  CMP.W       #0,D2                            ; checking if its right
00001B0A  6700 000C                929                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001B0E                           930  
00001B0E  4BF9 000025D5            931  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001B14  6000 0008                932                  BRA         PRINT_MEMDIR                     ; branches for printing
00001B18                           933          
00001B18  4BF9 000025D3            934  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001B1E                           935  
00001B1E  4EB9 000022B2            936  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001B24  4BF9 00002611            937                  LEA         MSG_W,A5                         ; loads .W into A5
00001B2A  4EB9 000022B2            938                  JSR         PRINTNULL                        ; Prints .W
00001B30  4BF9 000025F9            939                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001B36  4EB9 000022B2            940                  JSR         PRINTNULL                        ; prints out spaces
00001B3C  6000 0002                941                  BRA         GETMEMSOURCE                     ; checks the source 
00001B40                           942                  
00001B40                           943  ; get source addressing mode       
00001B40                           944  GETMEMSOURCE                                                 
00001B40  323C 0000                945                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B44  4EB9 00001DFE            946                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B4A  3801                     947                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B4C  323C 0000                948                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B50  4EB9 00001E28            949                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B56  3A01                     950                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B58                           951  
00001B58  4BF9 00002354            952  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B5E  3204                     953                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B60  4EB9 00001F8C            954                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B66  B27C 0002                955                  CMP.W       #2,D1                            ; checks if it is Xn
00001B6A  6700 0016                956                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B6E  B27C 0001                957                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B72  6700 027E                958                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B76                           959  
00001B76  3404                     960  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B78  3605                     961                  MOVE.W      D5,D3                            ; moves EA to D3
00001B7A  4EB9 00001FC0            962                  JSR         EA_TO_STRING                     ; prints out the EA
00001B80  4E75                     963                  RTS                
00001B82                           964                  
00001B82                           965                  
00001B82  4BF9 00002360            966  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B88  3205                     967                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B8A  4EB9 00001F8C            968                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B90  4A41                     969                  TST.W       D1                               ; checks if it is valid
00001B92  67E2                     970                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B94  6000 025C                971                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B98                           972  
00001B98                           973  
00001B98  3602                     974  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B9A  3200                     975                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B9C  C27C 0018                976                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001BA0  E649                     977                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001BA2  B27C 0000                978                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001BA6  6700 0014                979                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001BAA  B27C 0003                980                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001BAE  6700 0016                981                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001BB2                           982                  
00001BB2  4BF9 00002572            983  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001BB8  6000 0012                984                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BBC                           985  
00001BBC  4BF9 00002576            986  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001BC2  6000 0008                987                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BC6                           988  
00001BC6  4BF9 0000257A            989  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001BCC                           990                  
00001BCC  4EB9 000022B2            991  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001BD2  3400                     992                  MOVE.W      D0,D2                            ; copies D0 to D2
00001BD4  4EB9 00001ED2            993                  JSR         GETDIRECTION                     ; gets direction
00001BDA  B47C 0000                994                  CMP.W       #0,D2                            ; checking if its right
00001BDE  6700 000C                995                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BE2                           996  
00001BE2  4BF9 000025D5            997  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BE8  6000 000C                998                  BRA         PRINT_REGDIR                     ; branches for printing
00001BEC                           999          
00001BEC  4BF9 000025D3           1000  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BF2  6000 0002               1001                  BRA         PRINT_REGDIR                     ; branches for printing
00001BF6                          1002                  
00001BF6  4EB9 000022B2           1003  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BFC                          1004  
00001BFC  3400                    1005  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BFE  4EB9 00001EDA           1006                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C04  B47C 0001               1007                  CMP.W       #1,D2                            ; Checks if it is word size
00001C08  6700 0014               1008                  BEQ         REG_WORD                         ; Prints .W
00001C0C  B47C 0002               1009                  CMP.W       #2,D2                            ; Checks if it is long size
00001C10  6700 0016               1010                  BEQ         REG_LONG                         ; Prints .L
00001C14                          1011  
00001C14  4BF9 0000260E           1012  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001C1A  6000 0012               1013                  BRA         PRINTREGEA      
00001C1E                          1014  
00001C1E  4BF9 00002611           1015  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001C24  6000 0008               1016                  BRA         PRINTREGEA      
00001C28                          1017                             
00001C28  4BF9 00002614           1018  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001C2E                          1019  
00001C2E  4EB9 000022B2           1020  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001C34  4BF9 000025F9           1021                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001C3A  4EB9 000022B2           1022                  JSR         PRINTNULL                        ; prints out spaces
00001C40  3400                    1023                  MOVE.W      D0,D2                            ; copies D0 to D2
00001C42  4EB9 00001EE2           1024                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C48  B47C 0001               1025                  CMP.W       #$1,D2                           ; Compares D1 to 1, if it is 1, it is a data register
00001C4C  6700 0060               1026                  BEQ         REG_REGISTER                     ; goes to register case if so
00001C50                          1027                                  
00001C50  3400                    1028  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C52  4EB9 00001EC8           1029                  JSR         GETROTATION                      ; gets the rotation size
00001C58  B47C 0000               1030                  CMP.W       #0,D2                            ; checks if D2 is 0 (shift count of 8)
00001C5C  6600 0006               1031                  BNE         COMPLETE_REGIM                   ; if not shigt count of 8, then branch to start printing
00001C60                          1032                  
00001C60  343C 0008               1033  MAKESHIFT8      MOVE.W      #8,D2                            ; sets shift cound to 8 (shift count of 8 is 000 in the opcode)
00001C64                          1034                  
00001C64  4BF9 000025E3           1035  COMPLETE_REGIM  LEA         MSG_POUND, A5                    ; loads # into A5
00001C6A  4EB9 000022B2           1036                  JSR         PRINTNULL                        ; prints #
00001C70  4BF9 000025E5           1037                  LEA         MSG_HEX, A5                      ; loads $ into A5
00001C76  4EB9 000022B2           1038                  JSR         PRINTNULL                        ; prints $
00001C7C  3202                    1039                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C7E  4EB9 00002178           1040                  JSR         PRINTHEXNUM                      ; prints shift count
00001C84  4BF9 000025E7           1041                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C8A  4EB9 000022B2           1042                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C90  4BF9 000025D7           1043                  LEA         MSG_DR, A5                       ; loads D into A5
00001C96  4EB9 000022B2           1044                  JSR         PRINTNULL                        ; prints out D 
00001C9C  323C 0000               1045                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CA0  4EB9 00001E28           1046                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CA6  4EB9 00002168           1047                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CAC  4E75                    1048                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CAE                          1049                  
00001CAE  3400                    1050  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001CB0  4EB9 00001EDA           1051                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001CB6  3202                    1052                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001CB8  4BF9 000025D7           1053                  LEA         MSG_DR, A5                       ; loads D into A5
00001CBE  4EB9 000022B2           1054                  JSR         PRINTNULL                        ; prints D
00001CC4  4EB9 00002168           1055                  JSR         PRINTNUM                         ; prints register number
00001CCA  4BF9 000025E7           1056                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001CD0  4EB9 000022B2           1057                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001CD6  4BF9 000025D7           1058                  LEA         MSG_DR, A5                       ; loads D into A5
00001CDC  4EB9 000022B2           1059                  JSR         PRINTNULL                        ; prints out D 
00001CE2  323C 0000               1060                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CE6  4EB9 00001E28           1061                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CEC  4EB9 00002168           1062                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CF2  4E75                    1063                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CF4                          1064               
00001CF4  3200                    1065  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001CF6  C27C FF00               1066                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001CFA  B27C 6000               1067                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001CFE  6600 0024               1068                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001D02                          1069                  
00001D02  4BF9 000025CE           1070                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001D08  4EB9 000022B2           1071                  JSR     PRINTNULL                            ; prints BRA
00001D0E  4BF9 00002606           1072                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D14  4EB9 000022B2           1073                  JSR     PRINTNULL                            ; prints out spaces
00001D1A                          1074  
00001D1A  3400                    1075                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D1C  4EB9 00001E9A           1076                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D22  4E75                    1077                  RTS
00001D24                          1078                  
00001D24                          1079  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001D24  3200                    1080  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D26  C27C F000               1081                  AND.W   #$F000,D1                            ; get top 4 bits
00001D2A  B27C 6000               1082                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001D2E  6600 0060               1083                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001D32  3200                    1084                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D34  C27C 0F00               1085                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001D38  E049                    1086                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001D3A                          1087                  
00001D3A  B27C 000E               1088                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001D3E  6700 002A               1089                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001D42                          1090                  
00001D42  B27C 000F               1091                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001D46  6700 0018               1092                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001D4A                          1093                      
00001D4A  B27C 0007               1094                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001D4E  6700 0006               1095                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001D52  6000 009E               1096                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001D56                          1097     
00001D56  4BF9 00002588           1098  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D5C  6000 0016               1099                  BRA     PRINTBCC
00001D60                          1100  
00001D60  4BF9 000025A1           1101  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D66  6000 000C               1102                  BRA     PRINTBCC
00001D6A                          1103                  
00001D6A  4BF9 00002597           1104  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D70  6000 0002               1105                  BRA     PRINTBCC
00001D74                          1106  
00001D74  4EB9 000022B2           1107  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D7A  4BF9 00002606           1108                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D80  4EB9 000022B2           1109                  JSR     PRINTNULL                            ; prints out spaces
00001D86  3400                    1110                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D88  4EB9 00001E9A           1111                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D8E  4E75                    1112                  RTS              
00001D90                          1113                  
00001D90                          1114  
00001D90  3200                    1115  CASE_JSR        MOVE.W  D0,D1                                ; check if JSR mandatory bits exist
00001D92  C27C FFC0               1116                  AND.W   #$FFC0,D1
00001D96  B27C 4E80               1117                  CMP.W   #$4E80,D1
00001D9A  6600 0040               1118                  BNE     CASE_RTS
00001D9E                          1119                  
00001D9E  1E3C 0000               1120                  MOVE.B  #0,D7
00001DA2  4BF9 00002359           1121                  LEA     VALIDEA_JSR,A5                       ; loads string of valid addresses
00001DA8  4DF9 00002360           1122                  LEA     VALIDXN_SHORTLONG,A6                 ; loads string of valid addresses
00001DAE  4EB9 00001E52           1123                  JSR     CHECKGET_EAXN                        ; checks if has valid effective address
00001DB4  B27C 0001               1124                  CMP     #1,D1
00001DB8  6700 0038               1125                  BEQ     CASE_DATA                            ; goes to case data if EA is invalid
00001DBC                          1126                  
00001DBC                          1127  PRINT_JSR       ;print JSR
00001DBC  4BF9 000025C4           1128                  LEA     MSG_JSR,A5
00001DC2  4EB9 000022B2           1129                  JSR     PRINTNULL
00001DC8                          1130                  
00001DC8                          1131                  ;print spaces
00001DC8  4BF9 00002606           1132                  LEA     MSG_7SPACES,A5
00001DCE  4EB9 000022B2           1133                  JSR     PRINTNULL
00001DD4                          1134                                  
00001DD4                          1135                  ;print address
00001DD4  4EB9 00001FC0           1136                  JSR     EA_TO_STRING
00001DDA  4E75                    1137                  RTS     
00001DDC                          1138  
00001DDC  B07C 4E75               1139  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001DE0  6600 0010               1140                  BNE     CASE_DATA           ; checks the next case if not equal
00001DE4  4BF9 000025C9           1141                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001DEA  4EB9 000022B2           1142                  JSR     PRINTNULL           ; prints RTS                
00001DF0  4E75                    1143                  RTS                         ; returns from the subroutine
00001DF2                          1144  
00001DF2  4EB8 19B2               1145  CASE_DATA       JSR INV_INSTR  
00001DF6  4E75                    1146                  RTS               
00001DF8                          1147  
00001DF8  4E75                    1148  CASE_EPICFAIL   RTS
00001DFA                          1149  
00001DFA  362B 00F3               1150  TEST            MOVE.W  $0F3(A3),D3
00001DFE                          1151  
00001DFE                          1152  
00001DFE                          1153  * Finds the EA type
00001DFE                          1154  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001DFE                          1155  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001DFE  48E7 3000               1156  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001E02  4A41                    1157                      TST.W     D1                    ; compares D1 to 0
00001E04  6700 000E               1158                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001E08                          1159                      
00001E08  343C 01C0               1160  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001E0C  363C 0006               1161                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001E10  6000 000A               1162                      BRA       FINDTYPEEA            
00001E14                          1163  
00001E14  343C 0038               1164  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001E18  363C 0003               1165                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001E1C                          1166  
00001E1C                          1167  
00001E1C  3200                    1168  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001E1E  C242                    1169                      AND.W     D2,D1                 ; applies bitmask to D1
00001E20  E669                    1170                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E22  4CDF 000C               1171                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E26  4E75                    1172                      RTS                             ; returns from subroutine    
00001E28                          1173                      
00001E28                          1174  * Finds Xn type
00001E28                          1175  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001E28                          1176  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001E28  48E7 3000               1177  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001E2C  4A41                    1178                      TST.W     D1                    ; compares D1 to 0
00001E2E  6700 000E               1179                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001E32                          1180  
00001E32  343C 0E00               1181  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001E36  363C 0009               1182                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001E3A  6000 000A               1183                      BRA       FINDTYPEXN            ; finds the type of Xn
00001E3E                          1184  
00001E3E  343C 0007               1185  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001E42  363C 0000               1186                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001E46                          1187                      
00001E46  3200                    1188  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001E48  C242                    1189                      AND.W     D2,D1                 ; applies bitmask to D1
00001E4A  E669                    1190                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E4C  4CDF 000C               1191                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E50  4E75                    1192                      RTS                             ; returns from subroutine 
00001E52                          1193                      
00001E52                          1194  * Checks and gets the EA and Xn
00001E52                          1195  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001E52                          1196  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001E52  3207                    1197  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001E54  4EB8 1DFE               1198                  JSR     GET_EA                  ; Gets EA
00001E58  3401                    1199                  MOVE.W  D1,D2                   ; Stores EA in D2
00001E5A  3207                    1200                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001E5C  4EB8 1E28               1201                  JSR     GET_XN                  ; Gets Xn
00001E60  3601                    1202                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001E62  3202                    1203                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001E64                          1204                  
00001E64  4EB9 00001F8C           1205                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001E6A  B27C 0002               1206                  CMP.W   #2,D1                   ; checks if it is Xn
00001E6E  6700 0012               1207                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001E72  B27C 0001               1208                  CMP.W   #1,D1                   ; Checks if it is invalid
00001E76  6700 001C               1209                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001E7A                          1210                  
00001E7A                          1211                  
00001E7A  323C 0000               1212  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001E7E  6000 0018               1213                  BRA     END_CHECKGET
00001E82                          1214        
00001E82                          1215  ; need XN
00001E82  2A4E                    1216  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001E84  3203                    1217                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001E86  4EB9 00001F8C           1218                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001E8C  4A41                    1219                  TST.W   D1                      ; checks if it is valid
00001E8E  67EA                    1220                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001E90  6000 0002               1221                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001E94                          1222   
00001E94  323C 0001               1223  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001E98                          1224  
00001E98  4E75                    1225  END_CHECKGET    RTS          
00001E9A                          1226                                            
00001E9A                          1227                                            
00001E9A                          1228  * Gets the displacement and pritns it 
00001E9A                          1229  * Inputs: D2 = instruction word, A2 = address of next word
00001E9A                          1230  * Outputs: prints out displacement
00001E9A  48E7 4004               1231  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001E9E  3A4A                    1232                      MOVE.W    A2,A5                 ; copies A2 to A5
00001EA0  C47C 00FF               1233                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001EA4  6600 0004               1234                      BNE       PRINTADDRESS          ; prints address if not 0
00001EA8  341A                    1235                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001EAA                          1236                      
00001EAA  D44D                    1237  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001EAC  3202                    1238                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001EAE  183C 0000               1239                      MOVE.B    #0,D4                 ; marks address as word length
00001EB2  4BF9 000025E5           1240                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001EB8  4EB9 000022B2           1241                      JSR       PRINTNULL             ; prints null
00001EBE  4EB9 0000218C           1242                      JSR       PRINTSHORTLONGNUM     ; prints address
00001EC4                          1243                      
00001EC4  4CDF 2002               1244                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001EC8                          1245                      
00001EC8                          1246                     
00001EC8                          1247  * Gets the rotation value for ASd and LSd
00001EC8                          1248  * Input: D2 = instruction word copy (of D0)                                    
00001EC8                          1249  * Output: rotation  value in D2             
00001EC8  C47C 0E00               1250  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001ECC  E04A                    1251                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001ECE  E24A                    1252                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001ED0  4E75                    1253                      RTS                             ; return from subroutine
00001ED2                          1254  
00001ED2                          1255  * Gets the direction value for ASd and LSd
00001ED2                          1256  * Input: D2 = instruction word copy (of D0)                                    
00001ED2                          1257  * Output: direction value in D2             
00001ED2  C47C 0100               1258  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001ED6  E04A                    1259                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001ED8  4E75                    1260                      RTS                             ; return from subroutine
00001EDA                          1261  
00001EDA                          1262  * Gets the rotation size value for ASd and LSd
00001EDA                          1263  * Input: D2 = instruction word copy (of D0)                                    
00001EDA                          1264  * Output: rotation size value in D2             
00001EDA  C47C 00C0               1265  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001EDE  EC4A                    1266                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001EE0  4E75                    1267                      RTS                             ; return from subroutine
00001EE2                          1268  
00001EE2                          1269  * Gets the rotation location  value for ASd and LSd
00001EE2                          1270  * Input: D2 = instruction word copy (of D0)                                    
00001EE2                          1271  * Output: rotation location value in D2             
00001EE2  C47C 0020               1272  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001EE6  EA4A                    1273                      LSR.W      #5,D2                ; shifts 5 bits to the right to only have the rotation bits
00001EE8  4E75                    1274                      RTS                             ; return from subroutine
00001EEA                          1275  
00001EEA                          1276  * Prints out registers for MOVEM
00001EEA                          1277  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001EEA                          1278  * Output: printed out registers
00001EEA                          1279  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001EEA  48E7 4706               1280  PRINTREGISTERS      MOVEM.L    D1/D5-D7/A5-A6,-(SP) ; saves D1/D5-D7/A5-A6
00001EEE  3A3C 0000               1281                      MOVE.W     #0,D5                ; sets counter to 0
00001EF2  3E1A                    1282                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001EF4  B83C 0001               1283                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EF8  6600 0010               1284                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001EFC                          1285  
00001EFC  3C3C 0000               1286  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001F00  4BF9 000025D7           1287                      LEA        MSG_DR,A5            ; loads D to A5
00001F06  6000 000C               1288                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001F0A                          1289                      
00001F0A  3C3C 0007               1290  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001F0E  4BF9 000025D9           1291                      LEA        MSG_AR,A5            ; loads A to A5
00001F14                          1292                      
00001F14  E34F                    1293  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001F16  6500 0018               1294                      BCS        PRINTREG             ; if pushes out a 1
00001F1A  DC44                    1295                      ADD.W      D4,D6                ; decrements or increments
00001F1C  5245                    1296                      ADD.W      #1,D5                ; increments D5
00001F1E  BA7C 0008               1297                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F22  66F0                    1298                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F24  B83C 0001               1299                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F28  6600 0052               1300                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F2C  6000 0042               1301                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001F30                          1302                      
00001F30  4EB9 000022B2           1303  PRINTREG            JSR        PRINTNULL
00001F36  3206                    1304                      MOVE.W     D6,D1
00001F38  4EB9 00002168           1305                      JSR        PRINTNUM 
00001F3E                          1306    
00001F3E  BE7C 0000               1307  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001F42  6600 0006               1308                      BNE        PRINTMORE            ; continue if there is more
00001F46  6000 0040               1309                      BRA        DONEPRINTINGREG      ; exit case
00001F4A                          1310  
00001F4A  2C4D                    1311  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001F4C  4BF9 000025EA           1312                      LEA        MSG_SLASH,A5         ; leads / into A5
00001F52  4EB9 000022B2           1313                      JSR        PRINTNULL            ; prints the slash
00001F58  2A4E                    1314                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001F5A  DC44                    1315                      ADD.W      D4,D6                ; decrements or increments
00001F5C  5245                    1316                      ADD.W      #1,D5                ; increments D5
00001F5E  BA7C 0008               1317                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F62  66B0                    1318                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F64  B83C 0001               1319                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F68  6600 0012               1320                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F6C  6000 0002               1321                      BRA        REGTOMEM2            ; loops
00001F70                          1322  
00001F70  3C3C 0000               1323  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001F74  4BF9 000025D9           1324                      LEA        MSG_AR,A5            ; loads A to A5
00001F7A  6098                    1325                      BRA        PRINTREGISTERLOOP    ; loops
00001F7C                          1326  
00001F7C  3C3C 0007               1327  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001F80  4BF9 000025D7           1328                      LEA        MSG_DR,A5            ; loads D to A5
00001F86  608C                    1329                      BRA        PRINTREGISTERLOOP    ; loops
00001F88                          1330  
00001F88  4CDF 60E2               1331  DONEPRINTINGREG     MOVEM.L    (SP)+,D1/D5-D7/A5-A6 ; saves D1/D5-D7/A5-A6
00001F8C                          1332  
00001F8C                          1333                          
00001F8C                          1334  * Checks if EA or Xn is valid
00001F8C                          1335  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001F8C                          1336  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001F8C  2F02                    1337  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001F8E                          1338  
00001F8E  141D                    1339  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001F90  B43C 00FF               1340                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001F94  6700 000A               1341                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001F98  B202                    1342                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001F9A  6700 000C               1343                     BEQ        VALIDEA               ; branches to valid EA
00001F9E  60EE                    1344                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001FA0                          1345                     
00001FA0  323C 0001               1346  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001FA4  6000 0016               1347                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001FA8                          1348                    
00001FA8  B43C 0007               1349  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001FAC  6700 000A               1350                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001FB0  323C 0000               1351                     MOVE.W     #$0,D1                ; marks that it is valid
00001FB4  6000 0006               1352                     BRA        CHECKEAEXIT           ; exits the subroutine
00001FB8                          1353  
00001FB8  323C 0002               1354  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001FBC                          1355  
00001FBC  241F                    1356  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001FBE  4E75                    1357                     RTS                              ; returns from subroutine
00001FC0                          1358  
00001FC0                          1359  * Converts EA and Xn into a string                                
00001FC0                          1360  * Inputs: D1 = operation size, D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001FC0                          1361  * Outputs: Prints out EA and Xn into a string
00001FC0  48E7 C004               1362  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001FC4  B47C 0001               1363                     CMP.W    #An,D2                  ; checks if it is An
00001FC8  6700 003A               1364                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001FCC                          1365                     
00001FCC  B47C 0002               1366                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001FD0  6700 004A               1367                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001FD4                          1368                     
00001FD4  B47C 0003               1369                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001FD8  6700 0072               1370                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001FDC                          1371                     
00001FDC  B47C 0004               1372                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001FE0  6700 00A6               1373                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001FE4                          1374                     
00001FE4  B47C 0007               1375                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001FE8  6700 00DA               1376                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001FEC                          1377                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001FEC                          1378  
00001FEC                          1379  * data register, Dn
00001FEC  4BF9 000025D7           1380  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001FF2  4EB9 000022B2           1381                     JSR      PRINTNULL               ; Prints D
00001FF8  3203                    1382                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FFA  4EB9 00002168           1383                     JSR      PRINTNUM                ; Prints the Xn
00002000  6000 0160               1384                     BRA      EA_TO_STRING_EXIT       ; exits           
00002004                          1385  
00002004                          1386  
00002004                          1387  * address register
00002004  4BF9 000025D9           1388  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
0000200A  4EB9 000022B2           1389                     JSR      PRINTNULL               ; Prints A
00002010  3203                    1390                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002012  4EB9 00002168           1391                     JSR      PRINTNUM                ; Prints the Xn
00002018  6000 0148               1392                     BRA      EA_TO_STRING_EXIT       ; exits
0000201C                          1393  
0000201C                          1394  * address register indirect
0000201C  4BF9 000025DB           1395  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00002022  4EB9 000022B2           1396                     JSR      PRINTNULL               ; Prints (
00002028  4BF9 000025D9           1397                     LEA      MSG_AR,A5               ; Loads A into A5
0000202E  4EB9 000022B2           1398                     JSR      PRINTNULL               ; Prints A
00002034  3203                    1399                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002036  4EB9 00002168           1400                     JSR      PRINTNUM                ; Prints the Xn
0000203C  4BF9 000025DD           1401                     LEA      MSG_RB,A5               ; Loads ) into A5
00002042  4EB9 000022B2           1402                     JSR      PRINTNULL               ; Prints )
00002048  6000 0118               1403                     BRA      EA_TO_STRING_EXIT       ; exits
0000204C                          1404  
0000204C                          1405  * address register indirect post increment
0000204C  4BF9 000025DB           1406  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00002052  4EB9 000022B2           1407                     JSR      PRINTNULL               ; Prints (
00002058  4BF9 000025D9           1408                     LEA      MSG_AR,A5               ; Loads A into A5
0000205E  4EB9 000022B2           1409                     JSR      PRINTNULL               ; Prints A
00002064  3203                    1410                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002066  4EB9 00002168           1411                     JSR      PRINTNUM                ; Prints the Xn
0000206C  4BF9 000025DD           1412                     LEA      MSG_RB,A5               ; Loads ) into A5
00002072  4EB9 000022B2           1413                     JSR      PRINTNULL               ; Prints )
00002078  4BF9 000025DF           1414                     LEA      MSG_PLUS,A5             ; Loads + into A5
0000207E  4EB9 000022B2           1415                     JSR      PRINTNULL               ; Prints +
00002084  6000 00DC               1416                     BRA      EA_TO_STRING_EXIT       ; exits
00002088                          1417  
00002088                          1418  
00002088                          1419  * address register indirect pre increment
00002088  4BF9 000025E1           1420  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
0000208E  4EB9 000022B2           1421                     JSR      PRINTNULL               ; Prints -
00002094  4BF9 000025DB           1422                     LEA      MSG_LB,A5               ; Loads ( into A5
0000209A  4EB9 000022B2           1423                     JSR      PRINTNULL               ; Prints (
000020A0  4BF9 000025D9           1424                     LEA      MSG_AR,A5               ; Loads A into A5
000020A6  4EB9 000022B2           1425                     JSR      PRINTNULL               ; Prints A
000020AC  3203                    1426                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000020AE  4EB9 00002168           1427                     JSR      PRINTNUM                ; Prints the Xn
000020B4  4BF9 000025DD           1428                     LEA      MSG_RB,A5               ; Loads ) into A5
000020BA  4EB9 000022B2           1429                     JSR      PRINTNULL               ; Prints )
000020C0  6000 00A0               1430                     BRA      EA_TO_STRING_EXIT       ; exits
000020C4                          1431  
000020C4                          1432  * other (long, short, immediate) with Xn yes
000020C4  301A                    1433  CASE_OTHER         MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000020C6  B67C 0000               1434                     CMP.W    #ABSShort,D3            ; checks if it is a word
000020CA  6700 0054               1435                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000020CE                          1436                     
000020CE  B67C 0001               1437                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000020D2  6700 0068               1438                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000020D6                          1439  
000020D6                          1440  * immediate
000020D6  4BF9 000025E3           1441  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000020DC  4EB9 000022B2           1442                     JSR      PRINTNULL               ; Prints #  
000020E2  4BF9 000025E5           1443                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020E8  4EB9 000022B2           1444                     JSR      PRINTNULL               ; Prints $
000020EE                          1445                     
000020EE  B27C 0002               1446                     CMP.W    #2,D1                   ; checks if it is long size
000020F2  6700 000E               1447                     BEQ      IMMEDIATE_LONG          ; branches if it is a long
000020F6                          1448                     
000020F6  3200                    1449                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020F8  4EB9 00002178           1450                     JSR      PRINTHEXNUM 
000020FE  6000 0062               1451                     BRA      EA_TO_STRING_EXIT       ; exits subroutine  
00002102                          1452  
00002102  3200                    1453  IMMEDIATE_LONG     MOVE.W   D0, D1                  ; moves instruction word into d1
00002104  383C 0000               1454                     MOVE.W   #0, D4                  ; moves word size into d4
00002108  4EB9 0000218C           1455                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000210E  301A                    1456                     MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002110  3200                    1457                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002112  383C 0000               1458                     MOVE.W   #0, D4                  ; moves word size into d4
00002116  4EB9 0000218C           1459                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000211C                          1460                     *MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
0000211C  6000 0044               1461                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00002120                          1462                     
00002120                          1463  * word address
00002120                          1464  CASE_WORD          
00002120  4BF9 000025E5           1465                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002126  4EB9 000022B2           1466                     JSR      PRINTNULL               ; Prints $
0000212C  3200                    1467                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000212E  383C 0000               1468                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00002132  4EB9 0000218C           1469                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002138  6000 0028               1470                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000213C                          1471  
0000213C                          1472  * long address 
0000213C                          1473  CASE_LONG          
0000213C  4BF9 000025E5           1474                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002142  4EB9 000022B2           1475                     JSR      PRINTNULL               ; Prints $
00002148  3200                    1476                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000214A  383C 0000               1477                     MOVE.W   #0, D4                  ; moves word size into d4
0000214E  4EB9 0000218C           1478                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002154  301A                    1479                     MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002156  3200                    1480                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002158  383C 0000               1481                     MOVE.W   #0, D4                  ; moves word size into d4
0000215C  4EB9 0000218C           1482                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002162                          1483                     *MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002162                          1484                     
00002162                          1485  * exits subroutine
00002162  4CDF 2003               1486  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00002166  4E75                    1487                      RTS                              ; returns from subroutine
00002168                          1488  
00002168                          1489  * Prints out the content of D1 as a decimal number
00002168                          1490  * Input: number in D1 to be printed
00002168                          1491  * Output: contents of D1 printed
00002168  48E7 C000               1492  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000216C  103C 0003               1493                   MOVE.B      #3,D0               ; prints D1
00002170  4E4F                    1494                   TRAP        #15                 ; is trap task 3
00002172                          1495              
00002172  4CDF 0003               1496                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00002176  4E75                    1497                   RTS                             ; returns from subroutine
00002178                          1498                   
00002178                          1499  * Prints out the content of D1 as a hex number
00002178                          1500  * Input: number in D1 to be printed
00002178                          1501  * Output: contents of D1 printed
00002178  48E7 C000               1502  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000217C  143C 0010               1503                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002180  103C 000F               1504                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002184  4E4F                    1505                   TRAP        #15                 ; is trap task 15
00002186  4CDF 0003               1506                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000218A  4E75                    1507                   RTS                             ; returns from subroutine
0000218C                          1508                   
0000218C                          1509  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
0000218C                          1510  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
0000218C                          1511  * Output: contents of D1 printed
0000218C  48E7 E000               1512  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00002190  B83C 0001               1513                            CMP.B       #1,D4               ; checks size of number
00002194  6700 0042               1514                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00002198                          1515  
00002198  3401                    1516  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
0000219A  C47C F000               1517                            AND.W       #$F000,D2           ; gets the first digit
0000219E  B47C 0000               1518                            CMP.W       #0, D2              ; checks if it is 0
000021A2  6600 00DC               1519                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021A6  4EB9 00002290           1520                            JSR         PRINTZERO           ; prints a zero
000021AC                          1521                            
000021AC  3401                    1522                            MOVE.W      D1,D2               ; copies number to D2
000021AE  C47C 0F00               1523                            AND.W       #$0F00,D2           ; gets the second digit
000021B2  B47C 0000               1524                            CMP.W       #0, D2              ; checks if it is 0
000021B6  6600 00C8               1525                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021BA  4EB9 00002290           1526                            JSR         PRINTZERO           ; prints a zero
000021C0                          1527                            
000021C0  3401                    1528                            MOVE.W      D1,D2               ; copies number to D2
000021C2  C47C 00F0               1529                            AND.W       #$00F0,D2           ; gets the third digit
000021C6  B47C 0000               1530                            CMP.W       #0, D2              ; checks if it is 0
000021CA  6600 00B4               1531                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021CE  4EB9 00002290           1532                            JSR         PRINTZERO           ; prints a zero
000021D4  6000 00AA               1533                            BRA         PRINTASHEX          ; prints last digit
000021D8                          1534                            
000021D8  2401                    1535  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
000021DA  C4BC F0000000           1536                            AND.L       #$F0000000,D2       ; gets the first digit
000021E0  B4BC 00000000           1537                            CMP.L       #0, D2              ; checks if it is 0
000021E6  6600 0098               1538                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021EA  4EB9 00002290           1539                            JSR         PRINTZERO           ; prints a zero
000021F0                          1540                            
000021F0  2401                    1541                            MOVE.L      D1,D2               ; copies number to D2
000021F2  C4BC 0F000000           1542                            AND.L       #$0F000000,D2       ; gets the second digit
000021F8  B4BC 00000000           1543                            CMP.L       #0, D2              ; checks if it is 0
000021FE  6600 0080               1544                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002202  4EB9 00002290           1545                            JSR         PRINTZERO           ; prints a zero
00002208                          1546                            
00002208  2401                    1547                            MOVE.L      D1,D2               ; copies number to D2
0000220A  C4BC 00F00000           1548                            AND.L       #$00F00000,D2       ; gets the third digit
00002210  B4BC 00000000           1549                            CMP.L       #0, D2              ; checks if it is 0
00002216  6600 0068               1550                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000221A  4EB9 00002290           1551                            JSR         PRINTZERO           ; prints a zero
00002220                          1552                            
00002220  2401                    1553                            MOVE.L      D1,D2               ; copies number to D2
00002222  C4BC 000F0000           1554                            AND.L       #$000F0000,D2       ; gets the fourth digit
00002228  B4BC 00000000           1555                            CMP.L       #0, D2              ; checks if it is 0
0000222E  6600 0050               1556                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002232  4EB9 00002290           1557                            JSR         PRINTZERO           ; prints a zero
00002238                          1558                            
00002238  2401                    1559                            MOVE.L      D1,D2               ; copies number to D2
0000223A  C4BC 0000F000           1560                            AND.L       #$0000F000,D2       ; gets the fith digit
00002240  B4BC 00000000           1561                            CMP.L       #0, D2              ; checks if it is 0
00002246  6600 0038               1562                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000224A  4EB9 00002290           1563                            JSR         PRINTZERO           ; prints a zero
00002250                          1564                            
00002250  2401                    1565                            MOVE.L      D1,D2               ; copies number to D2
00002252  C4BC 00000F00           1566                            AND.L       #$00000F00,D2       ; gets the sixth digit
00002258  B4BC 00000000           1567                            CMP.L       #0, D2              ; checks if it is 0
0000225E  6600 0020               1568                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002262  4EB9 00002290           1569                            JSR         PRINTZERO           ; prints a zero
00002268                          1570                            
00002268  2401                    1571                            MOVE.L      D1,D2               ; copies number to D2
0000226A  C4BC 000000F0           1572                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002270  B4BC 00000000           1573                            CMP.L       #0, D2              ; checks if it is 0
00002276  6600 0008               1574                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000227A  4EB9 00002290           1575                            JSR         PRINTZERO           ; prints a zero
00002280                          1576  
00002280  143C 0010               1577  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002284  103C 000F               1578                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002288  4E4F                    1579                            TRAP        #15                 ; is trap task 15
0000228A  4CDF 0007               1580                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
0000228E  4E75                    1581                            RTS                             ; returns from subroutine    
00002290                          1582  * Prints a zero
00002290                          1583  * Input: nothing
00002290                          1584  * Output: 0 printed out to the console
00002290  2F01                    1585  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002292  7200                    1586                            MOVE.L      #0,D1               ; moves 0 to D1
00002294  4EB8 2168               1587                            JSR         PRINTNUM            ; prints the number
00002298  221F                    1588                            MOVE.L      (SP)+,D1            ; restores D1
0000229A  4E75                    1589                            RTS                             ; returns from subroutine
0000229C                          1590              
0000229C                          1591  * Prints contents of things between a range
0000229C                          1592  * input: A5, A6 (the range)
0000229C                          1593  * output: prints memory contents from A5 to A6 as strings   
0000229C  48E7 C040               1594  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
000022A0  224D                    1595                  MOVEA.L     A5, A1           ; loads A5 into A1
000022A2  9DCD                    1596                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
000022A4  320E                    1597                  MOVE.W      A6, D1           ; move n into D1
000022A6  103C 0001               1598                  MOVE.B      #1, D0           ; display n characters of string at A1
000022AA  4E4F                    1599                  TRAP        #15              ; is trap task 1
000022AC  4CDF 0203               1600                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
000022B0  4E75                    1601                  RTS                          ; returns
000022B2                          1602      
000022B2                          1603  * Prints null terminated string
000022B2                          1604  * input: string pointed to by A5
000022B2                          1605  * output: prints out the null terminated string
000022B2  48E7 8040               1606  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
000022B6  224D                    1607                  MOVE.L      A5,A1           ; loads A5 into A1
000022B8  103C 000E               1608                  MOVE.B      #14,D0          ; prints null terminated string
000022BC  4E4F                    1609                  TRAP        #15             ; is trap task 10
000022BE  4CDF 0201               1610                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
000022C2  4E75                    1611                  RTS                         ; returns from subroutine
000022C4                          1612                  
000022C4  2F0D                    1613  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
000022C6  4BF9 00002516           1614                  LEA         NEW_LINE,A5     ; Prints null
000022CC  4EB8 22B2               1615                  JSR         PRINTNULL       ; prints the new line
000022D0  2A5F                    1616                  MOVE.L      (SP)+,A5        ; returns A5
000022D2  4E75                    1617                  RTS
000022D4                          1618  
000022D4                          1619  * Prints the size of the MOVE or MOVEA operation  
000022D4                          1620  * input: D0
000022D4                          1621  * output: prints out the size of a MOVE or MOVEA operation        
000022D4  48E7 0004               1622  PRINTMOVESIZE   MOVEM.L A5,-(SP)         ; saves D0 and A5
000022D8  3200                    1623                  MOVE.W  D0,D1               ; stores d0 in d1
000022DA  C27C 3000               1624                  AND.W   #$3000,D1           ; gets the size
000022DE  B27C 2000               1625                  CMP.W   #$2000,D1           ; checks if is long
000022E2  6700 001E               1626                  BEQ     MOVE_LONG
000022E6  B27C 3000               1627                  CMP.W   #$3000,D1           ; checks if is word
000022EA  6700 000C               1628                  BEQ     MOVE_WORD      
000022EE                          1629                  
000022EE  4BF9 0000260E           1630  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000022F4  6000 0012               1631                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000022F8                          1632  
000022F8  4BF9 00002611           1633  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000022FE  6000 0008               1634                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002302                          1635  
00002302  4BF9 00002614           1636  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00002308                          1637                  
00002308  4EB8 22B2               1638  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
0000230C  E049                    1639                  LSR.W   #8,D1               ; shifts bytes 8 to the right
0000230E  E849                    1640                  LSR.W   #4,D1               ; shifts bytes 4 to the right
00002310  4CDF 2000               1641                  MOVEM.L (SP)+,A5            ; restores D0 and A5
00002314  4E75                    1642                  RTS
00002316                          1643  
00002316  43F9 00002485           1644  ERROR           LEA     ERROR_MSG,A1
0000231C  103C 000E               1645                  MOVE.B  #14,D0
00002320  4E4F                    1646                  TRAP    #15 
00002322                          1647            
00002322  FFFF FFFF               1648      SIMHALT             ; halt simulator
00002326                          1649  
00002326                          1650  * Put variables and constants here
00002326                          1651  
00002326  =0000000D               1652  CR                              EQU     $0D
00002326  =0000000A               1653  LF                              EQU     $0A 
00002326  =00000009               1654  TAB                             EQU     $09  
00002326                          1655  
00002326                          1656  * Addressing Modes
00002326  =00000000               1657  Dn                              EQU     0
00002326  =00000001               1658  An                              EQU     1
00002326  =00000002               1659  AnIndirect                      EQU     2
00002326  =00000003               1660  AnPost                          EQU     3
00002326  =00000004               1661  AnPre                           EQU     4
00002326  =00000007               1662  Other                           EQU     7           ; short, long, immediate
00002326                          1663  
00002326                          1664  * Xn
00002326  =00000000               1665  ABSShort                        EQU     0
00002326  =00000001               1666  ABSLong                         EQU     1
00002326  =00000004               1667  XnImmediate                     EQU     4
00002326                          1668  
00002326                          1669  * Valid Addressing Modes
00002326= 00 01 02 03 04 07 FF    1670  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
0000232D                          1671  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
0000232D= 00 02 03 04 07 FF       1672  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002333= 02 04 07 FF             1673  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002337= 02 03 07 FF             1674  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000233B= 02 03 04 07 FF          1675  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002340= 00 02 03 04 07 FF       1676  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002346= 01 07 FF                1677  VALIDEA_LEA                     DC.B    An,Other,-1
00002349= 00 02 03 04 07 FF       1678  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000234F= 02 03 04 07 FF          1679  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002354= 02 03 04 07 FF          1680  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00002359= 02 07 FF                1681  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
0000235C                          1682  
0000235C                          1683  * Valid Xn
0000235C= 00 01 04 FF             1684  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00002360                          1685  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00002360= 00 01 FF                1686  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00002363                          1687  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00002363                          1688  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00002363                          1689  
00002363                          1690  * posible memory ASd/LSd rotation values
00002363  =00000000               1691  ASd_MEM                         EQU     0   
00002363  =00000001               1692  LSd_MEM                         EQU     1 
00002363  =00000003               1693  ROd_MEM                         EQU     3
00002363                          1694   
00002363  =00000000               1695  ASd_REG                         EQU     0   
00002363  =00000001               1696  LSd_REG                         EQU     1 
00002363  =00000003               1697  ROd_REG                         EQU     3
00002363                          1698  
00002363                          1699  * Messages
00002363= 57 65 6C 63 6F 6D ...   1700  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
0000238B= 46 6F 72 6D 61 74 ...   1701  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
000023D6= 4C 65 74 74 65 72 ...   1702  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000023F6= 50 6C 65 61 73 65 ...   1703  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
0000242D= 50 6C 65 61 73 65 ...   1704  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00002463= 49 6E 76 61 6C 69 ...   1705  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002485= 45 72 72 6F 72 20 ...   1706  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
000024A1= 09 44 41 54 41 00       1707  INVALID_INSTR                   DC.B    TAB,'DATA',0
000024A7= 46 69 6E 69 73 68 ...   1708  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
000024EB= 0D 0A 50 72 65 73 ...   1709  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
00002516= 0D 0A 00                1710  NEW_LINE                        DC.B    CR,LF,0
00002519= 09 09 09 00             1711  THREE_TAB                       DC.B    TAB,TAB,TAB,0
0000251D                          1712  
0000251D                          1713  * Opcode Messages
0000251D= 09 4E 4F 50 00          1714  MSG_NOP                         DC.B    TAB,'NOP',0
00002522= 09 4D 4F 56 45 00       1715  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00002528= 09 4D 4F 56 45 41 00    1716  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
0000252F= 09 4D 4F 56 45 51 00    1717  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00002536= 09 4D 4F 56 45 4D 00    1718  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
0000253D= 09 41 44 44 00          1719  MSG_ADD                         DC.B    TAB,'ADD',0
00002542= 09 41 44 44 41 00       1720  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002548= 09 41 44 44 51 00       1721  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
0000254E= 09 53 55 42 00          1722  MSG_SUB                         DC.B    TAB,'SUB',0
00002553= 09 4D 55 4C 53 00       1723  MSG_MULS                        DC.B    TAB,'MULS',0
00002559= 09 44 49 56 55 00       1724  MSG_DIVU                        DC.B    TAB,'DIVU',0
0000255F= 09 4C 45 41 00          1725  MSG_LEA                         DC.B    TAB,'LEA',0
00002564= 09 41 4E 44 00          1726  MSG_AND                         DC.B    TAB,'AND',0
00002569= 09 4F 52 00             1727  MSG_OR                          DC.B    TAB,'OR',0
0000256D= 09 4E 4F 54 00          1728  MSG_NOT                         DC.B    TAB,'NOT',0
00002572= 09 4C 53 00             1729  MSG_LSd                         DC.B    TAB,'LS',0
00002576= 09 41 53 00             1730  MSG_ASd                         DC.B    TAB,'AS',0
0000257A= 09 52 4F 00             1731  MSG_ROd                         DC.B    TAB,'RO',0
0000257E= 09 42 43 43 00          1732  MSG_BCC                         DC.B    TAB,'BCC',0
00002583= 09 42 43 53 00          1733  MSG_BCS                         DC.B    TAB,'BCS',0
00002588= 09 42 45 51 00          1734  MSG_BEQ                         DC.B    TAB,'BEQ',0
0000258D= 09 42 4E 45 00          1735  MSG_BNE                         DC.B    TAB,'BNE',0
00002592= 09 42 47 45 00          1736  MSG_BGE                         DC.B    TAB,'BGE',0
00002597= 09 42 47 54 00          1737  MSG_BGT                         DC.B    TAB,'BGT',0
0000259C= 09 42 48 49 00          1738  MSG_BHI                         DC.B    TAB,'BHI',0
000025A1= 09 42 4C 45 00          1739  MSG_BLE                         DC.B    TAB,'BLE',0
000025A6= 09 42 4C 53 00          1740  MSG_BLS                         DC.B    TAB,'BLS',0
000025AB= 09 42 4C 54 00          1741  MSG_BLT                         DC.B    TAB,'BLT',0
000025B0= 09 42 4D 49 00          1742  MSG_BMI                         DC.B    TAB,'BMI',0
000025B5= 09 42 50 4C 00          1743  MSG_BPL                         DC.B    TAB,'BPL',0
000025BA= 09 42 56 43 00          1744  MSG_BVC                         DC.B    TAB,'BVC',0
000025BF= 09 42 56 53 00          1745  MSG_BVS                         DC.B    TAB,'BVS',0
000025C4= 09 4A 53 52 00          1746  MSG_JSR                         DC.B    TAB,'JSR',0
000025C9= 09 52 54 53 00          1747  MSG_RTS                         DC.B    TAB,'RTS',0
000025CE= 09 42 52 41 00          1748  MSG_BRA                         DC.B    TAB,'BRA',0
000025D3                          1749  
000025D3                          1750  * Direction for LSd and ASd
000025D3= 52 00                   1751  MSG_RIGHT                       DC.B    'R',0
000025D5= 4C 00                   1752  MSG_LEFT                        DC.B    'L',0
000025D7                          1753  
000025D7                          1754  * Effective Addresses Messages
000025D7= 44 00                   1755  MSG_DR                          DC.B    'D',0
000025D9= 41 00                   1756  MSG_AR                          DC.B    'A',0
000025DB= 28 00                   1757  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000025DD= 29 00                   1758  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000025DF= 2B 00                   1759  MSG_PLUS                        DC.B    '+',0
000025E1= 2D 00                   1760  MSG_MINUS                       DC.B    '-',0
000025E3= 23 00                   1761  MSG_POUND                       DC.B    '#',0 
000025E5= 24 00                   1762  MSG_HEX                         DC.B    '$',0 
000025E7= 2C 20 00                1763  MSG_COMMA                       DC.B    ', ',0
000025EA= 2F 00                   1764  MSG_SLASH                       DC.B    '/',0  
000025EC= 20 00                   1765  MSG_SPACE                       DC.B    ' ',0
000025EE= 09 00                   1766  MSG_TAB                         DC.B    TAB,0
000025F0= 20 20 20 00             1767  MSG_3SPACES                     DC.B    '   ',0
000025F4= 20 20 20 20 00          1768  MSG_4SPACES                     DC.B    '    ',0
000025F9= 20 20 20 20 20 00       1769  MSG_5SPACES                     DC.B    '     ',0
000025FF= 20 20 20 20 20 20 00    1770  MSG_6SPACES                     DC.B    '      ',0
00002606= 20 20 20 20 20 20 ...   1771  MSG_7SPACES                     DC.B    '       ',0
0000260E                          1772  
0000260E                          1773  * Size Messages
0000260E= 2E 42 00                1774  MSG_B                           DC.B    '.B',0
00002611= 2E 57 00                1775  MSG_W                           DC.B    '.W',0
00002614= 2E 4C 00                1776  MSG_L                           DC.B    '.L',0
00002617                          1777  
00002617                          1778  * Variables
00002617  =00000100               1779  STARTING_ADDRESS                EQU     $100
00002617  =00000150               1780  ENDING_ADDRESS                  EQU     $150
00002617  =00000200               1781  CURRENT_INSTR                   EQU     $200
00002617  =00000250               1782  REG_VAR                         EQU     $250 * Hold bits 11-9
00002617  =00000300               1783  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00002617  =00000350               1784  EA_MODE                         EQU     $350 * Hold bits 5-3
00002617  =00000400               1785  EA_REG                          EQU     $400 * Hold bits 2-0
00002617= 00                      1786  LINE_COUNT                      DC.B     0
00002618= 19                      1787  LINE_MAX                        DC.B     25
00002619                          1788              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1690
ADDQ_BYTE           1732
ADDQ_LONG           176A
ADDQ_WORD           174E
ADD_SUB_BYTE        15AE
ADD_SUB_HELP        1528
ADD_SUB_LONG        15CA
ADD_SUB_OPERAND     15E0
ADD_SUB_SIZE        158A
ADD_SUB_WORD        15BC
AN                  1
AND_BYTE            1954
AND_LONG            198C
AND_WORD            1970
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           2463
CASE_ADD            1500
CASE_ADDA           1658
CASE_ADDQ           16DC
CASE_AND            190E
CASE_AR             2004
CASE_ARI            201C
CASE_ARIPOST        204C
CASE_ARIPRE         2088
CASE_ASDMEM         1AE8
CASE_ASDREG         1BBC
CASE_BCC            1D24
CASE_BEQ            1D56
CASE_BGT            1D6A
CASE_BLE            1D60
CASE_BRA            1CF4
CASE_DATA           1DF2
CASE_DR             1FEC
CASE_EPICFAIL       1DF8
CASE_IMMEDIATE      20D6
CASE_JSR            1D90
CASE_LEA            1870
CASE_LEFTMEM        1B0E
CASE_LEFTREG        1BE2
CASE_LONG           213C
CASE_LSDASDROD      1AA8
CASE_LSDMEM         1ADE
CASE_LSDREG         1BB2
CASE_MOVE           12AC
CASE_MOVEM          1372
CASE_MOVEQ          1478
CASE_NOP            1296
CASE_NOT            1A44
CASE_OR             19E4
CASE_OTHER          20C4
CASE_RIGHTMEM       1B18
CASE_RIGHTREG       1BEC
CASE_RODMEM         1AF2
CASE_RODREG         1BC6
CASE_RTS            1DDC
CASE_SHIFTMEM       1AC6
CASE_SHIFTREG       1B98
CASE_SUB            17D8
CASE_SUBA           185A
CASE_WORD           2120
CHECKEAEXIT         1FBC
CHECKEAMLOOP        1F8E
CHECKEAXN_IFVALID   1F8C
CHECKGET_EAXN       1E52
CHECKMEMSOURE       1B58
CHECKMOREBITS       1F3E
CHECKSHIFT_XN       1B82
CHECK_LENGTH        11DE
CHECK_LINE          1186
CHECK_ODD           127A
CHECK_ORDER         10AE
CHECK_XN            1E82
CLEAR_SCREEN        11BA
COMPLETE_REGIM      1C64
CONCAT              1226
CONTINUE            24EB
CONVERT             11F0
CR                  D
CURRENT_INSTR       200
DESTEA              1E08
DESTXN              1E32
DISASSEMBLE         10D4
DN                  0
DN_PLUS_EA          1624
DONE                24A7
DONEPRINTINGREG     1F88
EASHIFT_VALID       1B76
EAXN_INVALID        1E94
EAXN_VALID          1E7A
EA_MODE             350
EA_REG              400
EA_TO_STRING        1FC0
EA_TO_STRING_EXIT   2162
ENDING              242D
ENDING_ADDRESS      150
END_CHECKGET        1E98
ERROR               2316
ERROR_MSG           2485
FINDTYPEEA          1E1C
FINDTYPEXN          1E46
FINISHED            10F8
FINISHMOVE          2308
FINISH_ADD          15D8
FINISH_ADDA         16B0
FINISH_ADDQ         1786
FINISH_AND          19A8
FINISH_SUB          1820
FINISH_SUBA         1826
FORMAT1             238B
FORMAT2             23D6
GETDIRECTION        1ED2
GETDISPLACEMENT     1E9A
GETMEMSOURCE        1B40
GETROTATION         1EC8
GETROTATIONLOCATION  1EE2
GETROTATIONSIZE     1EDA
GET_EA              1DFE
GET_XN              1E28
IMMEDIATE_LONG      2102
INPUT1              1020
INPUT2              1066
INSERTA             1332
INVALID             123E
INVALIDEA           1FA0
INVALID_INSTR       24A1
INV_INSTR           19B2
ISNUMBER            1206
LF                  A
LINE_COUNT          2617
LINE_MAX            2618
LSD_MEM             1
LSD_REG             1
MAKESHIFT8          1C60
MEM2REGLONG         1442
MEM2REGWORD         1438
MEMTOREG1           1F0A
MEMTOREG2           1F7C
MOVEM_MEM2REG       1404
MOVEM_REG2MEM       1390
MOVE_BYTE           22EE
MOVE_LONG           2302
MOVE_WORD           22F8
MSG_3SPACES         25F0
MSG_4SPACES         25F4
MSG_5SPACES         25F9
MSG_6SPACES         25FF
MSG_7SPACES         2606
MSG_ADD             253D
MSG_ADDA            2542
MSG_ADDQ            2548
MSG_AND             2564
MSG_AR              25D9
MSG_ASD             2576
MSG_B               260E
MSG_BCC             257E
MSG_BCS             2583
MSG_BEQ             2588
MSG_BGE             2592
MSG_BGT             2597
MSG_BHI             259C
MSG_BLE             25A1
MSG_BLS             25A6
MSG_BLT             25AB
MSG_BMI             25B0
MSG_BNE             258D
MSG_BPL             25B5
MSG_BRA             25CE
MSG_BVC             25BA
MSG_BVS             25BF
MSG_COMMA           25E7
MSG_DIVU            2559
MSG_DR              25D7
MSG_HEX             25E5
MSG_JSR             25C4
MSG_L               2614
MSG_LB              25DB
MSG_LEA             255F
MSG_LEFT            25D5
MSG_LSD             2572
MSG_MINUS           25E1
MSG_MOVE            2522
MSG_MOVEA           2528
MSG_MOVEM           2536
MSG_MOVEQ           252F
MSG_MULS            2553
MSG_NOP             251D
MSG_NOT             256D
MSG_OR              2569
MSG_PLUS            25DF
MSG_POUND           25E3
MSG_RB              25DD
MSG_RIGHT           25D3
MSG_ROD             257A
MSG_RTS             25C9
MSG_SLASH           25EA
MSG_SPACE           25EC
MSG_SUB             254E
MSG_TAB             25EE
MSG_W               2611
NEW_LINE            2516
NEXT_SCREEN         119A
NOTNUMBER           120E
OPCODE_DECODE       128E
OPMODE_VAR          300
OR_SIZE             1A2C
OTHER               7
OTHEREA             1FB8
PRINTADD            1566
PRINTADDRESS        1EAA
PRINTASHEX          2280
PRINTBCC            1D74
PRINTENTER          22C4
PRINTHEXNUM         2178
PRINTLONGZERO       21D8
PRINTMEM2REG        1448
PRINTMORE           1F4A
PRINTMOVE           1350
PRINTMOVESIZE       22D4
PRINTNULL           22B2
PRINTNUM            2168
PRINTRANGE          229C
PRINTREG            1F30
PRINTREG2MEM        13D4
PRINTREGEA          1C2E
PRINTREGISTERLOOP   1F14
PRINTREGISTERS      1EEA
PRINTREGSIZE        1BFC
PRINTSHIFTMEM       1AF8
PRINTSHIFTREG       1BCC
PRINTSHORTLONGNUM   218C
PRINTSHORTZERO      2198
PRINTSUB            17EE
PRINTZERO           2290
PRINT_8             17CC
PRINT_ADDQ_DATA     17A6
PRINT_ADDR          1282
PRINT_JSR           1DBC
PRINT_MEMDIR        1B1E
PRINT_MOVEQ         149A
PRINT_REGDIR        1BF6
READ_KEY            11AA
REG2MEMLONG         13CE
REG2MEMWORD         13C4
REGTOMEM1           1EFC
REGTOMEM2           1F70
REG_BYTE            1C14
REG_IMMEDIATE       1C50
REG_LONG            1C28
REG_REGISTER        1CAE
REG_VAR             250
REG_WORD            1C1E
RESET_INPUT         11D6
RESTART             1120
RETURN              123C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1E14
SOURCEXN            1E3E
START               1000
STARTING            23F6
STARTING_ADDRESS    100
TAB                 9
TEST                1DFA
TEST_RANGE          1262
THREE_TAB           2519
VALIDEA             1FA8
VALIDEA_ADDSUB_DESTOPERAND  233B
VALIDEA_ALL         2326
VALIDEA_ANDORNOT    2349
VALIDEA_ANDOR_DESTOPERAND  234F
VALIDEA_JSR         2359
VALIDEA_LEA         2346
VALIDEA_MOVEM_MEMTOREG  2337
VALIDEA_MOVEM_REGTOMEM  2333
VALIDEA_MOVEQ       232D
VALIDEA_MULSDIVU    2340
VALIDEA_SHIFT       2354
VALIDXN_ALL         235C
VALIDXN_SHORTLONG   2360
WELCOME             2363
XNIMMEDIATE         4
