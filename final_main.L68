00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/8/2020 2:15:56 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00002263             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 0000228B             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 000022D6             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000022F6             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 00001146             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 00001158             36                  JSR     CONVERT
00001052  4EB9 000011C4             37                  JSR     TEST_RANGE
00001058  4EB9 000011DC             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 0000232D             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 00001146             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 00001158             55                  JSR     CONVERT
0000109A  4EB9 000011C4             56                  JSR     TEST_RANGE
000010A0  4EB9 000011DC             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0088                 64                  BLT     RESET_INPUT
000010B8                            65                                 
000010B8                            66  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010B8                            67                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010B8                            68                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010B8  4EB9 000011F0             69                  JSR     OPCODE_DECODE       ; decode the opcode
000010BE  4EB9 0000218C             70                  JSR     PRINTENTER          ; prints a new line
000010C4  B5CB                      71                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010C6  6FF0                      72                  BLE     DISASSEMBLE         ; if not, loop
000010C8                            73  
000010C8  4BF9 000023B1             74  FINISHED        LEA     DONE,A5
000010CE  4EB9 0000217A             75                  JSR     PRINTNULL
000010D4  103C 0005                 76                  MOVE.B  #5,D0
000010D8  4E4F                      77                  TRAP    #15
000010DA                            78                  
000010DA  B23C 000D                 79                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010DE  6700 0008                 80                  BEQ     RESTART             ; it's Enter, restart
000010E2                            81                  
000010E2  103C 0009                 82                  MOVE.B  #9,D0
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  103C 000B                 85  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010EC  323C FF00                 86                  MOVE.W  #$FF00, D1          Clear Screen
000010F0  4E4F                      87                  TRAP    #15                 Call Trap
000010F2                            88                  
000010F2  103C 000C                 89                  MOVE.B  #12,D0              Keyboard echo
000010F6  123C 0001                 90                  MOVE.B  #1,D1               Visible
000010FA  4E4F                      91                  TRAP    #15
000010FC                            92                  
000010FC  207C 00000000             93                  MOVE.L  #$0000000, A0       ; Reset A1
00001102  227C 00000000             94                  MOVE.L  #$0000000, A1       ; Reset A1
00001108  247C 00000000             95                  MOVE.L  #$0000000, A2       ; Reset A2
0000110E  267C 00000000             96                  MOVE.L  #$0000000, A3       ; Reset A3
00001114  287C 00000000             97                  MOVE.L  #$0000000, A4       ; Reset A4
0000111A  2A7C 00000000             98                  MOVE.L  #$0000000, A5       ; Reset A5
00001120  2C7C 00000000             99                  MOVE.L  #$0000000, A6       ; Reset A6
00001126  2E7C 01000000            100                  MOVEA.L #$01000000,A7       ; Reset A7
0000112C  4281                     101                  CLR.L   D1                  ; Reset D1
0000112E  4281                     102                  CLR.L   D1                  ; Reset D1
00001130  4282                     103                  CLR.L   D2                  ; Reset D2
00001132  4283                     104                  CLR.L   D3                  ; Reset D3
00001134  4284                     105                  CLR.L   D4                  ; Reset D4
00001136  4285                     106                  CLR.L   D5                  ; Reset D5
00001138  4286                     107                  CLR.L   D6                  ; Reset D6
0000113A  6000 FEC4                108                  BRA     START               ; branch to start of program
0000113E                           109  
0000113E                           110  *--------------------SUBROUTINES------------------    
0000113E                           111  
0000113E  143C 0001                112  RESET_INPUT     MOVE.B  #1,D2
00001142  6000 0062                113                  BRA     INVALID            
00001146                           114                  
00001146  7800                     115  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001148  B204                     116                  CMP.B   D4,D1               ; D1 stores length
0000114A  6700 005A                117                  BEQ     INVALID             ; input is null
0000114E  0C41 0008                118                  CMPI    #$8,D1              ; check if input is longer than a longword
00001152  6600 0052                119                  BNE     INVALID             ; input is longer than a longword
00001156  4E75                     120                  RTS
00001158                           121                              
00001158  4283                     122  CONVERT         CLR.L   D3
0000115A  4284                     123                  CLR.L   D4
0000115C  1619                     124                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000115E  B63C 0039                125                  CMP.B   #57,D3
00001162  6E00 0012                126                  BGT     NOTNUMBER
00001166                           127                  
00001166  B63C 002F                128                  CMP.B   #47,D3
0000116A  6E00 0002                129                  BGT     ISNUMBER
0000116E                           130                  
0000116E  0603 00D0                131  ISNUMBER        ADD.B   #-48,D3             ; current char is number
00001172  6000 001A                132                  BRA     CONCAT
00001176                           133              
00001176  B63C 0041                134  NOTNUMBER       CMP.B   #65,D3
0000117A  6D00 002A                135                  BLT     INVALID
0000117E  B63C 0046                136                  CMP.B   #70,D3
00001182  6E00 0022                137                  BGT     INVALID  
00001186  0603 00C9                138                  ADD.B   #-55,D3             ; is letter             
0000118A  6000 0002                139                  BRA     CONCAT
0000118E                           140              
0000118E  BC3C 0000                141  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001192  6D00 0010                142                  BLT     RETURN
00001196  1806                     143                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001198  E50C                     144                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
0000119A  E9AB                     145                  LSL.L   D4,D3               ; moves current char to correct position  
0000119C  DA83                     146                  ADD.L   D3,D5               ; D5 stores converted input so far
0000119E  0606 00FF                147                  ADD.B   #-1,D6  
000011A2  60B4                     148                  BRA     CONVERT             ; continue loop for remaining chars
000011A4                           149                  
000011A4  4E75                     150  RETURN          RTS
000011A6                           151                  
000011A6  227C 00000000            152  INVALID         MOVEA.L #$0000000, A1       ; clear A1
000011AC  43F9 00002363            153                  LEA     BAD_INPUT,A1        ; output invalid message
000011B2  103C 000E                154                  MOVE.B  #14,D0
000011B6  4E4F                     155                  TRAP    #15
000011B8  B47C 0001                156                  CMP     #1,D2
000011BC  6700 FE62                157                  BEQ     INPUT1
000011C0  6000 FEA4                158                  BRA     INPUT2
000011C4                           159  
000011C4  4284                     160  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011C6  223C 00001000            161                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011CC  BA81                     162                  CMP.L      D1,D5            ; Compare minimum address with input
000011CE  6DD6                     163                  BLT        INVALID          ; input is too low. 
000011D0  223C 00FFFFFE            164                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011D6  BA81                     165                  CMP.L      D1,D5            ; compare maximum address with input
000011D8  6ECC                     166                  BGT        INVALID          ; input too large
000011DA  4E75                     167                  RTS                         ; input is within range
000011DC                           168             
000011DC  0805 0000                169  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011E0  66C4                     170                  BNE        INVALID
000011E2  4E75                     171                  RTS
000011E4                           172  
000011E4                           173  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
000011E4                           174  *                MOVE.L  A6,D1                   ; loads current address in D1
000011E4                           175  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E4                           176  *                JSR     PRINTSHORTLONGNUM       ; prints out address
000011E4                           177  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
000011E4                           178  *                RTS
000011E4  220E                     179                  MOVE.L  A6,D1                   ; loads current address in D1
000011E6  7801                     180                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E8  4EB9 00002054            181                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011EE  4E75                     182                  RTS
000011F0                           183  
000011F0                           184  
000011F0                           185  
000011F0                           186  * Checks every single possible opcode we could have. Jump table
000011F0                           187  * Inputs: (A2) which is a pointer to intruction word to be translated
000011F0                           188  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011F0                           189  
000011F0  3C4A                     190  OPCODE_DECODE   MOVE.W  A2,A6
000011F2  301A                     191                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011F4                           192                  
000011F4                           193  
000011F4                           194  *---------------NOP opcode----------------------                
000011F4  B07C 4E71                195  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011F8  6600 0014                196                  BNE     CASE_MOVE               ; checks the next case if not equal
000011FC                           197                  
000011FC  4EB8 11E4                198                  JSR     PRINT_ADDR
00001200  4BF9 000023EA            199                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001206  4EB9 0000217A            200                  JSR     PRINTNULL               ; prints NOP                
0000120C  4E75                     201                  RTS                             ; returns from the subroutine
0000120E                           202  
0000120E                           203  *---------------MOVE opcode----------------------              
0000120E                           204                  * if first two bits are 00, next two are not 00
0000120E  3200                     205  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001210  C27C C000                206                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001214  6600 00C2                207                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001218  B07C 0FFF                208                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
0000121C  6F00 00BA                209                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001220                           210                  
00001220                           211                  ; Check source
00001220  4BF9 00002226            212                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001226  4DF9 0000225C            213                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000122C  3E3C 0000                214                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001230  4EB9 00001D46            215                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001236  B27C 0001                216                  CMP.W   #1,D1                    ; checks if invalid
0000123A  6700 0AAE                217                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000123E  3802                     218                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
00001240  3A03                     219                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001242                           220                  
00001242                           221                  ; Check destination
00001242  4BF9 00002226            222                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001248  4DF9 00002260            223                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000124E  3E3C 0001                224                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001252  4EB9 00001D46            225                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001258  B27C 0001                226                  CMP.W   #1,D1                    ; checks if invalid
0000125C  6700 0A8C                227                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001260  3C02                     228                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001262  3E03                     229                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001264                           230                  
00001264                           231                  ; Checking if it is MOVEA
00001264  3200                     232                  MOVE.W  D0,D1                    ; stores d0 in d1
00001266  C27C 01C0                233                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
0000126A  B27C 0040                234                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000126E  6700 0028                235                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001272                           236                  
00001272  4EB8 11E4                237                  JSR     PRINT_ADDR               ; print address
00001276  4BF9 000023EF            238                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
0000127C  4EB9 0000217A            239                  JSR     PRINTNULL                ; prints out MOVE
00001282  4EB9 0000219C            240                  JSR     PRINTMOVESIZE            ; prints out the size 
00001288  4BF9 000024C1            241                  LEA     MSG_4SPACES,A5           ; loads spaces
0000128E  4EB9 0000217A            242                  JSR     PRINTNULL                ; prints out spaces
00001294  6000 0020                243                  BRA     PRINTMOVE                ; Branches to print move
00001298                           244                  
00001298  4BF9 000023F5            245  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
0000129E  4EB9 0000217A            246                  JSR     PRINTNULL                ; prints out MOVEA
000012A4  4EB9 0000219C            247                  JSR     PRINTMOVESIZE            ; prints out the size 
000012AA  4BF9 000024BD            248                  LEA     MSG_3SPACES,A5           ; loads spaces
000012B0  4EB9 0000217A            249                  JSR     PRINTNULL                ; prints out spaces
000012B6                           250   
000012B6  3404                     251  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000012B8  3605                     252                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000012BA  4EB9 00001EB4            253                  JSR     EA_TO_STRING             ; outputs it into a string
000012C0                           254                  
000012C0                           255                  ; prints a comma to seperate
000012C0  4BF9 000024B4            256                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000012C6  4EB9 0000217A            257                  JSR     PRINTNULL                ; prints out MOVE
000012CC                           258                  
000012CC                           259                  ; print destination
000012CC  3406                     260                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
000012CE  3607                     261                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
000012D0  4EB9 00001EB4            262                  JSR     EA_TO_STRING             ; outputs it into a string
000012D6  4E75                     263                  RTS                              ; exits subroutine                 
000012D8                           264                
000012D8                           265  *---------------MOVEM opcode----------------------                
000012D8  3200                     266  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012DA  C27C FB80                267                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012DE  B27C 4880                268                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012E2  6600 010E                269                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012E6                           270                  
000012E6                           271                  ; Check D
000012E6  3200                     272                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012E8  C27C 0400                273                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012EC  3E01                     274                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012EE  B27C 0400                275                  CMP.W   #$0400,D1                       ; checks if value is 1
000012F2  6700 007A                276                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012F6                           277  
000012F6                           278  MOVEM_REG2MEM   ; loads EA and XN
000012F6  3E3C 0000                279                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000012FA  4BF9 00002233            280                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001300  4DF9 00002260            281                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001306  4EB9 00001D46            282                  JSR     CHECKGET_EAXN
0000130C  B27C 0001                283                  CMP.W   #1,D1                           ; checks if D1 invalid
00001310  6700 09D8                284                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001314  4EB8 11E4                285                  JSR     PRINT_ADDR                      ; prints the address
00001318  4BF9 00002403            286                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000131E  4EB9 0000217A            287                  JSR     PRINTNULL                       ; prints MOVEM
00001324                           288                  
00001324                           289                  ; finds and prints size
00001324  3200                     290                  MOVE.W  D0,D1                           ; copies D0
00001326  C27C 0040                291                  AND.W   #$0040,D1                       ; gets the size bit
0000132A  6600 000C                292                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
0000132E                           293  
0000132E  4BF9 000024DE            294  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
00001334  6000 0008                295                  BRA     PRINTREG2MEM                    ; prints the registers           
00001338                           296                  
00001338  4BF9 000024E1            297  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
0000133E                           298             
0000133E  4EB9 0000217A            299  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
00001344  4BF9 000024BD            300                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000134A  4EB9 0000217A            301                  JSR     PRINTNULL                       ; prints out spaces
00001350  383C 0001                302                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
00001354  4EB9 00001DDE            303                  JSR     PRINTREGISTERS                  ; prints registers
0000135A  4BF9 000024B4            304                  LEA     MSG_COMMA,A5                    ; loads comma
00001360  4EB9 0000217A            305                  JSR     PRINTNULL                       ; prints comma
00001366  4EB9 00001EB4            306                  JSR     EA_TO_STRING                    ; prints EA
0000136C  4E75                     307                  RTS
0000136E                           308  
0000136E                           309  MOVEM_MEM2REG  ; loads EA and XN
0000136E  3E3C 0000                310                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001372  4BF9 00002237            311                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
00001378  4DF9 00002260            312                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000137E  4EB9 00001D46            313                  JSR     CHECKGET_EAXN
00001384  B27C 0001                314                  CMP.W   #1,D1                           ; checks if D1 invalid
00001388  6700 0960                315                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000138C  4EB8 11E4                316                  JSR     PRINT_ADDR                      ; prints the address
00001390  4BF9 00002403            317                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001396  4EB9 0000217A            318                  JSR     PRINTNULL                       ; prints MOVEM
0000139C                           319                  
0000139C                           320                  ; finds and prints size
0000139C  3200                     321                  MOVE.W  D0,D1                           ; copies D0
0000139E  C27C 0040                322                  AND.W   #$0040,D1                       ; gets the size bit
000013A2  6600 0012                323                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
000013A6                           324  
000013A6  4BF9 000024DE            325  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
000013AC  4EB9 0000217A            326                  JSR     PRINTNULL                       ; prints MOVEM
000013B2  6000 000E                327                  BRA     PRINTMEM2REG                    ; prints the registers           
000013B6                           328                  
000013B6  4BF9 000024E1            329  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
000013BC  4EB9 0000217A            330                  JSR     PRINTNULL                       ; prints MOVEM 
000013C2                           331             
000013C2  4EB9 0000217A            332  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
000013C8  4BF9 000024BD            333                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013CE  4EB9 0000217A            334                  JSR     PRINTNULL                       ; prints out spaces
000013D4  4EB9 00001EB4            335                  JSR     EA_TO_STRING                    ; prints EA
000013DA  4BF9 000024B4            336                  LEA     MSG_COMMA,A5                    ; loads comma
000013E0  4EB9 0000217A            337                  JSR     PRINTNULL                       ; prints comma
000013E6  383C FFFF                338                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
000013EA  4EB9 00001DDE            339                  JSR     PRINTREGISTERS                  ; prints registers
000013F0  4E75                     340                  RTS
000013F2                           341                          
000013F2                           342  
000013F2                           343  *---------------MOVEQ opcode----------------------
000013F2  3200                     344  CASE_MOVEQ      MOVE.W  D0,D1
000013F4  C27C F100                345                  AND.W   #$F100,D1
000013F8  B27C 7000                346                  CMP.W   #$7000,D1
000013FC  6600 0058                347                  BNE     CASE_ADD
00001400                           348                  
00001400                           349                  ;loads Register
00001400  323C 0001                350                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001404  4EB9 00001D1C            351                  JSR     GET_XN                          ; gets XN and puts in D1
0000140A  3401                     352                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
0000140C                           353                  
0000140C                           354                  ;loads DATA
0000140C  3200                     355                  MOVE.W  D0,D1
0000140E  C27C 00FF                356                  AND.W   #$00FF,D1                       ;bit mask to get DATA
00001412  3601                     357                  MOVE.W  D1,D3                          ;copy data into D3
00001414                           358                                                        ;must convert bits to hex
00001414                           359                                  
00001414  4EB8 11E4                360  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
00001418                           361  
00001418  4BF9 000023FC            362                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
0000141E  4EB9 0000217A            363                  JSR     PRINTNULL  
00001424                           364                  
00001424  4BF9 000024BD            365                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000142A  4EB9 0000217A            366                  JSR     PRINTNULL                       ; prints out spaces
00001430                           367                  
00001430  4BF9 000024E1            368                  LEA     MSG_L,A5                        ;PRINT SIZE L
00001436  4EB9 0000217A            369                  JSR     PRINTNULL
0000143C                           370      
0000143C  4BF9 000023E6            371                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
00001442  4EB9 0000217A            372                  JSR     PRINTNULL
00001448                           373                  
00001448  4BF9 000024B0            374                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
0000144E  4EB9 0000217A            375                  JSR     PRINTNULL
00001454  4E75                     376                  RTS
00001456                           377                  
00001456                           378  *---------------ADD opcode----------------------                
00001456                           379  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
00001456  3200                     380  CASE_ADD        MOVE.W  D0,D1
00001458  C27C F000                381                  AND.W   #$F000,D1
0000145C  B27C D000                382                  CMP.W   #$D000,D1
00001460  6600 01BE                383                  BNE     CASE_ADDQ
00001464                           384   
00001464  4EB8 11E4                385                  JSR     PRINT_ADDR              ; print address
00001468                           386                  
00001468  4EB9 00001482            387                  JSR     ADD_SUB_HELP
0000146E                           388                  
0000146E                           389                  ; bits 7-8 determine if it is ADDA or ADD
0000146E  3200                     390                  MOVE.W  D0,D1
00001470  E149                     391                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001472  E049                     392                  LSR.W   #8,D1
00001474  EC49                     393                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001476  B27C 0003                394                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
0000147A  6700 0124                395                  BEQ     CASE_ADDA
0000147E                           396                  
0000147E  6000 0040                397                  BRA     PRINTADD                ; Branches to print add
00001482                           398                  
00001482                           399                  ; Check bits 0-5 
00001482  4BF9 00002226            400  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001488  4DF9 0000225C            401                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000148E  3E3C 0000                402                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001492  4EB9 00001D46            403                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001498  B27C 0001                404                  CMP.W       #1,D1                    ; checks if invalid
0000149C  6700 084C                405                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000014A0  3802                     406                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000014A2  3A03                     407                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000014A4                           408                  
000014A4                           409                  ; Check 6-11
000014A4  4BF9 00002226            410                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000014AA  4DF9 00002260            411                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000014B0  3E3C 0001                412                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
000014B4  4EB9 00001D46            413                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000014BA  3C02                     414                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
000014BC  3E03                     415                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
000014BE                           416    
000014BE  4E75                     417                  RTS                
000014C0                           418                    
000014C0  4BF9 0000240A            419  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
000014C6  4EB9 0000217A            420                  JSR         PRINTNULL               ; print ADD
000014CC  3200                     421                  MOVE.W      D0,D1                   ; bits 7-8 contain size
000014CE  4EB9 000014E4            422                  JSR         ADD_SUB_SIZE
000014D4  4BF9 000024C6            423                  LEA         MSG_5SPACES,A5          ; loads spaces
000014DA  4EB9 0000217A            424                  JSR         PRINTNULL               ; prints out spaces
000014E0  6000 0050                425                  BRA         FINISH_ADD
000014E4                           426                    
000014E4  3200                     427  ADD_SUB_SIZE    MOVE.W      D0,D1
000014E6  E149                     428                  LSL.W       #8,D1
000014E8  E049                     429                  LSR.W       #8,D1
000014EA  EC49                     430                  LSR.W       #6,D1                   ; gets bits 6-7
000014EC                           431                    
000014EC  B27C 0000                432                  CMP.W       #0,D1
000014F0  6700 0016                433                  BEQ         ADD_SUB_BYTE
000014F4  B27C 0001                434                  CMP.W       #1,D1                   ; if 1, it is a word
000014F8  6700 001C                435                  BEQ         ADD_SUB_WORD
000014FC  B27C 0002                436                  CMP.W       #2,D1                   ; if 2, it is a long
00001500  6700 0022                437                  BEQ         ADD_SUB_LONG
00001504  6000 029C                438                  BRA         CASE_SUBA               ; error
00001508                           439                    
00001508  4BF9 000024DB            440  ADD_SUB_BYTE    LEA         MSG_B,A5
0000150E  4EB9 0000217A            441                  JSR         PRINTNULL
00001514  4E75                     442                  RTS
00001516                           443                    
00001516  4BF9 000024DE            444  ADD_SUB_WORD    LEA         MSG_W,A5
0000151C  4EB9 0000217A            445                  JSR         PRINTNULL
00001522  4E75                     446                  RTS
00001524                           447    
00001524  4BF9 000024E1            448  ADD_SUB_LONG    LEA         MSG_L,A5
0000152A  4EB9 0000217A            449                  JSR         PRINTNULL
00001530  4E75                     450                  RTS
00001532                           451        
00001532  4EB9 0000153A            452  FINISH_ADD      JSR         ADD_SUB_OPERAND
00001538  4E75                     453                  RTS
0000153A                           454    
0000153A  EF49                     455  ADD_SUB_OPERAND LSL.W       #7,D1
0000153C  EE49                     456                  LSR.W       #7,D1
0000153E  E049                     457                  LSR.W       #8,D1
00001540  B27C 0001                458                  CMP.W       #1,D1
00001544  6600 002E                459                  BNE         Dn_PLUS_EA          
00001548                           460                    
00001548                           461                  ; print Data Register
00001548  4BF9 000024A4            462                  LEA         MSG_DR,A5
0000154E  4EB9 0000217A            463                  JSR         PRINTNULL
00001554  3207                     464                  MOVE.W      D7,D1
00001556  4EB9 00002030            465                  JSR         PRINTNUM                
0000155C                           466                  
0000155C                           467                  ; prints a comma to seperate
0000155C  4BF9 000024B4            468                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001562  4EB9 0000217A            469                  JSR         PRINTNULL                ; prints out MOVE
00001568                           470                 
00001568                           471                  ; below is EA+Dn->Dn  
00001568  3404                     472                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000156A  3605                     473                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000156C  4EB9 00001EB4            474                  JSR         EA_TO_STRING             ; outputs it into a string
00001572  4E75                     475                  RTS                                 ; exits subroutine 
00001574                           476  
00001574                           477  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001574  3404                     478                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001576  3605                     479                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001578  4EB9 00001EB4            480                  JSR         EA_TO_STRING             ; outputs it into a string   
0000157E                           481                  
0000157E                           482                  ; prints a comma to seperate
0000157E  4BF9 000024B4            483                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001584  4EB9 0000217A            484                  JSR         PRINTNULL                ; prints out MOVE
0000158A                           485                  
0000158A                           486                  ; below is Dn+EA->EA
0000158A  4BF9 000024A4            487                  LEA         MSG_DR,A5                ; print data register
00001590  4EB9 0000217A            488                  JSR         PRINTNULL
00001596  3207                     489                  MOVE.W      D7,D1
00001598  4EB9 00002030            490                  JSR         PRINTNUM             
0000159E  4E75                     491                  RTS                                  ; exits subroutine          
000015A0                           492                        
000015A0                           493  *---------------ADDA opcode----------------------
000015A0                           494  CASE_ADDA       ; gets bit 8 (size bit)
000015A0  3200                     495                  MOVE.W      D0,D1
000015A2  EF49                     496                  LSL.W       #7,D1
000015A4  EE49                     497                  LSR.W       #7,D1
000015A6  E049                     498                  LSR         #8,D1                   
000015A8                           499                  
000015A8  4BF9 0000240F            500                  LEA         MSG_ADDA,A5             ; print ADDA
000015AE  4EB9 0000217A            501                  JSR         PRINTNULL
000015B4                           502                   
000015B4  B27C 0001                503                  CMP.W       #1,D1
000015B8  6700 001E                504                  BEQ         ADDA_LONG
000015BC                           505                    
000015BC  4BF9 000024DE            506                  LEA         MSG_W,A5
000015C2  4EB9 0000217A            507                  JSR         PRINTNULL
000015C8  4BF9 000024C1            508                  LEA         MSG_4SPACES,A5          ; loads spaces
000015CE  4EB9 0000217A            509                  JSR         PRINTNULL               ; prints out spaces
000015D4  6000 001E                510                  BRA         FINISH_ADDA   
000015D8                           511                    
000015D8  4BF9 000024E1            512  ADDA_LONG       LEA         MSG_L,A5
000015DE  4EB9 0000217A            513                  JSR         PRINTNULL
000015E4  4BF9 000024C1            514                  LEA         MSG_4SPACES,A5          ; loads spaces
000015EA  4EB9 0000217A            515                  JSR         PRINTNULL               ; prints out spaces
000015F0  6000 0002                516                  BRA         FINISH_ADDA
000015F4                           517                    
000015F4  3404                     518  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015F6  3605                     519                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015F8  4EB9 00001EB4            520                  JSR         EA_TO_STRING             ; outputs it into a string
000015FE                           521                    
000015FE                           522                  ; prints a comma to seperate
000015FE  4BF9 000024B4            523                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001604  4EB9 0000217A            524                  JSR         PRINTNULL                ; prints out MOVE
0000160A                           525            
0000160A  4BF9 000024A6            526                  LEA         MSG_AR,A5                ; print address register
00001610  4EB9 0000217A            527                  JSR         PRINTNULL
00001616  3207                     528                  MOVE.W      D7,D1
00001618  4EB9 00002030            529                  JSR         PRINTNUM             
0000161E  4E75                     530                  RTS                              ; exits subroutine
00001620                           531                  
00001620                           532  *---------------ADDQ opcode----------------------                  
00001620  3200                     533  CASE_ADDQ       MOVE.W      D0,D1
00001622  C27C F000                534                  AND.W       #$F000,D1       
00001626  B27C 5000                535                  CMP.W       #$5000,D1
0000162A  6600 00F0                536                  BNE         CASE_SUB
0000162E                           537                                                   
0000162E  4EB8 11E4                538                  JSR         PRINT_ADDR              ; print address  
00001632  4BF9 00002415            539                  LEA         MSG_ADDQ,A5             ; print ADDQ
00001638  4EB9 0000217A            540                  JSR         PRINTNULL
0000163E                           541                  
0000163E                           542                  ; get bits 6-7 (size bits)
0000163E  3200                     543                  MOVE.W      D0,D1
00001640  E149                     544                  LSL.W       #8,D1
00001642  E049                     545                  LSR.W       #8,D1
00001644  EC49                     546                  LSR.W       #6,D1
00001646  3401                     547                  MOVE.W      D1,D2
00001648                           548                  
00001648                           549                  ; Check bits 0-5 
00001648  4BF9 00002226            550                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000164E  4DF9 0000225C            551                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001654  3E3C 0000                552                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001658  4EB9 00001D46            553                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000165E  B27C 0001                554                  CMP.W       #1,D1                    ; checks if invalid
00001662  6700 0686                555                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001666  3802                     556                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001668  3A03                     557                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
0000166A                           558                  
0000166A  B47C 0001                559                  CMP.W       #1,D2
0000166E  6700 0026                560                  BEQ         ADDQ_WORD
00001672  B47C 0002                561                  CMP.W       #2,D2
00001676  6700 003A                562                  BEQ         ADDQ_LONG
0000167A                           563                    
0000167A  4BF9 000024DB            564  ADDQ_BYTE       LEA         MSG_B,A5
00001680  4EB9 0000217A            565                  JSR         PRINTNULL
00001686  4BF9 000024C1            566                  LEA         MSG_4SPACES,A5          ; loads spaces
0000168C  4EB9 0000217A            567                  JSR         PRINTNULL               ; prints out spaces
00001692  6000 003A                568                  BRA         FINISH_ADDQ  
00001696                           569   
00001696  4BF9 000024DE            570  ADDQ_WORD       LEA         MSG_W,A5
0000169C  4EB9 0000217A            571                  JSR         PRINTNULL
000016A2  4BF9 000024C1            572                  LEA         MSG_4SPACES,A5          ; loads spaces
000016A8  4EB9 0000217A            573                  JSR         PRINTNULL               ; prints out spaces
000016AE  6000 001E                574                  BRA         FINISH_ADDQ                 
000016B2                           575    
000016B2  4BF9 000024E1            576  ADDQ_LONG       LEA         MSG_L,A5
000016B8  4EB9 0000217A            577                  JSR         PRINTNULL
000016BE  4BF9 000024C1            578                  LEA         MSG_4SPACES,A5          ; loads spaces
000016C4  4EB9 0000217A            579                  JSR         PRINTNULL               ; prints out spaces
000016CA  6000 0002                580                  BRA         FINISH_ADDQ                  
000016CE                           581                    
000016CE  4EB9 000016EC            582  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
000016D4                           583   
000016D4                           584                  ; prints a comma to seperate
000016D4  4BF9 000024B4            585                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016DA  4EB9 0000217A            586                  JSR         PRINTNULL                ; prints out MOVE
000016E0                           587                    
000016E0                           588                  ; prints destination
000016E0  3404                     589                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016E2  3605                     590                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016E4  4EB9 00001EB4            591                  JSR         EA_TO_STRING             ; outputs it into a string
000016EA                           592                 
000016EA  4E75                     593                  RTS
000016EC                           594   
000016EC  4BF9 000024B0            595  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
000016F2  4EB9 0000217A            596                  JSR         PRINTNULL
000016F8                           597                  ; gets bits 9-11 (data bits)
000016F8  E949                     598                  LSL.W       #4,D1
000016FA  E849                     599                  LSR.W       #4,D1                               ; get rid of left 4 bits
000016FC  E049                     600                  LSR.W       #8,D1
000016FE  E249                     601                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001700                           602                  
00001700  B27C 0000                603                  CMP.W       #0,D1
00001704  6700 000A                604                  BEQ         PRINT_8
00001708  4EB9 00002030            605                  JSR         PRINTNUM
0000170E  4E75                     606                  RTS 
00001710                           607  
00001710  123C 0008                608  PRINT_8         MOVE.B      #8,D1
00001714  4EB9 00002030            609                  JSR         PRINTNUM
0000171A  4E75                     610                  RTS   
0000171C                           611         
0000171C                           612  *---------------SUB opcode---------------------- 
0000171C  3200                     613  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000171E  C27C F000                614                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001722  B27C 9000                615                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001726  6600 0090                616                  BNE         CASE_LEA
0000172A                           617                 
0000172A  4EB8 1482                618                  JSR         ADD_SUB_HELP
0000172E  4EB8 11E4                619                  JSR         PRINT_ADDR                          ; print address                              
00001732                           620                  
00001732  6000 0002                621                  BRA         PRINTSUB                            ; Branches to print sub
00001736                           622  
00001736  4BF9 0000241B            623  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
0000173C  4EB9 0000217A            624                  JSR         PRINTNULL
00001742  3200                     625                  MOVE.W      D0,D1                               ; bits 6-7 contain size
00001744  4EB8 14E4                626                  JSR         ADD_SUB_SIZE
00001748  4BF9 000024C6            627                  LEA         MSG_5SPACES,A5                      ; loads spaces
0000174E  4EB9 0000217A            628                  JSR         PRINTNULL                           ; prints out spaces
00001754  3200                     629                  MOVE.W      D0,D1
00001756  E149                     630                  LSL.W       #8,D1
00001758  E049                     631                  LSR.W       #8,D1
0000175A  EC49                     632                  LSR.W       #6,D1
0000175C  B27C 0003                633                  CMP.W       #3,D1
00001760  6600 0006                634                  BNE         FINISH_SUB
00001764  6000 0008                635                  BRA         FINISH_SUBA                         ; same as ADDA
00001768                           636                  
00001768  4EB8 153A                637  FINISH_SUB      JSR         ADD_SUB_OPERAND
0000176C  4E75                     638                  RTS
0000176E                           639                    
0000176E  3404                     640  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001770  3605                     641                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001772  4EB9 00001EB4            642                  JSR         EA_TO_STRING             ; outputs it into a string
00001778                           643                
00001778                           644                  ; prints a comma to seperate
00001778  4BF9 000024B4            645                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000177E  4EB9 0000217A            646                  JSR         PRINTNULL                ; prints out MOVE
00001784                           647                  
00001784  4BF9 000024A6            648                  LEA         MSG_AR,A5                ; print address register
0000178A  4EB9 0000217A            649                  JSR         PRINTNULL
00001790  3200                     650                  MOVE.W      D0,D1
00001792  E949                     651                  LSL.W       #4,D1
00001794  E849                     652                  LSR.W       #4,D1
00001796  E049                     653                  LSR.W       #8,D1
00001798  E249                     654                  LSR.W       #1,D1
0000179A  4EB9 00002030            655                  JSR         PRINTNUM             
000017A0  4E75                     656                  RTS                              ; exits subroutine
000017A2                           657  
000017A2                           658  
000017A2                           659  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
000017A2  3200                     660  CASE_SUBA       MOVE.W      D0,D1
000017A4  EF49                     661                  LSL.W       #7,D1
000017A6  EE49                     662                  LSR.W       #7,D1
000017A8  E049                     663                  LSR.W       #8,D1
000017AA  B23C 0000                664                  CMP.B       #0,D1
000017AE  6700 FD66                665                  BEQ         ADD_SUB_WORD
000017B2  6000 FD70                666                  BRA         ADD_SUB_LONG
000017B6  4E75                     667                  RTS         
000017B8                           668                   
000017B8  3200                     669  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000017BA  C27C F000                670                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000017BE  B27C 4000                671                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
000017C2  6600 0092                672                  BNE.W   CASE_AND                             ; If its not, check AND
000017C6  3200                     673                  MOVE.W  D0,D1                                ; Copies instruction word to D1
000017C8  C27C 01C0                674                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
000017CC  B27C 01C0                675                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
000017D0  6600 0084                676                  BNE.W   CASE_AND                             ; If its not, check AND
000017D4                           677                  
000017D4                           678                  ; Check source
000017D4  4BF9 00002246            679                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000017DA  4DF9 00002260            680                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000017E0  3E3C 0000                681                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
000017E4  4EB9 00001D46            682                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000017EA  3802                     683                  MOVE.W  D2,D4                                ; Saves D2 in D4
000017EC  3A03                     684                  MOVE.W  D3,D5                                ; Saves D2 in D4
000017EE                           685                  
000017EE                           686                  ; Check destination
000017EE  4BF9 00002246            687                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000017F4  4DF9 00002260            688                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000017FA  3E3C 0001                689                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000017FE  4EB9 00001D46            690                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001804  3C02                     691                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001806  3E03                     692                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001808                           693  
00001808  4BF9 0000242C            694                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000180E  4EB9 0000217A            695                  JSR     PRINTNULL                            ; prints LEA
00001814  4BF9 000024D3            696                  LEA     MSG_7SPACES,A5                       ; loads spaces
0000181A  4EB9 0000217A            697                  JSR     PRINTNULL                            ; prints out spaces
00001820                           698                  
00001820                           699                  ; print source
00001820  3404                     700                  MOVE.W  D4,D2
00001822  3605                     701                  MOVE.W  D5,D3
00001824  4EB9 00001EB4            702                  JSR     EA_TO_STRING                         ; Prints out the EA
0000182A                           703                  
0000182A                           704                  ; comma
0000182A  4BF9 000024B4            705                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001830  4EB9 0000217A            706                  JSR     PRINTNULL                       
00001836                           707                   
00001836                           708                  ; register
00001836  4BF9 000024A6            709                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
0000183C  4EB9 0000217A            710                  JSR     PRINTNULL 
00001842  3401                     711                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
00001844  323C 0001                712                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
00001848  4EB9 00001D1C            713                  JSR     GET_XN                               ; Gets Xn, puts it into D1
0000184E  4EB9 00002030            714                  JSR     PRINTNUM                             ; Prints the number in D1
00001854  4E75                     715                  RTS
00001856                           716  
00001856                           717  *---------------AND opcode----------------------
00001856  3200                     718  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001858  C27C F000                719                  AND.W       #$F000,D1       
0000185C  B27C C000                720                  CMP.W       #$C000,D1
00001860  6600 00C2                721                  BNE         CASE_OR
00001864                           722                  
00001864  3200                     723                  MOVE.W      D0,D1
00001866  E149                     724                  LSL.W       #8,D1
00001868  E049                     725                  LSR.W       #8,D1
0000186A  EC49                     726                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000186C  3C01                     727                  MOVE.W      D1,D6
0000186E  BC7C 0003                728                  CMP.W       #3,D6
00001872  6700 008A                729                  BEQ         INV_INSTR
00001876                           730                  
00001876  4EB8 11E4                731                  JSR         PRINT_ADDR                      ; print address
0000187A  4BF9 00002431            732                  LEA         MSG_AND,A5                      ; print AND
00001880  4EB9 0000217A            733                  JSR         PRINTNULL
00001886                           734                  
00001886  3206                     735                  MOVE.W      D6,D1
00001888  B27C 0000                736                  CMP.W       #0,D1
0000188C  6700 0012                737                  BEQ         AND_BYTE
00001890  B27C 0001                738                  CMP.W       #1,D1                   ; if 1, it is a word
00001894  6700 0026                739                  BEQ         AND_WORD
00001898  B27C 0002                740                  CMP.W       #2,D1                   ; if 2, it is a long
0000189C  6700 003A                741                  BEQ         AND_LONG
000018A0                           742                  
000018A0  4BF9 000024DB            743  AND_BYTE        LEA         MSG_B,A5
000018A6  4EB9 0000217A            744                  JSR         PRINTNULL
000018AC  4BF9 000024D3            745                  LEA         MSG_7SPACES,A5                  ; loads spaces
000018B2  4EB9 0000217A            746                  JSR         PRINTNULL                       ; prints out spaces
000018B8  6000 003A                747                  BRA         FINISH_AND
000018BC                           748                                    
000018BC  4BF9 000024DE            749  AND_WORD        LEA         MSG_W,A5
000018C2  4EB9 0000217A            750                  JSR         PRINTNULL
000018C8  4BF9 000024D3            751                  LEA         MSG_7SPACES,A5                  ; loads spaces
000018CE  4EB9 0000217A            752                  JSR         PRINTNULL                       ; prints out spaces
000018D4  6000 001E                753                  BRA         FINISH_AND
000018D8                           754    
000018D8  4BF9 000024E1            755  AND_LONG        LEA         MSG_L,A5
000018DE  4EB9 0000217A            756                  JSR         PRINTNULL
000018E4  4BF9 000024D3            757                  LEA         MSG_7SPACES,A5                  ; loads spaces
000018EA  4EB9 0000217A            758                  JSR         PRINTNULL                       ; prints out spaces
000018F0  6000 0002                759                  BRA         FINISH_AND
000018F4                           760        
000018F4  4EB8 1482                761  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
000018F8  4EB8 153A                762                  JSR         ADD_SUB_OPERAND
000018FC  4E75                     763                  RTS
000018FE                           764                  
000018FE  4BF9 000023A1            765  INV_INSTR       LEA         INVALID_INSTR,A5
00001904  4EB9 0000217A            766                  JSR         PRINTNULL
0000190A  2200                     767                  MOVE.L      D0,D1
0000190C  383C 0000                768                  MOVE.W      #0,D4
00001910  4EB9 00002054            769                  JSR         PRINTSHORTLONGNUM
00001916  4BF9 000023E3            770                  LEA         NEW_LINE,A5
0000191C  4EB9 0000217A            771                  JSR         PRINTNULL
00001922  4E75                     772                  RTS               
00001924                           773                  
00001924                           774  *---------------OR opcode----------------------            
00001924  3200                     775  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001926  C27C F000                776                  AND.W       #$F000,D1       
0000192A  B27C 8000                777                  CMP.W       #$8000,D1
0000192E  6600 0058                778                  BNE         CASE_NOT
00001932                           779                                                
00001932  3200                     780                  MOVE.W      D0,D1
00001934  E149                     781                  LSL.W       #8,D1
00001936  E049                     782                  LSR.W       #8,D1
00001938  EC49                     783                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000193A  B27C 0003                784                  CMP.W       #3,D1
0000193E  3C01                     785                  MOVE.W      D1,D6
00001940  67BC                     786                  BEQ         INV_INSTR
00001942                           787                  
00001942  4EB8 11E4                788                  JSR         PRINT_ADDR                      ; print address
00001946                           789                  
00001946  4BF9 00002436            790                  LEA         MSG_OR,A5
0000194C  4EB9 0000217A            791                  JSR         PRINTNULL                       ; print "OR"
00001952                           792                  
00001952  3206                     793                  MOVE.W      D6,D1
00001954  4EB9 00001970            794                  JSR         OR_SIZE                         ; print ".B",".W",".L"
0000195A  4BF9 000024CC            795                  LEA         MSG_6SPACES,A5                  ; loads spaces
00001960  4EB9 0000217A            796                  JSR         PRINTNULL                       ; prints out spaces
00001966                           797  
00001966  4EB8 1482                798                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
0000196A  4EB8 153A                799                  JSR         ADD_SUB_OPERAND                 ; print 
0000196E  4E75                     800                  RTS
00001970                           801  
00001970  B27C 0000                802  OR_SIZE         CMP.W       #0,D1
00001974  6700 FB92                803                  BEQ         ADD_SUB_BYTE
00001978  B27C 0001                804                  CMP.W       #1,D1                   ; if 1, it is a word
0000197C  6700 FB98                805                  BEQ         ADD_SUB_WORD
00001980  B27C 0002                806                  CMP.W       #2,D1                   ; if 2, it is a long
00001984  6700 FB9E                807                  BEQ         ADD_SUB_LONG
00001988                           808                  ; no need for rts, since ADD_SUB_ already has                
00001988                           809  
00001988                           810  *---------------NOT opcode----------------------
00001988  3200                     811  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
0000198A  C27C FF00                812                  AND.W       #$FF00,D1       
0000198E  B27C 4600                813                  CMP.W       #$4600,D1
00001992  6600 005C                814                  BNE         CASE_LSDASDROD
00001996                           815                 
00001996                           816                  ; get bits 6-7 (size)
00001996  3200                     817                  MOVE.W      D0,D1
00001998  E149                     818                  LSL.W       #8,D1
0000199A  E049                     819                  LSR.W       #8,D1
0000199C  EC49                     820                  LSR.W       #6,D1 
0000199E  3C01                     821                  MOVE.W      D1,D6                         
000019A0  BC7C 0003                822                  CMP.W       #3,D6
000019A4  6700 FF58                823                  BEQ         INV_INSTR
000019A8                           824                  
000019A8  4EB8 11E4                825                  JSR         PRINT_ADDR
000019AC                           826                  
000019AC  4BF9 0000243A            827                  LEA         MSG_NOT,A5
000019B2  4EB9 0000217A            828                  JSR         PRINTNULL                       ; print "NOT"
000019B8                           829                                 
000019B8  3206                     830                  MOVE.W      D6,D1
000019BA                           831  
000019BA  4EB8 1970                832                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000019BE  4BF9 000024C6            833                  LEA         MSG_5SPACES,A5                  ; loads spaces
000019C4  4EB9 0000217A            834                  JSR         PRINTNULL                       ; prints out spaces
000019CA                           835                  
000019CA                           836                  ; get bits 0-5 
000019CA  4BF9 00002226            837                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000019D0  4DF9 0000225C            838                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000019D6  3E3C 0000                839                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000019DA  4EB9 00001D46            840                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000019E0  B27C 0001                841                  CMP.W       #1,D1                    ; checks if invalid
000019E4  6700 0304                842                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000019E8  4EB9 00001EB4            843                  JSR         EA_TO_STRING             ; outputs it into a string
000019EE                           844    
000019EE  4E75                     845                  RTS
000019F0                           846  
000019F0  3200                     847  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
000019F2  C27C F000                848                  AND.W       #$F000, D1                       ; gets first 4 bits
000019F6  B27C E000                849                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000019FA  6600 0230                850                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000019FE  3400                     851                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A00  4EB9 00001DCE            852                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A06  B47C 0003                853                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001A0A  6600 00D8                854                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001A0E                           855                  
00001A0E  3400                     856  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001A10  4EB9 00001DBC            857                  JSR         GETROTATION                      ; gets rotation value of D2
00001A16  B47C 0000                858                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001A1A  6700 0014                859                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001A1E  B47C 0003                860                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001A22  6700 0016                861                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001A26                           862                  
00001A26  4BF9 0000243F            863  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001A2C  6000 0012                864                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001A30                           865  
00001A30  4BF9 00002443            866  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001A36  6000 0008                867                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001A3A                           868  
00001A3A  4BF9 00002447            869  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001A40                           870                  
00001A40  4EB8 11E4                871  PRINTSHIFTMEM   JSR         PRINT_ADDR                       ; prints address
00001A44  4EB9 0000217A            872                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001A4A  3400                     873                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A4C  4EB9 00001DC6            874                  JSR         GETDIRECTION                     ; gets direction
00001A52  B47C 0000                875                  CMP.W       #0,D2                            ; checking if its right
00001A56  6700 000C                876                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001A5A                           877  
00001A5A  4BF9 000024A2            878  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001A60  6000 0008                879                  BRA         PRINT_MEMDIR                     ; branches for printing
00001A64                           880          
00001A64  4BF9 000024A0            881  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001A6A                           882  
00001A6A  4EB9 0000217A            883  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001A70  4BF9 000024DE            884                  LEA         MSG_W,A5                         ; loads .W into A5
00001A76  4EB9 0000217A            885                  JSR         PRINTNULL                        ; Prints .W
00001A7C  4BF9 000024D3            886                  LEA         MSG_7SPACES,A5                   ; loads spaces
00001A82  4EB9 0000217A            887                  JSR         PRINTNULL                        ; prints out spaces
00001A88  6000 0002                888                  BRA         GETMEMSOURCE                     ; checks the source 
00001A8C                           889                  
00001A8C                           890  ; get source addressing mode       
00001A8C                           891  GETMEMSOURCE                                                 
00001A8C  323C 0000                892                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001A90  4EB9 00001CF2            893                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001A96  3801                     894                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001A98  323C 0000                895                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001A9C  4EB9 00001D1C            896                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001AA2  3A01                     897                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001AA4                           898  
00001AA4  4BF9 00002254            899  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001AAA  3204                     900                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001AAC  4EB9 00001E80            901                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001AB2  B27C 0002                902                  CMP.W       #2,D1                            ; checks if it is Xn
00001AB6  6700 0016                903                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001ABA  B27C 0001                904                  CMP.W       #1,D1                            ; Checks if it is invalid
00001ABE  6700 022A                905                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001AC2                           906  
00001AC2  3404                     907  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001AC4  3605                     908                  MOVE.W      D5,D3                            ; moves EA to D3
00001AC6  4EB9 00001EB4            909                  JSR         EA_TO_STRING                     ; prints out the EA
00001ACC  4E75                     910                  RTS                
00001ACE                           911                  
00001ACE                           912                  
00001ACE  4BF9 00002260            913  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001AD4  3205                     914                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001AD6  4EB9 00001E80            915                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001ADC  4A41                     916                  TST.W       D1                               ; checks if it is valid
00001ADE  67E2                     917                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001AE0  6000 0208                918                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001AE4                           919  
00001AE4                           920  
00001AE4  3602                     921  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001AE6  3200                     922                  MOVE.W      D0,D1                            ; copies D0 to D1
00001AE8  C27C 0018                923                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001AEC  E649                     924                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001AEE  B27C 0000                925                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001AF2  6700 0014                926                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001AF6  B27C 0003                927                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001AFA  6700 0016                928                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001AFE                           929                  
00001AFE  4BF9 0000243F            930  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001B04  6000 0012                931                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B08                           932  
00001B08  4BF9 00002443            933  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001B0E  6000 0008                934                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B12                           935  
00001B12  4BF9 00002447            936  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001B18                           937                  
00001B18  4EB8 11E4                938  PRINTSHIFTREG   JSR         PRINT_ADDR                       ; prints address
00001B1C  4EB9 0000217A            939                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001B22  3400                     940                  MOVE.W      D0,D2                            ; copies D0 to D2
00001B24  4EB9 00001DC6            941                  JSR         GETDIRECTION                     ; gets direction
00001B2A  B47C 0000                942                  CMP.W       #0,D2                            ; checking if its right
00001B2E  6700 000C                943                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001B32                           944  
00001B32  4BF9 000024A2            945  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001B38  6000 000C                946                  BRA         PRINT_REGDIR                     ; branches for printing
00001B3C                           947          
00001B3C  4BF9 000024A0            948  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001B42  6000 0002                949                  BRA         PRINT_REGDIR                     ; branches for printing
00001B46                           950                  
00001B46  4EB9 0000217A            951  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001B4C                           952  
00001B4C  3400                     953  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001B4E  4EB9 00001DCE            954                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001B54  B47C 0001                955                  CMP.W       #1,D2                            ; Checks if it is word size
00001B58  6700 0014                956                  BEQ         REG_WORD                         ; Prints .W
00001B5C  B47C 0002                957                  CMP.W       #2,D2                            ; Checks if it is long size
00001B60  6700 0016                958                  BEQ         REG_LONG                         ; Prints .L
00001B64                           959  
00001B64  4BF9 000024DB            960  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001B6A  6000 0012                961                  BRA         PRINTREGEA      
00001B6E                           962  
00001B6E  4BF9 000024DE            963  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001B74  6000 0008                964                  BRA         PRINTREGEA      
00001B78                           965                             
00001B78  4BF9 000024E1            966  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001B7E                           967  
00001B7E  4EB9 0000217A            968  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001B84  4BF9 000024C6            969                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001B8A  4EB9 0000217A            970                  JSR         PRINTNULL                        ; prints out spaces
00001B90  3400                     971                  MOVE.W      D0,D2                            ; copies D0 to D1
00001B92  4EB9 00001DD6            972                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001B98  B27C 0001                973                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001B9C  6700 0048                974                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001BA0                           975                                  
00001BA0  3400                     976  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001BA2  4EB9 00001DCE            977                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BA8  3202                     978                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001BAA  4BF9 000024B0            979                  LEA         MSG_POUND, A5                    ; loads # into A5
00001BB0  4EB9 0000217A            980                  JSR         PRINTNULL                        ; prints #
00001BB6  4EB9 00002030            981                  JSR         PRINTNUM                         ; prints shift count
00001BBC  4BF9 000024B4            982                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001BC2  4EB9 0000217A            983                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001BC8  4BF9 000024A4            984                  LEA         MSG_DR, A5                       ; loads D into A5
00001BCE  4EB9 0000217A            985                  JSR         PRINTNULL                        ; prints out D 
00001BD4  323C 0000                986                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001BD8  4EB9 00001D1C            987                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001BDE  4EB9 00002030            988                  JSR         PRINTNUM                         ; prints data register number in D1          
00001BE4  4E75                     989                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001BE6                           990                  
00001BE6  3400                     991  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001BE8  4EB9 00001DCE            992                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BEE  3202                     993                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001BF0  4BF9 000024A4            994                  LEA         MSG_DR, A5                       ; loads D into A5
00001BF6  4EB9 0000217A            995                  JSR         PRINTNULL                        ; prints D
00001BFC  4EB9 00002030            996                  JSR         PRINTNUM                         ; prints register number
00001C02  4BF9 000024B4            997                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C08  4EB9 0000217A            998                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C0E  4BF9 000024A4            999                  LEA         MSG_DR, A5                       ; loads D into A5
00001C14  4EB9 0000217A           1000                  JSR         PRINTNULL                        ; prints out D 
00001C1A  323C 0000               1001                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C1E  4EB9 00001D1C           1002                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C24  4EB9 00002030           1003                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C2A  4E75                    1004                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C2C                          1005               
00001C2C  3200                    1006  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001C2E  C27C FF00               1007                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001C32  B27C 6000               1008                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001C36  6600 0028               1009                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001C3A                          1010                  
00001C3A  4EB8 11E4               1011                  JSR     PRINT_ADDR
00001C3E  4BF9 0000249B           1012                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001C44  4EB9 0000217A           1013                  JSR     PRINTNULL                            ; prints BRA
00001C4A  4BF9 000024D3           1014                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001C50  4EB9 0000217A           1015                  JSR     PRINTNULL                            ; prints out spaces
00001C56                          1016  
00001C56  3400                    1017                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001C58  4EB9 00001D8E           1018                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001C5E  4E75                    1019                  RTS
00001C60                          1020                  
00001C60                          1021  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001C60                          1022  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001C60  3200                    1023  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001C62  C27C F000               1024                  AND.W   #$F000,D1                            ; get top 4 bits
00001C66  B27C 6000               1025                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001C6A  6600 0064               1026                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001C6E  3200                    1027                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001C70  C27C 0F00               1028                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001C74  E049                    1029                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001C76                          1030                  
00001C76  B27C 000E               1031                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001C7A  6700 002A               1032                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001C7E                          1033                  
00001C7E  B27C 000F               1034                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001C82  6700 0018               1035                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001C86                          1036                      
00001C86  B27C 0007               1037                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001C8A  6700 0006               1038                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001C8E  6000 005A               1039                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001C92                          1040     
00001C92  4BF9 00002455           1041  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001C98  6000 0016               1042                  BRA     PRINTBCC
00001C9C                          1043  
00001C9C  4BF9 0000246E           1044  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001CA2  6000 000C               1045                  BRA     PRINTBCC
00001CA6                          1046                  
00001CA6  4BF9 00002464           1047  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001CAC  6000 0002               1048                  BRA     PRINTBCC
00001CB0                          1049  
00001CB0  4EB8 11E4               1050  PRINTBCC        JSR     PRINT_ADDR                           ; prints address
00001CB4  4EB9 0000217A           1051                  JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001CBA  4BF9 000024D3           1052                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001CC0  4EB9 0000217A           1053                  JSR     PRINTNULL                            ; prints out spaces
00001CC6  3400                    1054                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001CC8  4EB9 00001D8E           1055                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001CCE  4E75                    1056                  RTS              
00001CD0                          1057                  
00001CD0                          1058  
00001CD0                          1059  CASE_JSR       
00001CD0                          1060  
00001CD0  B07C 4E75               1061  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001CD4  6600 0014               1062                  BNE     CASE_DATA           ; checks the next case if not equal
00001CD8  4EB8 11E4               1063                  JSR     PRINT_ADDR          ; prints address
00001CDC  4BF9 00002496           1064                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001CE2  4EB9 0000217A           1065                  JSR     PRINTNULL           ; prints RTS                
00001CE8  4E75                    1066                  RTS                         ; returns from the subroutine
00001CEA                          1067  
00001CEA                          1068                  
00001CEA                          1069  
00001CEA  4EB8 18FE               1070  CASE_DATA           JSR INV_INSTR  
00001CEE  4E75                    1071                      RTS               
00001CF0                          1072  
00001CF0  4E75                    1073  CASE_EPICFAIL       RTS
00001CF2                          1074  
00001CF2                          1075  
00001CF2                          1076  * Finds the EA type
00001CF2                          1077  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001CF2                          1078  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001CF2  48E7 3000               1079  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001CF6  4A41                    1080                      TST.W     D1                    ; compares D1 to 0
00001CF8  6700 000E               1081                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001CFC                          1082                      
00001CFC  343C 01C0               1083  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001D00  363C 0006               1084                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001D04  6000 000A               1085                      BRA       FINDTYPEEA            
00001D08                          1086  
00001D08  343C 0038               1087  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001D0C  363C 0003               1088                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001D10                          1089  
00001D10                          1090  
00001D10  3200                    1091  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001D12  C242                    1092                      AND.W     D2,D1                 ; applies bitmask to D1
00001D14  E669                    1093                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001D16  4CDF 000C               1094                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001D1A  4E75                    1095                      RTS                             ; returns from subroutine    
00001D1C                          1096                      
00001D1C                          1097  * Finds Xn type
00001D1C                          1098  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001D1C                          1099  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D1C  48E7 3000               1100  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D20  4A41                    1101                      TST.W     D1                    ; compares D1 to 0
00001D22  6700 000E               1102                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001D26                          1103  
00001D26  343C 0E00               1104  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001D2A  363C 0009               1105                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001D2E  6000 000A               1106                      BRA       FINDTYPEXN            ; finds the type of Xn
00001D32                          1107  
00001D32  343C 0007               1108  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001D36  363C 0000               1109                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001D3A                          1110                      
00001D3A  3200                    1111  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001D3C  C242                    1112                      AND.W     D2,D1                 ; applies bitmask to D1
00001D3E  E669                    1113                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001D40  4CDF 000C               1114                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001D44  4E75                    1115                      RTS                             ; returns from subroutine 
00001D46                          1116                      
00001D46                          1117  * Checks and gets the EA and Xn
00001D46                          1118  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001D46                          1119  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001D46  3207                    1120  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001D48  4EB8 1CF2               1121                  JSR     GET_EA                  ; Gets EA
00001D4C  3401                    1122                  MOVE.W  D1,D2                   ; Stores EA in D2
00001D4E  3207                    1123                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001D50  4EB8 1D1C               1124                  JSR     GET_XN                  ; Gets Xn
00001D54  3601                    1125                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001D56  3202                    1126                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001D58                          1127                  
00001D58  4EB9 00001E80           1128                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001D5E  B27C 0002               1129                  CMP.W   #2,D1                   ; checks if it is Xn
00001D62  6700 0012               1130                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001D66  B27C 0001               1131                  CMP.W   #1,D1                   ; Checks if it is invalid
00001D6A  6700 001C               1132                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001D6E                          1133                  
00001D6E                          1134                  
00001D6E  323C 0000               1135  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001D72  6000 0018               1136                  BRA     END_CHECKGET
00001D76                          1137        
00001D76                          1138  ; need XN
00001D76  2A4E                    1139  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001D78  3203                    1140                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001D7A  4EB9 00001E80           1141                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001D80  4A41                    1142                  TST.W   D1                      ; checks if it is valid
00001D82  67EA                    1143                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001D84  6000 0002               1144                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001D88                          1145   
00001D88  323C 0001               1146  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001D8C                          1147  
00001D8C  4E75                    1148  END_CHECKGET    RTS          
00001D8E                          1149                                            
00001D8E                          1150                                            
00001D8E                          1151  * Gets the displacement and pritns it 
00001D8E                          1152  * Inputs: D2 = instruction word, A2 = address of next word
00001D8E                          1153  * Outputs: prints out displacement
00001D8E  48E7 4004               1154  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001D92  3A4A                    1155                      MOVE.W    A2,A5                 ; copies A2 to A5
00001D94  C47C 00FF               1156                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001D98  6600 0004               1157                      BNE       PRINTADDRESS          ; prints address if not 0
00001D9C  341A                    1158                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001D9E                          1159                      
00001D9E  D44D                    1160  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001DA0  3202                    1161                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001DA2  183C 0000               1162                      MOVE.B    #0,D4                 ; marks address as word  length
00001DA6  4BF9 000024B2           1163                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001DAC  4EB9 0000217A           1164                      JSR       PRINTNULL             ; prints null
00001DB2  4EB9 00002054           1165                      JSR       PRINTSHORTLONGNUM     ; prints address
00001DB8                          1166                      
00001DB8  4CDF 2002               1167                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001DBC                          1168                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001DBC                          1169  
00001DBC                          1170  * Gets the rotation value for ASd and LSd
00001DBC                          1171  * Input: D2 = instruction word copy (of D0)                                    
00001DBC                          1172  * Output: rotation  value in D2             
00001DBC  C47C 0E00               1173  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001DC0  E04A                    1174                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001DC2  E24A                    1175                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001DC4  4E75                    1176                      RTS                             ; return from subroutine
00001DC6                          1177  
00001DC6                          1178  * Gets the direction value for ASd and LSd
00001DC6                          1179  * Input: D2 = instruction word copy (of D0)                                    
00001DC6                          1180  * Output: direction value in D2             
00001DC6  C47C 0100               1181  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001DCA  E04A                    1182                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001DCC  4E75                    1183                      RTS                             ; return from subroutine
00001DCE                          1184  
00001DCE                          1185  * Gets the rotation size value for ASd and LSd
00001DCE                          1186  * Input: D2 = instruction word copy (of D0)                                    
00001DCE                          1187  * Output: rotation size value in D2             
00001DCE  C47C 00C0               1188  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001DD2  EC4A                    1189                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001DD4  4E75                    1190                      RTS                             ; return from subroutine
00001DD6                          1191  
00001DD6                          1192  * Gets the rotation location  value for ASd and LSd
00001DD6                          1193  * Input: D2 = instruction word copy (of D0)                                    
00001DD6                          1194  * Output: rotation location value in D2             
00001DD6  C47C 0020               1195  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001DDA  EA4A                    1196                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001DDC  4E75                    1197                      RTS                             ; return from subroutine
00001DDE                          1198  
00001DDE                          1199  * Prints out registers for MOVEM
00001DDE                          1200  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001DDE                          1201  * Output: printed out registers
00001DDE                          1202  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001DDE  48E7 0706               1203  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001DE2  3A3C 0000               1204                      MOVE.W     #0,D5                ; sets counter to 0
00001DE6  3E1A                    1205                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001DE8  B83C 0001               1206                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001DEC  6600 0010               1207                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001DF0                          1208  
00001DF0  3C3C 0000               1209  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001DF4  4BF9 000024A4           1210                      LEA        MSG_DR,A5            ; loads D to A5
00001DFA  6000 000C               1211                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001DFE                          1212                      
00001DFE  3C3C 0007               1213  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001E02  4BF9 000024A6           1214                      LEA        MSG_AR,A5            ; loads A to A5
00001E08                          1215                      
00001E08  E34F                    1216  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001E0A  6500 0018               1217                      BCS        PRINTREG             ; if pushes out a 1
00001E0E  DC44                    1218                      ADD.W      D4,D6                ; decrements or increments
00001E10  5245                    1219                      ADD.W      #1,D5                ; increments D5
00001E12  BA7C 0008               1220                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001E16  66F0                    1221                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001E18  B83C 0001               1222                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E1C  6600 0052               1223                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001E20  6000 0042               1224                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001E24                          1225                      
00001E24  4EB9 0000217A           1226  PRINTREG            JSR        PRINTNULL
00001E2A  3206                    1227                      MOVE.W     D6,D1
00001E2C  4EB9 00002030           1228                      JSR        PRINTNUM 
00001E32                          1229    
00001E32  BE7C 0000               1230  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001E36  6600 0006               1231                      BNE        PRINTMORE            ; continue if there is more
00001E3A  6000 0040               1232                      BRA        DONEPRINTINGREG      ; exit case
00001E3E                          1233  
00001E3E  2C4D                    1234  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001E40  4BF9 000024B7           1235                      LEA        MSG_SLASH,A5         ; leads / into A5
00001E46  4EB9 0000217A           1236                      JSR        PRINTNULL            ; prints the slash
00001E4C  2A4E                    1237                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001E4E  DC44                    1238                      ADD.W      D4,D6                ; decrements or increments
00001E50  5245                    1239                      ADD.W      #1,D5                ; increments D5
00001E52  BA7C 0008               1240                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001E56  66B0                    1241                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001E58  B83C 0001               1242                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E5C  6600 0012               1243                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001E60  6000 0002               1244                      BRA        REGTOMEM2            ; loops
00001E64                          1245  
00001E64  3C3C 0000               1246  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001E68  4BF9 000024A6           1247                      LEA        MSG_AR,A5            ; loads A to A5
00001E6E  6098                    1248                      BRA        PRINTREGISTERLOOP    ; loops
00001E70                          1249  
00001E70  3C3C 0007               1250  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001E74  4BF9 000024A4           1251                      LEA        MSG_DR,A5            ; loads D to A5
00001E7A  608C                    1252                      BRA        PRINTREGISTERLOOP    ; loops
00001E7C                          1253  
00001E7C  4CDF 60E0               1254  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001E80                          1255  
00001E80                          1256                          
00001E80                          1257  * Checks if EA or Xn is valid
00001E80                          1258  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001E80                          1259  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001E80  2F02                    1260  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001E82                          1261  
00001E82  141D                    1262  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001E84  B43C 00FF               1263                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001E88  6700 000A               1264                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001E8C  B202                    1265                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001E8E  6700 000C               1266                     BEQ        VALIDEA               ; branches to valid EA
00001E92  60EE                    1267                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001E94                          1268                     
00001E94  323C 0001               1269  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001E98  6000 0016               1270                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001E9C                          1271                    
00001E9C  B43C 0007               1272  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001EA0  6700 000A               1273                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001EA4  323C 0000               1274                     MOVE.W     #$0,D1                ; marks that it is valid
00001EA8  6000 0006               1275                     BRA        CHECKEAEXIT           ; exits the subroutine
00001EAC                          1276  
00001EAC  323C 0002               1277  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001EB0                          1278  
00001EB0  241F                    1279  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001EB2  4E75                    1280                     RTS                              ; returns from subroutine
00001EB4                          1281  
00001EB4                          1282  * Converts EA and Xn into a string                                
00001EB4                          1283  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001EB4                          1284  * Outputs: Prints out EA and Xn into a string
00001EB4  48E7 C004               1285  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001EB8  B47C 0001               1286                     CMP.W    #An,D2                  ; checks if it is An
00001EBC  6700 003A               1287                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001EC0                          1288                     
00001EC0  B47C 0002               1289                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001EC4  6700 004A               1290                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001EC8                          1291                     
00001EC8  B47C 0003               1292                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001ECC  6700 0072               1293                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001ED0                          1294                     
00001ED0  B47C 0004               1295                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001ED4  6700 00A6               1296                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001ED8                          1297                     
00001ED8  B47C 0007               1298                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001EDC  6700 00DA               1299                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001EE0                          1300                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001EE0                          1301  
00001EE0                          1302  * data register, Dn
00001EE0  4BF9 000024A4           1303  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001EE6  4EB9 0000217A           1304                     JSR      PRINTNULL               ; Prints D
00001EEC  3203                    1305                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001EEE  4EB9 00002030           1306                     JSR      PRINTNUM                ; Prints the Xn
00001EF4  6000 0134               1307                     BRA      EA_TO_STRING_EXIT       ; exits           
00001EF8                          1308  
00001EF8                          1309  
00001EF8                          1310  * address register
00001EF8  4BF9 000024A6           1311  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001EFE  4EB9 0000217A           1312                     JSR      PRINTNULL               ; Prints A
00001F04  3203                    1313                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F06  4EB9 00002030           1314                     JSR      PRINTNUM                ; Prints the Xn
00001F0C  6000 011C               1315                     BRA      EA_TO_STRING_EXIT       ; exits
00001F10                          1316  
00001F10                          1317  * address register indirect
00001F10  4BF9 000024A8           1318  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001F16  4EB9 0000217A           1319                     JSR      PRINTNULL               ; Prints (
00001F1C  4BF9 000024A6           1320                     LEA      MSG_AR,A5               ; Loads A into A5
00001F22  4EB9 0000217A           1321                     JSR      PRINTNULL               ; Prints A
00001F28  3203                    1322                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F2A  4EB9 00002030           1323                     JSR      PRINTNUM                ; Prints the Xn
00001F30  4BF9 000024AA           1324                     LEA      MSG_RB,A5               ; Loads ) into A5
00001F36  4EB9 0000217A           1325                     JSR      PRINTNULL               ; Prints )
00001F3C  6000 00EC               1326                     BRA      EA_TO_STRING_EXIT       ; exits
00001F40                          1327  
00001F40                          1328  * address register indirect post increment
00001F40  4BF9 000024A8           1329  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001F46  4EB9 0000217A           1330                     JSR      PRINTNULL               ; Prints (
00001F4C  4BF9 000024A6           1331                     LEA      MSG_AR,A5               ; Loads A into A5
00001F52  4EB9 0000217A           1332                     JSR      PRINTNULL               ; Prints A
00001F58  3203                    1333                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F5A  4EB9 00002030           1334                     JSR      PRINTNUM                ; Prints the Xn
00001F60  4BF9 000024AA           1335                     LEA      MSG_RB,A5               ; Loads ) into A5
00001F66  4EB9 0000217A           1336                     JSR      PRINTNULL               ; Prints )
00001F6C  4BF9 000024AC           1337                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001F72  4EB9 0000217A           1338                     JSR      PRINTNULL               ; Prints +
00001F78  6000 00B0               1339                     BRA      EA_TO_STRING_EXIT       ; exits
00001F7C                          1340  
00001F7C                          1341  
00001F7C                          1342  * address register indirect pre increment
00001F7C  4BF9 000024AE           1343  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001F82  4EB9 0000217A           1344                     JSR      PRINTNULL               ; Prints -
00001F88  4BF9 000024A8           1345                     LEA      MSG_LB,A5               ; Loads ( into A5
00001F8E  4EB9 0000217A           1346                     JSR      PRINTNULL               ; Prints (
00001F94  4BF9 000024A6           1347                     LEA      MSG_AR,A5               ; Loads A into A5
00001F9A  4EB9 0000217A           1348                     JSR      PRINTNULL               ; Prints A
00001FA0  3203                    1349                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FA2  4EB9 00002030           1350                     JSR      PRINTNUM                ; Prints the Xn
00001FA8  4BF9 000024AA           1351                     LEA      MSG_RB,A5               ; Loads ) into A5
00001FAE  4EB9 0000217A           1352                     JSR      PRINTNULL               ; Prints )
00001FB4  6000 0074               1353                     BRA      EA_TO_STRING_EXIT       ; exits
00001FB8                          1354  
00001FB8                          1355  * other (long, short, immediate) with Xn yes
00001FB8  301A                    1356  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001FBA  B67C 0000               1357                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001FBE  6700 002E               1358                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001FC2                          1359                     
00001FC2  B67C 0001               1360                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001FC6  6700 0042               1361                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001FCA                          1362  
00001FCA                          1363  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001FCA                          1364  * immediate
00001FCA  4BF9 000024B0           1365  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001FD0  4EB9 0000217A           1366                     JSR      PRINTNULL               ; Prints #  
00001FD6  4BF9 000024B2           1367                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001FDC  4EB9 0000217A           1368                     JSR      PRINTNULL               ; Prints $
00001FE2  3200                    1369                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001FE4  4EB9 00002040           1370                     JSR      PRINTHEXNUM 
00001FEA  6000 003E               1371                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001FEE                          1372                     
00001FEE                          1373  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001FEE                          1374  
00001FEE                          1375  * word address
00001FEE                          1376  CASE_WORD          
00001FEE  4BF9 000024B2           1377                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001FF4  4EB9 0000217A           1378                     JSR      PRINTNULL               ; Prints $
00001FFA  3200                    1379                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001FFC  383C 0000               1380                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00002000  4EB9 00002054           1381                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002006  6000 0022               1382                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000200A                          1383  
0000200A                          1384  * long address 
0000200A                          1385  CASE_LONG          
0000200A  4BF9 000024B2           1386                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002010  4EB9 0000217A           1387                     JSR      PRINTNULL               ; Prints $
00002016  3200                    1388                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002018  383C 0001               1389                     MOVE.W   #1, D4                  ; moves length size (long) into d4
0000201C  4EB9 00002054           1390                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002022  321A                    1391                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002024  4EB9 00002030           1392                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
0000202A                          1393  
0000202A                          1394  
0000202A                          1395  * exits subroutine
0000202A  4CDF 2003               1396  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
0000202E  4E75                    1397                      RTS                              ; returns from subroutine
00002030                          1398  
00002030                          1399  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00002030                          1400  
00002030                          1401  * Prints out the content of D1 as a decimal number
00002030                          1402  * Input: number in D1 to be printed
00002030                          1403  * Output: contents of D1 printed
00002030  48E7 C000               1404  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00002034  103C 0003               1405                   MOVE.B      #3,D0               ; prints D1
00002038  4E4F                    1406                   TRAP        #15                 ; is trap task 3
0000203A                          1407              
0000203A  4CDF 0003               1408                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000203E  4E75                    1409                   RTS                             ; returns from subroutine
00002040                          1410                   
00002040                          1411  * Prints out the content of D1 as a hex number
00002040                          1412  * Input: number in D1 to be printed
00002040                          1413  * Output: contents of D1 printed
00002040  48E7 C000               1414  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00002044  143C 0010               1415                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002048  103C 000F               1416                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000204C  4E4F                    1417                   TRAP        #15                 ; is trap task 15
0000204E  4CDF 0003               1418                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00002052  4E75                    1419                   RTS                             ; returns from subroutine
00002054                          1420                   
00002054                          1421  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00002054                          1422  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00002054                          1423  * Output: contents of D1 printed
00002054  48E7 E000               1424  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00002058  B83C 0001               1425                            CMP.B       #1,D4               ; checks size of number
0000205C  6700 0042               1426                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00002060                          1427  
00002060  3401                    1428  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00002062  C47C F000               1429                            AND.W       #$F000,D2           ; gets the first digit
00002066  B47C 0000               1430                            CMP.W       #0, D2              ; checks if it is 0
0000206A  6600 00DC               1431                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000206E  4EB9 00002158           1432                            JSR         PRINTZERO           ; prints a zero
00002074                          1433                            
00002074  3401                    1434                            MOVE.W      D1,D2               ; copies number to D2
00002076  C47C 0F00               1435                            AND.W       #$0F00,D2           ; gets the second digit
0000207A  B47C 0000               1436                            CMP.W       #0, D2              ; checks if it is 0
0000207E  6600 00C8               1437                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002082  4EB9 00002158           1438                            JSR         PRINTZERO           ; prints a zero
00002088                          1439                            
00002088  3401                    1440                            MOVE.W      D1,D2               ; copies number to D2
0000208A  C47C 00F0               1441                            AND.W       #$00F0,D2           ; gets the third digit
0000208E  B47C 0000               1442                            CMP.W       #0, D2              ; checks if it is 0
00002092  6600 00B4               1443                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002096  4EB9 00002158           1444                            JSR         PRINTZERO           ; prints a zero
0000209C  6000 00AA               1445                            BRA         PRINTASHEX          ; prints last digit
000020A0                          1446                            
000020A0  2401                    1447  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
000020A2  C4BC F0000000           1448                            AND.L       #$F0000000,D2       ; gets the first digit
000020A8  B4BC 00000000           1449                            CMP.L       #0, D2              ; checks if it is 0
000020AE  6600 0098               1450                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020B2  4EB9 00002158           1451                            JSR         PRINTZERO           ; prints a zero
000020B8                          1452                            
000020B8  2401                    1453                            MOVE.L      D1,D2               ; copies number to D2
000020BA  C4BC 0F000000           1454                            AND.L       #$0F000000,D2       ; gets the second digit
000020C0  B4BC 00000000           1455                            CMP.L       #0, D2              ; checks if it is 0
000020C6  6600 0080               1456                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020CA  4EB9 00002158           1457                            JSR         PRINTZERO           ; prints a zero
000020D0                          1458                            
000020D0  2401                    1459                            MOVE.L      D1,D2               ; copies number to D2
000020D2  C4BC 00F00000           1460                            AND.L       #$00F00000,D2       ; gets the third digit
000020D8  B4BC 00000000           1461                            CMP.L       #0, D2              ; checks if it is 0
000020DE  6600 0068               1462                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020E2  4EB9 00002158           1463                            JSR         PRINTZERO           ; prints a zero
000020E8                          1464                            
000020E8  2401                    1465                            MOVE.L      D1,D2               ; copies number to D2
000020EA  C4BC 000F0000           1466                            AND.L       #$000F0000,D2       ; gets the fourth digit
000020F0  B4BC 00000000           1467                            CMP.L       #0, D2              ; checks if it is 0
000020F6  6600 0050               1468                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020FA  4EB9 00002158           1469                            JSR         PRINTZERO           ; prints a zero
00002100                          1470                            
00002100  2401                    1471                            MOVE.L      D1,D2               ; copies number to D2
00002102  C4BC 0000F000           1472                            AND.L       #$0000F000,D2       ; gets the fith digit
00002108  B4BC 00000000           1473                            CMP.L       #0, D2              ; checks if it is 0
0000210E  6600 0038               1474                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002112  4EB9 00002158           1475                            JSR         PRINTZERO           ; prints a zero
00002118                          1476                            
00002118  2401                    1477                            MOVE.L      D1,D2               ; copies number to D2
0000211A  C4BC 00000F00           1478                            AND.L       #$00000F00,D2       ; gets the sixth digit
00002120  B4BC 00000000           1479                            CMP.L       #0, D2              ; checks if it is 0
00002126  6600 0020               1480                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000212A  4EB9 00002158           1481                            JSR         PRINTZERO           ; prints a zero
00002130                          1482                            
00002130  2401                    1483                            MOVE.L      D1,D2               ; copies number to D2
00002132  C4BC 000000F0           1484                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002138  B4BC 00000000           1485                            CMP.L       #0, D2              ; checks if it is 0
0000213E  6600 0008               1486                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002142  4EB9 00002158           1487                            JSR         PRINTZERO           ; prints a zero
00002148                          1488  
00002148  143C 0010               1489  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
0000214C  103C 000F               1490                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002150  4E4F                    1491                            TRAP        #15                 ; is trap task 15
00002152  4CDF 0007               1492                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002156  4E75                    1493                            RTS                             ; returns from subroutine    
00002158                          1494  * Prints a zero
00002158                          1495  * Input: nothing
00002158                          1496  * Output: 0 printed out to the console
00002158  2F01                    1497  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
0000215A  7200                    1498                            MOVE.L      #0,D1               ; moves 0 to D1
0000215C  4EB8 2030               1499                            JSR         PRINTNUM            ; prints the number
00002160  221F                    1500                            MOVE.L      (SP)+,D1            ; restores D1
00002162  4E75                    1501                            RTS                             ; returns from subroutine
00002164                          1502              
00002164                          1503  * Prints contents of things between a range
00002164                          1504  * input: A5, A6 (the range)
00002164                          1505  * output: prints memory contents from A5 to A6 as strings   
00002164  48E7 C040               1506  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00002168  224D                    1507                  MOVEA.L     A5, A1           ; loads A5 into A1
0000216A  9DCD                    1508                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
0000216C  320E                    1509                  MOVE.W      A6, D1           ; move n into D1
0000216E  103C 0001               1510                  MOVE.B      #1, D0           ; display n characters of string at A1
00002172  4E4F                    1511                  TRAP        #15              ; is trap task 1
00002174  4CDF 0203               1512                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00002178  4E75                    1513                  RTS                          ; returns
0000217A                          1514      
0000217A                          1515  * Prints null terminated string
0000217A                          1516  * input: string pointed to by A5
0000217A                          1517  * output: prints out the null terminated string
0000217A  48E7 8040               1518  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
0000217E  224D                    1519                  MOVE.L      A5,A1           ; loads A5 into A1
00002180  103C 000E               1520                  MOVE.B      #14,D0          ; prints null terminated string
00002184  4E4F                    1521                  TRAP        #15             ; is trap task 10
00002186  4CDF 0201               1522                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
0000218A  4E75                    1523                  RTS                         ; returns from subroutine
0000218C                          1524                  
0000218C  2F0D                    1525  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
0000218E  4BF9 000023E3           1526                  LEA         NEW_LINE,A5     ; Prints null
00002194  4EB8 217A               1527                  JSR         PRINTNULL       ; prints the new line
00002198  2A5F                    1528                  MOVE.L      (SP)+,A5        ; returns A5
0000219A  4E75                    1529                  RTS
0000219C                          1530  
0000219C                          1531  * Prints the size of the MOVE or MOVEA operation  
0000219C                          1532  * input: D0
0000219C                          1533  * output: prints out the size of a MOVE or MOVEA operation        
0000219C  48E7 8004               1534  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
000021A0  3200                    1535                  MOVE.W  D0,D1               ; stores d0 in d1
000021A2  C07C 3000               1536                  AND.W   #$3000,D0           ; gets the size
000021A6  B07C 2000               1537                  CMP.W   #$2000,D0           ; checks if is long
000021AA  6700 001E               1538                  BEQ     MOVE_LONG
000021AE  B07C 3000               1539                  CMP.W   #$3000,D0           ; checks if is word
000021B2  6700 000C               1540                  BEQ     MOVE_WORD      
000021B6                          1541                  
000021B6  4BF9 000024DB           1542  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000021BC  6000 0012               1543                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000021C0                          1544  
000021C0  4BF9 000024DE           1545  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000021C6  6000 0008               1546                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000021CA                          1547  
000021CA  4BF9 000024E1           1548  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000021D0                          1549                  
000021D0  4EB8 217A               1550  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000021D4  4CDF 2001               1551                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000021D8  4E75                    1552                  RTS
000021DA                          1553  
000021DA  43F9 00002385           1554  ERROR           LEA     ERROR_MSG,A1
000021E0  103C 000E               1555                  MOVE.B  #14,D0
000021E4  4E4F                    1556                  TRAP    #15 
000021E6                          1557         
000021E6                          1558  * DELETE THIS: Test                
000021E6  2661                    1559  DELETEME        MOVEA.L  -(A1),A3
000021E8  6700 0038               1560                  BEQ      DELETEMEAGAIN  
000021EC  6F00 0034               1561                  BLE      DELETEMEAGAIN
000021F0  6E00 0030               1562                  BGT      DELETEMEAGAIN
000021F4                          1563  
000021F4  E40A                    1564                  LSR.B      #2,D2
000021F6  E2E2                    1565                  LSR.W      -(A2)
000021F8  E2DA                    1566                  LSR.W      (A2)+
000021FA  E4AA                    1567                  LSR.L      D2,D2 
000021FC  E50A                    1568                  LSL.B      #2,D2
000021FE  E3E2                    1569                  LSL.W      -(A2)
00002200  E3DA                    1570                  LSL.W      (A2)+
00002202  E5AA                    1571                  LSL.L      D2,D2
00002204  E51A                    1572                  ROL.B      #2,D2
00002206  E7E2                    1573                  ROL.W      -(A2)
00002208  E7DA                    1574                  ROL.W      (A2)+
0000220A  E5BA                    1575                  ROL.L      D2,D2
0000220C  E41A                    1576                  ROR.B      #2,D2
0000220E  E6E2                    1577                  ROR.W      -(A2)
00002210  E6DA                    1578                  ROR.W      (A2)+
00002212  E4BA                    1579                  ROR.L      D2,D2
00002214                          1580                  
00002214  504D                    1581                  ADDQ.W      #8,A5
00002216  D6C2                    1582                  ADDA.W      D2,A3
00002218  9BCB                    1583                  SUB.L       A3,A5        
0000221A  8A43                    1584                  OR.W        D3,D5
0000221C  4642                    1585                  NOT.W       D2
0000221E                          1586                  
0000221E  C5FC 0010               1587                  MULS.W    #$0010,D2
00002222                          1588                  
00002222                          1589  DELETEMEAGAIN                 
00002222                          1590            
00002222  FFFF FFFF               1591      SIMHALT             ; halt simulator
00002226                          1592  
00002226                          1593  * Put variables and constants here
00002226                          1594  
00002226  =0000000D               1595  CR                              EQU     $0D
00002226  =0000000A               1596  LF                              EQU     $0A 
00002226  =00000009               1597  TAB                             EQU     $09  
00002226                          1598  
00002226                          1599  * Addressing Modes
00002226  =00000000               1600  Dn                              EQU     0
00002226  =00000001               1601  An                              EQU     1
00002226  =00000002               1602  AnIndirect                      EQU     2
00002226  =00000003               1603  AnPost                          EQU     3
00002226  =00000004               1604  AnPre                           EQU     4
00002226  =00000007               1605  Other                           EQU     7           ; short, long, immediate
00002226                          1606  
00002226                          1607  * Xn
00002226  =00000000               1608  ABSShort                        EQU     0
00002226  =00000001               1609  ABSLong                         EQU     1
00002226  =00000004               1610  XnImmediate                     EQU     4
00002226                          1611  
00002226                          1612  * Valid Addressing Modes
00002226= 00 01 02 03 04 07 FF    1613  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
0000222D                          1614  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
0000222D= 00 02 03 04 07 FF       1615  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002233= 02 04 07 FF             1616  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002237= 02 03 07 FF             1617  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000223B= 02 03 04 07 FF          1618  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002240= 00 02 03 04 07 FF       1619  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002246= 01 07 FF                1620  VALIDEA_LEA                     DC.B    An,Other,-1
00002249= 00 02 03 04 07 FF       1621  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000224F= 02 03 04 07 FF          1622  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002254= 02 03 04 07 FF          1623  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00002259= 02 07 FF                1624  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
0000225C                          1625  
0000225C                          1626  * Valid Xn
0000225C= 00 01 04 FF             1627  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00002260                          1628  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00002260= 00 01 FF                1629  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00002263                          1630  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00002263                          1631  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00002263                          1632  
00002263                          1633  * posible memory ASd/LSd rotation values
00002263  =00000000               1634  ASd_MEM                         EQU     0   
00002263  =00000001               1635  LSd_MEM                         EQU     1 
00002263  =00000003               1636  ROd_MEM                         EQU     3
00002263                          1637   
00002263  =00000000               1638  ASd_REG                         EQU     0   
00002263  =00000001               1639  LSd_REG                         EQU     1 
00002263  =00000003               1640  ROd_REG                         EQU     3
00002263                          1641  
00002263                          1642  * Messages
00002263= 57 65 6C 63 6F 6D ...   1643  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
0000228B= 46 6F 72 6D 61 74 ...   1644  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
000022D6= 4C 65 74 74 65 72 ...   1645  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000022F6= 50 6C 65 61 73 65 ...   1646  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
0000232D= 50 6C 65 61 73 65 ...   1647  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00002363= 49 6E 76 61 6C 69 ...   1648  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002385= 45 72 72 6F 72 20 ...   1649  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
Line 1650 ERROR: Immediate data exceeds 8 bits
000023A1= 31 30 30 30 20 20 ...   1650  INVALID_INSTR                   DC.B    '1000    ',TAB,'DATA',MSG_6SPACES,'$',0
000023B1= 46 69 6E 69 73 68 ...   1651  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
000023E3= 0D 0A 00                1652  NEW_LINE                        DC.B    CR,LF,0
000023E6= 09 09 09 00             1653  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000023EA                          1654  
000023EA                          1655  * Opcode Messages
000023EA= 09 4E 4F 50 00          1656  MSG_NOP                         DC.B    TAB,'NOP',0
000023EF= 09 4D 4F 56 45 00       1657  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000023F5= 09 4D 4F 56 45 41 00    1658  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000023FC= 09 4D 4F 56 45 51 00    1659  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00002403= 09 4D 4F 56 45 4D 00    1660  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
0000240A= 09 41 44 44 00          1661  MSG_ADD                         DC.B    TAB,'ADD',0
0000240F= 09 41 44 44 41 00       1662  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002415= 09 41 44 44 51 00       1663  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
0000241B= 09 53 55 42 00          1664  MSG_SUB                         DC.B    TAB,'SUB',0
00002420= 09 4D 55 4C 53 00       1665  MSG_MULS                        DC.B    TAB,'MULS',0
00002426= 09 44 49 56 55 00       1666  MSG_DIVU                        DC.B    TAB,'DIVU',0
0000242C= 09 4C 45 41 00          1667  MSG_LEA                         DC.B    TAB,'LEA',0
00002431= 09 41 4E 44 00          1668  MSG_AND                         DC.B    TAB,'AND',0
00002436= 09 4F 52 00             1669  MSG_OR                          DC.B    TAB,'OR',0
0000243A= 09 4E 4F 54 00          1670  MSG_NOT                         DC.B    TAB,'NOT',0
0000243F= 09 4C 53 00             1671  MSG_LSd                         DC.B    TAB,'LS',0
00002443= 09 41 53 00             1672  MSG_ASd                         DC.B    TAB,'AS',0
00002447= 09 52 4F 00             1673  MSG_ROd                         DC.B    TAB,'RO',0
0000244B= 09 42 43 43 00          1674  MSG_BCC                         DC.B    TAB,'BCC',0
00002450= 09 42 43 53 00          1675  MSG_BCS                         DC.B    TAB,'BCS',0
00002455= 09 42 45 51 00          1676  MSG_BEQ                         DC.B    TAB,'BEQ',0
0000245A= 09 42 4E 45 00          1677  MSG_BNE                         DC.B    TAB,'BNE',0
0000245F= 09 42 47 45 00          1678  MSG_BGE                         DC.B    TAB,'BGE',0
00002464= 09 42 47 54 00          1679  MSG_BGT                         DC.B    TAB,'BGT',0
00002469= 09 42 48 49 00          1680  MSG_BHI                         DC.B    TAB,'BHI',0
0000246E= 09 42 4C 45 00          1681  MSG_BLE                         DC.B    TAB,'BLE',0
00002473= 09 42 4C 53 00          1682  MSG_BLS                         DC.B    TAB,'BLS',0
00002478= 09 42 4C 54 00          1683  MSG_BLT                         DC.B    TAB,'BLT',0
0000247D= 09 42 4D 49 00          1684  MSG_BMI                         DC.B    TAB,'BMI',0
00002482= 09 42 50 4C 00          1685  MSG_BPL                         DC.B    TAB,'BPL',0
00002487= 09 42 56 43 00          1686  MSG_BVC                         DC.B    TAB,'BVC',0
0000248C= 09 42 56 53 00          1687  MSG_BVS                         DC.B    TAB,'BVS',0
00002491= 09 4A 53 52 00          1688  MSG_JSR                         DC.B    TAB,'JSR',0
00002496= 09 52 54 53 00          1689  MSG_RTS                         DC.B    TAB,'RTS',0
0000249B= 09 42 52 41 00          1690  MSG_BRA                         DC.B    TAB,'BRA',0
000024A0                          1691  
000024A0                          1692  * Direction for LSd and ASd
000024A0= 52 00                   1693  MSG_RIGHT                       DC.B    'R',0
000024A2= 4C 00                   1694  MSG_LEFT                        DC.B    'L',0
000024A4                          1695  
000024A4                          1696  * Effective Addresses Messages
000024A4= 44 00                   1697  MSG_DR                          DC.B    'D',0
000024A6= 41 00                   1698  MSG_AR                          DC.B    'A',0
000024A8= 28 00                   1699  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000024AA= 29 00                   1700  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000024AC= 2B 00                   1701  MSG_PLUS                        DC.B    '+',0
000024AE= 2D 00                   1702  MSG_MINUS                       DC.B    '-',0
000024B0= 23 00                   1703  MSG_POUND                       DC.B    '#',0 
000024B2= 24 00                   1704  MSG_HEX                         DC.B    '$',0 
000024B4= 2C 20 00                1705  MSG_COMMA                       DC.B    ', ',0
000024B7= 2F 00                   1706  MSG_SLASH                       DC.B    '/',0  
000024B9= 20 00                   1707  MSG_SPACE                       DC.B    ' ',0
000024BB= 09 00                   1708  MSG_TAB                         DC.B    TAB,0
000024BD= 20 20 20 00             1709  MSG_3SPACES                     DC.B    '   ',0
000024C1= 20 20 20 20 00          1710  MSG_4SPACES                     DC.B    '    ',0
000024C6= 20 20 20 20 20 00       1711  MSG_5SPACES                     DC.B    '     ',0
000024CC= 20 20 20 20 20 20 00    1712  MSG_6SPACES                     DC.B    '      ',0
000024D3= 20 20 20 20 20 20 ...   1713  MSG_7SPACES                     DC.B    '       ',0
000024DB                          1714  
000024DB                          1715  * Size Messages
000024DB= 2E 42 00                1716  MSG_B                           DC.B    '.B',0
000024DE= 2E 57 00                1717  MSG_W                           DC.B    '.W',0
000024E1= 2E 4C 00                1718  MSG_L                           DC.B    '.L',0
000024E4                          1719  
000024E4                          1720  * Variables
000024E4  =00000100               1721  STARTING_ADDRESS                EQU     $100
000024E4  =00000150               1722  ENDING_ADDRESS                  EQU     $150
000024E4  =00000200               1723  CURRENT_INSTR                   EQU     $200
000024E4  =00000250               1724  REG_VAR                         EQU     $250 * Hold bits 11-9
000024E4  =00000300               1725  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000024E4  =00000350               1726  EA_MODE                         EQU     $350 * Hold bits 5-3
000024E4  =00000400               1727  EA_REG                          EQU     $400 * Hold bits 2-0
000024E4                          1728  
000024E4                          1729              END     START        ; last line of source

1 error detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           15D8
ADDQ_BYTE           167A
ADDQ_LONG           16B2
ADDQ_WORD           1696
ADD_SUB_BYTE        1508
ADD_SUB_HELP        1482
ADD_SUB_LONG        1524
ADD_SUB_OPERAND     153A
ADD_SUB_SIZE        14E4
ADD_SUB_WORD        1516
AN                  1
AND_BYTE            18A0
AND_LONG            18D8
AND_WORD            18BC
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           2363
CASE_ADD            1456
CASE_ADDA           15A0
CASE_ADDQ           1620
CASE_AND            1856
CASE_AR             1EF8
CASE_ARI            1F10
CASE_ARIPOST        1F40
CASE_ARIPRE         1F7C
CASE_ASDMEM         1A30
CASE_ASDREG         1B08
CASE_BCC            1C60
CASE_BEQ            1C92
CASE_BGT            1CA6
CASE_BLE            1C9C
CASE_BRA            1C2C
CASE_DATA           1CEA
CASE_DR             1EE0
CASE_EPICFAIL       1CF0
CASE_IMMEDIATE      1FCA
CASE_JSR            1CD0
CASE_LEA            17B8
CASE_LEFTMEM        1A5A
CASE_LEFTREG        1B32
CASE_LONG           200A
CASE_LSDASDROD      19F0
CASE_LSDMEM         1A26
CASE_LSDREG         1AFE
CASE_MOVE           120E
CASE_MOVEM          12D8
CASE_MOVEQ          13F2
CASE_NOP            11F4
CASE_NOT            1988
CASE_OR             1924
CASE_OTHER          1FB8
CASE_RIGHTMEM       1A64
CASE_RIGHTREG       1B3C
CASE_RODMEM         1A3A
CASE_RODREG         1B12
CASE_RTS            1CD0
CASE_SHIFTMEM       1A0E
CASE_SHIFTREG       1AE4
CASE_SUB            171C
CASE_SUBA           17A2
CASE_WORD           1FEE
CHECKEAEXIT         1EB0
CHECKEAMLOOP        1E82
CHECKEAXN_IFVALID   1E80
CHECKGET_EAXN       1D46
CHECKMEMSOURE       1AA4
CHECKMOREBITS       1E32
CHECKSHIFT_XN       1ACE
CHECK_LENGTH        1146
CHECK_ODD           11DC
CHECK_ORDER         10AE
CHECK_XN            1D76
CONCAT              118E
CONVERT             1158
CR                  D
CURRENT_INSTR       200
DELETEME            21E6
DELETEMEAGAIN       2222
DESTEA              1CFC
DESTXN              1D26
DISASSEMBLE         10B8
DN                  0
DN_PLUS_EA          1574
DONE                23B1
DONEPRINTINGREG     1E7C
EASHIFT_VALID       1AC2
EAXN_INVALID        1D88
EAXN_VALID          1D6E
EA_MODE             350
EA_REG              400
EA_TO_STRING        1EB4
EA_TO_STRING_EXIT   202A
ENDING              232D
ENDING_ADDRESS      150
END_CHECKGET        1D8C
ERROR               21DA
ERROR_MSG           2385
FINDTYPEEA          1D10
FINDTYPEXN          1D3A
FINISHED            10C8
FINISHMOVE          21D0
FINISH_ADD          1532
FINISH_ADDA         15F4
FINISH_ADDQ         16CE
FINISH_AND          18F4
FINISH_SUB          1768
FINISH_SUBA         176E
FORMAT1             228B
FORMAT2             22D6
GETDIRECTION        1DC6
GETDISPLACEMENT     1D8E
GETMEMSOURCE        1A8C
GETROTATION         1DBC
GETROTATIONLOCATION  1DD6
GETROTATIONSIZE     1DCE
GET_EA              1CF2
GET_XN              1D1C
INPUT1              1020
INPUT2              1066
INSERTA             1298
INVALID             11A6
INVALIDEA           1E94
INVALID_INSTR       23A1
INV_INSTR           18FE
ISNUMBER            116E
LF                  A
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         13B6
MEM2REGWORD         13A6
MEMTOREG1           1DFE
MEMTOREG2           1E70
MOVEM_MEM2REG       136E
MOVEM_REG2MEM       12F6
MOVE_BYTE           21B6
MOVE_LONG           21CA
MOVE_WORD           21C0
MSG_3SPACES         24BD
MSG_4SPACES         24C1
MSG_5SPACES         24C6
MSG_6SPACES         24CC
MSG_7SPACES         24D3
MSG_ADD             240A
MSG_ADDA            240F
MSG_ADDQ            2415
MSG_AND             2431
MSG_AR              24A6
MSG_ASD             2443
MSG_B               24DB
MSG_BCC             244B
MSG_BCS             2450
MSG_BEQ             2455
MSG_BGE             245F
MSG_BGT             2464
MSG_BHI             2469
MSG_BLE             246E
MSG_BLS             2473
MSG_BLT             2478
MSG_BMI             247D
MSG_BNE             245A
MSG_BPL             2482
MSG_BRA             249B
MSG_BVC             2487
MSG_BVS             248C
MSG_COMMA           24B4
MSG_DIVU            2426
MSG_DR              24A4
MSG_HEX             24B2
MSG_JSR             2491
MSG_L               24E1
MSG_LB              24A8
MSG_LEA             242C
MSG_LEFT            24A2
MSG_LSD             243F
MSG_MINUS           24AE
MSG_MOVE            23EF
MSG_MOVEA           23F5
MSG_MOVEM           2403
MSG_MOVEQ           23FC
MSG_MULS            2420
MSG_NOP             23EA
MSG_NOT             243A
MSG_OR              2436
MSG_PLUS            24AC
MSG_POUND           24B0
MSG_RB              24AA
MSG_RIGHT           24A0
MSG_ROD             2447
MSG_RTS             2496
MSG_SLASH           24B7
MSG_SPACE           24B9
MSG_SUB             241B
MSG_TAB             24BB
MSG_W               24DE
NEW_LINE            23E3
NOTNUMBER           1176
OPCODE_DECODE       11F0
OPMODE_VAR          300
OR_SIZE             1970
OTHER               7
OTHEREA             1EAC
PRINTADD            14C0
PRINTADDRESS        1D9E
PRINTASHEX          2148
PRINTBCC            1CB0
PRINTENTER          218C
PRINTHEXNUM         2040
PRINTLONGZERO       20A0
PRINTMEM2REG        13C2
PRINTMORE           1E3E
PRINTMOVE           12B6
PRINTMOVESIZE       219C
PRINTNULL           217A
PRINTNUM            2030
PRINTRANGE          2164
PRINTREG            1E24
PRINTREG2MEM        133E
PRINTREGEA          1B7E
PRINTREGISTERLOOP   1E08
PRINTREGISTERS      1DDE
PRINTREGSIZE        1B4C
PRINTSHIFTMEM       1A40
PRINTSHIFTREG       1B18
PRINTSHORTLONGNUM   2054
PRINTSHORTZERO      2060
PRINTSUB            1736
PRINTZERO           2158
PRINT_8             1710
PRINT_ADDQ_DATA     16EC
PRINT_ADDR          11E4
PRINT_MEMDIR        1A6A
PRINT_MOVEQ         1414
PRINT_REGDIR        1B46
REG2MEMLONG         1338
REG2MEMWORD         132E
REGTOMEM1           1DF0
REGTOMEM2           1E64
REG_BYTE            1B64
REG_IMMEDIATE       1BA0
REG_LONG            1B78
REG_REGISTER        1BE6
REG_VAR             250
REG_WORD            1B6E
RESET_INPUT         113E
RESTART             10E8
RETURN              11A4
ROD_MEM             3
ROD_REG             3
SOURCEEA            1D08
SOURCEXN            1D32
START               1000
STARTING            22F6
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11C4
THREE_TAB           23E6
VALIDEA             1E9C
VALIDEA_ADDSUB_DESTOPERAND  223B
VALIDEA_ALL         2226
VALIDEA_ANDORNOT    2249
VALIDEA_ANDOR_DESTOPERAND  224F
VALIDEA_JSR         2259
VALIDEA_LEA         2246
VALIDEA_MOVEM_MEMTOREG  2237
VALIDEA_MOVEM_REGTOMEM  2233
VALIDEA_MOVEQ       222D
VALIDEA_MULSDIVU    2240
VALIDEA_SHIFT       2254
VALIDXN_ALL         225C
VALIDXN_SHORTLONG   2260
WELCOME             2263
XNIMMEDIATE         4
