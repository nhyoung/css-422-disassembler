00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/6/2020 4:43:03 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001B69             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001BDF             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001C16             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 00001968             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001AA0             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6E00 0052                 78                  BGT     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 00001C4C            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C  33C0 00000200            138                  MOVE.W  D0,CURRENT_INSTR
00001172                           139                  
00001172  B07C 4E71                140  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001176  6600 0010                141                  BNE     CASE_MOVE               ; checks the next case if not equal
0000117A  4BF9 00001C91            142                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001180  4EB9 00001A8E            143                  JSR     PRINTNULL               ; prints NOP                
00001186  4E75                     144                  RTS                             ; returns from the subroutine
00001188                           145                  
00001188                           146                  * if first two bits are 00, next two are not 00
00001188  3200                     147  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
0000118A  C27C C000                148                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000118E  6600 009A                149                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001192  B07C 0FFF                150                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001196  6F00 0092                151                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
0000119A                           152                  
0000119A                           153                  ; Check source
0000119A  4BF9 00001B2C            154                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011A0  4DF9 00001B62            155                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A6  3E3C 0000                156                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011AA  4EB9 000016FC            157                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011B0  B27C 0001                158                  CMP.W   #1,D1                    ; checks if invalid
000011B4  6700 04EE                159                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B8  3802                     160                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011BA  3A03                     161                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011BC                           162                  
000011BC                           163                  ; Check destination
000011BC  4BF9 00001B2C            164                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011C2  4DF9 00001B66            165                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C8  3E3C 0001                166                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011CC  4EB9 000016FC            167                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011D2  B27C 0001                168                  CMP.W   #1,D1                    ; checks if invalid
000011D6  6700 04CC                169                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011DA  3C02                     170                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011DC  3E03                     171                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011DE                           172                  
000011DE                           173                  ; Checking if it is MOVEA
000011DE  3200                     174                  MOVE.W  D0,D1                    ; stores d0 in d1
000011E0  C27C 01C0                175                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011E4  B27C 0040                176                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E8  6700 000C                177                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011EC                           178   
000011EC  4BF9 00001C96            179                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011F2  6000 0008                180                  BRA     PRINTMOVE                ; Branches to print move
000011F6                           181                  
000011F6  4BF9 00001C9C            182  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011FC                           183   
000011FC  4EB9 00001A8E            184  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001202  4EB9 00001AB0            185                  JSR     PRINTMOVESIZE            ; prints out the size  
00001208  3404                     186                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000120A  3605                     187                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000120C  4EB9 000017C8            188                  JSR     EA_TO_STRING             ; outputs it into a string
00001212                           189                  
00001212                           190                  ; prints a comma to seperate
00001212  4BF9 00001D8E            191                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001218  4EB9 00001A8E            192                  JSR     PRINTNULL                ; prints out MOVE
0000121E                           193                  
0000121E                           194                  ; print destination
0000121E  3406                     195                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001220  3607                     196                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001222  4EB9 000017C8            197                  JSR     EA_TO_STRING             ; outputs it into a string
00001228  4E75                     198                  RTS                              ; exits subroutine                 
0000122A                           199                
0000122A                           200                  
0000122A  3200                     201  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000122C  C27C FB80                202                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001230  B27C 4880                203                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001234  6600 005A                204                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001238                           205                  
00001238                           206                  ; loads EA and XN
00001238  323C 0000                207                  MOVE.W  #0,D1                           ; copies instruction word to D1
0000123C  4EB9 000016A8            208                  JSR     GET_EA                          ; gets EA and puts in D1
00001242  3401                     209                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
00001244  323C 0000                210                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001248  4EB9 000016D2            211                  JSR     GET_XN                          ; gets XN and puts in D1
0000124E  3601                     212                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
00001250                           213                  
00001250                           214                  ; Check D
00001250  3200                     215                  MOVE.W  D0,D1                           ; copies instruction word to D1
00001252  C27C 0400                216                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001256  3E01                     217                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001258  B27C 0400                218                  CMP.W   #$0400,D1                       ; checks if value is 1
0000125C  6700 0032                219                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
00001260                           220  
00001260  4BF9 00001B39            221  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001266  3202                     222                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001268  4EB9 00001794            223                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
0000126E  B27C 0001                224                  CMP.W   #1,D1                           ; checks if D1 invalid
00001272  6700 0430                225                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001276  B27C 0002                226                  CMP.W   #2,D1                           ; checks if we need to check Xn
0000127A                           227                  
0000127A  4BF9 00001B39            228  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001280  3203                     229                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
00001282  4EB9 00001794            230                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001288  B27C 0001                231                  CMP.W   #1,D1                           ; checks if D1 invalid
0000128C  6700 0416                232                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001290                           233  
00001290                           234                  
00001290                           235  
00001290                           236  MOVEM_MEM2REG    
00001290                           237                          
00001290                           238  
00001290                           239  
00001290  3200                     240  CASE_MOVEQ      MOVE.W  D0,D1
00001292  C27C F100                241                  AND.W   #$F100,D1
00001296  B27C 7000                242                  CMP.W   #$7000,D1
0000129A  6600 0046                243                  BNE     CASE_ADD
0000129E                           244                  
0000129E                           245                  ;loads Register
0000129E  323C 0001                246                  MOVE.W  #1,D1                           ; copies instruction word to D1
000012A2  4EB9 000016D2            247                  JSR     GET_XN                          ; gets XN and puts in D1
000012A8  3401                     248                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012AA                           249                  
000012AA                           250                  ;loads DATA
000012AA  3200                     251                  MOVE.W  D0,D1
000012AC  C27C 00FF                252                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012B0  3601                     253                  MOVE.W  D1,D3                          ;copy data into D3
000012B2                           254                                                          ;must convert bits to hex
000012B2                           255                  
000012B2                           256                  
000012B2  4BF9 00001CA3            257  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B8  4EB9 00001A8E            258                  JSR     PRINTNULL  
000012BE                           259                  
000012BE  4BF9 00001DA1            260                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012C4  4EB9 00001A8E            261                  JSR     PRINTNULL
000012CA                           262      
000012CA  4BF9 00001C8D            263                  LEA     THREE_TAB,A5                ;PRINT THREE TABS
000012D0  4EB9 00001A8E            264                  JSR     PRINTNULL
000012D6                           265                  
000012D6  4BF9 00001D8A            266                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012DC  4EB9 00001A8E            267                  JSR     PRINTNULL
000012E2                           268  
000012E2                           269  
000012E2  3200                     270  CASE_ADD        MOVE.W  D0,D1
000012E4  C27C F000                271                  AND.W   #$F000,D1
000012E8  B27C D000                272                  CMP.W   #$D000,D1
000012EC  6600 006E                273                  BNE     CASE_ADDQ
000012F0                           274                   
000012F0  3200                     275                  MOVE.W  D0,D1
000012F2  E149                     276                  LSL.W   #8,D1                   ; get rid of left 8 bits
000012F4  E049                     277                  LSR.W   #8,D1
000012F6  EC49                     278                  LSR.W   #6,D1                   ; get rid of right 6 bits
000012F8  B27C 0003                279                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000012FC  6700 005E                280                  BEQ     CASE_ADDA
00001300                           281                  
00001300                           282                  ; Check bits 0-6 
00001300  4BF9 00001B2C            283                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001306  4DF9 00001B62            284                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000130C  3E3C 0001                285                  MOVE.W  #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001310  4EB9 000016FC            286                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001316  B27C 0001                287                  CMP.W   #1,D1                    ; checks if invalid
0000131A  6700 0388                288                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000131E  3802                     289                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
00001320  3A03                     290                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001322                           291                  
00001322                           292                  ; Check destination
00001322  4BF9 00001B2C            293                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001328  4DF9 00001B66            294                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000132E  3E3C 0001                295                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001332  4EB9 000016FC            296                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001338  B27C 0001                297                  CMP.W   #1,D1                    ; checks if invalid
0000133C  6700 0366                298                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001340  3C02                     299                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001342  3E03                     300                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001344                           301                  
00001344                           302                  ; Checking if it is MOVEA
00001344  3200                     303                  MOVE.W  D0,D1                    ; stores d0 in d1
00001346  C27C 01C0                304                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
0000134A  B27C 0040                305                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000134E  6700 FEA6                306                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001352                           307   
00001352  4BF9 00001C96            308                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001358  6000 FEA2                309                  BRA     PRINTMOVE                ; Branches to print move
0000135C                           310   
0000135C                           311  
0000135C                           312  CASE_ADDA 
0000135C                           313  *
0000135C                           314  *CASE_ADDA       LEA         MSG_ADDA,A1
0000135C                           315  *                MOVE.B      #14,D0
0000135C                           316  *                TRAP        #15                 ; print "ADDA"
0000135C                           317  *                MOVE.W      OPMODE_VAR,D3
0000135C                           318  *                JSR         ADDA_SIZE
0000135C                           319  *                JSR         ADDR_MODE_JUMP_TABLE
0000135C                           320  *                    
0000135C                           321  *            
0000135C                           322  *ADDA_SIZE       CMP.W       #%111,D3
0000135C                           323  *                BEQ         PRINT_WORD 
0000135C                           324  *                BRA         PRINT_LONG          
0000135C                           325                  
0000135C                           326  
0000135C                           327  CASE_ADDQ       
0000135C                           328  
0000135C                           329  CASE_SUB
0000135C                           330  
0000135C  3200                     331  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000135E  C27C F000                332                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001362  B27C 4000                333                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001366  6600 0086                334                  BNE.W   CASE_AND                             ; If its not, check AND
0000136A  3200                     335                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000136C  C27C 01C0                336                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001370  B27C 01C0                337                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001374  6600 0078                338                  BNE.W   CASE_AND                             ; If its not, check AND
00001378                           339                  
00001378                           340                  ; Check source
00001378  4BF9 00001B4C            341                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000137E  4DF9 00001B66            342                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001384  3E3C 0000                343                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001388  4EB9 000016FC            344                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000138E  3802                     345                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001390  3A03                     346                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001392                           347                  
00001392                           348                  ; Check destination
00001392  4BF9 00001B4C            349                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001398  4DF9 00001B66            350                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000139E  3E3C 0001                351                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000013A2  4EB9 000016FC            352                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000013A8  3C02                     353                  MOVE.W  D2,D6                                ; Saves D2 in D4
000013AA  3E03                     354                  MOVE.W  D3,D7                                ; Saves D2 in D4
000013AC                           355  
000013AC  4BF9 00001CD3            356                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000013B2  4EB9 00001A8E            357                  JSR     PRINTNULL                            ; prints LEA
000013B8                           358                  
000013B8                           359                  ; print source
000013B8  3404                     360                  MOVE.W  D4,D2
000013BA  3605                     361                  MOVE.W  D5,D3
000013BC  4EB9 000017C8            362                  JSR     EA_TO_STRING                         ; Prints out the EA
000013C2                           363                  
000013C2                           364                  ; comma
000013C2  4BF9 00001D8E            365                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000013C8  4EB9 00001A8E            366                  JSR     PRINTNULL                       
000013CE                           367                   
000013CE                           368                  ; register
000013CE  4BF9 00001D80            369                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000013D4  4EB9 00001A8E            370                  JSR     PRINTNULL 
000013DA  3401                     371                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000013DC  323C 0001                372                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000013E0  4EB9 000016D2            373                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000013E6  4EB9 00001944            374                  JSR     PRINTNUM                             ; Prints the number in D1
000013EC  4E75                     375                  RTS
000013EE                           376  
000013EE                           377  **---------------AND opcode----------------------
000013EE                           378  CASE_AND
000013EE                           379  *CASE_AND        LEA         MSG_AND,A1
000013EE                           380  *                MOVE.B      #14,D0
000013EE                           381  *                TRAP        #15 
000013EE                           382  *                JSR         GET_VARS
000013EE                           383  *                JSR         AND_SIZE                        ; .B, .W, or .L  
000013EE                           384  *                MOVE.W      CURRENT_INSTR, D5                         
000013EE                           385  *                LSL.W       #7, D5                        
000013EE                           386  *                LSR.W       #8, D5                   
000013EE                           387  *                LSR.W       #7, D5                     
000013EE                           388  *                CMP.B       #00, D5                         ; check if destination is a Dn?
000013EE                           389  *                BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
000013EE                           390  *                CMP.B       #$01,D5                         ; Is the destination not a Dn?
000013EE                           391  *                BEQ         DEST_EA                         ; branch to DEST_EA            
000013EE                           392  *                RTS
000013EE                           393     
000013EE                           394  *AND_SIZE        CMP.B       #%00,OPMODE_VAR       
000013EE                           395  *                BEQ         PRINT_BYTE
000013EE                           396  *                CMP.B       #$01, OPMODE_VAR
000013EE                           397  *                BEQ         PRINT_WORD
000013EE                           398  *                CMP.B       #$02, OPMODE_VAR
000013EE                           399  *                BEQ         PRINT_LONG    
000013EE                           400  *    
000013EE                           401  *DEST_DN         MOVE.W      CURRENT_INSTR, D5               
000013EE                           402  *                LSL.W       #6,D5
000013EE                           403  *                LSL.W       #4,D5
000013EE                           404  *                LSR.W       #6,D5
000013EE                           405  *                LSR.W       #4,D5
000013EE                           406  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000013EE                           407  *                  
000013EE                           408  *                MOVE.W      CURRENT_INSTR, D6               
000013EE                           409  *                LSL.W       #6,D5
000013EE                           410  *                LSL.W       #4,D5
000013EE                           411  *                LSL.W       #3,D6
000013EE                           412  *                LSR.W       #6,D6
000013EE                           413  *                LSR.W       #4,D6
000013EE                           414  *                LSR.W       #3,D6                           ; d6 stores EA register
000013EE                           415  *                JSR         FIND_EA
000013EE                           416  *
000013EE                           417  *                
000013EE                           418  *                MOVE.W      CURRENT_INSTR, D5               
000013EE                           419  *                LSL.W       #4, D5                         
000013EE                           420  *                LSR.W       #8, D5                          ; shift bits to get register
000013EE                           421  *                LSR.W       #5, D5                          ; D5 contains register
000013EE                           422  *                LEA         MSG_COMMA, A1                   
000013EE                           423  *                MOVE.B      #14,D0
000013EE                           424  *                TRAP        #15                             ; print comma
000013EE                           425  *                LEA         MSG_DR, A1                      ; print D
000013EE                           426  *                MOVE.B      #14,D0
000013EE                           427  *                TRAP        #15
000013EE                           428  *                MOVEA.L     D5,A1
000013EE                           429  *                MOVE.B      #14,D0
000013EE                           430  *                TRAP        #15                              
000013EE                           431  *                RTS        
000013EE                           432  *
000013EE                           433  *FIND_EA        CMP.W       #%010,D5
000013EE                           434  *                BEQ         CASE_ARI
000013EE                           435  *                CMP.W       #%011,D5
000013EE                           436  *                BEQ         CASE_ARIPOST
000013EE                           437  *                CMP.W       #%100,D5
000013EE                           438  *                BEQ         CASE_ARIPRE
000013EE                           439  *                CMP.W       #%111,D5
000013EE                           440  *                BEQ         CASE_OTHER
000013EE                           441  *                BRA         ERROR    
000013EE                           442  *                                     
000013EE                           443  *DEST_EA         MOVE.W      CURRENT_INSTR, D5               
000013EE                           444  *                LSL.W       #4, D5                         
000013EE                           445  *                LSR.W       #8, D5                          ; shift bits to get register
000013EE                           446  *                LSR.W       #5, D5                          ; D5 contains register
000013EE                           447  *
000013EE                           448  *                LEA         MSG_DR, A1                   
000013EE                           449  *                MOVE.B      #14,D0
000013EE                           450  *                TRAP        #15                             ; print D
000013EE                           451  *                MOVEA.L     D5,A1  
000013EE                           452  *                MOVE.B      #14,D0                          ; print register
000013EE                           453  *                TRAP        #15
000013EE                           454  *                
000013EE                           455  *                LEA         MSG_COMMA, A1                   
000013EE                           456  *                MOVE.B      #14,D0
000013EE                           457  *                TRAP        #15                             ; print comma
000013EE                           458  *                
000013EE                           459  *                MOVE.W      CURRENT_INSTR, D5               
000013EE                           460  *                LSL.W       #6,D5
000013EE                           461  *                LSL.W       #4,D5
000013EE                           462  *                LSR.W       #6,D5
000013EE                           463  *                LSR.W       #4,D5
000013EE                           464  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000013EE                           465  *                  
000013EE                           466  *                MOVE.W      CURRENT_INSTR, D6               
000013EE                           467  *                LSL.W       #6,D6
000013EE                           468  *                LSL.W       #4,D6
000013EE                           469  *                LSL.W       #3,D6
000013EE                           470  *                LSR.W       #6,D6
000013EE                           471  *                LSR.W       #4,D6
000013EE                           472  *                LSR.W       #3,D6                           ; d6 stores EA register
000013EE                           473  *                JSR         FIND_EA                          
000013EE                           474  *                RTS                                     Return full instruction   
000013EE                           475              
000013EE                           476  CASE_OR
000013EE                           477  
000013EE                           478  CASE_NOT
000013EE                           479  
000013EE  3200                     480  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
000013F0  C27C F000                481                  AND.W       #$F000, D1                       ; gets first 4 bits
000013F4  B27C E000                482                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000013F8  6600 0210                483                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000013FC  3400                     484                  MOVE.W      D0,D2                            ; copies D0 to D2
000013FE  4EB9 00001784            485                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001404  B47C 0003                486                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001408  6600 00C8                487                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
0000140C                           488                  
0000140C  3400                     489  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000140E  4EB9 00001772            490                  JSR         GETROTATION                      ; gets rotation value of D2
00001414  B47C 0000                491                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001418  6700 0014                492                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
0000141C  B47C 0003                493                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001420  6700 0016                494                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001424                           495                  
00001424  4BF9 00001CE9            496  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
0000142A  6000 0012                497                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000142E                           498  
0000142E  4BF9 00001CED            499  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001434  6000 0008                500                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001438                           501  
00001438  4BF9 00001CF1            502  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000143E                           503                  
0000143E  4EB9 00001A8E            504  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
00001444  3400                     505                  MOVE.W      D0,D2                            ; copies D0 to D2
00001446  4EB9 0000177C            506                  JSR         GETDIRECTION                     ; gets direction
0000144C  B47C 0000                507                  CMP.W       #0,D2                            ; checking if its right
00001450  6700 000C                508                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001454                           509  
00001454  4BF9 00001D7C            510  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000145A  6000 0008                511                  BRA         PRINT_MEMDIR                     ; branches for printing
0000145E                           512          
0000145E  4BF9 00001D7A            513  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001464                           514  
00001464  4EB9 00001A8E            515  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000146A  4BF9 00001D9B            516                  LEA         MSG_W,A5                         ; loads .W into A5
00001470  4EB9 00001A8E            517                  JSR         PRINTNULL                        ; Prints .W
00001476  6000 0002                518                  BRA         GETMEMSOURCE                     ; checks the source 
0000147A                           519                  
0000147A                           520  ; get source addressing mode       
0000147A                           521  GETMEMSOURCE                                                 
0000147A  323C 0000                522                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000147E  4EB9 000016A8            523                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001484  3801                     524                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001486  323C 0000                525                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
0000148A  4EB9 000016D2            526                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001490  3A01                     527                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001492                           528  
00001492  4BF9 00001B5A            529  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001498  3204                     530                  MOVE.W      D4,D1                            ; marks down that we are checking EA
0000149A  4EB9 00001794            531                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000014A0  B27C 0002                532                  CMP.W       #2,D1                            ; checks if it is Xn
000014A4  6700 0016                533                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000014A8  B27C 0001                534                  CMP.W       #1,D1                            ; Checks if it is invalid
000014AC  6700 01F6                535                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000014B0                           536  
000014B0  3404                     537  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000014B2  3605                     538                  MOVE.W      D5,D3                            ; moves EA to D3
000014B4  4EB9 000017C8            539                  JSR         EA_TO_STRING                     ; prints out the EA
000014BA  4E75                     540                  RTS                
000014BC                           541                  
000014BC                           542                  
000014BC  4BF9 00001B66            543  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000014C2  3205                     544                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000014C4  4EB9 00001794            545                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000014CA  4A41                     546                  TST.W       D1                               ; checks if it is valid
000014CC  67E2                     547                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000014CE  6000 01D4                548                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000014D2                           549  
000014D2                           550  
000014D2  3602                     551  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000014D4  3200                     552                  MOVE.W      D0,D1                            ; copies D0 to D1
000014D6  C27C 0018                553                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000014DA  E649                     554                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000014DC  B27C 0000                555                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000014E0  6700 0014                556                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000014E4  B27C 0003                557                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000014E8  6700 0016                558                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000014EC                           559                  
000014EC  4BF9 00001CE9            560  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
000014F2  6000 0012                561                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000014F6                           562  
000014F6  4BF9 00001CED            563  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
000014FC  6000 0008                564                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001500                           565  
00001500  4BF9 00001CF1            566  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001506                           567                  
00001506  4EB9 00001A8E            568  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
0000150C  3400                     569                  MOVE.W      D0,D2                            ; copies D0 to D2
0000150E  4EB9 0000177C            570                  JSR         GETDIRECTION                     ; gets direction
00001514  B47C 0000                571                  CMP.W       #0,D2                            ; checking if its right
00001518  6700 000C                572                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
0000151C                           573  
0000151C  4BF9 00001D7C            574  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001522  6000 000C                575                  BRA         PRINT_REGDIR                     ; branches for printing
00001526                           576          
00001526  4BF9 00001D7A            577  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
0000152C  6000 0002                578                  BRA         PRINT_REGDIR                     ; branches for printing
00001530                           579                  
00001530  4EB9 00001A8E            580  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001536                           581  
00001536  3400                     582  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001538  4EB9 00001784            583                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000153E  B47C 0001                584                  CMP.W       #1,D2                            ; Checks if it is word size
00001542  6700 0014                585                  BEQ         REG_WORD                         ; Prints .W
00001546  B47C 0002                586                  CMP.W       #2,D2                            ; Checks if it is long size
0000154A  6700 0016                587                  BEQ         REG_LONG                         ; Prints .L
0000154E                           588  
0000154E  4BF9 00001D95            589  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001554  6000 0012                590                  BRA         PRINTREGEA      
00001558                           591  
00001558  4BF9 00001D9B            592  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
0000155E  6000 0008                593                  BRA         PRINTREGEA      
00001562                           594                             
00001562  4BF9 00001DA1            595  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001568                           596  
00001568  4EB9 00001A8E            597  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
0000156E  3400                     598                  MOVE.W      D0,D2                            ; copies D0 to D1
00001570  4EB9 0000178C            599                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001576  B27C 0001                600                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
0000157A  6700 0048                601                  BEQ         REG_REGISTER                     ; goes to ASd case if so
0000157E                           602                                  
0000157E  3400                     603  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001580  4EB9 00001784            604                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001586  3202                     605                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001588  4BF9 00001D8A            606                  LEA         MSG_POUND, A5                    ; loads # into A5
0000158E  4EB9 00001A8E            607                  JSR         PRINTNULL                        ; prints #
00001594  4EB9 00001944            608                  JSR         PRINTNUM                         ; prints shift count
0000159A  4BF9 00001D8E            609                  LEA         MSG_COMMA, A5                    ; loads , into A5
000015A0  4EB9 00001A8E            610                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000015A6  4BF9 00001D7E            611                  LEA         MSG_DR, A5                       ; loads D into A5
000015AC  4EB9 00001A8E            612                  JSR         PRINTNULL                        ; prints out D 
000015B2  323C 0000                613                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000015B6  4EB9 000016D2            614                  JSR         GET_XN                           ; gets the data register number, stores in D1
000015BC  4EB9 00001944            615                  JSR         PRINTNUM                         ; prints data register number in D1          
000015C2  4E75                     616                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000015C4                           617                  
000015C4  3400                     618  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
000015C6  4EB9 00001784            619                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000015CC  3202                     620                  MOVE.W      D2, D1                           ; moves rotation size to D1
000015CE  4BF9 00001D7E            621                  LEA         MSG_DR, A5                       ; loads D into A5
000015D4  4EB9 00001A8E            622                  JSR         PRINTNULL                        ; prints D
000015DA  4EB9 00001944            623                  JSR         PRINTNUM                         ; prints register number
000015E0  4BF9 00001D8E            624                  LEA         MSG_COMMA, A5                    ; loads , into A5
000015E6  4EB9 00001A8E            625                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000015EC  4BF9 00001D7E            626                  LEA         MSG_DR, A5                       ; loads D into A5
000015F2  4EB9 00001A8E            627                  JSR         PRINTNULL                        ; prints out D 
000015F8  323C 0000                628                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000015FC  4EB9 000016D2            629                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001602  4EB9 00001944            630                  JSR         PRINTNUM                         ; prints data register number in D1          
00001608  4E75                     631                  RTS                                          ; ends subroutine to go onto the next instruction opcode
0000160A                           632               
0000160A  3200                     633  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000160C  C27C FF00                634                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001610  B27C 6000                635                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001614  6600 0018                636                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001618                           637                  
00001618  4BF9 00001D72            638                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
0000161E  4EB9 00001A8E            639                  JSR     PRINTNULL                            ; prints BRA
00001624                           640  
00001624  3400                     641                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001626  4EB9 00001744            642                  JSR     GETDISPLACEMENT                      ; finds the displacement
0000162C  4E75                     643                  RTS
0000162E                           644                  
0000162E                           645  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
0000162E                           646  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
0000162E  3200                     647  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001630  C27C F000                648                  AND.W   #$F000,D1                            ; get top 4 bits
00001634  B27C 6000                649                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001638  6600 0054                650                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
0000163C  3200                     651                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
0000163E  C27C 0F00                652                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001642  E049                     653                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001644                           654                  
00001644  B27C 000E                655                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001648  6700 002A                656                  BEQ     CASE_BGT                             ; branches to BGT if it is
0000164C                           657                  
0000164C  B27C 000F                658                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001650  6700 0018                659                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001654                           660                      
00001654  B27C 0007                661                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001658  6700 0006                662                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
0000165C  6000 0046                663                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001660                           664     
00001660  4BF9 00001D05            665  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001666  6000 0016                666                  BRA     PRINTBCC
0000166A                           667  
0000166A  4BF9 00001D2D            668  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001670  6000 000C                669                  BRA     PRINTBCC
00001674                           670                  
00001674  4BF9 00001D1D            671  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
0000167A  6000 0002                672                  BRA     PRINTBCC
0000167E                           673  
0000167E  4EB9 00001A8E            674  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001684  3400                     675                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001686  4EB9 00001744            676                  JSR     GETDISPLACEMENT                      ; finds the displacement
0000168C  4E75                     677                  RTS              
0000168E                           678                  
0000168E                           679  
0000168E                           680  CASE_JSR       
0000168E                           681  
0000168E  B07C 4E75                682  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001692  6600 FAF4                683                  BNE     CASE_MOVE           ; checks the next case if not equal
00001696  4BF9 00001D6D            684                  LEA     MSG_RTS,A5          ; loads string pointer into A5
0000169C  4EB9 00001A8E            685                  JSR     PRINTNULL           ; prints RTS                
000016A2  4E75                     686                  RTS                         ; returns from the subroutine
000016A4                           687  
000016A4                           688                  
000016A4                           689  
000016A4                           690  CASE_DATA           
000016A4  4E75                     691                      RTS               
000016A6                           692  
000016A6  4E75                     693  CASE_EPICFAIL       RTS
000016A8                           694  
000016A8                           695  
000016A8                           696  * Finds the EA type
000016A8                           697  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
000016A8                           698  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000016A8  48E7 3000                699  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000016AC  4A41                     700                      TST.W     D1                    ; compares D1 to 0
000016AE  6700 000E                701                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
000016B2                           702                      
000016B2  343C 01C0                703  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
000016B6  363C 0006                704                      MOVE.W    #6,D3                 ; stores the shift amount to D3
000016BA  6000 000A                705                      BRA       FINDTYPEEA            
000016BE                           706  
000016BE  343C 0038                707  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
000016C2  363C 0003                708                      MOVE.W    #3,D3                 ; stores the shift amount to D3
000016C6                           709  
000016C6                           710  
000016C6  3200                     711  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
000016C8  C242                     712                      AND.W     D2,D1                 ; applies bitmask to D1
000016CA  E669                     713                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000016CC  4CDF 000C                714                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000016D0  4E75                     715                      RTS                             ; returns from subroutine    
000016D2                           716                      
000016D2                           717  * Finds Xn type
000016D2                           718  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
000016D2                           719  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000016D2  48E7 3000                720  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000016D6  4A41                     721                      TST.W     D1                    ; compares D1 to 0
000016D8  6700 000E                722                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
000016DC                           723  
000016DC  343C 0E00                724  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
000016E0  363C 0009                725                      MOVE.W    #9,D3                 ; stores the shift amount to D3
000016E4  6000 000A                726                      BRA       FINDTYPEXN            ; finds the type of Xn
000016E8                           727  
000016E8  343C 0007                728  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
000016EC  363C 0000                729                      MOVE.W    #0,D3                 ; stores the shift amount to D3
000016F0                           730                      
000016F0  3200                     731  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
000016F2  C242                     732                      AND.W     D2,D1                 ; applies bitmask to D1
000016F4  E669                     733                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000016F6  4CDF 000C                734                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000016FA  4E75                     735                      RTS                             ; returns from subroutine 
000016FC                           736                      
000016FC                           737  * Checks and gets the EA and Xn
000016FC                           738  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
000016FC                           739  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
000016FC  3207                     740  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
000016FE  4EB8 16A8                741                  JSR     GET_EA                  ; Gets EA
00001702  3401                     742                  MOVE.W  D1,D2                   ; Stores EA in D2
00001704  3207                     743                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001706  4EB8 16D2                744                  JSR     GET_XN                  ; Gets Xn
0000170A  3601                     745                  MOVE.W  D1,D3                   ; Stores Xn in D3
0000170C  3202                     746                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
0000170E                           747                  
0000170E  4EB9 00001794            748                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001714  B27C 0002                749                  CMP.W   #2,D1                   ; checks if it is Xn
00001718  6700 0012                750                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
0000171C  B27C 0001                751                  CMP.W   #1,D1                   ; Checks if it is invalid
00001720  6700 001C                752                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001724                           753                  
00001724                           754                  
00001724  323C 0000                755  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001728  6000 0018                756                  BRA     END_CHECKGET
0000172C                           757        
0000172C                           758  ; need XN
0000172C  2A4E                     759  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
0000172E  3203                     760                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001730  4EB9 00001794            761                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001736  4A41                     762                  TST.W   D1                      ; checks if it is valid
00001738  67EA                     763                  BEQ     EAXN_VALID              ; go to EA_VALID to print
0000173A  6000 0002                764                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
0000173E                           765   
0000173E  323C 0001                766  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001742                           767  
00001742  4E75                     768  END_CHECKGET    RTS          
00001744                           769                                            
00001744                           770                                            
00001744                           771  * Gets the displacement and pritns it 
00001744                           772  * Inputs: D2 = instruction word, A2 = address of next word
00001744                           773  * Outputs: prints out displacement
00001744  48E7 4004                774  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001748  3A4A                     775                      MOVE.W    A2,A5                 ; copies A2 to A5
0000174A  C47C 00FF                776                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
0000174E  6600 0004                777                      BNE       PRINTADDRESS          ; prints address if not 0
00001752  341A                     778                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001754                           779                      
00001754  D44D                     780  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001756  3202                     781                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001758  183C 0000                782                      MOVE.B    #0,D4                 ; marks address as word  length
0000175C  4BF9 00001D8C            783                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001762  4EB9 00001A8E            784                      JSR       PRINTNULL             ; prints null
00001768  4EB9 00001968            785                      JSR       PRINTSHORTLONGNUM     ; prints address
0000176E                           786                      
0000176E  4CDF 2002                787                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001772                           788                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001772                           789  
00001772                           790  * Gets the rotation value for ASd and LSd
00001772                           791  * Input: D2 = instruction word copy (of D0)                                    
00001772                           792  * Output: rotation  value in D2             
00001772  C47C 0E00                793  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001776  E04A                     794                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001778  E24A                     795                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
0000177A  4E75                     796                      RTS                             ; return from subroutine
0000177C                           797  
0000177C                           798  * Gets the direction value for ASd and LSd
0000177C                           799  * Input: D2 = instruction word copy (of D0)                                    
0000177C                           800  * Output: direction value in D2             
0000177C  C47C 0100                801  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001780  E04A                     802                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001782  4E75                     803                      RTS                             ; return from subroutine
00001784                           804  
00001784                           805  * Gets the rotation size value for ASd and LSd
00001784                           806  * Input: D2 = instruction word copy (of D0)                                    
00001784                           807  * Output: rotation size value in D2             
00001784  C47C 00C0                808  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001788  EC4A                     809                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
0000178A  4E75                     810                      RTS                             ; return from subroutine
0000178C                           811  
0000178C                           812  * Gets the rotation location  value for ASd and LSd
0000178C                           813  * Input: D2 = instruction word copy (of D0)                                    
0000178C                           814  * Output: rotation location value in D2             
0000178C  C47C 0020                815  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001790  EA4A                     816                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001792  4E75                     817                      RTS                             ; return from subroutine
00001794                           818  
00001794                           819                          
00001794                           820  * Checks if EA or Xn is valid
00001794                           821  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001794                           822  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001794  2F02                     823  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001796                           824  
00001796  141D                     825  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001798  B43C 00FF                826                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
0000179C  6700 000A                827                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
000017A0  B202                     828                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
000017A2  6700 000C                829                     BEQ        VALIDEA               ; branches to valid EA
000017A6  60EE                     830                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
000017A8                           831                     
000017A8  323C 0001                832  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
000017AC  6000 0016                833                     BRA        CHECKEAEXIT           ; exists the subroutine        
000017B0                           834                    
000017B0  B43C 0007                835  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
000017B4  6700 000A                836                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
000017B8  323C 0000                837                     MOVE.W     #$0,D1                ; marks that it is valid
000017BC  6000 0006                838                     BRA        CHECKEAEXIT           ; exits the subroutine
000017C0                           839  
000017C0  323C 0002                840  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
000017C4                           841  
000017C4  241F                     842  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
000017C6  4E75                     843                     RTS                              ; returns from subroutine
000017C8                           844  
000017C8                           845  * Converts EA and Xn into a string                                
000017C8                           846  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
000017C8                           847  * Outputs: Prints out EA and Xn into a string
000017C8  48E7 C004                848  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
000017CC  B47C 0001                849                     CMP.W    #An,D2                  ; checks if it is An
000017D0  6700 003A                850                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
000017D4                           851                     
000017D4  B47C 0002                852                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
000017D8  6700 004A                853                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
000017DC                           854                     
000017DC  B47C 0003                855                     CMP.W    #AnPost,D2              ; checks if it is (An)+
000017E0  6700 0072                856                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
000017E4                           857                     
000017E4  B47C 0004                858                     CMP.W    #AnPre,D2               ; checks if it is -(An)
000017E8  6700 00A6                859                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
000017EC                           860                     
000017EC  B47C 0007                861                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
000017F0  6700 00DA                862                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
000017F4                           863                     ; otherwise assumes D2 = #Dn which means its a data register                   
000017F4                           864  
000017F4                           865  * data register, Dn
000017F4  4BF9 00001D7E            866  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
000017FA  4EB9 00001A8E            867                     JSR      PRINTNULL               ; Prints D
00001800  3203                     868                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001802  4EB9 00001944            869                     JSR      PRINTNUM                ; Prints the Xn
00001808  6000 0134                870                     BRA      EA_TO_STRING_EXIT       ; exits           
0000180C                           871  
0000180C                           872  
0000180C                           873  * address register
0000180C  4BF9 00001D80            874  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001812  4EB9 00001A8E            875                     JSR      PRINTNULL               ; Prints A
00001818  3203                     876                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000181A  4EB9 00001944            877                     JSR      PRINTNUM                ; Prints the Xn
00001820  6000 011C                878                     BRA      EA_TO_STRING_EXIT       ; exits
00001824                           879  
00001824                           880  * address register indirect
00001824  4BF9 00001D82            881  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
0000182A  4EB9 00001A8E            882                     JSR      PRINTNULL               ; Prints (
00001830  4BF9 00001D80            883                     LEA      MSG_AR,A5               ; Loads A into A5
00001836  4EB9 00001A8E            884                     JSR      PRINTNULL               ; Prints A
0000183C  3203                     885                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000183E  4EB9 00001944            886                     JSR      PRINTNUM                ; Prints the Xn
00001844  4BF9 00001D84            887                     LEA      MSG_RB,A5               ; Loads ) into A5
0000184A  4EB9 00001A8E            888                     JSR      PRINTNULL               ; Prints )
00001850  6000 00EC                889                     BRA      EA_TO_STRING_EXIT       ; exits
00001854                           890  
00001854                           891  * address register indirect post increment
00001854  4BF9 00001D82            892  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
0000185A  4EB9 00001A8E            893                     JSR      PRINTNULL               ; Prints (
00001860  4BF9 00001D80            894                     LEA      MSG_AR,A5               ; Loads A into A5
00001866  4EB9 00001A8E            895                     JSR      PRINTNULL               ; Prints A
0000186C  3203                     896                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000186E  4EB9 00001944            897                     JSR      PRINTNUM                ; Prints the Xn
00001874  4BF9 00001D84            898                     LEA      MSG_RB,A5               ; Loads ) into A5
0000187A  4EB9 00001A8E            899                     JSR      PRINTNULL               ; Prints )
00001880  4BF9 00001D86            900                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001886  4EB9 00001A8E            901                     JSR      PRINTNULL               ; Prints +
0000188C  6000 00B0                902                     BRA      EA_TO_STRING_EXIT       ; exits
00001890                           903  
00001890                           904  
00001890                           905  * address register indirect pre increment
00001890  4BF9 00001D88            906  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001896  4EB9 00001A8E            907                     JSR      PRINTNULL               ; Prints -
0000189C  4BF9 00001D82            908                     LEA      MSG_LB,A5               ; Loads ( into A5
000018A2  4EB9 00001A8E            909                     JSR      PRINTNULL               ; Prints (
000018A8  4BF9 00001D80            910                     LEA      MSG_AR,A5               ; Loads A into A5
000018AE  4EB9 00001A8E            911                     JSR      PRINTNULL               ; Prints A
000018B4  3203                     912                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000018B6  4EB9 00001944            913                     JSR      PRINTNUM                ; Prints the Xn
000018BC  4BF9 00001D84            914                     LEA      MSG_RB,A5               ; Loads ) into A5
000018C2  4EB9 00001A8E            915                     JSR      PRINTNULL               ; Prints )
000018C8  6000 0074                916                     BRA      EA_TO_STRING_EXIT       ; exits
000018CC                           917  
000018CC                           918  * other (long, short, immediate) with Xn yes
000018CC  301A                     919  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000018CE  B67C 0000                920                     CMP.W    #ABSShort,D3            ; checks if it is a word
000018D2  6700 002E                921                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000018D6                           922                     
000018D6  B67C 0001                923                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000018DA  6700 0042                924                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000018DE                           925  
000018DE                           926  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
000018DE                           927  * immediate
000018DE  4BF9 00001D8A            928  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000018E4  4EB9 00001A8E            929                     JSR      PRINTNULL               ; Prints #  
000018EA  4BF9 00001D8C            930                     LEA      MSG_HEX,A5              ; Loads $ into A5
000018F0  4EB9 00001A8E            931                     JSR      PRINTNULL               ; Prints $
000018F6  3200                     932                     MOVE.W   D0, D1                  ; moves instruction word into d1
000018F8  4EB9 00001954            933                     JSR      PRINTHEXNUM 
000018FE  6000 003E                934                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001902                           935                     
00001902                           936  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001902                           937  
00001902                           938  * word address
00001902                           939  CASE_WORD          
00001902  4BF9 00001D8C            940                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001908  4EB9 00001A8E            941                     JSR      PRINTNULL               ; Prints $
0000190E  3200                     942                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001910  383C 0000                943                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001914  4EB9 00001968            944                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000191A  6000 0022                945                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000191E                           946  
0000191E                           947  * long address 
0000191E                           948  CASE_LONG          
0000191E  4BF9 00001D8C            949                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001924  4EB9 00001A8E            950                     JSR      PRINTNULL               ; Prints $
0000192A  3200                     951                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000192C  383C 0001                952                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001930  4EB9 00001968            953                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001936  321A                     954                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001938  4EB9 00001944            955                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
0000193E                           956  
0000193E                           957  
0000193E                           958  * exits subroutine
0000193E  4CDF 2003                959  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001942  4E75                     960                      RTS                              ; returns from subroutine
00001944                           961  
00001944                           962  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001944                           963  
00001944                           964  * Prints out the content of D1 as a decimal number
00001944                           965  * Input: number in D1 to be printed
00001944                           966  * Output: contents of D1 printed
00001944  48E7 C000                967  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001948  103C 0003                968                   MOVE.B      #3,D0               ; prints D1
0000194C  4E4F                     969                   TRAP        #15                 ; is trap task 3
0000194E                           970              
0000194E  4CDF 0003                971                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001952  4E75                     972                   RTS                             ; returns from subroutine
00001954                           973                   
00001954                           974  * Prints out the content of D1 as a hex number
00001954                           975  * Input: number in D1 to be printed
00001954                           976  * Output: contents of D1 printed
00001954  48E7 C000                977  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001958  143C 0010                978                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
0000195C  103C 000F                979                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001960  4E4F                     980                   TRAP        #15                 ; is trap task 15
00001962  4CDF 0003                981                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001966  4E75                     982                   RTS                             ; returns from subroutine
00001968                           983                   
00001968                           984  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001968                           985  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001968                           986  * Output: contents of D1 printed
00001968  48E7 E000                987  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
0000196C  B83C 0001                988                            CMP.B       #1,D4               ; checks size of number
00001970  6700 0042                989                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001974                           990  
00001974  3401                     991  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001976  C47C F000                992                            AND.W       #$F000,D2           ; gets the first digit
0000197A  B47C 0000                993                            CMP.W       #0, D2              ; checks if it is 0
0000197E  6600 00DC                994                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001982  4EB9 00001A6C            995                            JSR         PRINTZERO           ; prints a zero
00001988                           996                            
00001988  3401                     997                            MOVE.W      D1,D2               ; copies number to D2
0000198A  C47C 0F00                998                            AND.W       #$0F00,D2           ; gets the second digit
0000198E  B47C 0000                999                            CMP.W       #0, D2              ; checks if it is 0
00001992  6600 00C8               1000                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001996  4EB9 00001A6C           1001                            JSR         PRINTZERO           ; prints a zero
0000199C                          1002                            
0000199C  3401                    1003                            MOVE.W      D1,D2               ; copies number to D2
0000199E  C47C 00F0               1004                            AND.W       #$00F0,D2           ; gets the third digit
000019A2  B47C 0000               1005                            CMP.W       #0, D2              ; checks if it is 0
000019A6  6600 00B4               1006                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019AA  4EB9 00001A6C           1007                            JSR         PRINTZERO           ; prints a zero
000019B0  6000 00AA               1008                            BRA         PRINTASHEX          ; prints last digit
000019B4                          1009                            
000019B4  2401                    1010  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
000019B6  C4BC F0000000           1011                            AND.L       #$F0000000,D2       ; gets the first digit
000019BC  B4BC 00000000           1012                            CMP.L       #0, D2              ; checks if it is 0
000019C2  6600 0098               1013                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019C6  4EB9 00001A6C           1014                            JSR         PRINTZERO           ; prints a zero
000019CC                          1015                            
000019CC  2401                    1016                            MOVE.L      D1,D2               ; copies number to D2
000019CE  C4BC 0F000000           1017                            AND.L       #$0F000000,D2       ; gets the second digit
000019D4  B4BC 00000000           1018                            CMP.L       #0, D2              ; checks if it is 0
000019DA  6600 0080               1019                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019DE  4EB9 00001A6C           1020                            JSR         PRINTZERO           ; prints a zero
000019E4                          1021                            
000019E4  2401                    1022                            MOVE.L      D1,D2               ; copies number to D2
000019E6  C4BC 00F00000           1023                            AND.L       #$00F00000,D2       ; gets the third digit
000019EC  B4BC 00000000           1024                            CMP.L       #0, D2              ; checks if it is 0
000019F2  6600 0068               1025                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019F6  4EB9 00001A6C           1026                            JSR         PRINTZERO           ; prints a zero
000019FC                          1027                            
000019FC  2401                    1028                            MOVE.L      D1,D2               ; copies number to D2
000019FE  C4BC 000F0000           1029                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001A04  B4BC 00000000           1030                            CMP.L       #0, D2              ; checks if it is 0
00001A0A  6600 0050               1031                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A0E  4EB9 00001A6C           1032                            JSR         PRINTZERO           ; prints a zero
00001A14                          1033                            
00001A14  2401                    1034                            MOVE.L      D1,D2               ; copies number to D2
00001A16  C4BC 0000F000           1035                            AND.L       #$0000F000,D2       ; gets the fith digit
00001A1C  B4BC 00000000           1036                            CMP.L       #0, D2              ; checks if it is 0
00001A22  6600 0038               1037                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A26  4EB9 00001A6C           1038                            JSR         PRINTZERO           ; prints a zero
00001A2C                          1039                            
00001A2C  2401                    1040                            MOVE.L      D1,D2               ; copies number to D2
00001A2E  C4BC 00000F00           1041                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001A34  B4BC 00000000           1042                            CMP.L       #0, D2              ; checks if it is 0
00001A3A  6600 0020               1043                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A3E  4EB9 00001A6C           1044                            JSR         PRINTZERO           ; prints a zero
00001A44                          1045                            
00001A44  2401                    1046                            MOVE.L      D1,D2               ; copies number to D2
00001A46  C4BC 000000F0           1047                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001A4C  B4BC 00000000           1048                            CMP.L       #0, D2              ; checks if it is 0
00001A52  6600 0008               1049                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A56  4EB9 00001A6C           1050                            JSR         PRINTZERO           ; prints a zero
00001A5C                          1051  
00001A5C  143C 0010               1052  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001A60  103C 000F               1053                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001A64  4E4F                    1054                            TRAP        #15                 ; is trap task 15
00001A66  4CDF 0007               1055                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001A6A  4E75                    1056                            RTS                             ; returns from subroutine    
00001A6C                          1057  * Prints a zero
00001A6C                          1058  * Input: nothing
00001A6C                          1059  * Output: 0 printed out to the console
00001A6C  2F01                    1060  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001A6E  7200                    1061                            MOVE.L      #0,D1               ; moves 0 to D1
00001A70  4EB8 1944               1062                            JSR         PRINTNUM            ; prints the number
00001A74  221F                    1063                            MOVE.L      (SP)+,D1            ; restores D1
00001A76  4E75                    1064                            RTS                             ; returns from subroutine
00001A78                          1065              
00001A78                          1066  * Prints contents of things between a range
00001A78                          1067  * input: A5, A6 (the range)
00001A78                          1068  * output: prints memory contents from A5 to A6 as strings   
00001A78  48E7 C040               1069  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001A7C  224D                    1070                  MOVEA.L     A5, A1           ; loads A5 into A1
00001A7E  9DCD                    1071                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001A80  320E                    1072                  MOVE.W      A6, D1           ; move n into D1
00001A82  103C 0001               1073                  MOVE.B      #1, D0           ; display n characters of string at A1
00001A86  4E4F                    1074                  TRAP        #15              ; is trap task 1
00001A88  4CDF 0203               1075                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001A8C  4E75                    1076                  RTS                          ; returns
00001A8E                          1077      
00001A8E                          1078  * Prints null terminated string
00001A8E                          1079  * input: string pointed to by A5
00001A8E                          1080  * output: prints out the null terminated string
00001A8E  48E7 8040               1081  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001A92  224D                    1082                  MOVE.L      A5,A1           ; loads A5 into A1
00001A94  103C 000E               1083                  MOVE.B      #14,D0          ; prints null terminated string
00001A98  4E4F                    1084                  TRAP        #15             ; is trap task 10
00001A9A  4CDF 0201               1085                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001A9E  4E75                    1086                  RTS                         ; returns from subroutine
00001AA0                          1087                  
00001AA0  2F0D                    1088  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001AA2  4BF9 00001C8A           1089                  LEA         NEW_LINE,A5     ; Prints null
00001AA8  4EB8 1A8E               1090                  JSR         PRINTNULL       ; prints the new line
00001AAC  2A5F                    1091                  MOVE.L      (SP)+,A5        ; returns A5
00001AAE  4E75                    1092                  RTS
00001AB0                          1093  
00001AB0                          1094  * Prints the size of the MOVE or MOVEA operation  
00001AB0                          1095  * input: D0
00001AB0                          1096  * output: prints out the size of a MOVE or MOVEA operation        
00001AB0  48E7 8004               1097  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001AB4  3200                    1098                  MOVE.W  D0,D1               ; stores d0 in d1
00001AB6  C07C 3000               1099                  AND.W   #$3000,D0           ; gets the size
00001ABA  B07C 2000               1100                  CMP.W   #$2000,D0           ; checks if is long
00001ABE  6700 001E               1101                  BEQ     MOVE_LONG
00001AC2  B07C 3000               1102                  CMP.W   #$3000,D0           ; checks if is word
00001AC6  6700 000C               1103                  BEQ     MOVE_WORD      
00001ACA                          1104                  
00001ACA  4BF9 00001D95           1105  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001AD0  6000 0012               1106                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001AD4                          1107  
00001AD4  4BF9 00001D9B           1108  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001ADA  6000 0008               1109                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001ADE                          1110  
00001ADE  4BF9 00001DA1           1111  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001AE4                          1112                  
00001AE4  4EB8 1A8E               1113  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001AE8  4CDF 2001               1114                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001AEC  4E75                    1115                  RTS
00001AEE                          1116  
00001AEE  43F9 00001C6E           1117  ERROR           LEA     ERROR_MSG,A1
00001AF4  103C 000E               1118                  MOVE.B  #14,D0
00001AF8  4E4F                    1119                  TRAP    #15 
00001AFA                          1120         
00001AFA                          1121  * DELETE THIS: Test                
00001AFA  2661                    1122  DELETEME        MOVEA.L  -(A1),A3
00001AFC  6700 002A               1123                  BEQ      DELETEMEAGAIN  
00001B00  6F00 0026               1124                  BLE      DELETEMEAGAIN
00001B04  6E00 0022               1125                  BGT      DELETEMEAGAIN
00001B08                          1126  
00001B08  E40A                    1127                  LSR.B      #2,D2
00001B0A  E2E2                    1128                  LSR.W      -(A2)
00001B0C  E2DA                    1129                  LSR.W      (A2)+
00001B0E  E4AA                    1130                  LSR.L      D2,D2 
00001B10  E50A                    1131                  LSL.B      #2,D2
00001B12  E3E2                    1132                  LSL.W      -(A2)
00001B14  E3DA                    1133                  LSL.W      (A2)+
00001B16  E5AA                    1134                  LSL.L      D2,D2
00001B18  E51A                    1135                  ROL.B      #2,D2
00001B1A  E7E2                    1136                  ROL.W      -(A2)
00001B1C  E7DA                    1137                  ROL.W      (A2)+
00001B1E  E5BA                    1138                  ROL.L      D2,D2
00001B20  E41A                    1139                  ROR.B      #2,D2
00001B22  E6E2                    1140                  ROR.W      -(A2)
00001B24  E6DA                    1141                  ROR.W      (A2)+
00001B26  E4BA                    1142                  ROR.L      D2,D2
00001B28                          1143                         
00001B28                          1144                  
00001B28                          1145  DELETEMEAGAIN                 
00001B28                          1146            
00001B28  FFFF FFFF               1147      SIMHALT             ; halt simulator
00001B2C                          1148  
00001B2C                          1149  * Put variables and constants here
00001B2C                          1150  
00001B2C  =0000000D               1151  CR                              EQU     $0D
00001B2C  =0000000A               1152  LF                              EQU     $0A 
00001B2C  =00000009               1153  TAB                             EQU     $09  
00001B2C                          1154  
00001B2C                          1155  * Addressing Modes
00001B2C  =00000000               1156  Dn                              EQU     0
00001B2C  =00000001               1157  An                              EQU     1
00001B2C  =00000002               1158  AnIndirect                      EQU     2
00001B2C  =00000003               1159  AnPost                          EQU     3
00001B2C  =00000004               1160  AnPre                           EQU     4
00001B2C  =00000007               1161  Other                           EQU     7           ; short, long, immediate
00001B2C                          1162  
00001B2C                          1163  * Xn
00001B2C  =00000000               1164  ABSShort                        EQU     0
00001B2C  =00000001               1165  ABSLong                         EQU     1
00001B2C  =00000004               1166  XnImmediate                     EQU     4
00001B2C                          1167  
00001B2C                          1168  * Valid Addressing Modes
00001B2C= 00 01 02 03 04 07 FF    1169  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001B33                          1170  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001B33= 00 02 03 04 07 FF       1171  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001B39= 02 04 07 FF             1172  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001B3D= 02 03 07 FF             1173  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001B41= 02 03 04 07 FF          1174  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001B46= 00 02 03 04 07 FF       1175  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001B4C= 01 07 FF                1176  VALIDEA_LEA                     DC.B    An,Other,-1
00001B4F= 00 02 03 04 07 FF       1177  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001B55= 02 03 04 07 FF          1178  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001B5A= 02 03 04 07 FF          1179  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001B5F= 02 07 FF                1180  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001B62                          1181  
00001B62                          1182  * Valid Xn
00001B62= 00 01 04 FF             1183  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001B66                          1184  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001B66= 00 01 FF                1185  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001B69                          1186  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001B69                          1187  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001B69                          1188  
00001B69                          1189  * posible memory ASd/LSd rotation values
00001B69  =00000000               1190  ASd_MEM                         EQU     0   
00001B69  =00000001               1191  LSd_MEM                         EQU     1 
00001B69  =00000003               1192  ROd_MEM                         EQU     3
00001B69                          1193   
00001B69  =00000000               1194  ASd_REG                         EQU     0   
00001B69  =00000001               1195  LSd_REG                         EQU     1 
00001B69  =00000003               1196  ROd_REG                         EQU     3
00001B69                          1197  
00001B69                          1198  * Starting messages
00001B69= 57 65 6C 63 6F 6D ...   1199  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001B90= 46 6F 72 6D 61 74 ...   1200                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001BDF= 50 6C 65 61 73 65 ...   1201  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001C16= 50 6C 65 61 73 65 ...   1202  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001C4C= 49 6E 76 61 6C 69 ...   1203  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001C6E= 45 72 72 6F 72 20 ...   1204  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001C8A= 0D 0A 00                1205  NEW_LINE                        DC.B    CR,LF,0
00001C8D= 09 09 09 00             1206  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001C91                          1207  
00001C91                          1208  * Opcode Messages
00001C91= 09 4E 4F 50 00          1209  MSG_NOP                         DC.B    TAB,'NOP',0
00001C96= 09 4D 4F 56 45 00       1210  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001C9C= 09 4D 4F 56 45 41 00    1211  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001CA3= 09 4D 4F 56 45 51 00    1212  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001CAA= 09 4D 4F 56 45 4D 00    1213  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001CB1= 09 41 44 44 00          1214  MSG_ADD                         DC.B    TAB,'ADD',0
00001CB6= 09 41 44 44 41 00       1215  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001CBC= 09 41 44 44 51 00       1216  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001CC2= 09 53 55 42 00          1217  MSG_SUB                         DC.B    TAB,'SUB',0
00001CC7= 09 4D 55 4C 53 00       1218  MSG_MULS                        DC.B    TAB,'MULS',0
00001CCD= 09 44 49 56 55 00       1219  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001CD3= 09 4C 45 41 09 09 ...   1220  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001CDB= 09 41 4E 44 00          1221  MSG_AND                         DC.B    TAB,'AND',0
00001CE0= 09 4F 52 00             1222  MSG_OR                          DC.B    TAB,'OR',0
00001CE4= 09 4E 4F 54 00          1223  MSG_NOT                         DC.B    TAB,'NOT',0
00001CE9= 09 4C 53 00             1224  MSG_LSd                         DC.B    TAB,'LS',0
00001CED= 09 41 53 00             1225  MSG_ASd                         DC.B    TAB,'AS',0
00001CF1= 09 52 4F 00             1226  MSG_ROd                         DC.B    TAB,'RO',0
00001CF5= 09 42 43 43 09 09 ...   1227  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001CFD= 09 42 43 53 09 09 ...   1228  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001D05= 09 42 45 51 09 09 ...   1229  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001D0D= 09 42 4E 45 09 09 ...   1230  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001D15= 09 42 47 45 09 09 ...   1231  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001D1D= 09 42 47 54 09 09 ...   1232  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001D25= 09 42 48 49 09 09 ...   1233  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001D2D= 09 42 4C 45 09 09 ...   1234  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001D35= 09 42 4C 53 09 09 ...   1235  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001D3D= 09 42 4C 54 09 09 ...   1236  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001D45= 09 42 4D 49 09 09 ...   1237  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001D4D= 09 42 50 4C 09 09 ...   1238  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001D55= 09 42 56 43 09 09 ...   1239  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001D5D= 09 42 56 53 09 09 ...   1240  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001D65= 09 4A 53 52 09 09 ...   1241  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001D6D= 09 52 54 53 00          1242  MSG_RTS                         DC.B    TAB,'RTS',0
00001D72= 09 42 52 41 09 09 ...   1243  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001D7A                          1244  
00001D7A                          1245  * Direction for LSd and ASd
00001D7A= 52 00                   1246  MSG_RIGHT                       DC.B    'R',0
00001D7C= 4C 00                   1247  MSG_LEFT                        DC.B    'L',0
00001D7E                          1248  
00001D7E                          1249  * Effective Addresses Messages
00001D7E= 44 00                   1250  MSG_DR                          DC.B    'D',0
00001D80= 41 00                   1251  MSG_AR                          DC.B    'A',0
00001D82= 28 00                   1252  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001D84= 29 00                   1253  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001D86= 2B 00                   1254  MSG_PLUS                        DC.B    '+',0
00001D88= 2D 00                   1255  MSG_MINUS                       DC.B    '-',0
00001D8A= 23 00                   1256  MSG_POUND                       DC.B    '#',0 
00001D8C= 24 00                   1257  MSG_HEX                         DC.B    '$',0 
00001D8E= 2C 20 00                1258  MSG_COMMA                       DC.B    ', ',0 
00001D91= 20 00                   1259  MSG_SPACE                       DC.B    ' ',0
00001D93= 09 00                   1260  MSG_TAB                         DC.B    TAB,0
00001D95                          1261  
00001D95                          1262  * Size Messages
00001D95= 2E 42 09 09 09 00       1263  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001D9B= 2E 57 09 09 09 00       1264  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001DA1= 2E 4C 09 09 09 00       1265  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001DA7                          1266  
00001DA7                          1267  * Variables
00001DA7  =00000100               1268  STARTING_ADDRESS                EQU     $100
00001DA7  =00000150               1269  ENDING_ADDRESS                  EQU     $150
00001DA7  =00000200               1270  CURRENT_INSTR                   EQU     $200
00001DA7  =00000250               1271  REG_VAR                         EQU     $250 * Hold bits 11-9
00001DA7  =00000300               1272  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001DA7  =00000350               1273  EA_MODE                         EQU     $350 * Hold bits 5-3
00001DA7  =00000400               1274  EA_REG                          EQU     $400 * Hold bits 2-0
00001DA7                          1275  
00001DA7                          1276              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1C4C
CASE_ADD            12E2
CASE_ADDA           135C
CASE_ADDQ           135C
CASE_AND            13EE
CASE_AR             180C
CASE_ARI            1824
CASE_ARIPOST        1854
CASE_ARIPRE         1890
CASE_ASDMEM         142E
CASE_ASDREG         14F6
CASE_BCC            162E
CASE_BEQ            1660
CASE_BGT            1674
CASE_BLE            166A
CASE_BRA            160A
CASE_DATA           16A4
CASE_DR             17F4
CASE_EPICFAIL       16A6
CASE_IMMEDIATE      18DE
CASE_JSR            168E
CASE_LEA            135C
CASE_LEFTMEM        1454
CASE_LEFTREG        151C
CASE_LONG           191E
CASE_LSDASD         13EE
CASE_LSDMEM         1424
CASE_LSDREG         14EC
CASE_MOVE           1188
CASE_MOVEM          122A
CASE_MOVEQ          1290
CASE_NOP            1172
CASE_NOT            13EE
CASE_OR             13EE
CASE_OTHER          18CC
CASE_RIGHTMEM       145E
CASE_RIGHTREG       1526
CASE_RODMEM         1438
CASE_RODREG         1500
CASE_RTS            168E
CASE_SHIFTMEM       140C
CASE_SHIFTREG       14D2
CASE_SUB            135C
CASE_WORD           1902
CHECKEAEXIT         17C4
CHECKEAMLOOP        1796
CHECKEAXN_IFVALID   1794
CHECKGET_EAXN       16FC
CHECKMEMSOURE       1492
CHECKSHIFT_XN       14BC
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            172C
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1AFA
DELETEMEAGAIN       1B28
DESTEA              16B2
DESTXN              16DC
DISASSEMBLE         10A4
DN                  0
EASHIFT_VALID       14B0
EAXN_INVALID        173E
EAXN_VALID          1724
EA_MODE             350
EA_REG              400
EA_TO_STRING        17C8
EA_TO_STRING_EXIT   193E
ENDING              1C16
ENDING_ADDRESS      150
END_CHECKGET        1742
ERROR               1AEE
ERROR_MSG           1C6E
FINDTYPEEA          16C6
FINDTYPEXN          16F0
FINISHMOVE          1AE4
GETDIRECTION        177C
GETDISPLACEMENT     1744
GETMEMSOURCE        147A
GETROTATION         1772
GETROTATIONLOCATION  178C
GETROTATIONSIZE     1784
GET_EA              16A8
GET_XN              16D2
INPUT1              100C
INPUT2              1052
INSERTA             11F6
INVALID             112C
INVALIDEA           17A8
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       1290
MOVEM_REG2MEM       1260
MOVE_BYTE           1ACA
MOVE_LONG           1ADE
MOVE_WORD           1AD4
MSG_ADD             1CB1
MSG_ADDA            1CB6
MSG_ADDQ            1CBC
MSG_AND             1CDB
MSG_AR              1D80
MSG_ASD             1CED
MSG_B               1D95
MSG_BCC             1CF5
MSG_BCS             1CFD
MSG_BEQ             1D05
MSG_BGE             1D15
MSG_BGT             1D1D
MSG_BHI             1D25
MSG_BLE             1D2D
MSG_BLS             1D35
MSG_BLT             1D3D
MSG_BMI             1D45
MSG_BNE             1D0D
MSG_BPL             1D4D
MSG_BRA             1D72
MSG_BVC             1D55
MSG_BVS             1D5D
MSG_COMMA           1D8E
MSG_DIVU            1CCD
MSG_DR              1D7E
MSG_HEX             1D8C
MSG_JSR             1D65
MSG_L               1DA1
MSG_LB              1D82
MSG_LEA             1CD3
MSG_LEFT            1D7C
MSG_LSD             1CE9
MSG_MINUS           1D88
MSG_MOVE            1C96
MSG_MOVEA           1C9C
MSG_MOVEM           1CAA
MSG_MOVEQ           1CA3
MSG_MULS            1CC7
MSG_NOP             1C91
MSG_NOT             1CE4
MSG_OR              1CE0
MSG_PLUS            1D86
MSG_POUND           1D8A
MSG_RB              1D84
MSG_RIGHT           1D7A
MSG_ROD             1CF1
MSG_RTS             1D6D
MSG_SPACE           1D91
MSG_SUB             1CC2
MSG_TAB             1D93
MSG_W               1D9B
NEW_LINE            1C8A
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OTHER               7
OTHEREA             17C0
PRINTADDRESS        1754
PRINTASHEX          1A5C
PRINTBCC            167E
PRINTENTER          1AA0
PRINTHEXNUM         1954
PRINTLONGZERO       19B4
PRINTMOVE           11FC
PRINTMOVESIZE       1AB0
PRINTNULL           1A8E
PRINTNUM            1944
PRINTRANGE          1A78
PRINTREGEA          1568
PRINTREGSIZE        1536
PRINTSHIFTMEM       143E
PRINTSHIFTREG       1506
PRINTSHORTLONGNUM   1968
PRINTSHORTZERO      1974
PRINTZERO           1A6C
PRINT_MEMDIR        1464
PRINT_MOVEQ         12B2
PRINT_REGDIR        1530
REG2MEMXNCHECK      127A
REG_BYTE            154E
REG_IMMEDIATE       157E
REG_LONG            1562
REG_REGISTER        15C4
REG_VAR             250
REG_WORD            1558
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            16BE
SOURCEXN            16E8
START               1000
STARTING            1BDF
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           1C8D
VALIDEA             17B0
VALIDEA_ADDSUB_DESTOPERAND  1B41
VALIDEA_ALL         1B2C
VALIDEA_ANDORNOT    1B4F
VALIDEA_ANDOR_DESTOPERAND  1B55
VALIDEA_JSR         1B5F
VALIDEA_LEA         1B4C
VALIDEA_MOVEM_MEMTOREG  1B3D
VALIDEA_MOVEM_REGTOMEM  1B39
VALIDEA_MOVEQ       1B33
VALIDEA_MULSDIVU    1B46
VALIDEA_SHIFT       1B5A
VALIDXN_ALL         1B62
VALIDXN_SHORTLONG   1B66
WELCOME             1B69
XNIMMEDIATE         4
