00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 1:19:19 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 000022A3             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 000022CB             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 00002316             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 00002336             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011CE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011E0             36                  JSR     CONVERT
00001052  4EB9 0000124C             37                  JSR     TEST_RANGE
00001058  4EB9 00001264             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 0000236D             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011CE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011E0             55                  JSR     CONVERT
0000109A  4EB9 0000124C             56                  JSR     TEST_RANGE
000010A0  4EB9 00001264             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0110                 64                  BLT     RESET_INPUT
000010B8  4BF9 00002456             65                  LEA     NEW_LINE,A5
000010BE  4EB9 000021F6             66                  JSR     PRINTNULL
000010C4                            67                                 
000010C4                            68  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010C4                            69                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010C4                            70                  ; JSR     PRINTSHORTLONGNUM   ; prints out address
000010C4                            71                  
000010C4  1439 00002557             72                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010CC  13C2 00002557             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010D2                            75                  
000010D2  4EB9 00001278             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010D8                            77                  
000010D8  4EB9 00001176             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010DE                            79                  
000010DE  4EB9 00002208             80                  JSR     PRINTENTER          ; prints a new line
000010E4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010E6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010E8                            83                  
000010E8                            84  
000010E8  4BF9 000023E7             85  FINISHED        LEA     DONE,A5
000010EE  4EB9 000021F6             86                  JSR     PRINTNULL
000010F4  103C 0005                 87                  MOVE.B  #5,D0
000010F8  4E4F                      88                  TRAP    #15
000010FA                            89                  
000010FA  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
000010FE  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001102                            92                  
00001102  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001106  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000110A                            95  
0000110A  103C 0009                 96                  MOVE.B  #9,D0
0000110E  4E4F                      97                  TRAP    #15
00001110                            98                  
00001110  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001114  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001118  4E4F                     101                  TRAP    #15                 Call Trap
0000111A                           102                  
0000111A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000111E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001122  4E4F                     105                  TRAP    #15
00001124                           106                  
00001124  1439 00002557            107                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
0000112A  143C 0000                108                  MOVE.B  #0,D2               ; set variable to 0
0000112E  13C2 00002557            109                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
00001134                           110   
00001134  207C 00000000            111                  MOVE.L  #$0000000, A0       ; Reset A1
0000113A  227C 00000000            112                  MOVE.L  #$0000000, A1       ; Reset A1
00001140  247C 00000000            113                  MOVE.L  #$0000000, A2       ; Reset A2
00001146  267C 00000000            114                  MOVE.L  #$0000000, A3       ; Reset A3
0000114C  287C 00000000            115                  MOVE.L  #$0000000, A4       ; Reset A4
00001152  2A7C 00000000            116                  MOVE.L  #$0000000, A5       ; Reset A5
00001158  2C7C 00000000            117                  MOVE.L  #$0000000, A6       ; Reset A6
0000115E  2E7C 01000000            118                  MOVEA.L #$01000000,A7       ; Reset A7
00001164  4281                     119                  CLR.L   D1                  ; Reset D1
00001166  4281                     120                  CLR.L   D1                  ; Reset D1
00001168  4282                     121                  CLR.L   D2                  ; Reset D2
0000116A  4283                     122                  CLR.L   D3                  ; Reset D3
0000116C  4284                     123                  CLR.L   D4                  ; Reset D4
0000116E  4285                     124                  CLR.L   D5                  ; Reset D5
00001170  4286                     125                  CLR.L   D6                  ; Reset D6
00001172  6000 FE8C                126                  BRA     START               ; branch to start of program
00001176                           127  
00001176                           128  *--------------------SUBROUTINES------------------
00001176  1439 00002557            129  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000117C  1639 00002558            130                  MOVE.B  LINE_MAX,D3                
00001182  B602                     131                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001184  6F00 0004                132                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001188  4E75                     133                  RTS
0000118A                           134  
0000118A  4BF9 0000242B            135  NEXT_SCREEN     LEA     CONTINUE,A5
00001190  4EB9 000021F6            136                  JSR     PRINTNULL
00001196  6000 0002                137                  BRA     READ_KEY
0000119A                           138                  
0000119A  103C 0005                139  READ_KEY        MOVE.B  #5,D0
0000119E  4E4F                     140                  TRAP    #15
000011A0                           141                  
000011A0  B23C 000D                142                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000011A4  6700 0004                143                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
000011A8  60F0                     144                  BRA     READ_KEY
000011AA                           145                  
000011AA  103C 000B                146  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
000011AE  323C FF00                147                  MOVE.W  #$FF00, D1          Clear Screen
000011B2  4E4F                     148                  TRAP    #15                 Call Trap
000011B4                           149                  
000011B4                           150                  ; reset line counter
000011B4  1439 00002557            151                  MOVE.B  LINE_COUNT,D2
000011BA  143C 0000                152                  MOVE.B  #$0,D2
000011BE  13C2 00002557            153                  MOVE.B  D2,LINE_COUNT
000011C4  4E75                     154                  RTS       
000011C6                           155      
000011C6                           156  
000011C6  143C 0001                157  RESET_INPUT     MOVE.B  #1,D2
000011CA  6000 0062                158                  BRA     INVALID            
000011CE                           159                  
000011CE  7800                     160  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011D0  B204                     161                  CMP.B   D4,D1               ; D1 stores length
000011D2  6700 005A                162                  BEQ     INVALID             ; input is null
000011D6  0C41 0008                163                  CMPI    #$8,D1              ; check if input is longer than a longword
000011DA  6600 0052                164                  BNE     INVALID             ; input is longer than a longword
000011DE  4E75                     165                  RTS
000011E0                           166                              
000011E0  4283                     167  CONVERT         CLR.L   D3
000011E2  4284                     168                  CLR.L   D4
000011E4  1619                     169                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011E6  B63C 0039                170                  CMP.B   #57,D3
000011EA  6E00 0012                171                  BGT     NOTNUMBER
000011EE                           172                  
000011EE  B63C 002F                173                  CMP.B   #47,D3
000011F2  6E00 0002                174                  BGT     ISNUMBER
000011F6                           175                  
000011F6  0603 00D0                176  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000011FA  6000 001A                177                  BRA     CONCAT
000011FE                           178              
000011FE  B63C 0041                179  NOTNUMBER       CMP.B   #65,D3
00001202  6D00 002A                180                  BLT     INVALID
00001206  B63C 0046                181                  CMP.B   #70,D3
0000120A  6E00 0022                182                  BGT     INVALID  
0000120E  0603 00C9                183                  ADD.B   #-55,D3             ; is letter             
00001212  6000 0002                184                  BRA     CONCAT
00001216                           185              
00001216  BC3C 0000                186  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000121A  6D00 0010                187                  BLT     RETURN
0000121E  1806                     188                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001220  E50C                     189                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001222  E9AB                     190                  LSL.L   D4,D3               ; moves current char to correct position  
00001224  DA83                     191                  ADD.L   D3,D5               ; D5 stores converted input so far
00001226  0606 00FF                192                  ADD.B   #-1,D6  
0000122A  60B4                     193                  BRA     CONVERT             ; continue loop for remaining chars
0000122C                           194                  
0000122C  4E75                     195  RETURN          RTS
0000122E                           196                  
0000122E  227C 00000000            197  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001234  43F9 000023A3            198                  LEA     BAD_INPUT,A1        ; output invalid message
0000123A  103C 000E                199                  MOVE.B  #14,D0
0000123E  4E4F                     200                  TRAP    #15
00001240  B47C 0001                201                  CMP     #1,D2
00001244  6700 FDDA                202                  BEQ     INPUT1
00001248  6000 FE1C                203                  BRA     INPUT2
0000124C                           204  
0000124C  4284                     205  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000124E  223C 00001000            206                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001254  BA81                     207                  CMP.L      D1,D5            ; Compare minimum address with input
00001256  6DD6                     208                  BLT        INVALID          ; input is too low. 
00001258  223C 00FFFFFE            209                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000125E  BA81                     210                  CMP.L      D1,D5            ; compare maximum address with input
00001260  6ECC                     211                  BGT        INVALID          ; input too large
00001262  4E75                     212                  RTS                         ; input is within range
00001264                           213             
00001264  0805 0000                214  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001268  66C4                     215                  BNE        INVALID
0000126A  4E75                     216                  RTS
0000126C                           217  
0000126C                           218  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
0000126C                           219  *                MOVE.L  A6,D1                   ; loads current address in D1
0000126C                           220  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
0000126C                           221  *                JSR     PRINTSHORTLONGNUM       ; prints out address
0000126C                           222  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
0000126C                           223  *                RTS
0000126C  220E                     224                  MOVE.L  A6,D1                   ; loads current address in D1
0000126E  7801                     225                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001270  4EB9 000020D0            226                  JSR     PRINTSHORTLONGNUM       ; prints out address
00001276  4E75                     227                  RTS
00001278                           228  
00001278                           229  
00001278                           230  
00001278                           231  * Checks every single possible opcode we could have. Jump table
00001278                           232  * Inputs: (A2) which is a pointer to intruction word to be translated
00001278                           233  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001278                           234  
00001278  3C4A                     235  OPCODE_DECODE   MOVE.W  A2,A6
0000127A  301A                     236                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000127C  4EB8 126C                237                  JSR     PRINT_ADDR
00001280                           238                  
00001280                           239  
00001280                           240  *---------------NOP opcode----------------------                
00001280  B07C 4E71                241  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001284  6600 0010                242                  BNE     CASE_MOVE               ; checks the next case if not equal
00001288                           243                  
00001288  4BF9 0000245D            244                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000128E  4EB9 000021F6            245                  JSR     PRINTNULL               ; prints NOP                
00001294  4E75                     246                  RTS                             ; returns from the subroutine
00001296                           247  
00001296                           248  *---------------MOVE opcode----------------------              
00001296                           249                  * if first two bits are 00, next two are not 00
00001296  3200                     250  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001298  C27C C000                251                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000129C  6600 00BE                252                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
000012A0  B07C 0FFF                253                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000012A4  6F00 00B6                254                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
000012A8                           255                  
000012A8                           256                  ; Check source
000012A8  4BF9 00002266            257                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012AE  4DF9 0000229C            258                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012B4  3E3C 0000                259                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012B8  4EB9 00001DC2            260                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012BE  B27C 0001                261                  CMP.W   #1,D1                    ; checks if invalid
000012C2  6700 0AA2                262                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012C6  3802                     263                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012C8  3A03                     264                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012CA                           265                  
000012CA                           266                  ; Check destination
000012CA  4BF9 00002266            267                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012D0  4DF9 000022A0            268                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012D6  3E3C 0001                269                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012DA  4EB9 00001DC2            270                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012E0  B27C 0001                271                  CMP.W   #1,D1                    ; checks if invalid
000012E4  6700 0A80                272                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012E8  3C02                     273                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012EA  3E03                     274                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012EC                           275                  
000012EC                           276                  ; Checking if it is MOVEA
000012EC  3200                     277                  MOVE.W  D0,D1                    ; stores d0 in d1
000012EE  C27C 01C0                278                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000012F2  B27C 0040                279                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000012F6  6700 0024                280                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000012FA                           281                  
000012FA  4BF9 00002462            282                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001300  4EB9 000021F6            283                  JSR     PRINTNULL                ; prints out MOVE
00001306  4EB9 00002218            284                  JSR     PRINTMOVESIZE            ; prints out the size 
0000130C  4BF9 00002534            285                  LEA     MSG_4SPACES,A5           ; loads spaces
00001312  4EB9 000021F6            286                  JSR     PRINTNULL                ; prints out spaces
00001318  6000 0020                287                  BRA     PRINTMOVE                ; Branches to print move
0000131C                           288                  
0000131C  4BF9 00002468            289  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001322  4EB9 000021F6            290                  JSR     PRINTNULL                ; prints out MOVEA
00001328  4EB9 00002218            291                  JSR     PRINTMOVESIZE            ; prints out the size 
0000132E  4BF9 00002530            292                  LEA     MSG_3SPACES,A5           ; loads spaces
00001334  4EB9 000021F6            293                  JSR     PRINTNULL                ; prints out spaces
0000133A                           294   
0000133A  3404                     295  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000133C  3605                     296                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000133E  4EB9 00001F30            297                  JSR     EA_TO_STRING             ; outputs it into a string
00001344                           298                  
00001344                           299                  ; prints a comma to seperate
00001344  4BF9 00002527            300                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000134A  4EB9 000021F6            301                  JSR     PRINTNULL                ; prints out MOVE
00001350                           302                  
00001350                           303                  ; print destination
00001350  3406                     304                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001352  3607                     305                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001354  4EB9 00001F30            306                  JSR     EA_TO_STRING             ; outputs it into a string
0000135A  4E75                     307                  RTS                              ; exits subroutine                 
0000135C                           308                
0000135C                           309  *---------------MOVEM opcode----------------------                
0000135C  3200                     310  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000135E  C27C FB80                311                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001362  B27C 4880                312                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001366  6600 0106                313                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000136A                           314                  
0000136A                           315                  ; Check D
0000136A  3200                     316                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000136C  C27C 0400                317                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001370  3E01                     318                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001372  B27C 0400                319                  CMP.W   #$0400,D1                       ; checks if value is 1
00001376  6700 0076                320                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000137A                           321  
0000137A                           322  MOVEM_REG2MEM   ; loads EA and XN
0000137A  3E3C 0000                323                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000137E  4BF9 00002273            324                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001384  4DF9 000022A0            325                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000138A  4EB9 00001DC2            326                  JSR     CHECKGET_EAXN
00001390  B27C 0001                327                  CMP.W   #1,D1                           ; checks if D1 invalid
00001394  6700 09D0                328                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001398  4BF9 00002476            329                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000139E  4EB9 000021F6            330                  JSR     PRINTNULL                       ; prints MOVEM
000013A4                           331                  
000013A4                           332                  ; finds and prints size
000013A4  3200                     333                  MOVE.W  D0,D1                           ; copies D0
000013A6  C27C 0040                334                  AND.W   #$0040,D1                       ; gets the size bit
000013AA  6600 000C                335                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000013AE                           336  
000013AE  4BF9 00002551            337  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013B4  6000 0008                338                  BRA     PRINTREG2MEM                    ; prints the registers           
000013B8                           339                  
000013B8  4BF9 00002554            340  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013BE                           341             
000013BE  4EB9 000021F6            342  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013C4  4BF9 00002530            343                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013CA  4EB9 000021F6            344                  JSR     PRINTNULL                       ; prints out spaces
000013D0  383C 0001                345                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013D4  4EB9 00001E5A            346                  JSR     PRINTREGISTERS                  ; prints registers
000013DA  4BF9 00002527            347                  LEA     MSG_COMMA,A5                    ; loads comma
000013E0  4EB9 000021F6            348                  JSR     PRINTNULL                       ; prints comma
000013E6  4EB9 00001F30            349                  JSR     EA_TO_STRING                    ; prints EA
000013EC  4E75                     350                  RTS
000013EE                           351  
000013EE                           352  MOVEM_MEM2REG  ; loads EA and XN
000013EE  3E3C 0000                353                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000013F2  4BF9 00002277            354                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
000013F8  4DF9 000022A0            355                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000013FE  4EB9 00001DC2            356                  JSR     CHECKGET_EAXN
00001404  B27C 0001                357                  CMP.W   #1,D1                           ; checks if D1 invalid
00001408  6700 095C                358                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000140C  4BF9 00002476            359                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001412  4EB9 000021F6            360                  JSR     PRINTNULL                       ; prints MOVEM
00001418                           361                  
00001418                           362                  ; finds and prints size
00001418  3200                     363                  MOVE.W  D0,D1                           ; copies D0
0000141A  C27C 0040                364                  AND.W   #$0040,D1                       ; gets the size bit
0000141E  6600 0012                365                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001422                           366  
00001422  4BF9 00002551            367  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001428  4EB9 000021F6            368                  JSR     PRINTNULL                       ; prints MOVEM
0000142E  6000 000E                369                  BRA     PRINTMEM2REG                    ; prints the registers           
00001432                           370                  
00001432  4BF9 00002554            371  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001438  4EB9 000021F6            372                  JSR     PRINTNULL                       ; prints MOVEM 
0000143E                           373             
0000143E  4EB9 000021F6            374  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
00001444  4BF9 00002530            375                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000144A  4EB9 000021F6            376                  JSR     PRINTNULL                       ; prints out spaces
00001450  4EB9 00001F30            377                  JSR     EA_TO_STRING                    ; prints EA
00001456  4BF9 00002527            378                  LEA     MSG_COMMA,A5                    ; loads comma
0000145C  4EB9 000021F6            379                  JSR     PRINTNULL                       ; prints comma
00001462  383C FFFF                380                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001466  4EB9 00001E5A            381                  JSR     PRINTREGISTERS                  ; prints registers
0000146C  4E75                     382                  RTS
0000146E                           383                          
0000146E                           384  
0000146E                           385  *---------------MOVEQ opcode----------------------
0000146E  3200                     386  CASE_MOVEQ      MOVE.W  D0,D1
00001470  C27C F100                387                  AND.W   #$F100,D1
00001474  B27C 7000                388                  CMP.W   #$7000,D1
00001478  6600 0054                389                  BNE     CASE_ADD
0000147C                           390                  
0000147C                           391                  ;loads Register
0000147C  323C 0001                392                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001480  4EB9 00001D98            393                  JSR     GET_XN                          ; gets XN and puts in D1
00001486  3401                     394                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
00001488                           395                  
00001488                           396                  ;loads DATA
00001488  3200                     397                  MOVE.W  D0,D1
0000148A  C27C 00FF                398                  AND.W   #$00FF,D1                       ;bit mask to get DATA
0000148E  3601                     399                  MOVE.W  D1,D3                          ;copy data into D3
00001490                           400                                                        ;must convert bits to hex
00001490                           401                                  
00001490  4BF9 0000246F            402  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
00001496  4EB9 000021F6            403                  JSR     PRINTNULL  
0000149C                           404                  
0000149C  4BF9 00002530            405                  LEA     MSG_3SPACES,A5                  ; loads spaces
000014A2  4EB9 000021F6            406                  JSR     PRINTNULL                       ; prints out spaces
000014A8                           407                  
000014A8  4BF9 00002554            408                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014AE  4EB9 000021F6            409                  JSR     PRINTNULL
000014B4                           410      
000014B4  4BF9 00002459            411                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000014BA  4EB9 000021F6            412                  JSR     PRINTNULL
000014C0                           413                  
000014C0  4BF9 00002523            414                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000014C6  4EB9 000021F6            415                  JSR     PRINTNULL
000014CC  4E75                     416                  RTS                                
000014CE                           417                                  
000014CE                           418  
000014CE                           419                  
000014CE                           420  *---------------ADD opcode----------------------                
000014CE                           421  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000014CE  3200                     422  CASE_ADD        MOVE.W  D0,D1
000014D0  C27C F000                423                  AND.W   #$F000,D1
000014D4  B27C D000                424                  CMP.W   #$D000,D1
000014D8  6600 01BA                425                  BNE     CASE_ADDQ
000014DC                           426                   
000014DC  4EB9 000014F6            427                  JSR     ADD_SUB_HELP
000014E2                           428                  
000014E2                           429                  ; bits 7-8 determine if it is ADDA or ADD
000014E2  3200                     430                  MOVE.W  D0,D1
000014E4  E149                     431                  LSL.W   #8,D1                   ; get rid of left 8 bits
000014E6  E049                     432                  LSR.W   #8,D1
000014E8  EC49                     433                  LSR.W   #6,D1                   ; get rid of right 6 bits
000014EA  B27C 0003                434                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000014EE  6700 0124                435                  BEQ     CASE_ADDA
000014F2                           436                  
000014F2  6000 0040                437                  BRA     PRINTADD                ; Branches to print add
000014F6                           438                  
000014F6                           439                  ; Check bits 0-5 
000014F6  4BF9 00002266            440  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000014FC  4DF9 0000229C            441                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001502  3E3C 0000                442                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001506  4EB9 00001DC2            443                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000150C  B27C 0001                444                  CMP.W       #1,D1                    ; checks if invalid
00001510  6700 0854                445                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001514  3802                     446                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001516  3A03                     447                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001518                           448                  
00001518                           449                  ; Check 6-11
00001518  4BF9 00002266            450                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000151E  4DF9 000022A0            451                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001524  3E3C 0001                452                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001528  4EB9 00001DC2            453                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000152E  3C02                     454                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001530  3E03                     455                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001532                           456    
00001532  4E75                     457                  RTS                
00001534                           458                    
00001534  4BF9 0000247D            459  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
0000153A  4EB9 000021F6            460                  JSR         PRINTNULL               ; print ADD
00001540  3200                     461                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001542  4EB9 00001558            462                  JSR         ADD_SUB_SIZE
00001548  4BF9 00002539            463                  LEA         MSG_5SPACES,A5          ; loads spaces
0000154E  4EB9 000021F6            464                  JSR         PRINTNULL               ; prints out spaces
00001554  6000 0050                465                  BRA         FINISH_ADD
00001558                           466                    
00001558  3200                     467  ADD_SUB_SIZE    MOVE.W      D0,D1
0000155A  E149                     468                  LSL.W       #8,D1
0000155C  E049                     469                  LSR.W       #8,D1
0000155E  EC49                     470                  LSR.W       #6,D1                   ; gets bits 6-7
00001560                           471                    
00001560  B27C 0000                472                  CMP.W       #0,D1
00001564  6700 0016                473                  BEQ         ADD_SUB_BYTE
00001568  B27C 0001                474                  CMP.W       #1,D1                   ; if 1, it is a word
0000156C  6700 001C                475                  BEQ         ADD_SUB_WORD
00001570  B27C 0002                476                  CMP.W       #2,D1                   ; if 2, it is a long
00001574  6700 0022                477                  BEQ         ADD_SUB_LONG
00001578  6000 0294                478                  BRA         CASE_SUBA               ; error
0000157C                           479                    
0000157C  4BF9 0000254E            480  ADD_SUB_BYTE    LEA         MSG_B,A5
00001582  4EB9 000021F6            481                  JSR         PRINTNULL
00001588  4E75                     482                  RTS
0000158A                           483                    
0000158A  4BF9 00002551            484  ADD_SUB_WORD    LEA         MSG_W,A5
00001590  4EB9 000021F6            485                  JSR         PRINTNULL
00001596  4E75                     486                  RTS
00001598                           487    
00001598  4BF9 00002554            488  ADD_SUB_LONG    LEA         MSG_L,A5
0000159E  4EB9 000021F6            489                  JSR         PRINTNULL
000015A4  4E75                     490                  RTS
000015A6                           491        
000015A6  4EB9 000015AE            492  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015AC  4E75                     493                  RTS
000015AE                           494    
000015AE  EF49                     495  ADD_SUB_OPERAND LSL.W       #7,D1
000015B0  EE49                     496                  LSR.W       #7,D1
000015B2  E049                     497                  LSR.W       #8,D1
000015B4  B27C 0001                498                  CMP.W       #1,D1
000015B8  6600 002E                499                  BNE         Dn_PLUS_EA          
000015BC                           500                    
000015BC                           501                  ; print Data Register
000015BC  4BF9 00002517            502                  LEA         MSG_DR,A5
000015C2  4EB9 000021F6            503                  JSR         PRINTNULL
000015C8  3207                     504                  MOVE.W      D7,D1
000015CA  4EB9 000020AC            505                  JSR         PRINTNUM                
000015D0                           506                  
000015D0                           507                  ; prints a comma to seperate
000015D0  4BF9 00002527            508                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015D6  4EB9 000021F6            509                  JSR         PRINTNULL                ; prints out MOVE
000015DC                           510                 
000015DC                           511                  ; below is EA+Dn->Dn  
000015DC  3404                     512                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015DE  3605                     513                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015E0  4EB9 00001F30            514                  JSR         EA_TO_STRING             ; outputs it into a string
000015E6  4E75                     515                  RTS                                 ; exits subroutine 
000015E8                           516  
000015E8                           517  Dn_PLUS_EA      ; below is Dn+EA->EA  
000015E8  3404                     518                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015EA  3605                     519                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015EC  4EB9 00001F30            520                  JSR         EA_TO_STRING             ; outputs it into a string   
000015F2                           521                  
000015F2                           522                  ; prints a comma to seperate
000015F2  4BF9 00002527            523                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015F8  4EB9 000021F6            524                  JSR         PRINTNULL                ; prints out MOVE
000015FE                           525                  
000015FE                           526                  ; below is Dn+EA->EA
000015FE  4BF9 00002517            527                  LEA         MSG_DR,A5                ; print data register
00001604  4EB9 000021F6            528                  JSR         PRINTNULL
0000160A  3207                     529                  MOVE.W      D7,D1
0000160C  4EB9 000020AC            530                  JSR         PRINTNUM             
00001612  4E75                     531                  RTS                                  ; exits subroutine          
00001614                           532                        
00001614                           533  *---------------ADDA opcode----------------------
00001614                           534  CASE_ADDA       ; gets bit 8 (size bit)
00001614  3200                     535                  MOVE.W      D0,D1
00001616  EF49                     536                  LSL.W       #7,D1
00001618  EE49                     537                  LSR.W       #7,D1
0000161A  E049                     538                  LSR         #8,D1                   
0000161C                           539                  
0000161C  4BF9 00002482            540                  LEA         MSG_ADDA,A5             ; print ADDA
00001622  4EB9 000021F6            541                  JSR         PRINTNULL
00001628                           542                   
00001628  B27C 0001                543                  CMP.W       #1,D1
0000162C  6700 001E                544                  BEQ         ADDA_LONG
00001630                           545                    
00001630  4BF9 00002551            546                  LEA         MSG_W,A5
00001636  4EB9 000021F6            547                  JSR         PRINTNULL
0000163C  4BF9 00002534            548                  LEA         MSG_4SPACES,A5          ; loads spaces
00001642  4EB9 000021F6            549                  JSR         PRINTNULL               ; prints out spaces
00001648  6000 001E                550                  BRA         FINISH_ADDA   
0000164C                           551                    
0000164C  4BF9 00002554            552  ADDA_LONG       LEA         MSG_L,A5
00001652  4EB9 000021F6            553                  JSR         PRINTNULL
00001658  4BF9 00002534            554                  LEA         MSG_4SPACES,A5          ; loads spaces
0000165E  4EB9 000021F6            555                  JSR         PRINTNULL               ; prints out spaces
00001664  6000 0002                556                  BRA         FINISH_ADDA
00001668                           557                    
00001668  3404                     558  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000166A  3605                     559                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000166C  4EB9 00001F30            560                  JSR         EA_TO_STRING             ; outputs it into a string
00001672                           561                    
00001672                           562                  ; prints a comma to seperate
00001672  4BF9 00002527            563                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001678  4EB9 000021F6            564                  JSR         PRINTNULL                ; prints out MOVE
0000167E                           565            
0000167E  4BF9 00002519            566                  LEA         MSG_AR,A5                ; print address register
00001684  4EB9 000021F6            567                  JSR         PRINTNULL
0000168A  3207                     568                  MOVE.W      D7,D1
0000168C  4EB9 000020AC            569                  JSR         PRINTNUM             
00001692  4E75                     570                  RTS                              ; exits subroutine
00001694                           571                  
00001694                           572  *---------------ADDQ opcode----------------------                  
00001694  3200                     573  CASE_ADDQ       MOVE.W      D0,D1
00001696  C27C F000                574                  AND.W       #$F000,D1       
0000169A  B27C 5000                575                  CMP.W       #$5000,D1
0000169E  6600 00EC                576                  BNE         CASE_SUB
000016A2                           577                                                   
000016A2  4BF9 00002488            578                  LEA         MSG_ADDQ,A5             ; print ADDQ
000016A8  4EB9 000021F6            579                  JSR         PRINTNULL
000016AE                           580                  
000016AE                           581                  ; get bits 6-7 (size bits)
000016AE  3200                     582                  MOVE.W      D0,D1
000016B0  E149                     583                  LSL.W       #8,D1
000016B2  E049                     584                  LSR.W       #8,D1
000016B4  EC49                     585                  LSR.W       #6,D1
000016B6  3401                     586                  MOVE.W      D1,D2
000016B8                           587                  
000016B8                           588                  ; Check bits 0-5 
000016B8  4BF9 00002266            589                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016BE  4DF9 0000229C            590                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016C4  3E3C 0000                591                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016C8  4EB9 00001DC2            592                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000016CE  B27C 0001                593                  CMP.W       #1,D1                    ; checks if invalid
000016D2  6700 0692                594                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000016D6  3802                     595                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000016D8  3A03                     596                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000016DA                           597                  
000016DA  B47C 0001                598                  CMP.W       #1,D2
000016DE  6700 0026                599                  BEQ         ADDQ_WORD
000016E2  B47C 0002                600                  CMP.W       #2,D2
000016E6  6700 003A                601                  BEQ         ADDQ_LONG
000016EA                           602                    
000016EA  4BF9 0000254E            603  ADDQ_BYTE       LEA         MSG_B,A5
000016F0  4EB9 000021F6            604                  JSR         PRINTNULL
000016F6  4BF9 00002534            605                  LEA         MSG_4SPACES,A5          ; loads spaces
000016FC  4EB9 000021F6            606                  JSR         PRINTNULL               ; prints out spaces
00001702  6000 003A                607                  BRA         FINISH_ADDQ  
00001706                           608   
00001706  4BF9 00002551            609  ADDQ_WORD       LEA         MSG_W,A5
0000170C  4EB9 000021F6            610                  JSR         PRINTNULL
00001712  4BF9 00002534            611                  LEA         MSG_4SPACES,A5          ; loads spaces
00001718  4EB9 000021F6            612                  JSR         PRINTNULL               ; prints out spaces
0000171E  6000 001E                613                  BRA         FINISH_ADDQ                 
00001722                           614    
00001722  4BF9 00002554            615  ADDQ_LONG       LEA         MSG_L,A5
00001728  4EB9 000021F6            616                  JSR         PRINTNULL
0000172E  4BF9 00002534            617                  LEA         MSG_4SPACES,A5          ; loads spaces
00001734  4EB9 000021F6            618                  JSR         PRINTNULL               ; prints out spaces
0000173A  6000 0002                619                  BRA         FINISH_ADDQ                  
0000173E                           620                    
0000173E  4EB9 0000175C            621  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001744                           622   
00001744                           623                  ; prints a comma to seperate
00001744  4BF9 00002527            624                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000174A  4EB9 000021F6            625                  JSR         PRINTNULL                ; prints out MOVE
00001750                           626                    
00001750                           627                  ; prints destination
00001750  3404                     628                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001752  3605                     629                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001754  4EB9 00001F30            630                  JSR         EA_TO_STRING             ; outputs it into a string
0000175A                           631                 
0000175A  4E75                     632                  RTS
0000175C                           633   
0000175C  4BF9 00002523            634  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
00001762  4EB9 000021F6            635                  JSR         PRINTNULL
00001768                           636                  ; gets bits 9-11 (data bits)
00001768  E949                     637                  LSL.W       #4,D1
0000176A  E849                     638                  LSR.W       #4,D1                               ; get rid of left 4 bits
0000176C  E049                     639                  LSR.W       #8,D1
0000176E  E249                     640                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001770                           641                  
00001770  B27C 0000                642                  CMP.W       #0,D1
00001774  6700 000A                643                  BEQ         PRINT_8
00001778  4EB9 000020AC            644                  JSR         PRINTNUM
0000177E  4E75                     645                  RTS 
00001780                           646  
00001780  123C 0008                647  PRINT_8         MOVE.B      #8,D1
00001784  4EB9 000020AC            648                  JSR         PRINTNUM
0000178A  4E75                     649                  RTS   
0000178C                           650         
0000178C                           651  *---------------SUB opcode---------------------- 
0000178C  3200                     652  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000178E  C27C F000                653                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001792  B27C 9000                654                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001796  6600 008C                655                  BNE         CASE_LEA
0000179A                           656                 
0000179A  4EB8 14F6                657                  JSR         ADD_SUB_HELP
0000179E                           658                  
0000179E  6000 0002                659                  BRA         PRINTSUB                            ; Branches to print sub
000017A2                           660  
000017A2  4BF9 0000248E            661  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017A8  4EB9 000021F6            662                  JSR         PRINTNULL
000017AE  3200                     663                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017B0  4EB8 1558                664                  JSR         ADD_SUB_SIZE
000017B4  4BF9 00002539            665                  LEA         MSG_5SPACES,A5                      ; loads spaces
000017BA  4EB9 000021F6            666                  JSR         PRINTNULL                           ; prints out spaces
000017C0  3200                     667                  MOVE.W      D0,D1
000017C2  E149                     668                  LSL.W       #8,D1
000017C4  E049                     669                  LSR.W       #8,D1
000017C6  EC49                     670                  LSR.W       #6,D1
000017C8  B27C 0003                671                  CMP.W       #3,D1
000017CC  6600 0006                672                  BNE         FINISH_SUB
000017D0  6000 0008                673                  BRA         FINISH_SUBA                         ; same as ADDA
000017D4                           674                  
000017D4  4EB8 15AE                675  FINISH_SUB      JSR         ADD_SUB_OPERAND
000017D8  4E75                     676                  RTS
000017DA                           677                    
000017DA  3404                     678  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000017DC  3605                     679                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000017DE  4EB9 00001F30            680                  JSR         EA_TO_STRING             ; outputs it into a string
000017E4                           681                
000017E4                           682                  ; prints a comma to seperate
000017E4  4BF9 00002527            683                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000017EA  4EB9 000021F6            684                  JSR         PRINTNULL                ; prints out MOVE
000017F0                           685                  
000017F0  4BF9 00002519            686                  LEA         MSG_AR,A5                ; print address register
000017F6  4EB9 000021F6            687                  JSR         PRINTNULL
000017FC  3200                     688                  MOVE.W      D0,D1
000017FE  E949                     689                  LSL.W       #4,D1
00001800  E849                     690                  LSR.W       #4,D1
00001802  E049                     691                  LSR.W       #8,D1
00001804  E249                     692                  LSR.W       #1,D1
00001806  4EB9 000020AC            693                  JSR         PRINTNUM             
0000180C  4E75                     694                  RTS                              ; exits subroutine
0000180E                           695  
0000180E                           696  
0000180E                           697  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000180E  3200                     698  CASE_SUBA       MOVE.W      D0,D1
00001810  EF49                     699                  LSL.W       #7,D1
00001812  EE49                     700                  LSR.W       #7,D1
00001814  E049                     701                  LSR.W       #8,D1
00001816  B23C 0000                702                  CMP.B       #0,D1
0000181A  6700 FD6E                703                  BEQ         ADD_SUB_WORD
0000181E  6000 FD78                704                  BRA         ADD_SUB_LONG
00001822  4E75                     705                  RTS         
00001824                           706                   
00001824  3200                     707  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001826  C27C F000                708                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000182A  B27C 4000                709                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000182E  6600 0092                710                  BNE.W   CASE_AND                             ; If its not, check AND
00001832  3200                     711                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001834  C27C 01C0                712                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001838  B27C 01C0                713                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000183C  6600 0084                714                  BNE.W   CASE_AND                             ; If its not, check AND
00001840                           715                  
00001840                           716                  ; Check source
00001840  4BF9 00002286            717                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001846  4DF9 000022A0            718                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000184C  3E3C 0000                719                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001850  4EB9 00001DC2            720                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001856  3802                     721                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001858  3A03                     722                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000185A                           723                  
0000185A                           724                  ; Check destination
0000185A  4BF9 00002286            725                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001860  4DF9 000022A0            726                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001866  3E3C 0001                727                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000186A  4EB9 00001DC2            728                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001870  3C02                     729                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001872  3E03                     730                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001874                           731  
00001874  4BF9 0000249F            732                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000187A  4EB9 000021F6            733                  JSR     PRINTNULL                            ; prints LEA
00001880  4BF9 00002546            734                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001886  4EB9 000021F6            735                  JSR     PRINTNULL                            ; prints out spaces
0000188C                           736                  
0000188C                           737                  ; print source
0000188C  3404                     738                  MOVE.W  D4,D2
0000188E  3605                     739                  MOVE.W  D5,D3
00001890  4EB9 00001F30            740                  JSR     EA_TO_STRING                         ; Prints out the EA
00001896                           741                  
00001896                           742                  ; comma
00001896  4BF9 00002527            743                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
0000189C  4EB9 000021F6            744                  JSR     PRINTNULL                       
000018A2                           745                   
000018A2                           746                  ; register
000018A2  4BF9 00002519            747                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018A8  4EB9 000021F6            748                  JSR     PRINTNULL 
000018AE  3401                     749                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018B0  323C 0001                750                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000018B4  4EB9 00001D98            751                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000018BA  4EB9 000020AC            752                  JSR     PRINTNUM                             ; Prints the number in D1
000018C0  4E75                     753                  RTS
000018C2                           754  
000018C2                           755  *---------------AND opcode----------------------
000018C2  3200                     756  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018C4  C27C F000                757                  AND.W       #$F000,D1       
000018C8  B27C C000                758                  CMP.W       #$C000,D1
000018CC  6600 00D6                759                  BNE         CASE_OR
000018D0                           760                  
000018D0  3200                     761                  MOVE.W      D0,D1
000018D2  E149                     762                  LSL.W       #8,D1
000018D4  E049                     763                  LSR.W       #8,D1
000018D6  EC49                     764                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000018D8  3C01                     765                  MOVE.W      D1,D6
000018DA  BC7C 0003                766                  CMP.W       #3,D6
000018DE  6700 0086                767                  BEQ         INV_INSTR
000018E2                           768                  
000018E2  4BF9 000024A4            769                  LEA         MSG_AND,A5                      ; print AND
000018E8  4EB9 000021F6            770                  JSR         PRINTNULL
000018EE                           771                  
000018EE  3206                     772                  MOVE.W      D6,D1
000018F0  B27C 0000                773                  CMP.W       #0,D1
000018F4  6700 0012                774                  BEQ         AND_BYTE
000018F8  B27C 0001                775                  CMP.W       #1,D1                   ; if 1, it is a word
000018FC  6700 0026                776                  BEQ         AND_WORD
00001900  B27C 0002                777                  CMP.W       #2,D1                   ; if 2, it is a long
00001904  6700 003A                778                  BEQ         AND_LONG
00001908                           779                  
00001908  4BF9 0000254E            780  AND_BYTE        LEA         MSG_B,A5
0000190E  4EB9 000021F6            781                  JSR         PRINTNULL
00001914  4BF9 00002546            782                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000191A  4EB9 000021F6            783                  JSR         PRINTNULL                       ; prints out spaces
00001920  6000 003A                784                  BRA         FINISH_AND
00001924                           785                                    
00001924  4BF9 00002551            786  AND_WORD        LEA         MSG_W,A5
0000192A  4EB9 000021F6            787                  JSR         PRINTNULL
00001930  4BF9 00002546            788                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001936  4EB9 000021F6            789                  JSR         PRINTNULL                       ; prints out spaces
0000193C  6000 001E                790                  BRA         FINISH_AND
00001940                           791    
00001940  4BF9 00002554            792  AND_LONG        LEA         MSG_L,A5
00001946  4EB9 000021F6            793                  JSR         PRINTNULL
0000194C  4BF9 00002546            794                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001952  4EB9 000021F6            795                  JSR         PRINTNULL                       ; prints out spaces
00001958  6000 0002                796                  BRA         FINISH_AND
0000195C                           797        
0000195C  4EB8 14F6                798  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001960  4EB8 15AE                799                  JSR         ADD_SUB_OPERAND
00001964  4E75                     800                  RTS
00001966                           801                  
00001966  4BF9 000023E1            802  INV_INSTR       LEA         INVALID_INSTR,A5
0000196C  4EB9 000021F6            803                  JSR         PRINTNULL
00001972  4BF9 0000253F            804                  LEA         MSG_6SPACES,A5
00001978  4EB9 000021F6            805                  JSR         PRINTNULL
0000197E  4BF9 00002525            806                  LEA         MSG_HEX,A5
00001984  4EB9 000021F6            807                  JSR         PRINTNULL
0000198A  2200                     808                  MOVE.L      D0,D1
0000198C  383C 0000                809                  MOVE.W      #0,D4
00001990  4EB9 000020D0            810                  JSR         PRINTSHORTLONGNUM
00001996  4BF9 00002456            811                  LEA         NEW_LINE,A5
0000199C  4EB9 000021F6            812                  JSR         PRINTNULL
000019A2  4E75                     813                  RTS               
000019A4                           814                  
000019A4                           815  *---------------OR opcode----------------------            
000019A4  3200                     816  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019A6  C27C F000                817                  AND.W       #$F000,D1       
000019AA  B27C 8000                818                  CMP.W       #$8000,D1
000019AE  6600 0054                819                  BNE         CASE_NOT
000019B2                           820                                                
000019B2  3200                     821                  MOVE.W      D0,D1
000019B4  E149                     822                  LSL.W       #8,D1
000019B6  E049                     823                  LSR.W       #8,D1
000019B8  EC49                     824                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019BA  B27C 0003                825                  CMP.W       #3,D1
000019BE  3C01                     826                  MOVE.W      D1,D6
000019C0  67A4                     827                  BEQ         INV_INSTR
000019C2                           828                  
000019C2                           829                  
000019C2  4BF9 000024A9            830                  LEA         MSG_OR,A5
000019C8  4EB9 000021F6            831                  JSR         PRINTNULL                       ; print "OR"
000019CE                           832                  
000019CE  3206                     833                  MOVE.W      D6,D1
000019D0  4EB9 000019EC            834                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000019D6  4BF9 0000253F            835                  LEA         MSG_6SPACES,A5                  ; loads spaces
000019DC  4EB9 000021F6            836                  JSR         PRINTNULL                       ; prints out spaces
000019E2                           837  
000019E2  4EB8 14F6                838                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
000019E6  4EB8 15AE                839                  JSR         ADD_SUB_OPERAND                 ; print 
000019EA  4E75                     840                  RTS
000019EC                           841  
000019EC  B27C 0000                842  OR_SIZE         CMP.W       #0,D1
000019F0  6700 FB8A                843                  BEQ         ADD_SUB_BYTE
000019F4  B27C 0001                844                  CMP.W       #1,D1                   ; if 1, it is a word
000019F8  6700 FB90                845                  BEQ         ADD_SUB_WORD
000019FC  B27C 0002                846                  CMP.W       #2,D1                   ; if 2, it is a long
00001A00  6700 FB96                847                  BEQ         ADD_SUB_LONG
00001A04                           848                  ; no need for rts, since ADD_SUB_ already has                
00001A04                           849  
00001A04                           850  *---------------NOT opcode----------------------
00001A04  3200                     851  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A06  C27C FF00                852                  AND.W       #$FF00,D1       
00001A0A  B27C 4600                853                  CMP.W       #$4600,D1
00001A0E  6600 0058                854                  BNE         CASE_LSDASDROD
00001A12                           855                 
00001A12                           856                  ; get bits 6-7 (size)
00001A12  3200                     857                  MOVE.W      D0,D1
00001A14  E149                     858                  LSL.W       #8,D1
00001A16  E049                     859                  LSR.W       #8,D1
00001A18  EC49                     860                  LSR.W       #6,D1 
00001A1A  3C01                     861                  MOVE.W      D1,D6                         
00001A1C  BC7C 0003                862                  CMP.W       #3,D6
00001A20  6700 FF44                863                  BEQ         INV_INSTR
00001A24                           864                                  
00001A24  4BF9 000024AD            865                  LEA         MSG_NOT,A5
00001A2A  4EB9 000021F6            866                  JSR         PRINTNULL                       ; print "NOT"
00001A30                           867                                 
00001A30  3206                     868                  MOVE.W      D6,D1
00001A32                           869  
00001A32  4EB8 19EC                870                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A36  4BF9 00002539            871                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A3C  4EB9 000021F6            872                  JSR         PRINTNULL                       ; prints out spaces
00001A42                           873                  
00001A42                           874                  ; get bits 0-5 
00001A42  4BF9 00002266            875                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A48  4DF9 0000229C            876                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A4E  3E3C 0000                877                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A52  4EB9 00001DC2            878                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A58  B27C 0001                879                  CMP.W       #1,D1                    ; checks if invalid
00001A5C  6700 0308                880                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001A60  4EB9 00001F30            881                  JSR         EA_TO_STRING             ; outputs it into a string
00001A66                           882    
00001A66  4E75                     883                  RTS
00001A68                           884  
00001A68  3200                     885  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001A6A  C27C F000                886                  AND.W       #$F000, D1                       ; gets first 4 bits
00001A6E  B27C E000                887                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001A72  6600 0240                888                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001A76  3400                     889                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A78  4EB9 00001E4A            890                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A7E  B47C 0003                891                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001A82  6600 00D4                892                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001A86                           893                  
00001A86  3400                     894  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001A88  4EB9 00001E38            895                  JSR         GETROTATION                      ; gets rotation value of D2
00001A8E  B47C 0000                896                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001A92  6700 0014                897                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001A96  B47C 0003                898                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001A9A  6700 0016                899                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001A9E                           900                  
00001A9E  4BF9 000024B2            901  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001AA4  6000 0012                902                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AA8                           903  
00001AA8  4BF9 000024B6            904  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001AAE  6000 0008                905                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AB2                           906  
00001AB2  4BF9 000024BA            907  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AB8                           908                  
00001AB8  4EB9 000021F6            909  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001ABE  3400                     910                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AC0  4EB9 00001E42            911                  JSR         GETDIRECTION                     ; gets direction
00001AC6  B47C 0000                912                  CMP.W       #0,D2                            ; checking if its right
00001ACA  6700 000C                913                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001ACE                           914  
00001ACE  4BF9 00002515            915  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001AD4  6000 0008                916                  BRA         PRINT_MEMDIR                     ; branches for printing
00001AD8                           917          
00001AD8  4BF9 00002513            918  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001ADE                           919  
00001ADE  4EB9 000021F6            920  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001AE4  4BF9 00002551            921                  LEA         MSG_W,A5                         ; loads .W into A5
00001AEA  4EB9 000021F6            922                  JSR         PRINTNULL                        ; Prints .W
00001AF0  4BF9 00002539            923                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001AF6  4EB9 000021F6            924                  JSR         PRINTNULL                        ; prints out spaces
00001AFC  6000 0002                925                  BRA         GETMEMSOURCE                     ; checks the source 
00001B00                           926                  
00001B00                           927  ; get source addressing mode       
00001B00                           928  GETMEMSOURCE                                                 
00001B00  323C 0000                929                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B04  4EB9 00001D6E            930                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B0A  3801                     931                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B0C  323C 0000                932                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B10  4EB9 00001D98            933                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B16  3A01                     934                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B18                           935  
00001B18  4BF9 00002294            936  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B1E  3204                     937                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B20  4EB9 00001EFC            938                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B26  B27C 0002                939                  CMP.W       #2,D1                            ; checks if it is Xn
00001B2A  6700 0016                940                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B2E  B27C 0001                941                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B32  6700 0232                942                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B36                           943  
00001B36  3404                     944  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B38  3605                     945                  MOVE.W      D5,D3                            ; moves EA to D3
00001B3A  4EB9 00001F30            946                  JSR         EA_TO_STRING                     ; prints out the EA
00001B40  4E75                     947                  RTS                
00001B42                           948                  
00001B42                           949                  
00001B42  4BF9 000022A0            950  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B48  3205                     951                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B4A  4EB9 00001EFC            952                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B50  4A41                     953                  TST.W       D1                               ; checks if it is valid
00001B52  67E2                     954                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B54  6000 0210                955                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B58                           956  
00001B58                           957  
00001B58  3602                     958  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B5A  3200                     959                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B5C  C27C 0018                960                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001B60  E649                     961                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001B62  B27C 0000                962                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B66  6700 0014                963                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001B6A  B27C 0003                964                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B6E  6700 0016                965                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001B72                           966                  
00001B72  4BF9 000024B2            967  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001B78  6000 0012                968                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B7C                           969  
00001B7C  4BF9 000024B6            970  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001B82  6000 0008                971                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B86                           972  
00001B86  4BF9 000024BA            973  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001B8C                           974                  
00001B8C  4EB9 000021F6            975  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001B92  3400                     976                  MOVE.W      D0,D2                            ; copies D0 to D2
00001B94  4EB9 00001E42            977                  JSR         GETDIRECTION                     ; gets direction
00001B9A  B47C 0000                978                  CMP.W       #0,D2                            ; checking if its right
00001B9E  6700 000C                979                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BA2                           980  
00001BA2  4BF9 00002515            981  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BA8  6000 000C                982                  BRA         PRINT_REGDIR                     ; branches for printing
00001BAC                           983          
00001BAC  4BF9 00002513            984  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BB2  6000 0002                985                  BRA         PRINT_REGDIR                     ; branches for printing
00001BB6                           986                  
00001BB6  4EB9 000021F6            987  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BBC                           988  
00001BBC  3400                     989  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BBE  4EB9 00001E4A            990                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BC4  B47C 0001                991                  CMP.W       #1,D2                            ; Checks if it is word size
00001BC8  6700 0014                992                  BEQ         REG_WORD                         ; Prints .W
00001BCC  B47C 0002                993                  CMP.W       #2,D2                            ; Checks if it is long size
00001BD0  6700 0016                994                  BEQ         REG_LONG                         ; Prints .L
00001BD4                           995  
00001BD4  4BF9 0000254E            996  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001BDA  6000 0012                997                  BRA         PRINTREGEA      
00001BDE                           998  
00001BDE  4BF9 00002551            999  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001BE4  6000 0008               1000                  BRA         PRINTREGEA      
00001BE8                          1001                             
00001BE8  4BF9 00002554           1002  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001BEE                          1003  
00001BEE  4EB9 000021F6           1004  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001BF4  4BF9 00002539           1005                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001BFA  4EB9 000021F6           1006                  JSR         PRINTNULL                        ; prints out spaces
00001C00  3400                    1007                  MOVE.W      D0,D2                            ; copies D0 to D2
00001C02  4EB9 00001E52           1008                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C08  B47C 0001               1009                  CMP.W       #$1,D2                           ; Compares D1 to 1, if it is 1, it is a data register
00001C0C  6700 0060               1010                  BEQ         REG_REGISTER                     ; goes to register case if so
00001C10                          1011                                  
00001C10  3400                    1012  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C12  4EB9 00001E38           1013                  JSR         GETROTATION                      ; gets the rotation size
00001C18  B47C 0000               1014                  CMP.W       #0,D2                            ; checks if D2 is 0 (shift count of 8)
00001C1C  6600 0006               1015                  BNE         COMPLETE_REGIM                   ; if not shigt count of 8, then branch to start printing
00001C20                          1016                  
00001C20  343C 0008               1017  MAKESHIFT8      MOVE.W      #8,D2                            ; sets shift cound to 8 (shift count of 8 is 000 in the opcode)
00001C24                          1018                  
00001C24  4BF9 00002523           1019  COMPLETE_REGIM  LEA         MSG_POUND, A5                    ; loads # into A5
00001C2A  4EB9 000021F6           1020                  JSR         PRINTNULL                        ; prints #
00001C30  4BF9 00002525           1021                  LEA         MSG_HEX, A5                      ; loads $ into A5
00001C36  4EB9 000021F6           1022                  JSR         PRINTNULL                        ; prints $
00001C3C  3202                    1023                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C3E  4EB9 000020BC           1024                  JSR         PRINTHEXNUM                      ; prints shift count
00001C44  4BF9 00002527           1025                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C4A  4EB9 000021F6           1026                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C50  4BF9 00002517           1027                  LEA         MSG_DR, A5                       ; loads D into A5
00001C56  4EB9 000021F6           1028                  JSR         PRINTNULL                        ; prints out D 
00001C5C  323C 0000               1029                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C60  4EB9 00001D98           1030                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C66  4EB9 000020AC           1031                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C6C  4E75                    1032                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C6E                          1033                  
00001C6E  3400                    1034  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001C70  4EB9 00001E4A           1035                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C76  3202                    1036                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C78  4BF9 00002517           1037                  LEA         MSG_DR, A5                       ; loads D into A5
00001C7E  4EB9 000021F6           1038                  JSR         PRINTNULL                        ; prints D
00001C84  4EB9 000020AC           1039                  JSR         PRINTNUM                         ; prints register number
00001C8A  4BF9 00002527           1040                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C90  4EB9 000021F6           1041                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C96  4BF9 00002517           1042                  LEA         MSG_DR, A5                       ; loads D into A5
00001C9C  4EB9 000021F6           1043                  JSR         PRINTNULL                        ; prints out D 
00001CA2  323C 0000               1044                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CA6  4EB9 00001D98           1045                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CAC  4EB9 000020AC           1046                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CB2  4E75                    1047                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CB4                          1048               
00001CB4  3200                    1049  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001CB6  C27C FF00               1050                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001CBA  B27C 6000               1051                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001CBE  6600 0024               1052                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001CC2                          1053                  
00001CC2  4BF9 0000250E           1054                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001CC8  4EB9 000021F6           1055                  JSR     PRINTNULL                            ; prints BRA
00001CCE  4BF9 00002546           1056                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001CD4  4EB9 000021F6           1057                  JSR     PRINTNULL                            ; prints out spaces
00001CDA                          1058  
00001CDA  3400                    1059                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001CDC  4EB9 00001E0A           1060                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001CE2  4E75                    1061                  RTS
00001CE4                          1062                  
00001CE4                          1063  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001CE4                          1064  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001CE4  3200                    1065  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CE6  C27C F000               1066                  AND.W   #$F000,D1                            ; get top 4 bits
00001CEA  B27C 6000               1067                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001CEE  6600 0060               1068                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001CF2  3200                    1069                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CF4  C27C 0F00               1070                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001CF8  E049                    1071                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001CFA                          1072                  
00001CFA  B27C 000E               1073                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001CFE  6700 002A               1074                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001D02                          1075                  
00001D02  B27C 000F               1076                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001D06  6700 0018               1077                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001D0A                          1078                      
00001D0A  B27C 0007               1079                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001D0E  6700 0006               1080                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001D12  6000 0052               1081                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001D16                          1082     
00001D16  4BF9 000024C8           1083  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D1C  6000 0016               1084                  BRA     PRINTBCC
00001D20                          1085  
00001D20  4BF9 000024E1           1086  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D26  6000 000C               1087                  BRA     PRINTBCC
00001D2A                          1088                  
00001D2A  4BF9 000024D7           1089  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D30  6000 0002               1090                  BRA     PRINTBCC
00001D34                          1091  
00001D34  4EB9 000021F6           1092  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D3A  4BF9 00002546           1093                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D40  4EB9 000021F6           1094                  JSR     PRINTNULL                            ; prints out spaces
00001D46  3400                    1095                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D48  4EB9 00001E0A           1096                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D4E  4E75                    1097                  RTS              
00001D50                          1098                  
00001D50                          1099  
00001D50                          1100  CASE_JSR       
00001D50                          1101  
00001D50  B07C 4E75               1102  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001D54  6600 0010               1103                  BNE     CASE_DATA           ; checks the next case if not equal
00001D58  4BF9 00002509           1104                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001D5E  4EB9 000021F6           1105                  JSR     PRINTNULL           ; prints RTS                
00001D64  4E75                    1106                  RTS                         ; returns from the subroutine
00001D66                          1107  
00001D66                          1108                  
00001D66                          1109  
00001D66  4EB8 1966               1110  CASE_DATA           JSR INV_INSTR  
00001D6A  4E75                    1111                      RTS               
00001D6C                          1112  
00001D6C  4E75                    1113  CASE_EPICFAIL       RTS
00001D6E                          1114  
00001D6E                          1115  
00001D6E                          1116  * Finds the EA type
00001D6E                          1117  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001D6E                          1118  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D6E  48E7 3000               1119  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D72  4A41                    1120                      TST.W     D1                    ; compares D1 to 0
00001D74  6700 000E               1121                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001D78                          1122                      
00001D78  343C 01C0               1123  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001D7C  363C 0006               1124                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001D80  6000 000A               1125                      BRA       FINDTYPEEA            
00001D84                          1126  
00001D84  343C 0038               1127  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001D88  363C 0003               1128                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001D8C                          1129  
00001D8C                          1130  
00001D8C  3200                    1131  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001D8E  C242                    1132                      AND.W     D2,D1                 ; applies bitmask to D1
00001D90  E669                    1133                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001D92  4CDF 000C               1134                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001D96  4E75                    1135                      RTS                             ; returns from subroutine    
00001D98                          1136                      
00001D98                          1137  * Finds Xn type
00001D98                          1138  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001D98                          1139  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D98  48E7 3000               1140  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D9C  4A41                    1141                      TST.W     D1                    ; compares D1 to 0
00001D9E  6700 000E               1142                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001DA2                          1143  
00001DA2  343C 0E00               1144  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001DA6  363C 0009               1145                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001DAA  6000 000A               1146                      BRA       FINDTYPEXN            ; finds the type of Xn
00001DAE                          1147  
00001DAE  343C 0007               1148  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001DB2  363C 0000               1149                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001DB6                          1150                      
00001DB6  3200                    1151  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001DB8  C242                    1152                      AND.W     D2,D1                 ; applies bitmask to D1
00001DBA  E669                    1153                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001DBC  4CDF 000C               1154                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001DC0  4E75                    1155                      RTS                             ; returns from subroutine 
00001DC2                          1156                      
00001DC2                          1157  * Checks and gets the EA and Xn
00001DC2                          1158  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001DC2                          1159  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001DC2  3207                    1160  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001DC4  4EB8 1D6E               1161                  JSR     GET_EA                  ; Gets EA
00001DC8  3401                    1162                  MOVE.W  D1,D2                   ; Stores EA in D2
00001DCA  3207                    1163                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001DCC  4EB8 1D98               1164                  JSR     GET_XN                  ; Gets Xn
00001DD0  3601                    1165                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001DD2  3202                    1166                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001DD4                          1167                  
00001DD4  4EB9 00001EFC           1168                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001DDA  B27C 0002               1169                  CMP.W   #2,D1                   ; checks if it is Xn
00001DDE  6700 0012               1170                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001DE2  B27C 0001               1171                  CMP.W   #1,D1                   ; Checks if it is invalid
00001DE6  6700 001C               1172                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001DEA                          1173                  
00001DEA                          1174                  
00001DEA  323C 0000               1175  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001DEE  6000 0018               1176                  BRA     END_CHECKGET
00001DF2                          1177        
00001DF2                          1178  ; need XN
00001DF2  2A4E                    1179  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001DF4  3203                    1180                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001DF6  4EB9 00001EFC           1181                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001DFC  4A41                    1182                  TST.W   D1                      ; checks if it is valid
00001DFE  67EA                    1183                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001E00  6000 0002               1184                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001E04                          1185   
00001E04  323C 0001               1186  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001E08                          1187  
00001E08  4E75                    1188  END_CHECKGET    RTS          
00001E0A                          1189                                            
00001E0A                          1190                                            
00001E0A                          1191  * Gets the displacement and pritns it 
00001E0A                          1192  * Inputs: D2 = instruction word, A2 = address of next word
00001E0A                          1193  * Outputs: prints out displacement
00001E0A  48E7 4004               1194  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001E0E  3A4A                    1195                      MOVE.W    A2,A5                 ; copies A2 to A5
00001E10  C47C 00FF               1196                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001E14  6600 0004               1197                      BNE       PRINTADDRESS          ; prints address if not 0
00001E18  341A                    1198                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001E1A                          1199                      
00001E1A  D44D                    1200  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001E1C  3202                    1201                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001E1E  183C 0000               1202                      MOVE.B    #0,D4                 ; marks address as word  length
00001E22  4BF9 00002525           1203                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001E28  4EB9 000021F6           1204                      JSR       PRINTNULL             ; prints null
00001E2E  4EB9 000020D0           1205                      JSR       PRINTSHORTLONGNUM     ; prints address
00001E34                          1206                      
00001E34  4CDF 2002               1207                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001E38                          1208                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001E38                          1209  
00001E38                          1210  * Gets the rotation value for ASd and LSd
00001E38                          1211  * Input: D2 = instruction word copy (of D0)                                    
00001E38                          1212  * Output: rotation  value in D2             
00001E38  C47C 0E00               1213  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001E3C  E04A                    1214                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E3E  E24A                    1215                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001E40  4E75                    1216                      RTS                             ; return from subroutine
00001E42                          1217  
00001E42                          1218  * Gets the direction value for ASd and LSd
00001E42                          1219  * Input: D2 = instruction word copy (of D0)                                    
00001E42                          1220  * Output: direction value in D2             
00001E42  C47C 0100               1221  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001E46  E04A                    1222                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E48  4E75                    1223                      RTS                             ; return from subroutine
00001E4A                          1224  
00001E4A                          1225  * Gets the rotation size value for ASd and LSd
00001E4A                          1226  * Input: D2 = instruction word copy (of D0)                                    
00001E4A                          1227  * Output: rotation size value in D2             
00001E4A  C47C 00C0               1228  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001E4E  EC4A                    1229                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E50  4E75                    1230                      RTS                             ; return from subroutine
00001E52                          1231  
00001E52                          1232  * Gets the rotation location  value for ASd and LSd
00001E52                          1233  * Input: D2 = instruction word copy (of D0)                                    
00001E52                          1234  * Output: rotation location value in D2             
00001E52  C47C 0020               1235  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001E56  EA4A                    1236                      LSR.W      #5,D2                ; shifts 5 bits to the right to only have the rotation bits
00001E58  4E75                    1237                      RTS                             ; return from subroutine
00001E5A                          1238  
00001E5A                          1239  * Prints out registers for MOVEM
00001E5A                          1240  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001E5A                          1241  * Output: printed out registers
00001E5A                          1242  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001E5A  48E7 0706               1243  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001E5E  3A3C 0000               1244                      MOVE.W     #0,D5                ; sets counter to 0
00001E62  3E1A                    1245                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001E64  B83C 0001               1246                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E68  6600 0010               1247                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001E6C                          1248  
00001E6C  3C3C 0000               1249  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001E70  4BF9 00002517           1250                      LEA        MSG_DR,A5            ; loads D to A5
00001E76  6000 000C               1251                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001E7A                          1252                      
00001E7A  3C3C 0007               1253  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001E7E  4BF9 00002519           1254                      LEA        MSG_AR,A5            ; loads A to A5
00001E84                          1255                      
00001E84  E34F                    1256  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001E86  6500 0018               1257                      BCS        PRINTREG             ; if pushes out a 1
00001E8A  DC44                    1258                      ADD.W      D4,D6                ; decrements or increments
00001E8C  5245                    1259                      ADD.W      #1,D5                ; increments D5
00001E8E  BA7C 0008               1260                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001E92  66F0                    1261                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001E94  B83C 0001               1262                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E98  6600 0052               1263                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001E9C  6000 0042               1264                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001EA0                          1265                      
00001EA0  4EB9 000021F6           1266  PRINTREG            JSR        PRINTNULL
00001EA6  3206                    1267                      MOVE.W     D6,D1
00001EA8  4EB9 000020AC           1268                      JSR        PRINTNUM 
00001EAE                          1269    
00001EAE  BE7C 0000               1270  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001EB2  6600 0006               1271                      BNE        PRINTMORE            ; continue if there is more
00001EB6  6000 0040               1272                      BRA        DONEPRINTINGREG      ; exit case
00001EBA                          1273  
00001EBA  2C4D                    1274  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001EBC  4BF9 0000252A           1275                      LEA        MSG_SLASH,A5         ; leads / into A5
00001EC2  4EB9 000021F6           1276                      JSR        PRINTNULL            ; prints the slash
00001EC8  2A4E                    1277                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001ECA  DC44                    1278                      ADD.W      D4,D6                ; decrements or increments
00001ECC  5245                    1279                      ADD.W      #1,D5                ; increments D5
00001ECE  BA7C 0008               1280                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001ED2  66B0                    1281                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001ED4  B83C 0001               1282                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001ED8  6600 0012               1283                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001EDC  6000 0002               1284                      BRA        REGTOMEM2            ; loops
00001EE0                          1285  
00001EE0  3C3C 0000               1286  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001EE4  4BF9 00002519           1287                      LEA        MSG_AR,A5            ; loads A to A5
00001EEA  6098                    1288                      BRA        PRINTREGISTERLOOP    ; loops
00001EEC                          1289  
00001EEC  3C3C 0007               1290  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001EF0  4BF9 00002517           1291                      LEA        MSG_DR,A5            ; loads D to A5
00001EF6  608C                    1292                      BRA        PRINTREGISTERLOOP    ; loops
00001EF8                          1293  
00001EF8  4CDF 60E0               1294  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001EFC                          1295  
00001EFC                          1296                          
00001EFC                          1297  * Checks if EA or Xn is valid
00001EFC                          1298  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001EFC                          1299  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001EFC  2F02                    1300  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001EFE                          1301  
00001EFE  141D                    1302  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001F00  B43C 00FF               1303                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001F04  6700 000A               1304                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001F08  B202                    1305                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001F0A  6700 000C               1306                     BEQ        VALIDEA               ; branches to valid EA
00001F0E  60EE                    1307                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001F10                          1308                     
00001F10  323C 0001               1309  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001F14  6000 0016               1310                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001F18                          1311                    
00001F18  B43C 0007               1312  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001F1C  6700 000A               1313                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001F20  323C 0000               1314                     MOVE.W     #$0,D1                ; marks that it is valid
00001F24  6000 0006               1315                     BRA        CHECKEAEXIT           ; exits the subroutine
00001F28                          1316  
00001F28  323C 0002               1317  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001F2C                          1318  
00001F2C  241F                    1319  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001F2E  4E75                    1320                     RTS                              ; returns from subroutine
00001F30                          1321  
00001F30                          1322  * Converts EA and Xn into a string                                
00001F30                          1323  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001F30                          1324  * Outputs: Prints out EA and Xn into a string
00001F30  48E7 C004               1325  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001F34  B47C 0001               1326                     CMP.W    #An,D2                  ; checks if it is An
00001F38  6700 003A               1327                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001F3C                          1328                     
00001F3C  B47C 0002               1329                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001F40  6700 004A               1330                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001F44                          1331                     
00001F44  B47C 0003               1332                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001F48  6700 0072               1333                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001F4C                          1334                     
00001F4C  B47C 0004               1335                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001F50  6700 00A6               1336                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001F54                          1337                     
00001F54  B47C 0007               1338                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001F58  6700 00DA               1339                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001F5C                          1340                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001F5C                          1341  
00001F5C                          1342  * data register, Dn
00001F5C  4BF9 00002517           1343  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001F62  4EB9 000021F6           1344                     JSR      PRINTNULL               ; Prints D
00001F68  3203                    1345                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F6A  4EB9 000020AC           1346                     JSR      PRINTNUM                ; Prints the Xn
00001F70  6000 0134               1347                     BRA      EA_TO_STRING_EXIT       ; exits           
00001F74                          1348  
00001F74                          1349  
00001F74                          1350  * address register
00001F74  4BF9 00002519           1351  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001F7A  4EB9 000021F6           1352                     JSR      PRINTNULL               ; Prints A
00001F80  3203                    1353                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F82  4EB9 000020AC           1354                     JSR      PRINTNUM                ; Prints the Xn
00001F88  6000 011C               1355                     BRA      EA_TO_STRING_EXIT       ; exits
00001F8C                          1356  
00001F8C                          1357  * address register indirect
00001F8C  4BF9 0000251B           1358  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001F92  4EB9 000021F6           1359                     JSR      PRINTNULL               ; Prints (
00001F98  4BF9 00002519           1360                     LEA      MSG_AR,A5               ; Loads A into A5
00001F9E  4EB9 000021F6           1361                     JSR      PRINTNULL               ; Prints A
00001FA4  3203                    1362                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FA6  4EB9 000020AC           1363                     JSR      PRINTNUM                ; Prints the Xn
00001FAC  4BF9 0000251D           1364                     LEA      MSG_RB,A5               ; Loads ) into A5
00001FB2  4EB9 000021F6           1365                     JSR      PRINTNULL               ; Prints )
00001FB8  6000 00EC               1366                     BRA      EA_TO_STRING_EXIT       ; exits
00001FBC                          1367  
00001FBC                          1368  * address register indirect post increment
00001FBC  4BF9 0000251B           1369  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001FC2  4EB9 000021F6           1370                     JSR      PRINTNULL               ; Prints (
00001FC8  4BF9 00002519           1371                     LEA      MSG_AR,A5               ; Loads A into A5
00001FCE  4EB9 000021F6           1372                     JSR      PRINTNULL               ; Prints A
00001FD4  3203                    1373                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FD6  4EB9 000020AC           1374                     JSR      PRINTNUM                ; Prints the Xn
00001FDC  4BF9 0000251D           1375                     LEA      MSG_RB,A5               ; Loads ) into A5
00001FE2  4EB9 000021F6           1376                     JSR      PRINTNULL               ; Prints )
00001FE8  4BF9 0000251F           1377                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001FEE  4EB9 000021F6           1378                     JSR      PRINTNULL               ; Prints +
00001FF4  6000 00B0               1379                     BRA      EA_TO_STRING_EXIT       ; exits
00001FF8                          1380  
00001FF8                          1381  
00001FF8                          1382  * address register indirect pre increment
00001FF8  4BF9 00002521           1383  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001FFE  4EB9 000021F6           1384                     JSR      PRINTNULL               ; Prints -
00002004  4BF9 0000251B           1385                     LEA      MSG_LB,A5               ; Loads ( into A5
0000200A  4EB9 000021F6           1386                     JSR      PRINTNULL               ; Prints (
00002010  4BF9 00002519           1387                     LEA      MSG_AR,A5               ; Loads A into A5
00002016  4EB9 000021F6           1388                     JSR      PRINTNULL               ; Prints A
0000201C  3203                    1389                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000201E  4EB9 000020AC           1390                     JSR      PRINTNUM                ; Prints the Xn
00002024  4BF9 0000251D           1391                     LEA      MSG_RB,A5               ; Loads ) into A5
0000202A  4EB9 000021F6           1392                     JSR      PRINTNULL               ; Prints )
00002030  6000 0074               1393                     BRA      EA_TO_STRING_EXIT       ; exits
00002034                          1394  
00002034                          1395  * other (long, short, immediate) with Xn yes
00002034  301A                    1396  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00002036  B67C 0000               1397                     CMP.W    #ABSShort,D3            ; checks if it is a word
0000203A  6700 002E               1398                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
0000203E                          1399                     
0000203E  B67C 0001               1400                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00002042  6700 0042               1401                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00002046                          1402  
00002046                          1403  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00002046                          1404  * immediate
00002046  4BF9 00002523           1405  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
0000204C  4EB9 000021F6           1406                     JSR      PRINTNULL               ; Prints #  
00002052  4BF9 00002525           1407                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002058  4EB9 000021F6           1408                     JSR      PRINTNULL               ; Prints $
0000205E  3200                    1409                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002060  4EB9 000020BC           1410                     JSR      PRINTHEXNUM 
00002066  6000 003E               1411                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
0000206A                          1412                     
0000206A                          1413  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
0000206A                          1414  
0000206A                          1415  * word address
0000206A                          1416  CASE_WORD          
0000206A  4BF9 00002525           1417                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002070  4EB9 000021F6           1418                     JSR      PRINTNULL               ; Prints $
00002076  3200                    1419                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002078  383C 0000               1420                     MOVE.W   #0, D4                  ; moves length size (word) into d4
0000207C  4EB9 000020D0           1421                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002082  6000 0022               1422                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00002086                          1423  
00002086                          1424  * long address 
00002086                          1425  CASE_LONG          
00002086  4BF9 00002525           1426                     LEA      MSG_HEX,A5              ; Loads $ into A5
0000208C  4EB9 000021F6           1427                     JSR      PRINTNULL               ; Prints $
00002092  3200                    1428                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002094  383C 0001               1429                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00002098  4EB9 000020D0           1430                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000209E  321A                    1431                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
000020A0  4EB9 000020AC           1432                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
000020A6                          1433  
000020A6                          1434  
000020A6                          1435  * exits subroutine
000020A6  4CDF 2003               1436  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
000020AA  4E75                    1437                      RTS                              ; returns from subroutine
000020AC                          1438  
000020AC                          1439  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
000020AC                          1440  
000020AC                          1441  * Prints out the content of D1 as a decimal number
000020AC                          1442  * Input: number in D1 to be printed
000020AC                          1443  * Output: contents of D1 printed
000020AC  48E7 C000               1444  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000020B0  103C 0003               1445                   MOVE.B      #3,D0               ; prints D1
000020B4  4E4F                    1446                   TRAP        #15                 ; is trap task 3
000020B6                          1447              
000020B6  4CDF 0003               1448                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000020BA  4E75                    1449                   RTS                             ; returns from subroutine
000020BC                          1450                   
000020BC                          1451  * Prints out the content of D1 as a hex number
000020BC                          1452  * Input: number in D1 to be printed
000020BC                          1453  * Output: contents of D1 printed
000020BC  48E7 C000               1454  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000020C0  143C 0010               1455                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000020C4  103C 000F               1456                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000020C8  4E4F                    1457                   TRAP        #15                 ; is trap task 15
000020CA  4CDF 0003               1458                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000020CE  4E75                    1459                   RTS                             ; returns from subroutine
000020D0                          1460                   
000020D0                          1461  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
000020D0                          1462  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
000020D0                          1463  * Output: contents of D1 printed
000020D0  48E7 E000               1464  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
000020D4  B83C 0001               1465                            CMP.B       #1,D4               ; checks size of number
000020D8  6700 0042               1466                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
000020DC                          1467  
000020DC  3401                    1468  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
000020DE  C47C F000               1469                            AND.W       #$F000,D2           ; gets the first digit
000020E2  B47C 0000               1470                            CMP.W       #0, D2              ; checks if it is 0
000020E6  6600 00DC               1471                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020EA  4EB9 000021D4           1472                            JSR         PRINTZERO           ; prints a zero
000020F0                          1473                            
000020F0  3401                    1474                            MOVE.W      D1,D2               ; copies number to D2
000020F2  C47C 0F00               1475                            AND.W       #$0F00,D2           ; gets the second digit
000020F6  B47C 0000               1476                            CMP.W       #0, D2              ; checks if it is 0
000020FA  6600 00C8               1477                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020FE  4EB9 000021D4           1478                            JSR         PRINTZERO           ; prints a zero
00002104                          1479                            
00002104  3401                    1480                            MOVE.W      D1,D2               ; copies number to D2
00002106  C47C 00F0               1481                            AND.W       #$00F0,D2           ; gets the third digit
0000210A  B47C 0000               1482                            CMP.W       #0, D2              ; checks if it is 0
0000210E  6600 00B4               1483                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002112  4EB9 000021D4           1484                            JSR         PRINTZERO           ; prints a zero
00002118  6000 00AA               1485                            BRA         PRINTASHEX          ; prints last digit
0000211C                          1486                            
0000211C  2401                    1487  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
0000211E  C4BC F0000000           1488                            AND.L       #$F0000000,D2       ; gets the first digit
00002124  B4BC 00000000           1489                            CMP.L       #0, D2              ; checks if it is 0
0000212A  6600 0098               1490                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000212E  4EB9 000021D4           1491                            JSR         PRINTZERO           ; prints a zero
00002134                          1492                            
00002134  2401                    1493                            MOVE.L      D1,D2               ; copies number to D2
00002136  C4BC 0F000000           1494                            AND.L       #$0F000000,D2       ; gets the second digit
0000213C  B4BC 00000000           1495                            CMP.L       #0, D2              ; checks if it is 0
00002142  6600 0080               1496                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002146  4EB9 000021D4           1497                            JSR         PRINTZERO           ; prints a zero
0000214C                          1498                            
0000214C  2401                    1499                            MOVE.L      D1,D2               ; copies number to D2
0000214E  C4BC 00F00000           1500                            AND.L       #$00F00000,D2       ; gets the third digit
00002154  B4BC 00000000           1501                            CMP.L       #0, D2              ; checks if it is 0
0000215A  6600 0068               1502                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000215E  4EB9 000021D4           1503                            JSR         PRINTZERO           ; prints a zero
00002164                          1504                            
00002164  2401                    1505                            MOVE.L      D1,D2               ; copies number to D2
00002166  C4BC 000F0000           1506                            AND.L       #$000F0000,D2       ; gets the fourth digit
0000216C  B4BC 00000000           1507                            CMP.L       #0, D2              ; checks if it is 0
00002172  6600 0050               1508                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002176  4EB9 000021D4           1509                            JSR         PRINTZERO           ; prints a zero
0000217C                          1510                            
0000217C  2401                    1511                            MOVE.L      D1,D2               ; copies number to D2
0000217E  C4BC 0000F000           1512                            AND.L       #$0000F000,D2       ; gets the fith digit
00002184  B4BC 00000000           1513                            CMP.L       #0, D2              ; checks if it is 0
0000218A  6600 0038               1514                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000218E  4EB9 000021D4           1515                            JSR         PRINTZERO           ; prints a zero
00002194                          1516                            
00002194  2401                    1517                            MOVE.L      D1,D2               ; copies number to D2
00002196  C4BC 00000F00           1518                            AND.L       #$00000F00,D2       ; gets the sixth digit
0000219C  B4BC 00000000           1519                            CMP.L       #0, D2              ; checks if it is 0
000021A2  6600 0020               1520                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021A6  4EB9 000021D4           1521                            JSR         PRINTZERO           ; prints a zero
000021AC                          1522                            
000021AC  2401                    1523                            MOVE.L      D1,D2               ; copies number to D2
000021AE  C4BC 000000F0           1524                            AND.L       #$000000F0,D2       ; gets the seventh digit
000021B4  B4BC 00000000           1525                            CMP.L       #0, D2              ; checks if it is 0
000021BA  6600 0008               1526                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021BE  4EB9 000021D4           1527                            JSR         PRINTZERO           ; prints a zero
000021C4                          1528  
000021C4  143C 0010               1529  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000021C8  103C 000F               1530                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000021CC  4E4F                    1531                            TRAP        #15                 ; is trap task 15
000021CE  4CDF 0007               1532                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
000021D2  4E75                    1533                            RTS                             ; returns from subroutine    
000021D4                          1534  * Prints a zero
000021D4                          1535  * Input: nothing
000021D4                          1536  * Output: 0 printed out to the console
000021D4  2F01                    1537  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
000021D6  7200                    1538                            MOVE.L      #0,D1               ; moves 0 to D1
000021D8  4EB8 20AC               1539                            JSR         PRINTNUM            ; prints the number
000021DC  221F                    1540                            MOVE.L      (SP)+,D1            ; restores D1
000021DE  4E75                    1541                            RTS                             ; returns from subroutine
000021E0                          1542              
000021E0                          1543  * Prints contents of things between a range
000021E0                          1544  * input: A5, A6 (the range)
000021E0                          1545  * output: prints memory contents from A5 to A6 as strings   
000021E0  48E7 C040               1546  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
000021E4  224D                    1547                  MOVEA.L     A5, A1           ; loads A5 into A1
000021E6  9DCD                    1548                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
000021E8  320E                    1549                  MOVE.W      A6, D1           ; move n into D1
000021EA  103C 0001               1550                  MOVE.B      #1, D0           ; display n characters of string at A1
000021EE  4E4F                    1551                  TRAP        #15              ; is trap task 1
000021F0  4CDF 0203               1552                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
000021F4  4E75                    1553                  RTS                          ; returns
000021F6                          1554      
000021F6                          1555  * Prints null terminated string
000021F6                          1556  * input: string pointed to by A5
000021F6                          1557  * output: prints out the null terminated string
000021F6  48E7 8040               1558  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
000021FA  224D                    1559                  MOVE.L      A5,A1           ; loads A5 into A1
000021FC  103C 000E               1560                  MOVE.B      #14,D0          ; prints null terminated string
00002200  4E4F                    1561                  TRAP        #15             ; is trap task 10
00002202  4CDF 0201               1562                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00002206  4E75                    1563                  RTS                         ; returns from subroutine
00002208                          1564                  
00002208  2F0D                    1565  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
0000220A  4BF9 00002456           1566                  LEA         NEW_LINE,A5     ; Prints null
00002210  4EB8 21F6               1567                  JSR         PRINTNULL       ; prints the new line
00002214  2A5F                    1568                  MOVE.L      (SP)+,A5        ; returns A5
00002216  4E75                    1569                  RTS
00002218                          1570  
00002218                          1571  * Prints the size of the MOVE or MOVEA operation  
00002218                          1572  * input: D0
00002218                          1573  * output: prints out the size of a MOVE or MOVEA operation        
00002218  48E7 8004               1574  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
0000221C  3200                    1575                  MOVE.W  D0,D1               ; stores d0 in d1
0000221E  C07C 3000               1576                  AND.W   #$3000,D0           ; gets the size
00002222  B07C 2000               1577                  CMP.W   #$2000,D0           ; checks if is long
00002226  6700 001E               1578                  BEQ     MOVE_LONG
0000222A  B07C 3000               1579                  CMP.W   #$3000,D0           ; checks if is word
0000222E  6700 000C               1580                  BEQ     MOVE_WORD      
00002232                          1581                  
00002232  4BF9 0000254E           1582  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00002238  6000 0012               1583                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000223C                          1584  
0000223C  4BF9 00002551           1585  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00002242  6000 0008               1586                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002246                          1587  
00002246  4BF9 00002554           1588  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
0000224C                          1589                  
0000224C  4EB8 21F6               1590  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00002250  4CDF 2001               1591                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00002254  4E75                    1592                  RTS
00002256                          1593  
00002256  43F9 000023C5           1594  ERROR           LEA     ERROR_MSG,A1
0000225C  103C 000E               1595                  MOVE.B  #14,D0
00002260  4E4F                    1596                  TRAP    #15   
00002262                          1597            
00002262  FFFF FFFF               1598      SIMHALT             ; halt simulator
00002266                          1599  
00002266                          1600  * Put variables and constants here
00002266                          1601  
00002266  =0000000D               1602  CR                              EQU     $0D
00002266  =0000000A               1603  LF                              EQU     $0A 
00002266  =00000009               1604  TAB                             EQU     $09  
00002266                          1605  
00002266                          1606  * Addressing Modes
00002266  =00000000               1607  Dn                              EQU     0
00002266  =00000001               1608  An                              EQU     1
00002266  =00000002               1609  AnIndirect                      EQU     2
00002266  =00000003               1610  AnPost                          EQU     3
00002266  =00000004               1611  AnPre                           EQU     4
00002266  =00000007               1612  Other                           EQU     7           ; short, long, immediate
00002266                          1613  
00002266                          1614  * Xn
00002266  =00000000               1615  ABSShort                        EQU     0
00002266  =00000001               1616  ABSLong                         EQU     1
00002266  =00000004               1617  XnImmediate                     EQU     4
00002266                          1618  
00002266                          1619  * Valid Addressing Modes
00002266= 00 01 02 03 04 07 FF    1620  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
0000226D                          1621  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
0000226D= 00 02 03 04 07 FF       1622  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002273= 02 04 07 FF             1623  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002277= 02 03 07 FF             1624  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000227B= 02 03 04 07 FF          1625  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002280= 00 02 03 04 07 FF       1626  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002286= 01 07 FF                1627  VALIDEA_LEA                     DC.B    An,Other,-1
00002289= 00 02 03 04 07 FF       1628  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000228F= 02 03 04 07 FF          1629  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002294= 02 03 04 07 FF          1630  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00002299= 02 07 FF                1631  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
0000229C                          1632  
0000229C                          1633  * Valid Xn
0000229C= 00 01 04 FF             1634  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
000022A0                          1635  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
000022A0= 00 01 FF                1636  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
000022A3                          1637  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
000022A3                          1638  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
000022A3                          1639  
000022A3                          1640  * posible memory ASd/LSd rotation values
000022A3  =00000000               1641  ASd_MEM                         EQU     0   
000022A3  =00000001               1642  LSd_MEM                         EQU     1 
000022A3  =00000003               1643  ROd_MEM                         EQU     3
000022A3                          1644   
000022A3  =00000000               1645  ASd_REG                         EQU     0   
000022A3  =00000001               1646  LSd_REG                         EQU     1 
000022A3  =00000003               1647  ROd_REG                         EQU     3
000022A3                          1648  
000022A3                          1649  * Messages
000022A3= 57 65 6C 63 6F 6D ...   1650  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
000022CB= 46 6F 72 6D 61 74 ...   1651  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
00002316= 4C 65 74 74 65 72 ...   1652  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
00002336= 50 6C 65 61 73 65 ...   1653  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
0000236D= 50 6C 65 61 73 65 ...   1654  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
000023A3= 49 6E 76 61 6C 69 ...   1655  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
000023C5= 45 72 72 6F 72 20 ...   1656  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
000023E1= 09 44 41 54 41 00       1657  INVALID_INSTR                   DC.B    TAB,'DATA',0
000023E7= 46 69 6E 69 73 68 ...   1658  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
0000242B= 0D 0A 50 72 65 73 ...   1659  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
00002456= 0D 0A 00                1660  NEW_LINE                        DC.B    CR,LF,0
00002459= 09 09 09 00             1661  THREE_TAB                       DC.B    TAB,TAB,TAB,0
0000245D                          1662  
0000245D                          1663  * Opcode Messages
0000245D= 09 4E 4F 50 00          1664  MSG_NOP                         DC.B    TAB,'NOP',0
00002462= 09 4D 4F 56 45 00       1665  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00002468= 09 4D 4F 56 45 41 00    1666  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
0000246F= 09 4D 4F 56 45 51 00    1667  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00002476= 09 4D 4F 56 45 4D 00    1668  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
0000247D= 09 41 44 44 00          1669  MSG_ADD                         DC.B    TAB,'ADD',0
00002482= 09 41 44 44 41 00       1670  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002488= 09 41 44 44 51 00       1671  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
0000248E= 09 53 55 42 00          1672  MSG_SUB                         DC.B    TAB,'SUB',0
00002493= 09 4D 55 4C 53 00       1673  MSG_MULS                        DC.B    TAB,'MULS',0
00002499= 09 44 49 56 55 00       1674  MSG_DIVU                        DC.B    TAB,'DIVU',0
0000249F= 09 4C 45 41 00          1675  MSG_LEA                         DC.B    TAB,'LEA',0
000024A4= 09 41 4E 44 00          1676  MSG_AND                         DC.B    TAB,'AND',0
000024A9= 09 4F 52 00             1677  MSG_OR                          DC.B    TAB,'OR',0
000024AD= 09 4E 4F 54 00          1678  MSG_NOT                         DC.B    TAB,'NOT',0
000024B2= 09 4C 53 00             1679  MSG_LSd                         DC.B    TAB,'LS',0
000024B6= 09 41 53 00             1680  MSG_ASd                         DC.B    TAB,'AS',0
000024BA= 09 52 4F 00             1681  MSG_ROd                         DC.B    TAB,'RO',0
000024BE= 09 42 43 43 00          1682  MSG_BCC                         DC.B    TAB,'BCC',0
000024C3= 09 42 43 53 00          1683  MSG_BCS                         DC.B    TAB,'BCS',0
000024C8= 09 42 45 51 00          1684  MSG_BEQ                         DC.B    TAB,'BEQ',0
000024CD= 09 42 4E 45 00          1685  MSG_BNE                         DC.B    TAB,'BNE',0
000024D2= 09 42 47 45 00          1686  MSG_BGE                         DC.B    TAB,'BGE',0
000024D7= 09 42 47 54 00          1687  MSG_BGT                         DC.B    TAB,'BGT',0
000024DC= 09 42 48 49 00          1688  MSG_BHI                         DC.B    TAB,'BHI',0
000024E1= 09 42 4C 45 00          1689  MSG_BLE                         DC.B    TAB,'BLE',0
000024E6= 09 42 4C 53 00          1690  MSG_BLS                         DC.B    TAB,'BLS',0
000024EB= 09 42 4C 54 00          1691  MSG_BLT                         DC.B    TAB,'BLT',0
000024F0= 09 42 4D 49 00          1692  MSG_BMI                         DC.B    TAB,'BMI',0
000024F5= 09 42 50 4C 00          1693  MSG_BPL                         DC.B    TAB,'BPL',0
000024FA= 09 42 56 43 00          1694  MSG_BVC                         DC.B    TAB,'BVC',0
000024FF= 09 42 56 53 00          1695  MSG_BVS                         DC.B    TAB,'BVS',0
00002504= 09 4A 53 52 00          1696  MSG_JSR                         DC.B    TAB,'JSR',0
00002509= 09 52 54 53 00          1697  MSG_RTS                         DC.B    TAB,'RTS',0
0000250E= 09 42 52 41 00          1698  MSG_BRA                         DC.B    TAB,'BRA',0
00002513                          1699  
00002513                          1700  * Direction for LSd and ASd
00002513= 52 00                   1701  MSG_RIGHT                       DC.B    'R',0
00002515= 4C 00                   1702  MSG_LEFT                        DC.B    'L',0
00002517                          1703  
00002517                          1704  * Effective Addresses Messages
00002517= 44 00                   1705  MSG_DR                          DC.B    'D',0
00002519= 41 00                   1706  MSG_AR                          DC.B    'A',0
0000251B= 28 00                   1707  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
0000251D= 29 00                   1708  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
0000251F= 2B 00                   1709  MSG_PLUS                        DC.B    '+',0
00002521= 2D 00                   1710  MSG_MINUS                       DC.B    '-',0
00002523= 23 00                   1711  MSG_POUND                       DC.B    '#',0 
00002525= 24 00                   1712  MSG_HEX                         DC.B    '$',0 
00002527= 2C 20 00                1713  MSG_COMMA                       DC.B    ', ',0
0000252A= 2F 00                   1714  MSG_SLASH                       DC.B    '/',0  
0000252C= 20 00                   1715  MSG_SPACE                       DC.B    ' ',0
0000252E= 09 00                   1716  MSG_TAB                         DC.B    TAB,0
00002530= 20 20 20 00             1717  MSG_3SPACES                     DC.B    '   ',0
00002534= 20 20 20 20 00          1718  MSG_4SPACES                     DC.B    '    ',0
00002539= 20 20 20 20 20 00       1719  MSG_5SPACES                     DC.B    '     ',0
0000253F= 20 20 20 20 20 20 00    1720  MSG_6SPACES                     DC.B    '      ',0
00002546= 20 20 20 20 20 20 ...   1721  MSG_7SPACES                     DC.B    '       ',0
0000254E                          1722  
0000254E                          1723  * Size Messages
0000254E= 2E 42 00                1724  MSG_B                           DC.B    '.B',0
00002551= 2E 57 00                1725  MSG_W                           DC.B    '.W',0
00002554= 2E 4C 00                1726  MSG_L                           DC.B    '.L',0
00002557                          1727  
00002557                          1728  * Variables
00002557  =00000100               1729  STARTING_ADDRESS                EQU     $100
00002557  =00000150               1730  ENDING_ADDRESS                  EQU     $150
00002557  =00000200               1731  CURRENT_INSTR                   EQU     $200
00002557  =00000250               1732  REG_VAR                         EQU     $250 * Hold bits 11-9
00002557  =00000300               1733  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00002557  =00000350               1734  EA_MODE                         EQU     $350 * Hold bits 5-3
00002557  =00000400               1735  EA_REG                          EQU     $400 * Hold bits 2-0
00002557= 00                      1736  LINE_COUNT                      DC.B     0
00002558= 14                      1737  LINE_MAX                        DC.B     20
00002559                          1738              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           164C
ADDQ_BYTE           16EA
ADDQ_LONG           1722
ADDQ_WORD           1706
ADD_SUB_BYTE        157C
ADD_SUB_HELP        14F6
ADD_SUB_LONG        1598
ADD_SUB_OPERAND     15AE
ADD_SUB_SIZE        1558
ADD_SUB_WORD        158A
AN                  1
AND_BYTE            1908
AND_LONG            1940
AND_WORD            1924
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           23A3
CASE_ADD            14CE
CASE_ADDA           1614
CASE_ADDQ           1694
CASE_AND            18C2
CASE_AR             1F74
CASE_ARI            1F8C
CASE_ARIPOST        1FBC
CASE_ARIPRE         1FF8
CASE_ASDMEM         1AA8
CASE_ASDREG         1B7C
CASE_BCC            1CE4
CASE_BEQ            1D16
CASE_BGT            1D2A
CASE_BLE            1D20
CASE_BRA            1CB4
CASE_DATA           1D66
CASE_DR             1F5C
CASE_EPICFAIL       1D6C
CASE_IMMEDIATE      2046
CASE_JSR            1D50
CASE_LEA            1824
CASE_LEFTMEM        1ACE
CASE_LEFTREG        1BA2
CASE_LONG           2086
CASE_LSDASDROD      1A68
CASE_LSDMEM         1A9E
CASE_LSDREG         1B72
CASE_MOVE           1296
CASE_MOVEM          135C
CASE_MOVEQ          146E
CASE_NOP            1280
CASE_NOT            1A04
CASE_OR             19A4
CASE_OTHER          2034
CASE_RIGHTMEM       1AD8
CASE_RIGHTREG       1BAC
CASE_RODMEM         1AB2
CASE_RODREG         1B86
CASE_RTS            1D50
CASE_SHIFTMEM       1A86
CASE_SHIFTREG       1B58
CASE_SUB            178C
CASE_SUBA           180E
CASE_WORD           206A
CHECKEAEXIT         1F2C
CHECKEAMLOOP        1EFE
CHECKEAXN_IFVALID   1EFC
CHECKGET_EAXN       1DC2
CHECKMEMSOURE       1B18
CHECKMOREBITS       1EAE
CHECKSHIFT_XN       1B42
CHECK_LENGTH        11CE
CHECK_LINE          1176
CHECK_ODD           1264
CHECK_ORDER         10AE
CHECK_XN            1DF2
CLEAR_SCREEN        11AA
COMPLETE_REGIM      1C24
CONCAT              1216
CONTINUE            242B
CONVERT             11E0
CR                  D
CURRENT_INSTR       200
DESTEA              1D78
DESTXN              1DA2
DISASSEMBLE         10C4
DN                  0
DN_PLUS_EA          15E8
DONE                23E7
DONEPRINTINGREG     1EF8
EASHIFT_VALID       1B36
EAXN_INVALID        1E04
EAXN_VALID          1DEA
EA_MODE             350
EA_REG              400
EA_TO_STRING        1F30
EA_TO_STRING_EXIT   20A6
ENDING              236D
ENDING_ADDRESS      150
END_CHECKGET        1E08
ERROR               2256
ERROR_MSG           23C5
FINDTYPEEA          1D8C
FINDTYPEXN          1DB6
FINISHED            10E8
FINISHMOVE          224C
FINISH_ADD          15A6
FINISH_ADDA         1668
FINISH_ADDQ         173E
FINISH_AND          195C
FINISH_SUB          17D4
FINISH_SUBA         17DA
FORMAT1             22CB
FORMAT2             2316
GETDIRECTION        1E42
GETDISPLACEMENT     1E0A
GETMEMSOURCE        1B00
GETROTATION         1E38
GETROTATIONLOCATION  1E52
GETROTATIONSIZE     1E4A
GET_EA              1D6E
GET_XN              1D98
INPUT1              1020
INPUT2              1066
INSERTA             131C
INVALID             122E
INVALIDEA           1F10
INVALID_INSTR       23E1
INV_INSTR           1966
ISNUMBER            11F6
LF                  A
LINE_COUNT          2557
LINE_MAX            2558
LSD_MEM             1
LSD_REG             1
MAKESHIFT8          1C20
MEM2REGLONG         1432
MEM2REGWORD         1422
MEMTOREG1           1E7A
MEMTOREG2           1EEC
MOVEM_MEM2REG       13EE
MOVEM_REG2MEM       137A
MOVE_BYTE           2232
MOVE_LONG           2246
MOVE_WORD           223C
MSG_3SPACES         2530
MSG_4SPACES         2534
MSG_5SPACES         2539
MSG_6SPACES         253F
MSG_7SPACES         2546
MSG_ADD             247D
MSG_ADDA            2482
MSG_ADDQ            2488
MSG_AND             24A4
MSG_AR              2519
MSG_ASD             24B6
MSG_B               254E
MSG_BCC             24BE
MSG_BCS             24C3
MSG_BEQ             24C8
MSG_BGE             24D2
MSG_BGT             24D7
MSG_BHI             24DC
MSG_BLE             24E1
MSG_BLS             24E6
MSG_BLT             24EB
MSG_BMI             24F0
MSG_BNE             24CD
MSG_BPL             24F5
MSG_BRA             250E
MSG_BVC             24FA
MSG_BVS             24FF
MSG_COMMA           2527
MSG_DIVU            2499
MSG_DR              2517
MSG_HEX             2525
MSG_JSR             2504
MSG_L               2554
MSG_LB              251B
MSG_LEA             249F
MSG_LEFT            2515
MSG_LSD             24B2
MSG_MINUS           2521
MSG_MOVE            2462
MSG_MOVEA           2468
MSG_MOVEM           2476
MSG_MOVEQ           246F
MSG_MULS            2493
MSG_NOP             245D
MSG_NOT             24AD
MSG_OR              24A9
MSG_PLUS            251F
MSG_POUND           2523
MSG_RB              251D
MSG_RIGHT           2513
MSG_ROD             24BA
MSG_RTS             2509
MSG_SLASH           252A
MSG_SPACE           252C
MSG_SUB             248E
MSG_TAB             252E
MSG_W               2551
NEW_LINE            2456
NEXT_SCREEN         118A
NOTNUMBER           11FE
OPCODE_DECODE       1278
OPMODE_VAR          300
OR_SIZE             19EC
OTHER               7
OTHEREA             1F28
PRINTADD            1534
PRINTADDRESS        1E1A
PRINTASHEX          21C4
PRINTBCC            1D34
PRINTENTER          2208
PRINTHEXNUM         20BC
PRINTLONGZERO       211C
PRINTMEM2REG        143E
PRINTMORE           1EBA
PRINTMOVE           133A
PRINTMOVESIZE       2218
PRINTNULL           21F6
PRINTNUM            20AC
PRINTRANGE          21E0
PRINTREG            1EA0
PRINTREG2MEM        13BE
PRINTREGEA          1BEE
PRINTREGISTERLOOP   1E84
PRINTREGISTERS      1E5A
PRINTREGSIZE        1BBC
PRINTSHIFTMEM       1AB8
PRINTSHIFTREG       1B8C
PRINTSHORTLONGNUM   20D0
PRINTSHORTZERO      20DC
PRINTSUB            17A2
PRINTZERO           21D4
PRINT_8             1780
PRINT_ADDQ_DATA     175C
PRINT_ADDR          126C
PRINT_MEMDIR        1ADE
PRINT_MOVEQ         1490
PRINT_REGDIR        1BB6
READ_KEY            119A
REG2MEMLONG         13B8
REG2MEMWORD         13AE
REGTOMEM1           1E6C
REGTOMEM2           1EE0
REG_BYTE            1BD4
REG_IMMEDIATE       1C10
REG_LONG            1BE8
REG_REGISTER        1C6E
REG_VAR             250
REG_WORD            1BDE
RESET_INPUT         11C6
RESTART             1110
RETURN              122C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1D84
SOURCEXN            1DAE
START               1000
STARTING            2336
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          124C
THREE_TAB           2459
VALIDEA             1F18
VALIDEA_ADDSUB_DESTOPERAND  227B
VALIDEA_ALL         2266
VALIDEA_ANDORNOT    2289
VALIDEA_ANDOR_DESTOPERAND  228F
VALIDEA_JSR         2299
VALIDEA_LEA         2286
VALIDEA_MOVEM_MEMTOREG  2277
VALIDEA_MOVEM_REGTOMEM  2273
VALIDEA_MOVEQ       226D
VALIDEA_MULSDIVU    2280
VALIDEA_SHIFT       2294
VALIDXN_ALL         229C
VALIDXN_SHORTLONG   22A0
WELCOME             22A3
XNIMMEDIATE         4
