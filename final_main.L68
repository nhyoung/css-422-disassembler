00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/8/2020 3:46:22 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 0000214D             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 00002175             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 000021C0             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000021E0             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 00001146             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 00001158             36                  JSR     CONVERT
00001052  4EB9 000011C4             37                  JSR     TEST_RANGE
00001058  4EB9 000011DC             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 00002217             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 00001146             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 00001158             55                  JSR     CONVERT
0000109A  4EB9 000011C4             56                  JSR     TEST_RANGE
000010A0  4EB9 000011DC             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0088                 64                  BLT     RESET_INPUT
000010B8                            65                                 
000010B8                            66  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010B8                            67                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010B8                            68                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010B8  4EB9 000011F0             69                  JSR     OPCODE_DECODE       ; decode the opcode
000010BE  4EB9 00002076             70                  JSR     PRINTENTER          ; prints a new line
000010C4  B5CB                      71                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010C6  6FF0                      72                  BLE     DISASSEMBLE         ; if not, loop
000010C8                            73  
000010C8  4BF9 0000229A             74  FINISHED        LEA     DONE,A5
000010CE  4EB9 00002064             75                  JSR     PRINTNULL
000010D4  103C 0005                 76                  MOVE.B  #5,D0
000010D8  4E4F                      77                  TRAP    #15
000010DA                            78                  
000010DA  B23C 000D                 79                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010DE  6700 0008                 80                  BEQ     RESTART             ; it's Enter, restart
000010E2                            81                  
000010E2  103C 0009                 82                  MOVE.B  #9,D0
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  103C 000B                 85  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010EC  323C FF00                 86                  MOVE.W  #$FF00, D1          Clear Screen
000010F0  4E4F                      87                  TRAP    #15                 Call Trap
000010F2                            88                  
000010F2  103C 000C                 89                  MOVE.B  #12,D0              Keyboard echo
000010F6  123C 0001                 90                  MOVE.B  #1,D1               Visible
000010FA  4E4F                      91                  TRAP    #15
000010FC                            92                  
000010FC  207C 00000000             93                  MOVE.L  #$0000000, A0       ; Reset A1
00001102  227C 00000000             94                  MOVE.L  #$0000000, A1       ; Reset A1
00001108  247C 00000000             95                  MOVE.L  #$0000000, A2       ; Reset A2
0000110E  267C 00000000             96                  MOVE.L  #$0000000, A3       ; Reset A3
00001114  287C 00000000             97                  MOVE.L  #$0000000, A4       ; Reset A4
0000111A  2A7C 00000000             98                  MOVE.L  #$0000000, A5       ; Reset A5
00001120  2C7C 00000000             99                  MOVE.L  #$0000000, A6       ; Reset A6
00001126  2E7C 01000000            100                  MOVEA.L #$01000000,A7       ; Reset A7
0000112C  4281                     101                  CLR.L   D1                  ; Reset D1
0000112E  4281                     102                  CLR.L   D1                  ; Reset D1
00001130  4282                     103                  CLR.L   D2                  ; Reset D2
00001132  4283                     104                  CLR.L   D3                  ; Reset D3
00001134  4284                     105                  CLR.L   D4                  ; Reset D4
00001136  4285                     106                  CLR.L   D5                  ; Reset D5
00001138  4286                     107                  CLR.L   D6                  ; Reset D6
0000113A  6000 FEC4                108                  BRA     START               ; branch to start of program
0000113E                           109  
0000113E                           110  *--------------------SUBROUTINES------------------    
0000113E                           111  
0000113E  143C 0001                112  RESET_INPUT     MOVE.B  #1,D2
00001142  6000 0062                113                  BRA     INVALID            
00001146                           114                  
00001146  7800                     115  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001148  B204                     116                  CMP.B   D4,D1               ; D1 stores length
0000114A  6700 005A                117                  BEQ     INVALID             ; input is null
0000114E  0C41 0008                118                  CMPI    #$8,D1              ; check if input is longer than a longword
00001152  6600 0052                119                  BNE     INVALID             ; input is longer than a longword
00001156  4E75                     120                  RTS
00001158                           121                              
00001158  4283                     122  CONVERT         CLR.L   D3
0000115A  4284                     123                  CLR.L   D4
0000115C  1619                     124                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000115E  B63C 0039                125                  CMP.B   #57,D3
00001162  6E00 0012                126                  BGT     NOTNUMBER
00001166                           127                  
00001166  B63C 002F                128                  CMP.B   #47,D3
0000116A  6E00 0002                129                  BGT     ISNUMBER
0000116E                           130                  
0000116E  0603 00D0                131  ISNUMBER        ADD.B   #-48,D3             ; current char is number
00001172  6000 001A                132                  BRA     CONCAT
00001176                           133              
00001176  B63C 0041                134  NOTNUMBER       CMP.B   #65,D3
0000117A  6D00 002A                135                  BLT     INVALID
0000117E  B63C 0046                136                  CMP.B   #70,D3
00001182  6E00 0022                137                  BGT     INVALID  
00001186  0603 00C9                138                  ADD.B   #-55,D3             ; is letter             
0000118A  6000 0002                139                  BRA     CONCAT
0000118E                           140              
0000118E  BC3C 0000                141  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001192  6D00 0010                142                  BLT     RETURN
00001196  1806                     143                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001198  E50C                     144                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
0000119A  E9AB                     145                  LSL.L   D4,D3               ; moves current char to correct position  
0000119C  DA83                     146                  ADD.L   D3,D5               ; D5 stores converted input so far
0000119E  0606 00FF                147                  ADD.B   #-1,D6  
000011A2  60B4                     148                  BRA     CONVERT             ; continue loop for remaining chars
000011A4                           149                  
000011A4  4E75                     150  RETURN          RTS
000011A6                           151                  
000011A6  227C 00000000            152  INVALID         MOVEA.L #$0000000, A1       ; clear A1
000011AC  43F9 0000224D            153                  LEA     BAD_INPUT,A1        ; output invalid message
000011B2  103C 000E                154                  MOVE.B  #14,D0
000011B6  4E4F                     155                  TRAP    #15
000011B8  B47C 0001                156                  CMP     #1,D2
000011BC  6700 FE62                157                  BEQ     INPUT1
000011C0  6000 FEA4                158                  BRA     INPUT2
000011C4                           159  
000011C4  4284                     160  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011C6  223C 00001000            161                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011CC  BA81                     162                  CMP.L      D1,D5            ; Compare minimum address with input
000011CE  6DD6                     163                  BLT        INVALID          ; input is too low. 
000011D0  223C 00FFFFFE            164                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011D6  BA81                     165                  CMP.L      D1,D5            ; compare maximum address with input
000011D8  6ECC                     166                  BGT        INVALID          ; input too large
000011DA  4E75                     167                  RTS                         ; input is within range
000011DC                           168             
000011DC  0805 0000                169  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011E0  66C4                     170                  BNE        INVALID
000011E2  4E75                     171                  RTS
000011E4                           172  
000011E4                           173  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
000011E4                           174  *                MOVE.L  A6,D1                   ; loads current address in D1
000011E4                           175  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E4                           176  *                JSR     PRINTSHORTLONGNUM       ; prints out address
000011E4                           177  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
000011E4                           178  *                RTS
000011E4  220E                     179                  MOVE.L  A6,D1                   ; loads current address in D1
000011E6  7801                     180                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E8  4EB9 00001F3E            181                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011EE  4E75                     182                  RTS
000011F0                           183  
000011F0                           184  
000011F0                           185  
000011F0                           186  * Checks every single possible opcode we could have. Jump table
000011F0                           187  * Inputs: (A2) which is a pointer to intruction word to be translated
000011F0                           188  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011F0                           189  
000011F0  3C4A                     190  OPCODE_DECODE   MOVE.W  A2,A6
000011F2  301A                     191                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011F4                           192                  
000011F4                           193  
000011F4                           194  *---------------NOP opcode----------------------                
000011F4  B07C 4E71                195  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011F8  6600 0014                196                  BNE     CASE_MOVE               ; checks the next case if not equal
000011FC                           197                  
000011FC  4EB8 11E4                198                  JSR     PRINT_ADDR
00001200  4BF9 000022D3            199                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001206  4EB9 00002064            200                  JSR     PRINTNULL               ; prints NOP                
0000120C  4E75                     201                  RTS                             ; returns from the subroutine
0000120E                           202  
0000120E                           203  *---------------MOVE opcode----------------------              
0000120E                           204                  * if first two bits are 00, next two are not 00
0000120E  3200                     205  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001210  C27C C000                206                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001214  6600 009E                207                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001218  B07C 0FFF                208                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
0000121C  6F00 0096                209                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001220                           210                  
00001220                           211                  ; Check source
00001220  4BF9 00002110            212                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001226  4DF9 00002146            213                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000122C  3E3C 0000                214                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001230  4EB9 00001C30            215                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001236  B27C 0001                216                  CMP.W   #1,D1                    ; checks if invalid
0000123A  6700 0998                217                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000123E  3802                     218                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
00001240  3A03                     219                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001242                           220                  
00001242                           221                  ; Check destination
00001242  4BF9 00002110            222                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001248  4DF9 0000214A            223                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000124E  3E3C 0001                224                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001252  4EB9 00001C30            225                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001258  B27C 0001                226                  CMP.W   #1,D1                    ; checks if invalid
0000125C  6700 0976                227                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001260  3C02                     228                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001262  3E03                     229                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001264                           230                  
00001264                           231                  ; Checking if it is MOVEA
00001264  3200                     232                  MOVE.W  D0,D1                    ; stores d0 in d1
00001266  C27C 01C0                233                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
0000126A  B27C 0040                234                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000126E  6700 0010                235                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001272                           236                  
00001272  4EB8 11E4                237                  JSR     PRINT_ADDR               ; print address
00001276  4BF9 000022D8            238                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
0000127C  6000 0008                239                  BRA     PRINTMOVE                ; Branches to print move
00001280                           240                  
00001280  4BF9 000022DE            241  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001286                           242   
00001286  4EB9 00002064            243  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
0000128C  4EB9 00002086            244                  JSR     PRINTMOVESIZE            ; prints out the size  
00001292  3404                     245                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001294  3605                     246                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001296  4EB9 00001D9E            247                  JSR     EA_TO_STRING             ; outputs it into a string
0000129C                           248                  
0000129C                           249                  ; prints a comma to seperate
0000129C  4BF9 000023D0            250                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000012A2  4EB9 00002064            251                  JSR     PRINTNULL                ; prints out MOVE
000012A8                           252                  
000012A8                           253                  ; print destination
000012A8  3406                     254                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
000012AA  3607                     255                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
000012AC  4EB9 00001D9E            256                  JSR     EA_TO_STRING             ; outputs it into a string
000012B2  4E75                     257                  RTS                              ; exits subroutine                 
000012B4                           258                
000012B4                           259  *---------------MOVEM opcode----------------------                
000012B4  3200                     260  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012B6  C27C FB80                261                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012BA  B27C 4880                262                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012BE  6600 00F4                263                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012C2                           264                  
000012C2                           265                  ; Check D
000012C2  3200                     266                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012C4  C27C 0400                267                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012C8  3E01                     268                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012CA  B27C 0400                269                  CMP.W   #$0400,D1                       ; checks if value is 1
000012CE  6700 0074                270                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012D2                           271  
000012D2                           272  MOVEM_REG2MEM   ; loads EA and XN
000012D2  3E3C 0000                273                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000012D6  4BF9 0000211D            274                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
000012DC  4DF9 0000214A            275                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000012E2  4EB9 00001C30            276                  JSR     CHECKGET_EAXN
000012E8  B27C 0001                277                  CMP.W   #1,D1                           ; checks if D1 invalid
000012EC  6700 08E6                278                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000012F0  4EB8 11E4                279                  JSR     PRINT_ADDR                      ; prints the address
000012F4  4BF9 000022EC            280                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000012FA  4EB9 00002064            281                  JSR     PRINTNULL                       ; prints MOVEM
00001300                           282                  
00001300                           283                  ; finds and prints size
00001300  3200                     284                  MOVE.W  D0,D1                           ; copies D0
00001302  C27C 0040                285                  AND.W   #$0040,D1                       ; gets the size bit
00001306  6600 0012                286                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
0000130A                           287  
0000130A  4BF9 000023DF            288  REG2MEMWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001310  4EB9 00002064            289                  JSR     PRINTNULL                       ; prints MOVEM
00001316  6000 000E                290                  BRA     PRINTREG2MEM                    ; prints the registers           
0000131A                           291                  
0000131A  4BF9 000023E5            292  REG2MEMLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001320  4EB9 00002064            293                  JSR     PRINTNULL                       ; prints MOVEM 
00001326                           294             
00001326  383C 0001                295  PRINTREG2MEM    MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
0000132A  4EB9 00001CC8            296                  JSR     PRINTREGISTERS                  ; prints registers
00001330  4BF9 000023D0            297                  LEA     MSG_COMMA,A5                    ; loads comma
00001336  4EB9 00002064            298                  JSR     PRINTNULL                       ; prints comma
0000133C  4EB9 00001D9E            299                  JSR     EA_TO_STRING                    ; prints EA
00001342  4E75                     300                  RTS
00001344                           301  
00001344                           302  MOVEM_MEM2REG  ; loads EA and XN
00001344  3E3C 0000                303                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001348  4BF9 00002121            304                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
0000134E  4DF9 0000214A            305                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001354  4EB9 00001C30            306                  JSR     CHECKGET_EAXN
0000135A  B27C 0001                307                  CMP.W   #1,D1                           ; checks if D1 invalid
0000135E  6700 0874                308                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001362  4EB8 11E4                309                  JSR     PRINT_ADDR                      ; prints the address
00001366  4BF9 000022EC            310                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000136C  4EB9 00002064            311                  JSR     PRINTNULL                       ; prints MOVEM
00001372                           312                  
00001372                           313                  ; finds and prints size
00001372  3200                     314                  MOVE.W  D0,D1                           ; copies D0
00001374  C27C 0040                315                  AND.W   #$0040,D1                       ; gets the size bit
00001378  6600 0010                316                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
0000137C                           317  
0000137C  4BF9 000023DF            318  MEM2REGWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001382  4EB9 00002064            319                  JSR     PRINTNULL                       ; prints MOVEM
00001388  609C                     320                  BRA     PRINTREG2MEM                    ; prints the registers           
0000138A                           321                  
0000138A  4BF9 000023E5            322  MEM2REGLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001390  4EB9 00002064            323                  JSR     PRINTNULL                       ; prints MOVEM 
00001396                           324             
00001396  4EB9 00001D9E            325  PRINTMEM2REG    JSR     EA_TO_STRING                    ; prints EA
0000139C  4BF9 000023D0            326                  LEA     MSG_COMMA,A5                    ; loads comma
000013A2  4EB9 00002064            327                  JSR     PRINTNULL                       ; prints comma
000013A8  383C FFFF                328                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
000013AC  4EB9 00001CC8            329                  JSR     PRINTREGISTERS                  ; prints registers
000013B2  4E75                     330                  RTS
000013B4                           331                          
000013B4                           332  
000013B4                           333  *---------------MOVEQ opcode----------------------
000013B4  3200                     334  CASE_MOVEQ      MOVE.W  D0,D1
000013B6  C27C F100                335                  AND.W   #$F100,D1
000013BA  B27C 7000                336                  CMP.W   #$7000,D1
000013BE  6600 004C                337                  BNE     CASE_ADD
000013C2                           338                  
000013C2                           339                  ;loads Register
000013C2  323C 0001                340                  MOVE.W  #1,D1                           ; copies instruction word to D1
000013C6  4EB9 00001C06            341                  JSR     GET_XN                          ; gets XN and puts in D1
000013CC  3401                     342                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000013CE                           343                  
000013CE                           344                  ;loads DATA
000013CE  3200                     345                  MOVE.W  D0,D1
000013D0  C27C 00FF                346                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000013D4  3601                     347                  MOVE.W  D1,D3                          ;copy data into D3
000013D6                           348                                                        ;must convert bits to hex
000013D6                           349                                  
000013D6  4EB8 11E4                350  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
000013DA                           351  
000013DA  4BF9 000022E5            352                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000013E0  4EB9 00002064            353                  JSR     PRINTNULL  
000013E6                           354                  
000013E6  4BF9 000023E5            355                  LEA     MSG_L,A5                        ;PRINT SIZE L
000013EC  4EB9 00002064            356                  JSR     PRINTNULL
000013F2                           357      
000013F2  4BF9 000022CF            358                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000013F8  4EB9 00002064            359                  JSR     PRINTNULL
000013FE                           360                  
000013FE  4BF9 000023CC            361                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
00001404  4EB9 00002064            362                  JSR     PRINTNULL
0000140A  4E75                     363                  RTS
0000140C                           364                  
0000140C                           365  *---------------ADD opcode----------------------                
0000140C                           366  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
0000140C  3200                     367  CASE_ADD        MOVE.W  D0,D1
0000140E  C27C F000                368                  AND.W   #$F000,D1
00001412  B27C D000                369                  CMP.W   #$D000,D1
00001416  6600 019A                370                  BNE     CASE_ADDQ
0000141A                           371   
0000141A  4EB8 11E4                372                  JSR     PRINT_ADDR              ; print address
0000141E                           373                  
0000141E  4EB9 00001438            374                  JSR     ADD_SUB_HELP
00001424                           375                  
00001424                           376                  ; bits 7-8 determine if it is ADDA or ADD
00001424  3200                     377                  MOVE.W  D0,D1
00001426  E149                     378                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001428  E049                     379                  LSR.W   #8,D1
0000142A  EC49                     380                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000142C  B27C 0003                381                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001430  6700 0118                382                  BEQ     CASE_ADDA
00001434                           383                  
00001434  6000 0040                384                  BRA     PRINTADD                ; Branches to print add
00001438                           385                  
00001438                           386                  ; Check bits 0-5 
00001438  4BF9 00002110            387  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000143E  4DF9 00002146            388                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001444  3E3C 0000                389                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001448  4EB9 00001C30            390                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000144E  B27C 0001                391                  CMP.W       #1,D1                    ; checks if invalid
00001452  6700 0780                392                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001456  3802                     393                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001458  3A03                     394                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000145A                           395                  
0000145A                           396                  ; Check 6-11
0000145A  4BF9 00002110            397                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001460  4DF9 0000214A            398                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001466  3E3C 0001                399                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000146A  4EB9 00001C30            400                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001470  3C02                     401                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001472  3E03                     402                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001474                           403    
00001474  4E75                     404                  RTS                
00001476                           405                    
00001476  4BF9 000022F3            406  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
0000147C  4EB9 00002064            407                  JSR         PRINTNULL               ; print ADD
00001482  3200                     408                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001484  4EB9 0000148E            409                  JSR         ADD_SUB_SIZE
0000148A  6000 0050                410                  BRA         FINISH_ADD
0000148E                           411                    
0000148E  3200                     412  ADD_SUB_SIZE    MOVE.W      D0,D1
00001490  E149                     413                  LSL.W       #8,D1
00001492  E049                     414                  LSR.W       #8,D1
00001494  EC49                     415                  LSR.W       #6,D1                   ; gets bits 6-7
00001496                           416                    
00001496  B27C 0000                417                  CMP.W       #0,D1
0000149A  6700 0016                418                  BEQ         ADD_SUB_BYTE
0000149E  B27C 0001                419                  CMP.W       #1,D1                   ; if 1, it is a word
000014A2  6700 001C                420                  BEQ         ADD_SUB_WORD
000014A6  B27C 0002                421                  CMP.W       #2,D1                   ; if 2, it is a long
000014AA  6700 0022                422                  BEQ         ADD_SUB_LONG
000014AE  6000 0254                423                  BRA         CASE_SUBA                    ; error
000014B2                           424                    
000014B2  4BF9 000023D9            425  ADD_SUB_BYTE    LEA         MSG_B,A5
000014B8  4EB9 00002064            426                  JSR         PRINTNULL
000014BE  4E75                     427                  RTS
000014C0                           428                    
000014C0  4BF9 000023DF            429  ADD_SUB_WORD    LEA         MSG_W,A5
000014C6  4EB9 00002064            430                  JSR         PRINTNULL
000014CC  4E75                     431                  RTS
000014CE                           432    
000014CE  4BF9 000023E5            433  ADD_SUB_LONG    LEA         MSG_L,A5
000014D4  4EB9 00002064            434                  JSR         PRINTNULL
000014DA  4E75                     435                  RTS
000014DC                           436        
000014DC  4EB9 000014E4            437  FINISH_ADD      JSR         ADD_SUB_OPERAND
000014E2  4E75                     438                  RTS
000014E4                           439    
000014E4  EF49                     440  ADD_SUB_OPERAND LSL.W       #7,D1
000014E6  EE49                     441                  LSR.W       #7,D1
000014E8  E049                     442                  LSR.W       #8,D1
000014EA  B27C 0001                443                  CMP.W       #1,D1
000014EE  6600 002E                444                  BNE         Dn_PLUS_EA          
000014F2                           445                    
000014F2                           446                  ; print Data Register
000014F2  4BF9 000023C0            447                  LEA         MSG_DR,A5
000014F8  4EB9 00002064            448                  JSR         PRINTNULL
000014FE  3207                     449                  MOVE.W      D7,D1
00001500  4EB9 00001F1A            450                  JSR         PRINTNUM                
00001506                           451                  
00001506                           452                  ; prints a comma to seperate
00001506  4BF9 000023D0            453                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000150C  4EB9 00002064            454                  JSR         PRINTNULL                ; prints out MOVE
00001512                           455                 
00001512                           456                  ; below is EA+Dn->Dn  
00001512  3404                     457                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001514  3605                     458                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001516  4EB9 00001D9E            459                  JSR         EA_TO_STRING             ; outputs it into a string
0000151C  4E75                     460                  RTS                                 ; exits subroutine 
0000151E                           461  
0000151E                           462  Dn_PLUS_EA      ; below is Dn+EA->EA  
0000151E  3404                     463                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001520  3605                     464                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001522  4EB9 00001D9E            465                  JSR         EA_TO_STRING             ; outputs it into a string   
00001528                           466                  
00001528                           467                  ; prints a comma to seperate
00001528  4BF9 000023D0            468                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000152E  4EB9 00002064            469                  JSR         PRINTNULL                ; prints out MOVE
00001534                           470                  
00001534                           471                  ; below is Dn+EA->EA
00001534  4BF9 000023C0            472                  LEA         MSG_DR,A5                ; print data register
0000153A  4EB9 00002064            473                  JSR         PRINTNULL
00001540  3207                     474                  MOVE.W      D7,D1
00001542  4EB9 00001F1A            475                  JSR         PRINTNUM             
00001548  4E75                     476                  RTS                                  ; exits subroutine          
0000154A                           477                        
0000154A                           478  *---------------ADDA opcode----------------------
0000154A                           479  CASE_ADDA       ; gets bit 8 (size bit)
0000154A  3200                     480                  MOVE.W      D0,D1
0000154C  EF49                     481                  LSL.W       #7,D1
0000154E  EE49                     482                  LSR.W       #7,D1
00001550  E049                     483                  LSR         #8,D1                   
00001552                           484                  
00001552  4BF9 000022F8            485                  LEA         MSG_ADDA,A5             ; print ADDA
00001558  4EB9 00002064            486                  JSR         PRINTNULL
0000155E                           487                   
0000155E  B27C 0001                488                  CMP.W       #1,D1
00001562  6700 0012                489                  BEQ         ADDA_LONG
00001566                           490                    
00001566  4BF9 000023DF            491                  LEA         MSG_W,A5
0000156C  4EB9 00002064            492                  JSR         PRINTNULL
00001572  6000 0012                493                  BRA         FINISH_ADDA   
00001576                           494                    
00001576  4BF9 000023E5            495  ADDA_LONG       LEA         MSG_L,A5
0000157C  4EB9 00002064            496                  JSR         PRINTNULL
00001582  6000 0002                497                  BRA         FINISH_ADDA
00001586                           498                    
00001586  3404                     499  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001588  3605                     500                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000158A  4EB9 00001D9E            501                  JSR         EA_TO_STRING             ; outputs it into a string
00001590                           502                    
00001590                           503                  ; prints a comma to seperate
00001590  4BF9 000023D0            504                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001596  4EB9 00002064            505                  JSR         PRINTNULL                ; prints out MOVE
0000159C                           506            
0000159C  4BF9 000023C2            507                  LEA         MSG_AR,A5                ; print address register
000015A2  4EB9 00002064            508                  JSR         PRINTNULL
000015A8  3207                     509                  MOVE.W      D7,D1
000015AA  4EB9 00001F1A            510                  JSR         PRINTNUM             
000015B0  4E75                     511                  RTS                              ; exits subroutine
000015B2                           512                  
000015B2                           513  *---------------ADDQ opcode----------------------                  
000015B2  3200                     514  CASE_ADDQ       MOVE.W      D0,D1
000015B4  C27C F000                515                  AND.W       #$F000,D1       
000015B8  B27C 5000                516                  CMP.W       #$5000,D1
000015BC  6600 00CC                517                  BNE         CASE_SUB
000015C0                           518                                                   
000015C0  4EB8 11E4                519                  JSR         PRINT_ADDR              ; print address  
000015C4  4BF9 000022FE            520                  LEA         MSG_ADDQ,A5             ; print ADDQ
000015CA  4EB9 00002064            521                  JSR         PRINTNULL
000015D0                           522                  
000015D0                           523                  ; get bits 6-7 (size bits)
000015D0  3200                     524                  MOVE.W      D0,D1
000015D2  E149                     525                  LSL.W       #8,D1
000015D4  E049                     526                  LSR.W       #8,D1
000015D6  EC49                     527                  LSR.W       #6,D1
000015D8  3401                     528                  MOVE.W      D1,D2
000015DA                           529                  
000015DA                           530                  ; Check bits 0-5 
000015DA  4BF9 00002110            531                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000015E0  4DF9 00002146            532                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000015E6  3E3C 0000                533                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000015EA  4EB9 00001C30            534                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000015F0  B27C 0001                535                  CMP.W       #1,D1                    ; checks if invalid
000015F4  6700 05DE                536                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000015F8  3802                     537                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000015FA  3A03                     538                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000015FC                           539                  
000015FC  B47C 0001                540                  CMP.W       #1,D2
00001600  6700 001A                541                  BEQ         ADDQ_WORD
00001604  B47C 0002                542                  CMP.W       #2,D2
00001608  6700 0022                543                  BEQ         ADDQ_LONG
0000160C                           544                    
0000160C  4BF9 000023D9            545  ADDQ_BYTE       LEA         MSG_B,A5
00001612  4EB9 00002064            546                  JSR         PRINTNULL
00001618  6000 0022                547                  BRA         FINISH_ADDQ  
0000161C                           548   
0000161C  4BF9 000023DF            549  ADDQ_WORD       LEA         MSG_W,A5
00001622  4EB9 00002064            550                  JSR         PRINTNULL
00001628  6000 0012                551                  BRA         FINISH_ADDQ                 
0000162C                           552    
0000162C  4BF9 000023E5            553  ADDQ_LONG       LEA         MSG_L,A5
00001632  4EB9 00002064            554                  JSR         PRINTNULL
00001638  6000 0002                555                  BRA         FINISH_ADDQ                  
0000163C                           556                    
0000163C  4EB9 0000165A            557  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001642                           558   
00001642                           559                  ; prints a comma to seperate
00001642  4BF9 000023D0            560                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001648  4EB9 00002064            561                  JSR         PRINTNULL                ; prints out MOVE
0000164E                           562                    
0000164E                           563                  ; prints destination
0000164E  3404                     564                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001650  3605                     565                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001652  4EB9 00001D9E            566                  JSR         EA_TO_STRING             ; outputs it into a string
00001658                           567                 
00001658  4E75                     568                  RTS
0000165A                           569   
0000165A  4BF9 000023CC            570  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
00001660  4EB9 00002064            571                  JSR         PRINTNULL
00001666                           572                  ; gets bits 9-11 (data bits)
00001666  E949                     573                  LSL.W       #4,D1
00001668  E849                     574                  LSR.W       #4,D1                               ; get rid of left 4 bits
0000166A  E049                     575                  LSR.W       #8,D1
0000166C  E249                     576                  LSR.W       #1,D1                               ; get rid of right 9 bits
0000166E                           577                  
0000166E  B27C 0000                578                  CMP.W       #0,D1
00001672  6700 000A                579                  BEQ         PRINT_8
00001676  4EB9 00001F1A            580                  JSR         PRINTNUM
0000167C  4E75                     581                  RTS 
0000167E                           582  
0000167E  123C 0008                583  PRINT_8         MOVE.B      #8,D1
00001682  4EB9 00001F1A            584                  JSR         PRINTNUM
00001688  4E75                     585                  RTS   
0000168A                           586         
0000168A                           587  *---------------SUB opcode---------------------- 
0000168A  3200                     588  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000168C  C27C F000                589                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001690  B27C 9000                590                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001694  6600 0084                591                  BNE         CASE_LEA
00001698                           592                 
00001698  4EB8 1438                593                  JSR         ADD_SUB_HELP
0000169C  4EB8 11E4                594                  JSR         PRINT_ADDR                          ; print address               
000016A0                           595                  
000016A0  6000 0002                596                  BRA         PRINTSUB                            ; Branches to print move
000016A4                           597  
000016A4  4BF9 00002304            598  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
000016AA  4EB9 00002064            599                  JSR         PRINTNULL
000016B0  3200                     600                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000016B2  4EB8 148E                601                  JSR         ADD_SUB_SIZE
000016B6  3200                     602                  MOVE.W      D0,D1
000016B8  E149                     603                  LSL.W       #8,D1
000016BA  E049                     604                  LSR.W       #8,D1
000016BC  EC49                     605                  LSR.W       #6,D1
000016BE  B27C 0003                606                  CMP.W       #3,D1
000016C2  6600 0006                607                  BNE         FINISH_SUB
000016C6  6000 0008                608                  BRA         FINISH_SUBA                         ; same as ADDA
000016CA                           609                  
000016CA  4EB8 14E4                610  FINISH_SUB      JSR     ADD_SUB_OPERAND
000016CE  4E75                     611                  RTS
000016D0                           612                    
000016D0  3404                     613  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016D2  3605                     614                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016D4  4EB9 00001D9E            615                  JSR         EA_TO_STRING             ; outputs it into a string
000016DA                           616                
000016DA                           617                  ; prints a comma to seperate
000016DA  4BF9 000023D0            618                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016E0  4EB9 00002064            619                  JSR         PRINTNULL                ; prints out MOVE
000016E6                           620          
000016E6  4BF9 000023C2            621                  LEA         MSG_AR,A5                ; print address register
000016EC  4EB9 00002064            622                  JSR         PRINTNULL
000016F2  3200                     623                  MOVE.W      D0,D1
000016F4  E949                     624                  LSL.W       #4,D1
000016F6  E849                     625                  LSR.W       #4,D1
000016F8  E049                     626                  LSR.W       #8,D1
000016FA  E249                     627                  LSR.W       #1,D1
000016FC  4EB9 00001F1A            628                  JSR         PRINTNUM             
00001702  4E75                     629                  RTS                              ; exits subroutine
00001704                           630  
00001704                           631  
00001704                           632  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
00001704  3200                     633  CASE_SUBA       MOVE.W      D0,D1
00001706  EF49                     634                  LSL.W       #7,D1
00001708  EE49                     635                  LSR.W       #7,D1
0000170A  E049                     636                  LSR.W       #8,D1
0000170C  B23C 0000                637                  CMP.B       #0,D1
00001710  6700 FDAE                638                  BEQ         ADD_SUB_WORD
00001714  6000 FDB8                639                  BRA         ADD_SUB_LONG
00001718  4E75                     640                  RTS         
0000171A                           641                   
0000171A  3200                     642  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000171C  C27C F000                643                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001720  B27C 4000                644                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001724  6600 0086                645                  BNE.W   CASE_AND                             ; If its not, check AND
00001728  3200                     646                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000172A  C27C 01C0                647                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
0000172E  B27C 01C0                648                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001732  6600 0078                649                  BNE.W   CASE_AND                             ; If its not, check AND
00001736                           650                  
00001736                           651                  ; Check source
00001736  4BF9 00002130            652                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000173C  4DF9 0000214A            653                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001742  3E3C 0000                654                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001746  4EB9 00001C30            655                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000174C  3802                     656                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000174E  3A03                     657                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001750                           658                  
00001750                           659                  ; Check destination
00001750  4BF9 00002130            660                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001756  4DF9 0000214A            661                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000175C  3E3C 0001                662                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
00001760  4EB9 00001C30            663                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001766  3C02                     664                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001768  3E03                     665                  MOVE.W  D3,D7                                ; Saves D2 in D4
0000176A                           666  
0000176A  4BF9 00002315            667                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
00001770  4EB9 00002064            668                  JSR     PRINTNULL                            ; prints LEA
00001776                           669                  
00001776                           670                  ; print source
00001776  3404                     671                  MOVE.W  D4,D2
00001778  3605                     672                  MOVE.W  D5,D3
0000177A  4EB9 00001D9E            673                  JSR     EA_TO_STRING                         ; Prints out the EA
00001780                           674                  
00001780                           675                  ; comma
00001780  4BF9 000023D0            676                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001786  4EB9 00002064            677                  JSR     PRINTNULL                       
0000178C                           678                   
0000178C                           679                  ; register
0000178C  4BF9 000023C2            680                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001792  4EB9 00002064            681                  JSR     PRINTNULL 
00001798  3401                     682                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
0000179A  323C 0001                683                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
0000179E  4EB9 00001C06            684                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000017A4  4EB9 00001F1A            685                  JSR     PRINTNUM                             ; Prints the number in D1
000017AA  4E75                     686                  RTS
000017AC                           687  
000017AC                           688  *---------------AND opcode----------------------
000017AC  3200                     689  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017AE  C27C F000                690                  AND.W       #$F000,D1       
000017B2  B27C C000                691                  CMP.W       #$C000,D1
000017B6  6600 009E                692                  BNE         CASE_OR
000017BA                           693                  
000017BA  3200                     694                  MOVE.W      D0,D1
000017BC  E149                     695                  LSL.W       #8,D1
000017BE  E049                     696                  LSR.W       #8,D1
000017C0  EC49                     697                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000017C2  3C01                     698                  MOVE.W      D1,D6
000017C4  BC7C 0003                699                  CMP.W       #3,D6
000017C8  6700 0066                700                  BEQ         INV_INSTR
000017CC                           701                  
000017CC  4EB8 11E4                702                  JSR         PRINT_ADDR                      ; print address
000017D0  4BF9 0000231D            703                  LEA         MSG_AND,A5                      ; print AND
000017D6  4EB9 00002064            704                  JSR         PRINTNULL
000017DC                           705                  
000017DC  3206                     706                  MOVE.W      D6,D1
000017DE  B27C 0000                707                  CMP.W       #0,D1
000017E2  6700 0012                708                  BEQ         AND_BYTE
000017E6  B27C 0001                709                  CMP.W       #1,D1                   ; if 1, it is a word
000017EA  6700 001A                710                  BEQ         AND_WORD
000017EE  B27C 0002                711                  CMP.W       #2,D1                   ; if 2, it is a long
000017F2  6700 0022                712                  BEQ         AND_LONG
000017F6                           713                  
000017F6  4BF9 000023D9            714  AND_BYTE        LEA         MSG_B,A5
000017FC  4EB9 00002064            715                  JSR         PRINTNULL
00001802  6000 0022                716                  BRA         FINISH_AND
00001806                           717                                    
00001806  4BF9 000023DF            718  AND_WORD        LEA         MSG_W,A5
0000180C  4EB9 00002064            719                  JSR         PRINTNULL
00001812  6000 0012                720                  BRA         FINISH_AND
00001816                           721    
00001816  4BF9 000023E5            722  AND_LONG        LEA         MSG_L,A5
0000181C  4EB9 00002064            723                  JSR         PRINTNULL
00001822  6000 0002                724                  BRA         FINISH_AND
00001826                           725        
00001826  4EB8 1438                726  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
0000182A  4EB8 14E4                727                  JSR         ADD_SUB_OPERAND
0000182E  4E75                     728                  RTS
00001830                           729                  
00001830  4BF9 0000228B            730  INV_INSTR       LEA         INVALID_INSTR,A5
00001836  4EB9 00002064            731                  JSR         PRINTNULL
0000183C  2200                     732                  MOVE.L      D0,D1
0000183E  383C 0000                733                  MOVE.W      #0,D4
00001842  4EB9 00001F3E            734                  JSR         PRINTSHORTLONGNUM
00001848  4BF9 000022CC            735                  LEA         NEW_LINE,A5
0000184E  4EB9 00002064            736                  JSR         PRINTNULL
00001854  4E75                     737                  RTS               
00001856                           738                  
00001856                           739  *---------------OR opcode----------------------            
00001856  3200                     740  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001858  C27C F000                741                  AND.W       #$F000,D1       
0000185C  B27C 8000                742                  CMP.W       #$8000,D1
00001860  6600 004C                743                  BNE         CASE_NOT
00001864                           744                                                
00001864  3200                     745                  MOVE.W      D0,D1
00001866  E149                     746                  LSL.W       #8,D1
00001868  E049                     747                  LSR.W       #8,D1
0000186A  EC49                     748                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000186C  B27C 0003                749                  CMP.W       #3,D1
00001870  3C01                     750                  MOVE.W      D1,D6
00001872  67BC                     751                  BEQ         INV_INSTR
00001874                           752                  
00001874  4EB8 11E4                753                  JSR         PRINT_ADDR                      ; print address
00001878                           754                  
00001878  4BF9 00002322            755                  LEA         MSG_OR,A5
0000187E  4EB9 00002064            756                  JSR         PRINTNULL                       ; print "OR"
00001884                           757                  
00001884  3206                     758                  MOVE.W      D6,D1
00001886  4EB9 00001896            759                  JSR         OR_SIZE                         ; print ".B",".W",".L"
0000188C  4EB8 1438                760                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001890  4EB8 14E4                761                  JSR         ADD_SUB_OPERAND                 ; print 
00001894  4E75                     762                  RTS
00001896                           763  
00001896  B27C 0000                764  OR_SIZE         CMP.W       #0,D1
0000189A  6700 FC16                765                  BEQ         ADD_SUB_BYTE
0000189E  B27C 0001                766                  CMP.W       #1,D1                   ; if 1, it is a word
000018A2  6700 FC1C                767                  BEQ         ADD_SUB_WORD
000018A6  B27C 0002                768                  CMP.W       #2,D1                   ; if 2, it is a long
000018AA  6700 FC22                769                  BEQ         ADD_SUB_LONG
000018AE                           770                  ; no need for rts, since ADD_SUB_ already has                
000018AE                           771  
000018AE                           772  *---------------NOT opcode----------------------
000018AE  3200                     773  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018B0  C27C FF00                774                  AND.W       #$FF00,D1       
000018B4  B27C 4600                775                  CMP.W       #$4600,D1
000018B8  6600 0050                776                  BNE         CASE_LSDASDROD
000018BC                           777                 
000018BC                           778                  ; get bits 6-7 (size)
000018BC  3200                     779                  MOVE.W      D0,D1
000018BE  E149                     780                  LSL.W       #8,D1
000018C0  E049                     781                  LSR.W       #8,D1
000018C2  EC49                     782                  LSR.W       #6,D1 
000018C4  3C01                     783                  MOVE.W      D1,D6                         
000018C6  BC7C 0003                784                  CMP.W       #3,D6
000018CA  6700 FF64                785                  BEQ         INV_INSTR
000018CE                           786                  
000018CE  4EB8 11E4                787                  JSR         PRINT_ADDR
000018D2                           788                  
000018D2  4BF9 00002326            789                  LEA         MSG_NOT,A5
000018D8  4EB9 00002064            790                  JSR         PRINTNULL                       ; print "NOT"
000018DE                           791                                 
000018DE  3206                     792                  MOVE.W      D6,D1
000018E0                           793  
000018E0  4EB8 1896                794                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000018E4                           795                  
000018E4                           796                  ; get bits 0-5 
000018E4  4BF9 00002110            797                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000018EA  4DF9 00002146            798                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000018F0  3E3C 0000                799                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000018F4  4EB9 00001C30            800                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000018FA  B27C 0001                801                  CMP.W       #1,D1                    ; checks if invalid
000018FE  6700 02D4                802                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001902  4EB9 00001D9E            803                  JSR         EA_TO_STRING             ; outputs it into a string
00001908                           804    
00001908  4E75                     805                  RTS
0000190A                           806  
0000190A  3200                     807  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
0000190C  C27C F000                808                  AND.W       #$F000, D1                       ; gets first 4 bits
00001910  B27C E000                809                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001914  6600 0218                810                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001918  3400                     811                  MOVE.W      D0,D2                            ; copies D0 to D2
0000191A  4EB9 00001CB8            812                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001920  B47C 0003                813                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001924  6600 00CC                814                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001928                           815                  
00001928  3400                     816  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000192A  4EB9 00001CA6            817                  JSR         GETROTATION                      ; gets rotation value of D2
00001930  B47C 0000                818                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001934  6700 0014                819                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001938  B47C 0003                820                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
0000193C  6700 0016                821                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001940                           822                  
00001940  4BF9 0000232B            823  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001946  6000 0012                824                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000194A                           825  
0000194A  4BF9 0000232F            826  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001950  6000 0008                827                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001954                           828  
00001954  4BF9 00002333            829  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000195A                           830                  
0000195A  4EB8 11E4                831  PRINTSHIFTMEM   JSR         PRINT_ADDR                       ; prints address
0000195E  4EB9 00002064            832                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001964  3400                     833                  MOVE.W      D0,D2                            ; copies D0 to D2
00001966  4EB9 00001CB0            834                  JSR         GETDIRECTION                     ; gets direction
0000196C  B47C 0000                835                  CMP.W       #0,D2                            ; checking if its right
00001970  6700 000C                836                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001974                           837  
00001974  4BF9 000023BE            838  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000197A  6000 0008                839                  BRA         PRINT_MEMDIR                     ; branches for printing
0000197E                           840          
0000197E  4BF9 000023BC            841  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001984                           842  
00001984  4EB9 00002064            843  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000198A  4BF9 000023DF            844                  LEA         MSG_W,A5                         ; loads .W into A5
00001990  4EB9 00002064            845                  JSR         PRINTNULL                        ; Prints .W
00001996  6000 0002                846                  BRA         GETMEMSOURCE                     ; checks the source 
0000199A                           847                  
0000199A                           848  ; get source addressing mode       
0000199A                           849  GETMEMSOURCE                                                 
0000199A  323C 0000                850                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000199E  4EB9 00001BDC            851                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
000019A4  3801                     852                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
000019A6  323C 0000                853                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
000019AA  4EB9 00001C06            854                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000019B0  3A01                     855                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000019B2                           856  
000019B2  4BF9 0000213E            857  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000019B8  3204                     858                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000019BA  4EB9 00001D6A            859                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000019C0  B27C 0002                860                  CMP.W       #2,D1                            ; checks if it is Xn
000019C4  6700 0016                861                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000019C8  B27C 0001                862                  CMP.W       #1,D1                            ; Checks if it is invalid
000019CC  6700 0206                863                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000019D0                           864  
000019D0  3404                     865  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000019D2  3605                     866                  MOVE.W      D5,D3                            ; moves EA to D3
000019D4  4EB9 00001D9E            867                  JSR         EA_TO_STRING                     ; prints out the EA
000019DA  4E75                     868                  RTS                
000019DC                           869                  
000019DC                           870                  
000019DC  4BF9 0000214A            871  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000019E2  3205                     872                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000019E4  4EB9 00001D6A            873                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000019EA  4A41                     874                  TST.W       D1                               ; checks if it is valid
000019EC  67E2                     875                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000019EE  6000 01E4                876                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000019F2                           877  
000019F2                           878  
000019F2  3602                     879  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000019F4  3200                     880                  MOVE.W      D0,D1                            ; copies D0 to D1
000019F6  C27C 0018                881                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000019FA  E649                     882                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000019FC  B27C 0000                883                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001A00  6700 0014                884                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001A04  B27C 0003                885                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001A08  6700 0016                886                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001A0C                           887                  
00001A0C  4BF9 0000232B            888  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001A12  6000 0012                889                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A16                           890  
00001A16  4BF9 0000232F            891  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001A1C  6000 0008                892                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A20                           893  
00001A20  4BF9 00002333            894  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001A26                           895                  
00001A26  4EB8 11E4                896  PRINTSHIFTREG   JSR         PRINT_ADDR                       ; prints address
00001A2A  4EB9 00002064            897                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001A30  3400                     898                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A32  4EB9 00001CB0            899                  JSR         GETDIRECTION                     ; gets direction
00001A38  B47C 0000                900                  CMP.W       #0,D2                            ; checking if its right
00001A3C  6700 000C                901                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001A40                           902  
00001A40  4BF9 000023BE            903  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001A46  6000 000C                904                  BRA         PRINT_REGDIR                     ; branches for printing
00001A4A                           905          
00001A4A  4BF9 000023BC            906  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001A50  6000 0002                907                  BRA         PRINT_REGDIR                     ; branches for printing
00001A54                           908                  
00001A54  4EB9 00002064            909  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001A5A                           910  
00001A5A  3400                     911  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001A5C  4EB9 00001CB8            912                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A62  B47C 0001                913                  CMP.W       #1,D2                            ; Checks if it is word size
00001A66  6700 0014                914                  BEQ         REG_WORD                         ; Prints .W
00001A6A  B47C 0002                915                  CMP.W       #2,D2                            ; Checks if it is long size
00001A6E  6700 0016                916                  BEQ         REG_LONG                         ; Prints .L
00001A72                           917  
00001A72  4BF9 000023D9            918  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001A78  6000 0012                919                  BRA         PRINTREGEA      
00001A7C                           920  
00001A7C  4BF9 000023DF            921  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001A82  6000 0008                922                  BRA         PRINTREGEA      
00001A86                           923                             
00001A86  4BF9 000023E5            924  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001A8C                           925  
00001A8C  4EB9 00002064            926  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001A92  3400                     927                  MOVE.W      D0,D2                            ; copies D0 to D1
00001A94  4EB9 00001CC0            928                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001A9A  B27C 0001                929                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001A9E  6700 0048                930                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001AA2                           931                                  
00001AA2  3400                     932  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001AA4  4EB9 00001CB8            933                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AAA  3202                     934                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AAC  4BF9 000023CC            935                  LEA         MSG_POUND, A5                    ; loads # into A5
00001AB2  4EB9 00002064            936                  JSR         PRINTNULL                        ; prints #
00001AB8  4EB9 00001F1A            937                  JSR         PRINTNUM                         ; prints shift count
00001ABE  4BF9 000023D0            938                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001AC4  4EB9 00002064            939                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001ACA  4BF9 000023C0            940                  LEA         MSG_DR, A5                       ; loads D into A5
00001AD0  4EB9 00002064            941                  JSR         PRINTNULL                        ; prints out D 
00001AD6  323C 0000                942                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001ADA  4EB9 00001C06            943                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001AE0  4EB9 00001F1A            944                  JSR         PRINTNUM                         ; prints data register number in D1          
00001AE6  4E75                     945                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001AE8                           946                  
00001AE8  3400                     947  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001AEA  4EB9 00001CB8            948                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AF0  3202                     949                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AF2  4BF9 000023C0            950                  LEA         MSG_DR, A5                       ; loads D into A5
00001AF8  4EB9 00002064            951                  JSR         PRINTNULL                        ; prints D
00001AFE  4EB9 00001F1A            952                  JSR         PRINTNUM                         ; prints register number
00001B04  4BF9 000023D0            953                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001B0A  4EB9 00002064            954                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001B10  4BF9 000023C0            955                  LEA         MSG_DR, A5                       ; loads D into A5
00001B16  4EB9 00002064            956                  JSR         PRINTNULL                        ; prints out D 
00001B1C  323C 0000                957                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001B20  4EB9 00001C06            958                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001B26  4EB9 00001F1A            959                  JSR         PRINTNUM                         ; prints data register number in D1          
00001B2C  4E75                     960                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001B2E                           961               
00001B2E  3200                     962  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001B30  C27C FF00                963                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001B34  B27C 6000                964                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001B38  6600 001C                965                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001B3C                           966                  
00001B3C  4EB8 11E4                967                  JSR     PRINT_ADDR
00001B40  4BF9 000023B4            968                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001B46  4EB9 00002064            969                  JSR     PRINTNULL                            ; prints BRA
00001B4C                           970  
00001B4C  3400                     971                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001B4E  4EB9 00001C78            972                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001B54  4E75                     973                  RTS
00001B56                           974                  
00001B56                           975  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001B56                           976  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001B56  3200                     977  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B58  C27C F000                978                  AND.W   #$F000,D1                            ; get top 4 bits
00001B5C  B27C 6000                979                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001B60  6600 0058                980                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001B64  3200                     981                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B66  C27C 0F00                982                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001B6A  E049                     983                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001B6C                           984                  
00001B6C  B27C 000E                985                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001B70  6700 002A                986                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001B74                           987                  
00001B74  B27C 000F                988                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001B78  6700 0018                989                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001B7C                           990                      
00001B7C  B27C 0007                991                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001B80  6700 0006                992                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001B84  6000 004E                993                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001B88                           994     
00001B88  4BF9 00002347            995  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001B8E  6000 0016                996                  BRA     PRINTBCC
00001B92                           997  
00001B92  4BF9 0000236F            998  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001B98  6000 000C                999                  BRA     PRINTBCC
00001B9C                          1000                  
00001B9C  4BF9 0000235F           1001  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001BA2  6000 0002               1002                  BRA     PRINTBCC
00001BA6                          1003  
00001BA6  4EB8 11E4               1004  PRINTBCC        JSR     PRINT_ADDR                           ; prints address
00001BAA  4EB9 00002064           1005                  JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001BB0  3400                    1006                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001BB2  4EB9 00001C78           1007                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001BB8  4E75                    1008                  RTS              
00001BBA                          1009                  
00001BBA                          1010  
00001BBA                          1011  CASE_JSR       
00001BBA                          1012  
00001BBA  B07C 4E75               1013  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001BBE  6600 0014               1014                  BNE     CASE_DATA           ; checks the next case if not equal
00001BC2  4EB8 11E4               1015                  JSR     PRINT_ADDR          ; prints address
00001BC6  4BF9 000023AF           1016                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001BCC  4EB9 00002064           1017                  JSR     PRINTNULL           ; prints RTS                
00001BD2  4E75                    1018                  RTS                         ; returns from the subroutine
00001BD4                          1019  
00001BD4                          1020                  
00001BD4                          1021  
00001BD4  4EB8 1830               1022  CASE_DATA           JSR INV_INSTR  
00001BD8  4E75                    1023                      RTS               
00001BDA                          1024  
00001BDA  4E75                    1025  CASE_EPICFAIL       RTS
00001BDC                          1026  
00001BDC                          1027  
00001BDC                          1028  * Finds the EA type
00001BDC                          1029  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001BDC                          1030  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001BDC  48E7 3000               1031  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001BE0  4A41                    1032                      TST.W     D1                    ; compares D1 to 0
00001BE2  6700 000E               1033                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001BE6                          1034                      
00001BE6  343C 01C0               1035  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001BEA  363C 0006               1036                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001BEE  6000 000A               1037                      BRA       FINDTYPEEA            
00001BF2                          1038  
00001BF2  343C 0038               1039  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001BF6  363C 0003               1040                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001BFA                          1041  
00001BFA                          1042  
00001BFA  3200                    1043  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001BFC  C242                    1044                      AND.W     D2,D1                 ; applies bitmask to D1
00001BFE  E669                    1045                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C00  4CDF 000C               1046                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C04  4E75                    1047                      RTS                             ; returns from subroutine    
00001C06                          1048                      
00001C06                          1049  * Finds Xn type
00001C06                          1050  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001C06                          1051  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001C06  48E7 3000               1052  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001C0A  4A41                    1053                      TST.W     D1                    ; compares D1 to 0
00001C0C  6700 000E               1054                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001C10                          1055  
00001C10  343C 0E00               1056  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001C14  363C 0009               1057                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001C18  6000 000A               1058                      BRA       FINDTYPEXN            ; finds the type of Xn
00001C1C                          1059  
00001C1C  343C 0007               1060  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001C20  363C 0000               1061                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001C24                          1062                      
00001C24  3200                    1063  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001C26  C242                    1064                      AND.W     D2,D1                 ; applies bitmask to D1
00001C28  E669                    1065                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C2A  4CDF 000C               1066                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C2E  4E75                    1067                      RTS                             ; returns from subroutine 
00001C30                          1068                      
00001C30                          1069  * Checks and gets the EA and Xn
00001C30                          1070  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001C30                          1071  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001C30  3207                    1072  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001C32  4EB8 1BDC               1073                  JSR     GET_EA                  ; Gets EA
00001C36  3401                    1074                  MOVE.W  D1,D2                   ; Stores EA in D2
00001C38  3207                    1075                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001C3A  4EB8 1C06               1076                  JSR     GET_XN                  ; Gets Xn
00001C3E  3601                    1077                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001C40  3202                    1078                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001C42                          1079                  
00001C42  4EB9 00001D6A           1080                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001C48  B27C 0002               1081                  CMP.W   #2,D1                   ; checks if it is Xn
00001C4C  6700 0012               1082                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001C50  B27C 0001               1083                  CMP.W   #1,D1                   ; Checks if it is invalid
00001C54  6700 001C               1084                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001C58                          1085                  
00001C58                          1086                  
00001C58  323C 0000               1087  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001C5C  6000 0018               1088                  BRA     END_CHECKGET
00001C60                          1089        
00001C60                          1090  ; need XN
00001C60  2A4E                    1091  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001C62  3203                    1092                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001C64  4EB9 00001D6A           1093                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001C6A  4A41                    1094                  TST.W   D1                      ; checks if it is valid
00001C6C  67EA                    1095                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001C6E  6000 0002               1096                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001C72                          1097   
00001C72  323C 0001               1098  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001C76                          1099  
00001C76  4E75                    1100  END_CHECKGET    RTS          
00001C78                          1101                                            
00001C78                          1102                                            
00001C78                          1103  * Gets the displacement and pritns it 
00001C78                          1104  * Inputs: D2 = instruction word, A2 = address of next word
00001C78                          1105  * Outputs: prints out displacement
00001C78  48E7 4004               1106  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001C7C  3A4A                    1107                      MOVE.W    A2,A5                 ; copies A2 to A5
00001C7E  C47C 00FF               1108                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001C82  6600 0004               1109                      BNE       PRINTADDRESS          ; prints address if not 0
00001C86  341A                    1110                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001C88                          1111                      
00001C88  D44D                    1112  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001C8A  3202                    1113                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001C8C  183C 0000               1114                      MOVE.B    #0,D4                 ; marks address as word  length
00001C90  4BF9 000023CE           1115                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001C96  4EB9 00002064           1116                      JSR       PRINTNULL             ; prints null
00001C9C  4EB9 00001F3E           1117                      JSR       PRINTSHORTLONGNUM     ; prints address
00001CA2                          1118                      
00001CA2  4CDF 2002               1119                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001CA6                          1120                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001CA6                          1121  
00001CA6                          1122  * Gets the rotation value for ASd and LSd
00001CA6                          1123  * Input: D2 = instruction word copy (of D0)                                    
00001CA6                          1124  * Output: rotation  value in D2             
00001CA6  C47C 0E00               1125  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001CAA  E04A                    1126                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CAC  E24A                    1127                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001CAE  4E75                    1128                      RTS                             ; return from subroutine
00001CB0                          1129  
00001CB0                          1130  * Gets the direction value for ASd and LSd
00001CB0                          1131  * Input: D2 = instruction word copy (of D0)                                    
00001CB0                          1132  * Output: direction value in D2             
00001CB0  C47C 0100               1133  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001CB4  E04A                    1134                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CB6  4E75                    1135                      RTS                             ; return from subroutine
00001CB8                          1136  
00001CB8                          1137  * Gets the rotation size value for ASd and LSd
00001CB8                          1138  * Input: D2 = instruction word copy (of D0)                                    
00001CB8                          1139  * Output: rotation size value in D2             
00001CB8  C47C 00C0               1140  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001CBC  EC4A                    1141                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CBE  4E75                    1142                      RTS                             ; return from subroutine
00001CC0                          1143  
00001CC0                          1144  * Gets the rotation location  value for ASd and LSd
00001CC0                          1145  * Input: D2 = instruction word copy (of D0)                                    
00001CC0                          1146  * Output: rotation location value in D2             
00001CC0  C47C 0020               1147  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001CC4  EA4A                    1148                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CC6  4E75                    1149                      RTS                             ; return from subroutine
00001CC8                          1150  
00001CC8                          1151  * Prints out registers for MOVEM
00001CC8                          1152  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001CC8                          1153  * Output: printed out registers
00001CC8                          1154  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001CC8  48E7 0706               1155  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001CCC  3A3C 0000               1156                      MOVE.W     #0,D5                ; sets counter to 0
00001CD0  3E1A                    1157                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001CD2  B83C 0001               1158                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001CD6  6600 0010               1159                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001CDA                          1160  
00001CDA  3C3C 0000               1161  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001CDE  4BF9 000023C0           1162                      LEA        MSG_DR,A5            ; loads D to A5
00001CE4  6000 000C               1163                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001CE8                          1164                      
00001CE8  3C3C 0007               1165  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001CEC  4BF9 000023C2           1166                      LEA        MSG_AR,A5            ; loads A to A5
00001CF2                          1167                      
00001CF2  E34F                    1168  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001CF4  6500 0018               1169                      BCS        PRINTREG             ; if pushes out a 1
00001CF8  DC44                    1170                      ADD.W      D4,D6                ; decrements or increments
00001CFA  5245                    1171                      ADD.W      #1,D5                ; increments D5
00001CFC  BA7C 0008               1172                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D00  66F0                    1173                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D02  B83C 0001               1174                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D06  6600 0052               1175                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D0A  6000 0042               1176                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001D0E                          1177                      
00001D0E  4EB9 00002064           1178  PRINTREG            JSR        PRINTNULL
00001D14  3206                    1179                      MOVE.W     D6,D1
00001D16  4EB9 00001F1A           1180                      JSR        PRINTNUM 
00001D1C                          1181    
00001D1C  BE7C 0000               1182  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001D20  6600 0006               1183                      BNE        PRINTMORE            ; continue if there is more
00001D24  6000 0040               1184                      BRA        DONEPRINTINGREG      ; exit case
00001D28                          1185  
00001D28  2C4D                    1186  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001D2A  4BF9 000023D3           1187                      LEA        MSG_SLASH,A5         ; leads / into A5
00001D30  4EB9 00002064           1188                      JSR        PRINTNULL            ; prints the slash
00001D36  2A4E                    1189                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001D38  DC44                    1190                      ADD.W      D4,D6                ; decrements or increments
00001D3A  5245                    1191                      ADD.W      #1,D5                ; increments D5
00001D3C  BA7C 0008               1192                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D40  66B0                    1193                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D42  B83C 0001               1194                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D46  6600 0012               1195                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D4A  6000 0002               1196                      BRA        REGTOMEM2            ; loops
00001D4E                          1197  
00001D4E  3C3C 0000               1198  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001D52  4BF9 000023C2           1199                      LEA        MSG_AR,A5            ; loads A to A5
00001D58  6098                    1200                      BRA        PRINTREGISTERLOOP    ; loops
00001D5A                          1201  
00001D5A  3C3C 0007               1202  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001D5E  4BF9 000023C0           1203                      LEA        MSG_DR,A5            ; loads D to A5
00001D64  608C                    1204                      BRA        PRINTREGISTERLOOP    ; loops
00001D66                          1205  
00001D66  4CDF 60E0               1206  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001D6A                          1207  
00001D6A                          1208                          
00001D6A                          1209  * Checks if EA or Xn is valid
00001D6A                          1210  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001D6A                          1211  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001D6A  2F02                    1212  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001D6C                          1213  
00001D6C  141D                    1214  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001D6E  B43C 00FF               1215                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001D72  6700 000A               1216                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001D76  B202                    1217                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001D78  6700 000C               1218                     BEQ        VALIDEA               ; branches to valid EA
00001D7C  60EE                    1219                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001D7E                          1220                     
00001D7E  323C 0001               1221  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001D82  6000 0016               1222                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001D86                          1223                    
00001D86  B43C 0007               1224  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001D8A  6700 000A               1225                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001D8E  323C 0000               1226                     MOVE.W     #$0,D1                ; marks that it is valid
00001D92  6000 0006               1227                     BRA        CHECKEAEXIT           ; exits the subroutine
00001D96                          1228  
00001D96  323C 0002               1229  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001D9A                          1230  
00001D9A  241F                    1231  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001D9C  4E75                    1232                     RTS                              ; returns from subroutine
00001D9E                          1233  
00001D9E                          1234  * Converts EA and Xn into a string                                
00001D9E                          1235  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001D9E                          1236  * Outputs: Prints out EA and Xn into a string
00001D9E  48E7 C004               1237  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001DA2  B47C 0001               1238                     CMP.W    #An,D2                  ; checks if it is An
00001DA6  6700 003A               1239                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001DAA                          1240                     
00001DAA  B47C 0002               1241                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001DAE  6700 004A               1242                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001DB2                          1243                     
00001DB2  B47C 0003               1244                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001DB6  6700 0072               1245                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001DBA                          1246                     
00001DBA  B47C 0004               1247                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001DBE  6700 00A6               1248                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001DC2                          1249                     
00001DC2  B47C 0007               1250                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001DC6  6700 00DA               1251                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001DCA                          1252                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001DCA                          1253  
00001DCA                          1254  * data register, Dn
00001DCA  4BF9 000023C0           1255  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001DD0  4EB9 00002064           1256                     JSR      PRINTNULL               ; Prints D
00001DD6  3203                    1257                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DD8  4EB9 00001F1A           1258                     JSR      PRINTNUM                ; Prints the Xn
00001DDE  6000 0134               1259                     BRA      EA_TO_STRING_EXIT       ; exits           
00001DE2                          1260  
00001DE2                          1261  
00001DE2                          1262  * address register
00001DE2  4BF9 000023C2           1263  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001DE8  4EB9 00002064           1264                     JSR      PRINTNULL               ; Prints A
00001DEE  3203                    1265                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DF0  4EB9 00001F1A           1266                     JSR      PRINTNUM                ; Prints the Xn
00001DF6  6000 011C               1267                     BRA      EA_TO_STRING_EXIT       ; exits
00001DFA                          1268  
00001DFA                          1269  * address register indirect
00001DFA  4BF9 000023C4           1270  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001E00  4EB9 00002064           1271                     JSR      PRINTNULL               ; Prints (
00001E06  4BF9 000023C2           1272                     LEA      MSG_AR,A5               ; Loads A into A5
00001E0C  4EB9 00002064           1273                     JSR      PRINTNULL               ; Prints A
00001E12  3203                    1274                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E14  4EB9 00001F1A           1275                     JSR      PRINTNUM                ; Prints the Xn
00001E1A  4BF9 000023C6           1276                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E20  4EB9 00002064           1277                     JSR      PRINTNULL               ; Prints )
00001E26  6000 00EC               1278                     BRA      EA_TO_STRING_EXIT       ; exits
00001E2A                          1279  
00001E2A                          1280  * address register indirect post increment
00001E2A  4BF9 000023C4           1281  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001E30  4EB9 00002064           1282                     JSR      PRINTNULL               ; Prints (
00001E36  4BF9 000023C2           1283                     LEA      MSG_AR,A5               ; Loads A into A5
00001E3C  4EB9 00002064           1284                     JSR      PRINTNULL               ; Prints A
00001E42  3203                    1285                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E44  4EB9 00001F1A           1286                     JSR      PRINTNUM                ; Prints the Xn
00001E4A  4BF9 000023C6           1287                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E50  4EB9 00002064           1288                     JSR      PRINTNULL               ; Prints )
00001E56  4BF9 000023C8           1289                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001E5C  4EB9 00002064           1290                     JSR      PRINTNULL               ; Prints +
00001E62  6000 00B0               1291                     BRA      EA_TO_STRING_EXIT       ; exits
00001E66                          1292  
00001E66                          1293  
00001E66                          1294  * address register indirect pre increment
00001E66  4BF9 000023CA           1295  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001E6C  4EB9 00002064           1296                     JSR      PRINTNULL               ; Prints -
00001E72  4BF9 000023C4           1297                     LEA      MSG_LB,A5               ; Loads ( into A5
00001E78  4EB9 00002064           1298                     JSR      PRINTNULL               ; Prints (
00001E7E  4BF9 000023C2           1299                     LEA      MSG_AR,A5               ; Loads A into A5
00001E84  4EB9 00002064           1300                     JSR      PRINTNULL               ; Prints A
00001E8A  3203                    1301                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E8C  4EB9 00001F1A           1302                     JSR      PRINTNUM                ; Prints the Xn
00001E92  4BF9 000023C6           1303                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E98  4EB9 00002064           1304                     JSR      PRINTNULL               ; Prints )
00001E9E  6000 0074               1305                     BRA      EA_TO_STRING_EXIT       ; exits
00001EA2                          1306  
00001EA2                          1307  * other (long, short, immediate) with Xn yes
00001EA2  301A                    1308  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001EA4  B67C 0000               1309                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001EA8  6700 002E               1310                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001EAC                          1311                     
00001EAC  B67C 0001               1312                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001EB0  6700 0042               1313                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001EB4                          1314  
00001EB4                          1315  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001EB4                          1316  * immediate
00001EB4  4BF9 000023CC           1317  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001EBA  4EB9 00002064           1318                     JSR      PRINTNULL               ; Prints #  
00001EC0  4BF9 000023CE           1319                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EC6  4EB9 00002064           1320                     JSR      PRINTNULL               ; Prints $
00001ECC  3200                    1321                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001ECE  4EB9 00001F2A           1322                     JSR      PRINTHEXNUM 
00001ED4  6000 003E               1323                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001ED8                          1324                     
00001ED8                          1325  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001ED8                          1326  
00001ED8                          1327  * word address
00001ED8                          1328  CASE_WORD          
00001ED8  4BF9 000023CE           1329                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EDE  4EB9 00002064           1330                     JSR      PRINTNULL               ; Prints $
00001EE4  3200                    1331                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001EE6  383C 0000               1332                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001EEA  4EB9 00001F3E           1333                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001EF0  6000 0022               1334                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001EF4                          1335  
00001EF4                          1336  * long address 
00001EF4                          1337  CASE_LONG          
00001EF4  4BF9 000023CE           1338                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EFA  4EB9 00002064           1339                     JSR      PRINTNULL               ; Prints $
00001F00  3200                    1340                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001F02  383C 0001               1341                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001F06  4EB9 00001F3E           1342                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001F0C  321A                    1343                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001F0E  4EB9 00001F1A           1344                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001F14                          1345  
00001F14                          1346  
00001F14                          1347  * exits subroutine
00001F14  4CDF 2003               1348  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001F18  4E75                    1349                      RTS                              ; returns from subroutine
00001F1A                          1350  
00001F1A                          1351  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001F1A                          1352  
00001F1A                          1353  * Prints out the content of D1 as a decimal number
00001F1A                          1354  * Input: number in D1 to be printed
00001F1A                          1355  * Output: contents of D1 printed
00001F1A  48E7 C000               1356  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F1E  103C 0003               1357                   MOVE.B      #3,D0               ; prints D1
00001F22  4E4F                    1358                   TRAP        #15                 ; is trap task 3
00001F24                          1359              
00001F24  4CDF 0003               1360                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F28  4E75                    1361                   RTS                             ; returns from subroutine
00001F2A                          1362                   
00001F2A                          1363  * Prints out the content of D1 as a hex number
00001F2A                          1364  * Input: number in D1 to be printed
00001F2A                          1365  * Output: contents of D1 printed
00001F2A  48E7 C000               1366  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F2E  143C 0010               1367                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001F32  103C 000F               1368                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001F36  4E4F                    1369                   TRAP        #15                 ; is trap task 15
00001F38  4CDF 0003               1370                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F3C  4E75                    1371                   RTS                             ; returns from subroutine
00001F3E                          1372                   
00001F3E                          1373  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001F3E                          1374  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001F3E                          1375  * Output: contents of D1 printed
00001F3E  48E7 E000               1376  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001F42  B83C 0001               1377                            CMP.B       #1,D4               ; checks size of number
00001F46  6700 0042               1378                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001F4A                          1379  
00001F4A  3401                    1380  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001F4C  C47C F000               1381                            AND.W       #$F000,D2           ; gets the first digit
00001F50  B47C 0000               1382                            CMP.W       #0, D2              ; checks if it is 0
00001F54  6600 00DC               1383                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F58  4EB9 00002042           1384                            JSR         PRINTZERO           ; prints a zero
00001F5E                          1385                            
00001F5E  3401                    1386                            MOVE.W      D1,D2               ; copies number to D2
00001F60  C47C 0F00               1387                            AND.W       #$0F00,D2           ; gets the second digit
00001F64  B47C 0000               1388                            CMP.W       #0, D2              ; checks if it is 0
00001F68  6600 00C8               1389                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F6C  4EB9 00002042           1390                            JSR         PRINTZERO           ; prints a zero
00001F72                          1391                            
00001F72  3401                    1392                            MOVE.W      D1,D2               ; copies number to D2
00001F74  C47C 00F0               1393                            AND.W       #$00F0,D2           ; gets the third digit
00001F78  B47C 0000               1394                            CMP.W       #0, D2              ; checks if it is 0
00001F7C  6600 00B4               1395                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F80  4EB9 00002042           1396                            JSR         PRINTZERO           ; prints a zero
00001F86  6000 00AA               1397                            BRA         PRINTASHEX          ; prints last digit
00001F8A                          1398                            
00001F8A  2401                    1399  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001F8C  C4BC F0000000           1400                            AND.L       #$F0000000,D2       ; gets the first digit
00001F92  B4BC 00000000           1401                            CMP.L       #0, D2              ; checks if it is 0
00001F98  6600 0098               1402                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F9C  4EB9 00002042           1403                            JSR         PRINTZERO           ; prints a zero
00001FA2                          1404                            
00001FA2  2401                    1405                            MOVE.L      D1,D2               ; copies number to D2
00001FA4  C4BC 0F000000           1406                            AND.L       #$0F000000,D2       ; gets the second digit
00001FAA  B4BC 00000000           1407                            CMP.L       #0, D2              ; checks if it is 0
00001FB0  6600 0080               1408                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FB4  4EB9 00002042           1409                            JSR         PRINTZERO           ; prints a zero
00001FBA                          1410                            
00001FBA  2401                    1411                            MOVE.L      D1,D2               ; copies number to D2
00001FBC  C4BC 00F00000           1412                            AND.L       #$00F00000,D2       ; gets the third digit
00001FC2  B4BC 00000000           1413                            CMP.L       #0, D2              ; checks if it is 0
00001FC8  6600 0068               1414                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FCC  4EB9 00002042           1415                            JSR         PRINTZERO           ; prints a zero
00001FD2                          1416                            
00001FD2  2401                    1417                            MOVE.L      D1,D2               ; copies number to D2
00001FD4  C4BC 000F0000           1418                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001FDA  B4BC 00000000           1419                            CMP.L       #0, D2              ; checks if it is 0
00001FE0  6600 0050               1420                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FE4  4EB9 00002042           1421                            JSR         PRINTZERO           ; prints a zero
00001FEA                          1422                            
00001FEA  2401                    1423                            MOVE.L      D1,D2               ; copies number to D2
00001FEC  C4BC 0000F000           1424                            AND.L       #$0000F000,D2       ; gets the fith digit
00001FF2  B4BC 00000000           1425                            CMP.L       #0, D2              ; checks if it is 0
00001FF8  6600 0038               1426                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FFC  4EB9 00002042           1427                            JSR         PRINTZERO           ; prints a zero
00002002                          1428                            
00002002  2401                    1429                            MOVE.L      D1,D2               ; copies number to D2
00002004  C4BC 00000F00           1430                            AND.L       #$00000F00,D2       ; gets the sixth digit
0000200A  B4BC 00000000           1431                            CMP.L       #0, D2              ; checks if it is 0
00002010  6600 0020               1432                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002014  4EB9 00002042           1433                            JSR         PRINTZERO           ; prints a zero
0000201A                          1434                            
0000201A  2401                    1435                            MOVE.L      D1,D2               ; copies number to D2
0000201C  C4BC 000000F0           1436                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002022  B4BC 00000000           1437                            CMP.L       #0, D2              ; checks if it is 0
00002028  6600 0008               1438                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000202C  4EB9 00002042           1439                            JSR         PRINTZERO           ; prints a zero
00002032                          1440  
00002032  143C 0010               1441  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002036  103C 000F               1442                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000203A  4E4F                    1443                            TRAP        #15                 ; is trap task 15
0000203C  4CDF 0007               1444                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002040  4E75                    1445                            RTS                             ; returns from subroutine    
00002042                          1446  * Prints a zero
00002042                          1447  * Input: nothing
00002042                          1448  * Output: 0 printed out to the console
00002042  2F01                    1449  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002044  7200                    1450                            MOVE.L      #0,D1               ; moves 0 to D1
00002046  4EB8 1F1A               1451                            JSR         PRINTNUM            ; prints the number
0000204A  221F                    1452                            MOVE.L      (SP)+,D1            ; restores D1
0000204C  4E75                    1453                            RTS                             ; returns from subroutine
0000204E                          1454              
0000204E                          1455  * Prints contents of things between a range
0000204E                          1456  * input: A5, A6 (the range)
0000204E                          1457  * output: prints memory contents from A5 to A6 as strings   
0000204E  48E7 C040               1458  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00002052  224D                    1459                  MOVEA.L     A5, A1           ; loads A5 into A1
00002054  9DCD                    1460                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00002056  320E                    1461                  MOVE.W      A6, D1           ; move n into D1
00002058  103C 0001               1462                  MOVE.B      #1, D0           ; display n characters of string at A1
0000205C  4E4F                    1463                  TRAP        #15              ; is trap task 1
0000205E  4CDF 0203               1464                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00002062  4E75                    1465                  RTS                          ; returns
00002064                          1466      
00002064                          1467  * Prints null terminated string
00002064                          1468  * input: string pointed to by A5
00002064                          1469  * output: prints out the null terminated string
00002064  48E7 8040               1470  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002068  224D                    1471                  MOVE.L      A5,A1           ; loads A5 into A1
0000206A  103C 000E               1472                  MOVE.B      #14,D0          ; prints null terminated string
0000206E  4E4F                    1473                  TRAP        #15             ; is trap task 10
00002070  4CDF 0201               1474                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00002074  4E75                    1475                  RTS                         ; returns from subroutine
00002076                          1476                  
00002076  2F0D                    1477  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002078  4BF9 000022CC           1478                  LEA         NEW_LINE,A5     ; Prints null
0000207E  4EB8 2064               1479                  JSR         PRINTNULL       ; prints the new line
00002082  2A5F                    1480                  MOVE.L      (SP)+,A5        ; returns A5
00002084  4E75                    1481                  RTS
00002086                          1482  
00002086                          1483  * Prints the size of the MOVE or MOVEA operation  
00002086                          1484  * input: D0
00002086                          1485  * output: prints out the size of a MOVE or MOVEA operation        
00002086  48E7 8004               1486  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
0000208A  3200                    1487                  MOVE.W  D0,D1               ; stores d0 in d1
0000208C  C07C 3000               1488                  AND.W   #$3000,D0           ; gets the size
00002090  B07C 2000               1489                  CMP.W   #$2000,D0           ; checks if is long
00002094  6700 001E               1490                  BEQ     MOVE_LONG
00002098  B07C 3000               1491                  CMP.W   #$3000,D0           ; checks if is word
0000209C  6700 000C               1492                  BEQ     MOVE_WORD      
000020A0                          1493                  
000020A0  4BF9 000023D9           1494  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000020A6  6000 0012               1495                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020AA                          1496  
000020AA  4BF9 000023DF           1497  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000020B0  6000 0008               1498                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020B4                          1499  
000020B4  4BF9 000023E5           1500  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000020BA                          1501                  
000020BA  4EB8 2064               1502  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000020BE  4CDF 2001               1503                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000020C2  4E75                    1504                  RTS
000020C4                          1505  
000020C4  43F9 0000226F           1506  ERROR           LEA     ERROR_MSG,A1
000020CA  103C 000E               1507                  MOVE.B  #14,D0
000020CE  4E4F                    1508                  TRAP    #15 
000020D0                          1509         
000020D0                          1510  * DELETE THIS: Test                
000020D0  2661                    1511  DELETEME        MOVEA.L  -(A1),A3
000020D2  6700 0038               1512                  BEQ      DELETEMEAGAIN  
000020D6  6F00 0034               1513                  BLE      DELETEMEAGAIN
000020DA  6E00 0030               1514                  BGT      DELETEMEAGAIN
000020DE                          1515  
000020DE  E40A                    1516                  LSR.B      #2,D2
000020E0  E2E2                    1517                  LSR.W      -(A2)
000020E2  E2DA                    1518                  LSR.W      (A2)+
000020E4  E4AA                    1519                  LSR.L      D2,D2 
000020E6  E50A                    1520                  LSL.B      #2,D2
000020E8  E3E2                    1521                  LSL.W      -(A2)
000020EA  E3DA                    1522                  LSL.W      (A2)+
000020EC  E5AA                    1523                  LSL.L      D2,D2
000020EE  E51A                    1524                  ROL.B      #2,D2
000020F0  E7E2                    1525                  ROL.W      -(A2)
000020F2  E7DA                    1526                  ROL.W      (A2)+
000020F4  E5BA                    1527                  ROL.L      D2,D2
000020F6  E41A                    1528                  ROR.B      #2,D2
000020F8  E6E2                    1529                  ROR.W      -(A2)
000020FA  E6DA                    1530                  ROR.W      (A2)+
000020FC  E4BA                    1531                  ROR.L      D2,D2
000020FE                          1532                  
000020FE  504D                    1533                  ADDQ.W      #8,A5
00002100  D6C2                    1534                  ADDA.W      D2,A3
00002102  9BCB                    1535                  SUB.L       A3,A5        
00002104  8A43                    1536                  OR.W        D3,D5
00002106  4642                    1537                  NOT.W       D2
00002108                          1538                  
00002108  C5FC 0010               1539                  MULS.W    #$0010,D2
0000210C                          1540                  
0000210C                          1541  DELETEMEAGAIN                 
0000210C                          1542            
0000210C  FFFF FFFF               1543      SIMHALT             ; halt simulator
00002110                          1544  
00002110                          1545  * Put variables and constants here
00002110                          1546  
00002110  =0000000D               1547  CR                              EQU     $0D
00002110  =0000000A               1548  LF                              EQU     $0A 
00002110  =00000009               1549  TAB                             EQU     $09  
00002110                          1550  
00002110                          1551  * Addressing Modes
00002110  =00000000               1552  Dn                              EQU     0
00002110  =00000001               1553  An                              EQU     1
00002110  =00000002               1554  AnIndirect                      EQU     2
00002110  =00000003               1555  AnPost                          EQU     3
00002110  =00000004               1556  AnPre                           EQU     4
00002110  =00000007               1557  Other                           EQU     7           ; short, long, immediate
00002110                          1558  
00002110                          1559  * Xn
00002110  =00000000               1560  ABSShort                        EQU     0
00002110  =00000001               1561  ABSLong                         EQU     1
00002110  =00000004               1562  XnImmediate                     EQU     4
00002110                          1563  
00002110                          1564  * Valid Addressing Modes
00002110= 00 01 02 03 04 07 FF    1565  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00002117                          1566  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00002117= 00 02 03 04 07 FF       1567  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000211D= 02 04 07 FF             1568  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002121= 02 03 07 FF             1569  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00002125= 02 03 04 07 FF          1570  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000212A= 00 02 03 04 07 FF       1571  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002130= 01 07 FF                1572  VALIDEA_LEA                     DC.B    An,Other,-1
00002133= 00 02 03 04 07 FF       1573  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002139= 02 03 04 07 FF          1574  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000213E= 02 03 04 07 FF          1575  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00002143= 02 07 FF                1576  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00002146                          1577  
00002146                          1578  * Valid Xn
00002146= 00 01 04 FF             1579  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
0000214A                          1580  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
0000214A= 00 01 FF                1581  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
0000214D                          1582  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
0000214D                          1583  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
0000214D                          1584  
0000214D                          1585  * posible memory ASd/LSd rotation values
0000214D  =00000000               1586  ASd_MEM                         EQU     0   
0000214D  =00000001               1587  LSd_MEM                         EQU     1 
0000214D  =00000003               1588  ROd_MEM                         EQU     3
0000214D                          1589   
0000214D  =00000000               1590  ASd_REG                         EQU     0   
0000214D  =00000001               1591  LSd_REG                         EQU     1 
0000214D  =00000003               1592  ROd_REG                         EQU     3
0000214D                          1593  
0000214D                          1594  * Messages
0000214D= 57 65 6C 63 6F 6D ...   1595  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
00002175= 46 6F 72 6D 61 74 ...   1596  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
000021C0= 4C 65 74 74 65 72 ...   1597  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000021E0= 50 6C 65 61 73 65 ...   1598  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002217= 50 6C 65 61 73 65 ...   1599  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
0000224D= 49 6E 76 61 6C 69 ...   1600  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
0000226F= 45 72 72 6F 72 20 ...   1601  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
0000228B= 31 30 30 30 09 09 ...   1602  INVALID_INSTR                   DC.B    '1000',TAB,TAB,'DATA',TAB,TAB,TAB,'$',0
0000229A= 46 69 6E 69 73 68 ...   1603  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
000022CC= 0D 0A 00                1604  NEW_LINE                        DC.B    CR,LF,0
000022CF= 09 09 09 00             1605  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000022D3                          1606  
000022D3                          1607  * Opcode Messages
000022D3= 09 4E 4F 50 00          1608  MSG_NOP                         DC.B    TAB,'NOP',0
000022D8= 09 4D 4F 56 45 00       1609  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000022DE= 09 4D 4F 56 45 41 00    1610  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000022E5= 09 4D 4F 56 45 51 00    1611  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000022EC= 09 4D 4F 56 45 4D 00    1612  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000022F3= 09 41 44 44 00          1613  MSG_ADD                         DC.B    TAB,'ADD',0
000022F8= 09 41 44 44 41 00       1614  MSG_ADDA                        DC.B    TAB,'ADDA',0
000022FE= 09 41 44 44 51 00       1615  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00002304= 09 53 55 42 00          1616  MSG_SUB                         DC.B    TAB,'SUB',0
00002309= 09 4D 55 4C 53 00       1617  MSG_MULS                        DC.B    TAB,'MULS',0
0000230F= 09 44 49 56 55 00       1618  MSG_DIVU                        DC.B    TAB,'DIVU',0
00002315= 09 4C 45 41 09 09 ...   1619  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
0000231D= 09 41 4E 44 00          1620  MSG_AND                         DC.B    TAB,'AND',0
00002322= 09 4F 52 00             1621  MSG_OR                          DC.B    TAB,'OR',0
00002326= 09 4E 4F 54 00          1622  MSG_NOT                         DC.B    TAB,'NOT',0
0000232B= 09 4C 53 00             1623  MSG_LSd                         DC.B    TAB,'LS',0
0000232F= 09 41 53 00             1624  MSG_ASd                         DC.B    TAB,'AS',0
00002333= 09 52 4F 00             1625  MSG_ROd                         DC.B    TAB,'RO',0
00002337= 09 42 43 43 09 09 ...   1626  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
0000233F= 09 42 43 53 09 09 ...   1627  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00002347= 09 42 45 51 09 09 ...   1628  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
0000234F= 09 42 4E 45 09 09 ...   1629  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00002357= 09 42 47 45 09 09 ...   1630  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
0000235F= 09 42 47 54 09 09 ...   1631  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00002367= 09 42 48 49 09 09 ...   1632  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
0000236F= 09 42 4C 45 09 09 ...   1633  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00002377= 09 42 4C 53 09 09 ...   1634  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
0000237F= 09 42 4C 54 09 09 ...   1635  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00002387= 09 42 4D 49 09 09 ...   1636  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
0000238F= 09 42 50 4C 09 09 ...   1637  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00002397= 09 42 56 43 09 09 ...   1638  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
0000239F= 09 42 56 53 09 09 ...   1639  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
000023A7= 09 4A 53 52 09 09 ...   1640  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
000023AF= 09 52 54 53 00          1641  MSG_RTS                         DC.B    TAB,'RTS',0
000023B4= 09 42 52 41 09 09 ...   1642  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
000023BC                          1643  
000023BC                          1644  * Direction for LSd and ASd
000023BC= 52 00                   1645  MSG_RIGHT                       DC.B    'R',0
000023BE= 4C 00                   1646  MSG_LEFT                        DC.B    'L',0
000023C0                          1647  
000023C0                          1648  * Effective Addresses Messages
000023C0= 44 00                   1649  MSG_DR                          DC.B    'D',0
000023C2= 41 00                   1650  MSG_AR                          DC.B    'A',0
000023C4= 28 00                   1651  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000023C6= 29 00                   1652  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000023C8= 2B 00                   1653  MSG_PLUS                        DC.B    '+',0
000023CA= 2D 00                   1654  MSG_MINUS                       DC.B    '-',0
000023CC= 23 00                   1655  MSG_POUND                       DC.B    '#',0 
000023CE= 24 00                   1656  MSG_HEX                         DC.B    '$',0 
000023D0= 2C 20 00                1657  MSG_COMMA                       DC.B    ', ',0
000023D3= 2F 00                   1658  MSG_SLASH                       DC.B    '/',0  
000023D5= 20 00                   1659  MSG_SPACE                       DC.B    ' ',0
000023D7= 09 00                   1660  MSG_TAB                         DC.B    TAB,0
000023D9                          1661  
000023D9                          1662  * Size Messages
000023D9= 2E 42 09 09 09 00       1663  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
000023DF= 2E 57 09 09 09 00       1664  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
000023E5= 2E 4C 09 09 09 00       1665  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
000023EB                          1666  
000023EB                          1667  * Variables
000023EB  =00000100               1668  STARTING_ADDRESS                EQU     $100
000023EB  =00000150               1669  ENDING_ADDRESS                  EQU     $150
000023EB  =00000200               1670  CURRENT_INSTR                   EQU     $200
000023EB  =00000250               1671  REG_VAR                         EQU     $250 * Hold bits 11-9
000023EB  =00000300               1672  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000023EB  =00000350               1673  EA_MODE                         EQU     $350 * Hold bits 5-3
000023EB  =00000400               1674  EA_REG                          EQU     $400 * Hold bits 2-0
000023EB                          1675  
000023EB                          1676              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1576
ADDQ_BYTE           160C
ADDQ_LONG           162C
ADDQ_WORD           161C
ADD_SUB_BYTE        14B2
ADD_SUB_HELP        1438
ADD_SUB_LONG        14CE
ADD_SUB_OPERAND     14E4
ADD_SUB_SIZE        148E
ADD_SUB_WORD        14C0
AN                  1
AND_BYTE            17F6
AND_LONG            1816
AND_WORD            1806
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           224D
CASE_ADD            140C
CASE_ADDA           154A
CASE_ADDQ           15B2
CASE_AND            17AC
CASE_AR             1DE2
CASE_ARI            1DFA
CASE_ARIPOST        1E2A
CASE_ARIPRE         1E66
CASE_ASDMEM         194A
CASE_ASDREG         1A16
CASE_BCC            1B56
CASE_BEQ            1B88
CASE_BGT            1B9C
CASE_BLE            1B92
CASE_BRA            1B2E
CASE_DATA           1BD4
CASE_DR             1DCA
CASE_EPICFAIL       1BDA
CASE_IMMEDIATE      1EB4
CASE_JSR            1BBA
CASE_LEA            171A
CASE_LEFTMEM        1974
CASE_LEFTREG        1A40
CASE_LONG           1EF4
CASE_LSDASDROD      190A
CASE_LSDMEM         1940
CASE_LSDREG         1A0C
CASE_MOVE           120E
CASE_MOVEM          12B4
CASE_MOVEQ          13B4
CASE_NOP            11F4
CASE_NOT            18AE
CASE_OR             1856
CASE_OTHER          1EA2
CASE_RIGHTMEM       197E
CASE_RIGHTREG       1A4A
CASE_RODMEM         1954
CASE_RODREG         1A20
CASE_RTS            1BBA
CASE_SHIFTMEM       1928
CASE_SHIFTREG       19F2
CASE_SUB            168A
CASE_SUBA           1704
CASE_WORD           1ED8
CHECKEAEXIT         1D9A
CHECKEAMLOOP        1D6C
CHECKEAXN_IFVALID   1D6A
CHECKGET_EAXN       1C30
CHECKMEMSOURE       19B2
CHECKMOREBITS       1D1C
CHECKSHIFT_XN       19DC
CHECK_LENGTH        1146
CHECK_ODD           11DC
CHECK_ORDER         10AE
CHECK_XN            1C60
CONCAT              118E
CONVERT             1158
CR                  D
CURRENT_INSTR       200
DELETEME            20D0
DELETEMEAGAIN       210C
DESTEA              1BE6
DESTXN              1C10
DISASSEMBLE         10B8
DN                  0
DN_PLUS_EA          151E
DONE                229A
DONEPRINTINGREG     1D66
EASHIFT_VALID       19D0
EAXN_INVALID        1C72
EAXN_VALID          1C58
EA_MODE             350
EA_REG              400
EA_TO_STRING        1D9E
EA_TO_STRING_EXIT   1F14
ENDING              2217
ENDING_ADDRESS      150
END_CHECKGET        1C76
ERROR               20C4
ERROR_MSG           226F
FINDTYPEEA          1BFA
FINDTYPEXN          1C24
FINISHED            10C8
FINISHMOVE          20BA
FINISH_ADD          14DC
FINISH_ADDA         1586
FINISH_ADDQ         163C
FINISH_AND          1826
FINISH_SUB          16CA
FINISH_SUBA         16D0
FORMAT1             2175
FORMAT2             21C0
GETDIRECTION        1CB0
GETDISPLACEMENT     1C78
GETMEMSOURCE        199A
GETROTATION         1CA6
GETROTATIONLOCATION  1CC0
GETROTATIONSIZE     1CB8
GET_EA              1BDC
GET_XN              1C06
INPUT1              1020
INPUT2              1066
INSERTA             1280
INVALID             11A6
INVALIDEA           1D7E
INVALID_INSTR       228B
INV_INSTR           1830
ISNUMBER            116E
LF                  A
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         138A
MEM2REGWORD         137C
MEMTOREG1           1CE8
MEMTOREG2           1D5A
MOVEM_MEM2REG       1344
MOVEM_REG2MEM       12D2
MOVE_BYTE           20A0
MOVE_LONG           20B4
MOVE_WORD           20AA
MSG_ADD             22F3
MSG_ADDA            22F8
MSG_ADDQ            22FE
MSG_AND             231D
MSG_AR              23C2
MSG_ASD             232F
MSG_B               23D9
MSG_BCC             2337
MSG_BCS             233F
MSG_BEQ             2347
MSG_BGE             2357
MSG_BGT             235F
MSG_BHI             2367
MSG_BLE             236F
MSG_BLS             2377
MSG_BLT             237F
MSG_BMI             2387
MSG_BNE             234F
MSG_BPL             238F
MSG_BRA             23B4
MSG_BVC             2397
MSG_BVS             239F
MSG_COMMA           23D0
MSG_DIVU            230F
MSG_DR              23C0
MSG_HEX             23CE
MSG_JSR             23A7
MSG_L               23E5
MSG_LB              23C4
MSG_LEA             2315
MSG_LEFT            23BE
MSG_LSD             232B
MSG_MINUS           23CA
MSG_MOVE            22D8
MSG_MOVEA           22DE
MSG_MOVEM           22EC
MSG_MOVEQ           22E5
MSG_MULS            2309
MSG_NOP             22D3
MSG_NOT             2326
MSG_OR              2322
MSG_PLUS            23C8
MSG_POUND           23CC
MSG_RB              23C6
MSG_RIGHT           23BC
MSG_ROD             2333
MSG_RTS             23AF
MSG_SLASH           23D3
MSG_SPACE           23D5
MSG_SUB             2304
MSG_TAB             23D7
MSG_W               23DF
NEW_LINE            22CC
NOTNUMBER           1176
OPCODE_DECODE       11F0
OPMODE_VAR          300
OR_SIZE             1896
OTHER               7
OTHEREA             1D96
PRINTADD            1476
PRINTADDRESS        1C88
PRINTASHEX          2032
PRINTBCC            1BA6
PRINTENTER          2076
PRINTHEXNUM         1F2A
PRINTLONGZERO       1F8A
PRINTMEM2REG        1396
PRINTMORE           1D28
PRINTMOVE           1286
PRINTMOVESIZE       2086
PRINTNULL           2064
PRINTNUM            1F1A
PRINTRANGE          204E
PRINTREG            1D0E
PRINTREG2MEM        1326
PRINTREGEA          1A8C
PRINTREGISTERLOOP   1CF2
PRINTREGISTERS      1CC8
PRINTREGSIZE        1A5A
PRINTSHIFTMEM       195A
PRINTSHIFTREG       1A26
PRINTSHORTLONGNUM   1F3E
PRINTSHORTZERO      1F4A
PRINTSUB            16A4
PRINTZERO           2042
PRINT_8             167E
PRINT_ADDQ_DATA     165A
PRINT_ADDR          11E4
PRINT_MEMDIR        1984
PRINT_MOVEQ         13D6
PRINT_REGDIR        1A54
REG2MEMLONG         131A
REG2MEMWORD         130A
REGTOMEM1           1CDA
REGTOMEM2           1D4E
REG_BYTE            1A72
REG_IMMEDIATE       1AA2
REG_LONG            1A86
REG_REGISTER        1AE8
REG_VAR             250
REG_WORD            1A7C
RESET_INPUT         113E
RESTART             10E8
RETURN              11A4
ROD_MEM             3
ROD_REG             3
SOURCEEA            1BF2
SOURCEXN            1C1C
START               1000
STARTING            21E0
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11C4
THREE_TAB           22CF
VALIDEA             1D86
VALIDEA_ADDSUB_DESTOPERAND  2125
VALIDEA_ALL         2110
VALIDEA_ANDORNOT    2133
VALIDEA_ANDOR_DESTOPERAND  2139
VALIDEA_JSR         2143
VALIDEA_LEA         2130
VALIDEA_MOVEM_MEMTOREG  2121
VALIDEA_MOVEM_REGTOMEM  211D
VALIDEA_MOVEQ       2117
VALIDEA_MULSDIVU    212A
VALIDEA_SHIFT       213E
VALIDXN_ALL         2146
VALIDXN_SHORTLONG   214A
WELCOME             214D
XNIMMEDIATE         4
