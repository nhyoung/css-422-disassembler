00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/7/2020 3:39:00 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001DF9             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001E6F             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001EA6             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 00001BF4             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001D2C             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6600 0052                 78                  BNE     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 00001EDC            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C                           138                  
0000116C  B07C 4E71                139  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001170  6600 0010                140                  BNE     CASE_MOVE               ; checks the next case if not equal
00001174  4BF9 00001F3D            141                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117A  4EB9 00001D1A            142                  JSR     PRINTNULL               ; prints NOP                
00001180  4E75                     143                  RTS                             ; returns from the subroutine
00001182                           144                  
00001182                           145                  * if first two bits are 00, next two are not 00
00001182  3200                     146  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001184  C27C C000                147                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001188  6600 009A                148                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
0000118C  B07C 0FFF                149                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001190  6F00 0092                150                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001194                           151                  
00001194                           152                  ; Check source
00001194  4BF9 00001DBC            153                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119A  4DF9 00001DF2            154                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A0  3E3C 0000                155                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A4  4EB9 00001988            156                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AA  B27C 0001                157                  CMP.W   #1,D1                    ; checks if invalid
000011AE  6700 0780                158                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B2  3802                     159                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B4  3A03                     160                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011B6                           161                  
000011B6                           162                  ; Check destination
000011B6  4BF9 00001DBC            163                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011BC  4DF9 00001DF6            164                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C2  3E3C 0001                165                  MOVE.W  #1,D7                    ; Marks D7 as "destination" for CHECKGETEAXN
000011C6  4EB9 00001988            166                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011CC  B27C 0001                167                  CMP.W   #1,D1                    ; checks if invalid
000011D0  6700 075E                168                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D4  3C02                     169                  MOVE.W  D2,D6                    ; Moves D2 (destination effective address) to D6
000011D6  3E03                     170                  MOVE.W  D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
000011D8                           171                  
000011D8                           172                  ; Checking if it is MOVEA
000011D8  3200                     173                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DA  C27C 01C0                174                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011DE  B27C 0040                175                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E2  6700 000C                176                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011E6                           177   
000011E6  4BF9 00001F42            178                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011EC  6000 0008                179                  BRA     PRINTMOVE                ; Branches to print move
000011F0                           180                  
000011F0  4BF9 00001F48            181  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011F6                           182   
000011F6  4EB9 00001D1A            183  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
000011FC  4EB9 00001D3C            184                  JSR     PRINTMOVESIZE            ; prints out the size  
00001202  3404                     185                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001204  3605                     186                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001206  4EB9 00001A54            187                  JSR     EA_TO_STRING             ; outputs it into a string
0000120C                           188                  
0000120C                           189                  ; prints a comma to seperate
0000120C  4BF9 0000203A            190                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001212  4EB9 00001D1A            191                  JSR     PRINTNULL                ; prints out MOVE
00001218                           192                  
00001218                           193                  ; print destination
00001218  3406                     194                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121A  3607                     195                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000121C  4EB9 00001A54            196                  JSR     EA_TO_STRING             ; outputs it into a string
00001222  4E75                     197                  RTS                              ; exits subroutine                 
00001224                           198                
00001224                           199                  
00001224  3200                     200  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001226  C27C FB80                201                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122A  B27C 4880                202                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000122E  6600 005A                203                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001232                           204                  
00001232                           205                  ; loads EA and XN
00001232  323C 0000                206                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001236  4EB9 00001934            207                  JSR     GET_EA                          ; gets EA and puts in D1
0000123C  3401                     208                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
0000123E  323C 0000                209                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001242  4EB9 0000195E            210                  JSR     GET_XN                          ; gets XN and puts in D1
00001248  3601                     211                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
0000124A                           212                  
0000124A                           213                  ; Check D
0000124A  3200                     214                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000124C  C27C 0400                215                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001250  3E01                     216                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001252  B27C 0400                217                  CMP.W   #$0400,D1                       ; checks if value is 1
00001256  6700 0032                218                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000125A                           219  
0000125A  4BF9 00001DC9            220  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001260  3202                     221                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001262  4EB9 00001A20            222                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001268  B27C 0001                223                  CMP.W   #1,D1                           ; checks if D1 invalid
0000126C  6700 06C2                224                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001270  B27C 0002                225                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001274                           226                  
00001274  4BF9 00001DC9            227  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127A  3203                     228                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
0000127C  4EB9 00001A20            229                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001282  B27C 0001                230                  CMP.W   #1,D1                           ; checks if D1 invalid
00001286  6700 06A8                231                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128A                           232  
0000128A                           233                  
0000128A                           234  
0000128A                           235  MOVEM_MEM2REG    
0000128A                           236                          
0000128A                           237  
0000128A                           238  
0000128A  3200                     239  CASE_MOVEQ      MOVE.W  D0,D1
0000128C  C27C F100                240                  AND.W   #$F100,D1
00001290  B27C 7000                241                  CMP.W   #$7000,D1
00001294  6600 0048                242                  BNE     CASE_ADD
00001298                           243                  
00001298                           244                  ;loads Register
00001298  323C 0001                245                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000129C  4EB9 0000195E            246                  JSR     GET_XN                          ; gets XN and puts in D1
000012A2  3401                     247                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012A4                           248                  
000012A4                           249                  ;loads DATA
000012A4  3200                     250                  MOVE.W  D0,D1
000012A6  C27C 00FF                251                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012AA  3601                     252                  MOVE.W  D1,D3                          ;copy data into D3
000012AC                           253                                                          ;must convert bits to hex
000012AC                           254                  
000012AC                           255                  
000012AC  4BF9 00001F4F            256  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B2  4EB9 00001D1A            257                  JSR     PRINTNULL  
000012B8                           258                  
000012B8  4BF9 0000204D            259                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012BE  4EB9 00001D1A            260                  JSR     PRINTNULL
000012C4                           261      
000012C4  4BF9 00001F39            262                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000012CA  4EB9 00001D1A            263                  JSR     PRINTNULL
000012D0                           264                  
000012D0  4BF9 00002036            265                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012D6  4EB9 00001D1A            266                  JSR     PRINTNULL
000012DC  4E75                     267                  RTS
000012DE                           268                  
000012DE                           269  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000012DE  3200                     270  CASE_ADD        MOVE.W  D0,D1
000012E0  C27C F000                271                  AND.W   #$F000,D1
000012E4  B27C D000                272                  CMP.W   #$D000,D1
000012E8  6600 019E                273                  BNE     CASE_ADDQ
000012EC                           274                
000012EC  4EB9 0000130C            275                  JSR     ADD_SUB_HELP
000012F2                           276                  
000012F2                           277                  ; bits 7-8 determine if it is ADDA or ADD
000012F2  3200                     278                  MOVE.W  D0,D1
000012F4  E149                     279                  LSL.W   #8,D1                   ; get rid of left 8 bits
000012F6  E049                     280                  LSR.W   #8,D1
000012F8  EC49                     281                  LSR.W   #6,D1                   ; get rid of right 6 bits
000012FA  B27C 0003                282                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000012FE  6700 0120                283                  BEQ     CASE_ADDA
00001302                           284                  
00001302  4BF9 00001F5D            285                  LEA     MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001308  6000 0048                286                  BRA     PRINTADD                ; Branches to print move
0000130C                           287                  
0000130C                           288                  ; Check bits 0-5 
0000130C  4BF9 00001DBC            289  ADD_SUB_HELP    LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001312  4DF9 00001DF2            290                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001318  3E3C 0000                291                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000131C  4EB9 00001988            292                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001322  B27C 0001                293                  CMP.W   #1,D1                    ; checks if invalid
00001326  6700 0608                294                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000132A  3802                     295                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000132C  3A03                     296                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000132E                           297                  
0000132E                           298                  ; Check 6-11
0000132E  4BF9 00001DBC            299                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001334  4DF9 00001DF6            300                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000133A  3E3C 0001                301                  MOVE.W  #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000133E  4EB9 00001988            302                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001344  B27C 0001                303                  CMP.W   #1,D1                    ; checks if invalid
00001348  6700 05E6                304                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000134C  3C02                     305                  MOVE.W  D2,D6                    ; Moves D2 (destination effective address) to D6
0000134E  3E03                     306                  MOVE.W  D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001350                           307  
00001350  4E75                     308                  RTS                
00001352                           309                  
00001352  4EB9 00001D1A            310  PRINTADD        JSR     PRINTNULL
00001358  3200                     311                  MOVE.W  D0,D1                   ; bits 7-8 contain size
0000135A  4EB9 00001364            312                  JSR     ADD_SUB_SIZE
00001360  6000 0050                313                  BRA     FINISH_ADD
00001364                           314                  
00001364  3200                     315  ADD_SUB_SIZE    MOVE.W  D0,D1
00001366  E149                     316                  LSL.W   #8,D1
00001368  E049                     317                  LSR.W   #8,D1
0000136A  EC49                     318                  LSR.W   #6,D1                   ; gets bits 6-7
0000136C                           319                  
0000136C  B27C 0000                320                  CMP.W   #0,D1
00001370  6700 0016                321                  BEQ     ADD_SUB_BYTE
00001374  B27C 0001                322                  CMP.W   #1,D1                   ; if 1, it is a word
00001378  6700 001C                323                  BEQ     ADD_SUB_WORD
0000137C  B27C 0002                324                  CMP.W   #2,D1                   ; if 2, it is a long
00001380  6700 0022                325                  BEQ     ADD_SUB_LONG
00001384  6000 024C                326                  BRA     CASE_SUBA                    ; error
00001388                           327                  
00001388  4BF9 00002041            328  ADD_SUB_BYTE    LEA     MSG_B,A5
0000138E  4EB9 00001D1A            329                  JSR     PRINTNULL
00001394  4E75                     330                  RTS
00001396                           331                  
00001396  4BF9 00002047            332  ADD_SUB_WORD    LEA     MSG_W,A5
0000139C  4EB9 00001D1A            333                  JSR     PRINTNULL
000013A2  4E75                     334                  RTS
000013A4                           335  
000013A4  4BF9 0000204D            336  ADD_SUB_LONG    LEA     MSG_L,A5
000013AA  4EB9 00001D1A            337                  JSR     PRINTNULL
000013B0  4E75                     338                  RTS  
000013B2                           339      
000013B2  4EB9 000013BA            340  FINISH_ADD      JSR     ADD_SUB_OPERAND
000013B8  4E75                     341                  RTS
000013BA                           342  
000013BA  EF49                     343  ADD_SUB_OPERAND LSL.W   #7,D1
000013BC  EE49                     344                  LSR.W   #7,D1
000013BE  E049                     345                  LSR.W   #8,D1
000013C0  B27C 0001                346                  CMP.W   #1,D1
000013C4  6000 002E                347                  BRA     Dn_PLUS_EA          
000013C8                           348                  
000013C8                           349                  ; print Data Register
000013C8  4BF9 0000202A            350                  LEA     MSG_DR,A5
000013CE  4EB9 00001D1A            351                  JSR     PRINTNULL
000013D4  3207                     352                  MOVE.W  D7,D1
000013D6  4EB9 00001BD0            353                  JSR     PRINTNUM                
000013DC                           354                  
000013DC                           355                  ; prints a comma to seperate
000013DC  4BF9 0000203A            356                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000013E2  4EB9 00001D1A            357                  JSR     PRINTNULL                ; prints out MOVE
000013E8                           358                  
000013E8                           359                  ; below is EA+Dn->Dn  
000013E8  3404                     360                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013EA  3605                     361                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013EC  4EB9 00001A54            362                  JSR     EA_TO_STRING             ; outputs it into a string
000013F2  4E75                     363                  RTS                              ; exits subroutine 
000013F4                           364  
000013F4                           365  Dn_PLUS_EA      ; below is Dn+EA->EA  
000013F4  3404                     366                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013F6  3605                     367                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013F8  4EB9 00001A54            368                  JSR     EA_TO_STRING             ; outputs it into a string   
000013FE                           369                  
000013FE                           370                  ; prints a comma to seperate
000013FE  4BF9 0000203A            371                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001404  4EB9 00001D1A            372                  JSR     PRINTNULL                ; prints out MOVE
0000140A                           373                  
0000140A                           374                  ; below is Dn+EA->EA
0000140A  4BF9 0000202A            375                  LEA     MSG_DR,A5                  ; print data register
00001410  4EB9 00001D1A            376                  JSR     PRINTNULL
00001416  3207                     377                  MOVE.W  D7,D1
00001418  4EB9 00001BD0            378                  JSR     PRINTNUM             
0000141E  4E75                     379                  RTS                              ; exits subroutine                
00001420                           380                   
00001420                           381  
00001420  3200                     382  CASE_ADDA       MOVE.W  D0,D1
00001422  EF49                     383                  LSL.W   #7,D1
00001424  EE49                     384                  LSR.W   #7,D1
00001426  E049                     385                  LSR     #8,D1                               ; gets bit 8 (size bit)
00001428                           386                  
00001428  4BF9 00001F62            387                  LEA     MSG_ADDA,A5
0000142E  4EB9 00001D1A            388                  JSR     PRINTNULL
00001434                           389                  
00001434  B27C 0001                390                  CMP.W   #1,D1
00001438  6700 0012                391                  BEQ     ADDA_LONG
0000143C                           392                  
0000143C  4BF9 00002047            393                  LEA     MSG_W,A5
00001442  4EB9 00001D1A            394                  JSR     PRINTNULL
00001448  6000 0012                395                  BRA     FINISH_ADDA   
0000144C                           396                  
0000144C  4BF9 0000204D            397  ADDA_LONG       LEA     MSG_L,A5
00001452  4EB9 00001D1A            398                  JSR     PRINTNULL
00001458  6000 0002                399                  BRA     FINISH_ADDA
0000145C                           400                  
0000145C  3404                     401  FINISH_ADDA     MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000145E  3605                     402                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001460  4EB9 00001A54            403                  JSR     EA_TO_STRING             ; outputs it into a string
00001466                           404                  
00001466                           405                  ; prints a comma to seperate
00001466  4BF9 0000203A            406                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000146C  4EB9 00001D1A            407                  JSR     PRINTNULL                ; prints out MOVE
00001472                           408          
00001472  4BF9 0000202C            409                  LEA     MSG_AR,A5                ; print address register
00001478  4EB9 00001D1A            410                  JSR     PRINTNULL
0000147E  3207                     411                  MOVE.W  D7,D1
00001480  4EB9 00001BD0            412                  JSR     PRINTNUM             
00001486  4E75                     413                  RTS                              ; exits subroutine
00001488                           414                  
00001488  3200                     415  CASE_ADDQ       MOVE.W  D0,D1
0000148A  C27C F000                416                  AND.W   #$F000,D1       
0000148E  B27C 5000                417                  CMP.W   #$5000,D1
00001492  6600 00C8                418                  BNE     CASE_SUB
00001496                           419                  
00001496                           420                  ; Check bits 0-5 
00001496  4BF9 00001DBC            421                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000149C  4DF9 00001DF2            422                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000014A2  3E3C 0000                423                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000014A6  4EB9 00001988            424                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000014AC  B27C 0001                425                  CMP.W   #1,D1                    ; checks if invalid
000014B0  6700 047E                426                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000014B4  3802                     427                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000014B6  3A03                     428                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000014B8                           429                  
000014B8                           430                  ; get bits 6-7 (size bits)
000014B8  3200                     431                  MOVE.W  D0,D1
000014BA  E149                     432                  LSL.W   #8,D1
000014BC  E049                     433                  LSR.W   #8,D1
000014BE  EC49                     434                  LSR.W   #6,D1
000014C0  3401                     435                  MOVE.W  D1,D2
000014C2                           436  
000014C2                           437                  ; gets bits 9-11 (data bits)
000014C2  E949                     438                  LSL.W   #4,D1
000014C4  E849                     439                  LSR.W   #4,D1                               ; get rid of left 4 bits
000014C6  E049                     440                  LSR.W   #8,D1
000014C8  E249                     441                  LSR.W   #1,D1                               ; get rid of right 9 bits
000014CA                           442                  
000014CA  4BF9 00001F68            443                  LEA     MSG_ADDQ,A5
000014D0  4EB9 00001D1A            444                  JSR     PRINTNULL
000014D6                           445                  
000014D6  B47C 0001                446                  CMP.W   #1,D2
000014DA  6700 001A                447                  BEQ     ADDQ_WORD
000014DE  B47C 0002                448                  CMP.W   #2,D2
000014E2  6700 0022                449                  BEQ     ADDQ_LONG
000014E6                           450                  
000014E6  4BF9 00002041            451  ADDQ_BYTE       LEA     MSG_B,A5
000014EC  4EB9 00001D1A            452                  JSR     PRINTNULL
000014F2  6000 0022                453                  BRA     FINISH_ADDQ  
000014F6                           454  
000014F6  4BF9 00002047            455  ADDQ_WORD       LEA     MSG_W,A5
000014FC  4EB9 00001D1A            456                  JSR     PRINTNULL
00001502  6000 0012                457                  BRA     FINISH_ADDQ                 
00001506                           458  
00001506  4BF9 0000204D            459  ADDQ_LONG       LEA     MSG_L,A5
0000150C  4EB9 00001D1A            460                  JSR     PRINTNULL
00001512  6000 0002                461                  BRA     FINISH_ADDQ                  
00001516                           462                  
00001516  4EB9 00001534            463  FINISH_ADDQ     JSR     PRINT_ADDQ_DATA
0000151C                           464  
0000151C                           465                  ; prints a comma to seperate
0000151C  4BF9 0000203A            466                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001522  4EB9 00001D1A            467                  JSR     PRINTNULL                ; prints out MOVE
00001528                           468                  
00001528                           469                  ; prints destination
00001528  3404                     470                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000152A  3605                     471                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000152C  4EB9 00001A54            472                  JSR     EA_TO_STRING             ; outputs it into a string
00001532                           473                  
00001532  4E75                     474                  RTS
00001534                           475  
00001534                           476  
00001534  4BF9 00002036            477  PRINT_ADDQ_DATA LEA     MSG_POUND,A5
0000153A  4EB9 00001D1A            478                  JSR     PRINTNULL
00001540  B27C 0000                479                  CMP.W   #0,D1
00001544  6700 000A                480                  BEQ     PRINT_8
00001548  4EB9 00001BD0            481                  JSR     PRINTNUM
0000154E  4E75                     482                  RTS 
00001550                           483  
00001550  123C 0008                484  PRINT_8         MOVE.B  #8,D1
00001554  4EB9 00001BD0            485                  JSR     PRINTNUM
0000155A  4E75                     486                  RTS           
0000155C                           487                  
0000155C                           488  
0000155C  3200                     489  CASE_SUB        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000155E  C27C F000                490                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001562  B27C 9000                491                  CMP.W   #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001566  6600 0080                492                  BNE     CASE_LEA
0000156A                           493                  
0000156A  4EB8 130C                494                  JSR     ADD_SUB_HELP
0000156E                           495                                 
0000156E  4BF9 00001F6E            496                  LEA     MSG_SUB,A5                          ; loads string pointer for MOVE into A5
00001574  6000 0002                497                  BRA     PRINTSUB                            ; Branches to print move
00001578                           498  
00001578  4EB9 00001D1A            499  PRINTSUB        JSR     PRINTNULL
0000157E  3200                     500                  MOVE.W  D0,D1                               ; bits 6-7 contain size
00001580  4EB8 1364                501                  JSR     ADD_SUB_SIZE
00001584  3200                     502                  MOVE.W  D0,D1
00001586  E149                     503                  LSL.W   #8,D1
00001588  E049                     504                  LSR.W   #8,D1
0000158A  EC49                     505                  LSR.W   #6,D1
0000158C  B27C 0003                506                  CMP.W   #3,D1
00001590  6600 0006                507                  BNE     FINISH_SUB
00001594  6000 0008                508                  BRA     FINISH_SUBA                         ; same as ADDA
00001598                           509                  
00001598  4EB8 13BA                510  FINISH_SUB      JSR     ADD_SUB_OPERAND
0000159C  4E75                     511                  RTS
0000159E                           512                  
0000159E  3404                     513  FINISH_SUBA     MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000015A0  3605                     514                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000015A2  4EB9 00001A54            515                  JSR     EA_TO_STRING             ; outputs it into a string
000015A8                           516                  
000015A8                           517                  ; prints a comma to seperate
000015A8  4BF9 0000203A            518                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000015AE  4EB9 00001D1A            519                  JSR     PRINTNULL                ; prints out MOVE
000015B4                           520          
000015B4  4BF9 0000202C            521                  LEA     MSG_AR,A5                ; print address register
000015BA  4EB9 00001D1A            522                  JSR     PRINTNULL
000015C0  3200                     523                  MOVE.W  D0,D1
000015C2  E949                     524                  LSL.W   #4,D1
000015C4  E849                     525                  LSR.W   #4,D1
000015C6  E049                     526                  LSR.W   #8,D1
000015C8  E249                     527                  LSR.W   #1,D1
000015CA  4EB9 00001BD0            528                  JSR     PRINTNUM             
000015D0  4E75                     529                  RTS                              ; exits subroutine
000015D2                           530  
000015D2                           531  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
000015D2  3200                     532  CASE_SUBA       MOVE.W  D0,D1
000015D4  EF49                     533                  LSL.W   #7,D1
000015D6  EE49                     534                  LSR.W   #7,D1
000015D8  E049                     535                  LSR.W   #8,D1
000015DA                           536                  
000015DA  B23C 0000                537                  CMP.B   #0,D1
000015DE  6700 FDB6                538                  BEQ     ADD_SUB_WORD
000015E2  6000 FDC0                539                  BRA     ADD_SUB_LONG
000015E6  4E75                     540                  RTS         
000015E8                           541                  
000015E8                           542                  
000015E8                           543                  
000015E8  3200                     544  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000015EA  C27C F000                545                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000015EE  B27C 4000                546                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
000015F2  6600 0086                547                  BNE.W   CASE_AND                             ; If its not, check AND
000015F6  3200                     548                  MOVE.W  D0,D1                                ; Copies instruction word to D1
000015F8  C27C 01C0                549                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
000015FC  B27C 01C0                550                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001600  6600 0078                551                  BNE.W   CASE_AND                             ; If its not, check AND
00001604                           552                  
00001604                           553                  ; Check source
00001604  4BF9 00001DDC            554                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000160A  4DF9 00001DF6            555                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001610  3E3C 0000                556                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001614  4EB9 00001988            557                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000161A  3802                     558                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000161C  3A03                     559                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000161E                           560                  
0000161E                           561                  ; Check destination
0000161E  4BF9 00001DDC            562                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001624  4DF9 00001DF6            563                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000162A  3E3C 0001                564                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000162E  4EB9 00001988            565                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001634  3C02                     566                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001636  3E03                     567                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001638                           568  
00001638  4BF9 00001F7F            569                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000163E  4EB9 00001D1A            570                  JSR     PRINTNULL                            ; prints LEA
00001644                           571                  
00001644                           572                  ; print source
00001644  3404                     573                  MOVE.W  D4,D2
00001646  3605                     574                  MOVE.W  D5,D3
00001648  4EB9 00001A54            575                  JSR     EA_TO_STRING                         ; Prints out the EA
0000164E                           576                  
0000164E                           577                  ; comma
0000164E  4BF9 0000203A            578                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001654  4EB9 00001D1A            579                  JSR     PRINTNULL                       
0000165A                           580                   
0000165A                           581                  ; register
0000165A  4BF9 0000202C            582                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001660  4EB9 00001D1A            583                  JSR     PRINTNULL 
00001666  3401                     584                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
00001668  323C 0001                585                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
0000166C  4EB9 0000195E            586                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001672  4EB9 00001BD0            587                  JSR     PRINTNUM                             ; Prints the number in D1
00001678  4E75                     588                  RTS
0000167A                           589  
0000167A                           590  **---------------AND opcode----------------------
0000167A                           591  CASE_AND
0000167A                           592              
0000167A                           593  CASE_OR
0000167A                           594  
0000167A                           595  CASE_NOT
0000167A                           596  
0000167A  3200                     597  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
0000167C  C27C F000                598                  AND.W       #$F000, D1                       ; gets first 4 bits
00001680  B27C E000                599                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001684  6600 0210                600                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001688  3400                     601                  MOVE.W      D0,D2                            ; copies D0 to D2
0000168A  4EB9 00001A10            602                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001690  B47C 0003                603                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001694  6600 00C8                604                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001698                           605                  
00001698  3400                     606  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000169A  4EB9 000019FE            607                  JSR         GETROTATION                      ; gets rotation value of D2
000016A0  B47C 0000                608                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
000016A4  6700 0014                609                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
000016A8  B47C 0003                610                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
000016AC  6700 0016                611                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
000016B0                           612                  
000016B0  4BF9 00001F95            613  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
000016B6  6000 0012                614                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000016BA                           615  
000016BA  4BF9 00001F99            616  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
000016C0  6000 0008                617                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000016C4                           618  
000016C4  4BF9 00001F9D            619  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
000016CA                           620                  
000016CA  4EB9 00001D1A            621  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
000016D0  3400                     622                  MOVE.W      D0,D2                            ; copies D0 to D2
000016D2  4EB9 00001A08            623                  JSR         GETDIRECTION                     ; gets direction
000016D8  B47C 0000                624                  CMP.W       #0,D2                            ; checking if its right
000016DC  6700 000C                625                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
000016E0                           626  
000016E0  4BF9 00002028            627  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
000016E6  6000 0008                628                  BRA         PRINT_MEMDIR                     ; branches for printing
000016EA                           629          
000016EA  4BF9 00002026            630  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
000016F0                           631  
000016F0  4EB9 00001D1A            632  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
000016F6  4BF9 00002047            633                  LEA         MSG_W,A5                         ; loads .W into A5
000016FC  4EB9 00001D1A            634                  JSR         PRINTNULL                        ; Prints .W
00001702  6000 0002                635                  BRA         GETMEMSOURCE                     ; checks the source 
00001706                           636                  
00001706                           637  ; get source addressing mode       
00001706                           638  GETMEMSOURCE                                                 
00001706  323C 0000                639                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000170A  4EB9 00001934            640                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001710  3801                     641                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001712  323C 0000                642                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001716  4EB9 0000195E            643                  JSR         GET_XN                           ; Gets Xn, puts it into D1
0000171C  3A01                     644                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
0000171E                           645  
0000171E  4BF9 00001DEA            646  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001724  3204                     647                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001726  4EB9 00001A20            648                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
0000172C  B27C 0002                649                  CMP.W       #2,D1                            ; checks if it is Xn
00001730  6700 0016                650                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001734  B27C 0001                651                  CMP.W       #1,D1                            ; Checks if it is invalid
00001738  6700 01F6                652                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
0000173C                           653  
0000173C  3404                     654  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
0000173E  3605                     655                  MOVE.W      D5,D3                            ; moves EA to D3
00001740  4EB9 00001A54            656                  JSR         EA_TO_STRING                     ; prints out the EA
00001746  4E75                     657                  RTS                
00001748                           658                  
00001748                           659                  
00001748  4BF9 00001DF6            660  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
0000174E  3205                     661                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001750  4EB9 00001A20            662                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001756  4A41                     663                  TST.W       D1                               ; checks if it is valid
00001758  67E2                     664                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
0000175A  6000 01D4                665                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
0000175E                           666  
0000175E                           667  
0000175E  3602                     668  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001760  3200                     669                  MOVE.W      D0,D1                            ; copies D0 to D1
00001762  C27C 0018                670                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001766  E649                     671                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001768  B27C 0000                672                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
0000176C  6700 0014                673                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001770  B27C 0003                674                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001774  6700 0016                675                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001778                           676                  
00001778  4BF9 00001F95            677  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
0000177E  6000 0012                678                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001782                           679  
00001782  4BF9 00001F99            680  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001788  6000 0008                681                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
0000178C                           682  
0000178C  4BF9 00001F9D            683  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001792                           684                  
00001792  4EB9 00001D1A            685  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
00001798  3400                     686                  MOVE.W      D0,D2                            ; copies D0 to D2
0000179A  4EB9 00001A08            687                  JSR         GETDIRECTION                     ; gets direction
000017A0  B47C 0000                688                  CMP.W       #0,D2                            ; checking if its right
000017A4  6700 000C                689                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
000017A8                           690  
000017A8  4BF9 00002028            691  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
000017AE  6000 000C                692                  BRA         PRINT_REGDIR                     ; branches for printing
000017B2                           693          
000017B2  4BF9 00002026            694  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
000017B8  6000 0002                695                  BRA         PRINT_REGDIR                     ; branches for printing
000017BC                           696                  
000017BC  4EB9 00001D1A            697  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
000017C2                           698  
000017C2  3400                     699  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
000017C4  4EB9 00001A10            700                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000017CA  B47C 0001                701                  CMP.W       #1,D2                            ; Checks if it is word size
000017CE  6700 0014                702                  BEQ         REG_WORD                         ; Prints .W
000017D2  B47C 0002                703                  CMP.W       #2,D2                            ; Checks if it is long size
000017D6  6700 0016                704                  BEQ         REG_LONG                         ; Prints .L
000017DA                           705  
000017DA  4BF9 00002041            706  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
000017E0  6000 0012                707                  BRA         PRINTREGEA      
000017E4                           708  
000017E4  4BF9 00002047            709  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
000017EA  6000 0008                710                  BRA         PRINTREGEA      
000017EE                           711                             
000017EE  4BF9 0000204D            712  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
000017F4                           713  
000017F4  4EB9 00001D1A            714  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
000017FA  3400                     715                  MOVE.W      D0,D2                            ; copies D0 to D1
000017FC  4EB9 00001A18            716                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001802  B27C 0001                717                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001806  6700 0048                718                  BEQ         REG_REGISTER                     ; goes to ASd case if so
0000180A                           719                                  
0000180A  3400                     720  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
0000180C  4EB9 00001A10            721                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001812  3202                     722                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001814  4BF9 00002036            723                  LEA         MSG_POUND, A5                    ; loads # into A5
0000181A  4EB9 00001D1A            724                  JSR         PRINTNULL                        ; prints #
00001820  4EB9 00001BD0            725                  JSR         PRINTNUM                         ; prints shift count
00001826  4BF9 0000203A            726                  LEA         MSG_COMMA, A5                    ; loads , into A5
0000182C  4EB9 00001D1A            727                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001832  4BF9 0000202A            728                  LEA         MSG_DR, A5                       ; loads D into A5
00001838  4EB9 00001D1A            729                  JSR         PRINTNULL                        ; prints out D 
0000183E  323C 0000                730                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001842  4EB9 0000195E            731                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001848  4EB9 00001BD0            732                  JSR         PRINTNUM                         ; prints data register number in D1          
0000184E  4E75                     733                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001850                           734                  
00001850  3400                     735  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001852  4EB9 00001A10            736                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001858  3202                     737                  MOVE.W      D2, D1                           ; moves rotation size to D1
0000185A  4BF9 0000202A            738                  LEA         MSG_DR, A5                       ; loads D into A5
00001860  4EB9 00001D1A            739                  JSR         PRINTNULL                        ; prints D
00001866  4EB9 00001BD0            740                  JSR         PRINTNUM                         ; prints register number
0000186C  4BF9 0000203A            741                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001872  4EB9 00001D1A            742                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001878  4BF9 0000202A            743                  LEA         MSG_DR, A5                       ; loads D into A5
0000187E  4EB9 00001D1A            744                  JSR         PRINTNULL                        ; prints out D 
00001884  323C 0000                745                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001888  4EB9 0000195E            746                  JSR         GET_XN                           ; gets the data register number, stores in D1
0000188E  4EB9 00001BD0            747                  JSR         PRINTNUM                         ; prints data register number in D1          
00001894  4E75                     748                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001896                           749               
00001896  3200                     750  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001898  C27C FF00                751                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
0000189C  B27C 6000                752                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
000018A0  6600 0018                753                  BNE.W   CASE_BCC                             ; If its not, check BCC
000018A4                           754                  
000018A4  4BF9 0000201E            755                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
000018AA  4EB9 00001D1A            756                  JSR     PRINTNULL                            ; prints BRA
000018B0                           757  
000018B0  3400                     758                  MOVE.W  D0,D2                                ; Copies instruction word to D1
000018B2  4EB9 000019D0            759                  JSR     GETDISPLACEMENT                      ; finds the displacement
000018B8  4E75                     760                  RTS
000018BA                           761                  
000018BA                           762  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
000018BA                           763  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
000018BA  3200                     764  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
000018BC  C27C F000                765                  AND.W   #$F000,D1                            ; get top 4 bits
000018C0  B27C 6000                766                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
000018C4  6600 0054                767                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
000018C8  3200                     768                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
000018CA  C27C 0F00                769                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
000018CE  E049                     770                  LSR.W   #8,D1                                ; shifts 8 bits to the right
000018D0                           771                  
000018D0  B27C 000E                772                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
000018D4  6700 002A                773                  BEQ     CASE_BGT                             ; branches to BGT if it is
000018D8                           774                  
000018D8  B27C 000F                775                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
000018DC  6700 0018                776                  BEQ     CASE_BLE                             ; branches to BLE if it is
000018E0                           777                      
000018E0  B27C 0007                778                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
000018E4  6700 0006                779                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
000018E8  6000 0046                780                  BRA     CASE_DATA                            ; BCC condition code not in the system
000018EC                           781     
000018EC  4BF9 00001FB1            782  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
000018F2  6000 0016                783                  BRA     PRINTBCC
000018F6                           784  
000018F6  4BF9 00001FD9            785  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
000018FC  6000 000C                786                  BRA     PRINTBCC
00001900                           787                  
00001900  4BF9 00001FC9            788  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001906  6000 0002                789                  BRA     PRINTBCC
0000190A                           790  
0000190A  4EB9 00001D1A            791  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001910  3400                     792                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001912  4EB9 000019D0            793                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001918  4E75                     794                  RTS              
0000191A                           795                  
0000191A                           796  
0000191A                           797  CASE_JSR       
0000191A                           798  
0000191A  B07C 4E75                799  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
0000191E  6600 F862                800                  BNE     CASE_MOVE           ; checks the next case if not equal
00001922  4BF9 00002019            801                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001928  4EB9 00001D1A            802                  JSR     PRINTNULL           ; prints RTS                
0000192E  4E75                     803                  RTS                         ; returns from the subroutine
00001930                           804  
00001930                           805                  
00001930                           806  
00001930                           807  CASE_DATA           
00001930  4E75                     808                      RTS               
00001932                           809  
00001932  4E75                     810  CASE_EPICFAIL       RTS
00001934                           811  
00001934                           812  
00001934                           813  * Finds the EA type
00001934                           814  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001934                           815  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001934  48E7 3000                816  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001938  4A41                     817                      TST.W     D1                    ; compares D1 to 0
0000193A  6700 000E                818                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
0000193E                           819                      
0000193E  343C 01C0                820  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001942  363C 0006                821                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001946  6000 000A                822                      BRA       FINDTYPEEA            
0000194A                           823  
0000194A  343C 0038                824  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
0000194E  363C 0003                825                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001952                           826  
00001952                           827  
00001952  3200                     828  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001954  C242                     829                      AND.W     D2,D1                 ; applies bitmask to D1
00001956  E669                     830                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001958  4CDF 000C                831                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
0000195C  4E75                     832                      RTS                             ; returns from subroutine    
0000195E                           833                      
0000195E                           834  * Finds Xn type
0000195E                           835  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
0000195E                           836  * Output: Addressing Mode (3 bits, 0 to 7) in D1
0000195E  48E7 3000                837  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001962  4A41                     838                      TST.W     D1                    ; compares D1 to 0
00001964  6700 000E                839                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001968                           840  
00001968  343C 0E00                841  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
0000196C  363C 0009                842                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001970  6000 000A                843                      BRA       FINDTYPEXN            ; finds the type of Xn
00001974                           844  
00001974  343C 0007                845  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001978  363C 0000                846                      MOVE.W    #0,D3                 ; stores the shift amount to D3
0000197C                           847                      
0000197C  3200                     848  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
0000197E  C242                     849                      AND.W     D2,D1                 ; applies bitmask to D1
00001980  E669                     850                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001982  4CDF 000C                851                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001986  4E75                     852                      RTS                             ; returns from subroutine 
00001988                           853                      
00001988                           854  * Checks and gets the EA and Xn
00001988                           855  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001988                           856  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001988  3207                     857  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
0000198A  4EB8 1934                858                  JSR     GET_EA                  ; Gets EA
0000198E  3401                     859                  MOVE.W  D1,D2                   ; Stores EA in D2
00001990  3207                     860                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001992  4EB8 195E                861                  JSR     GET_XN                  ; Gets Xn
00001996  3601                     862                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001998  3202                     863                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
0000199A                           864                  
0000199A  4EB9 00001A20            865                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
000019A0  B27C 0002                866                  CMP.W   #2,D1                   ; checks if it is Xn
000019A4  6700 0012                867                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
000019A8  B27C 0001                868                  CMP.W   #1,D1                   ; Checks if it is invalid
000019AC  6700 001C                869                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
000019B0                           870                  
000019B0                           871                  
000019B0  323C 0000                872  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
000019B4  6000 0018                873                  BRA     END_CHECKGET
000019B8                           874        
000019B8                           875  ; need XN
000019B8  2A4E                     876  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
000019BA  3203                     877                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
000019BC  4EB9 00001A20            878                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
000019C2  4A41                     879                  TST.W   D1                      ; checks if it is valid
000019C4  67EA                     880                  BEQ     EAXN_VALID              ; go to EA_VALID to print
000019C6  6000 0002                881                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
000019CA                           882   
000019CA  323C 0001                883  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
000019CE                           884  
000019CE  4E75                     885  END_CHECKGET    RTS          
000019D0                           886                                            
000019D0                           887                                            
000019D0                           888  * Gets the displacement and pritns it 
000019D0                           889  * Inputs: D2 = instruction word, A2 = address of next word
000019D0                           890  * Outputs: prints out displacement
000019D0  48E7 4004                891  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
000019D4  3A4A                     892                      MOVE.W    A2,A5                 ; copies A2 to A5
000019D6  C47C 00FF                893                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
000019DA  6600 0004                894                      BNE       PRINTADDRESS          ; prints address if not 0
000019DE  341A                     895                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
000019E0                           896                      
000019E0  D44D                     897  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
000019E2  3202                     898                      MOVE.W    D2,D1                 ; moves address to D1 for printing
000019E4  183C 0000                899                      MOVE.B    #0,D4                 ; marks address as word  length
000019E8  4BF9 00002038            900                      LEA       MSG_HEX,A5            ; loads hex sign to A5
000019EE  4EB9 00001D1A            901                      JSR       PRINTNULL             ; prints null
000019F4  4EB9 00001BF4            902                      JSR       PRINTSHORTLONGNUM     ; prints address
000019FA                           903                      
000019FA  4CDF 2002                904                      MOVEM.L    (SP)+,D1/A5              ; restores D1
000019FE                           905                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
000019FE                           906  
000019FE                           907  * Gets the rotation value for ASd and LSd
000019FE                           908  * Input: D2 = instruction word copy (of D0)                                    
000019FE                           909  * Output: rotation  value in D2             
000019FE  C47C 0E00                910  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001A02  E04A                     911                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001A04  E24A                     912                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001A06  4E75                     913                      RTS                             ; return from subroutine
00001A08                           914  
00001A08                           915  * Gets the direction value for ASd and LSd
00001A08                           916  * Input: D2 = instruction word copy (of D0)                                    
00001A08                           917  * Output: direction value in D2             
00001A08  C47C 0100                918  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001A0C  E04A                     919                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001A0E  4E75                     920                      RTS                             ; return from subroutine
00001A10                           921  
00001A10                           922  * Gets the rotation size value for ASd and LSd
00001A10                           923  * Input: D2 = instruction word copy (of D0)                                    
00001A10                           924  * Output: rotation size value in D2             
00001A10  C47C 00C0                925  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001A14  EC4A                     926                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001A16  4E75                     927                      RTS                             ; return from subroutine
00001A18                           928  
00001A18                           929  * Gets the rotation location  value for ASd and LSd
00001A18                           930  * Input: D2 = instruction word copy (of D0)                                    
00001A18                           931  * Output: rotation location value in D2             
00001A18  C47C 0020                932  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001A1C  EA4A                     933                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001A1E  4E75                     934                      RTS                             ; return from subroutine
00001A20                           935  
00001A20                           936                          
00001A20                           937  * Checks if EA or Xn is valid
00001A20                           938  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001A20                           939  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001A20  2F02                     940  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001A22                           941  
00001A22  141D                     942  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001A24  B43C 00FF                943                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001A28  6700 000A                944                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001A2C  B202                     945                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001A2E  6700 000C                946                     BEQ        VALIDEA               ; branches to valid EA
00001A32  60EE                     947                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001A34                           948                     
00001A34  323C 0001                949  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001A38  6000 0016                950                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001A3C                           951                    
00001A3C  B43C 0007                952  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001A40  6700 000A                953                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001A44  323C 0000                954                     MOVE.W     #$0,D1                ; marks that it is valid
00001A48  6000 0006                955                     BRA        CHECKEAEXIT           ; exits the subroutine
00001A4C                           956  
00001A4C  323C 0002                957  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001A50                           958  
00001A50  241F                     959  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001A52  4E75                     960                     RTS                              ; returns from subroutine
00001A54                           961  
00001A54                           962  * Converts EA and Xn into a string                                
00001A54                           963  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001A54                           964  * Outputs: Prints out EA and Xn into a string
00001A54  48E7 C004                965  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001A58  B47C 0001                966                     CMP.W    #An,D2                  ; checks if it is An
00001A5C  6700 003A                967                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001A60                           968                     
00001A60  B47C 0002                969                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001A64  6700 004A                970                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001A68                           971                     
00001A68  B47C 0003                972                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001A6C  6700 0072                973                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001A70                           974                     
00001A70  B47C 0004                975                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001A74  6700 00A6                976                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001A78                           977                     
00001A78  B47C 0007                978                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001A7C  6700 00DA                979                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001A80                           980                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001A80                           981  
00001A80                           982  * data register, Dn
00001A80  4BF9 0000202A            983  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001A86  4EB9 00001D1A            984                     JSR      PRINTNULL               ; Prints D
00001A8C  3203                     985                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001A8E  4EB9 00001BD0            986                     JSR      PRINTNUM                ; Prints the Xn
00001A94  6000 0134                987                     BRA      EA_TO_STRING_EXIT       ; exits           
00001A98                           988  
00001A98                           989  
00001A98                           990  * address register
00001A98  4BF9 0000202C            991  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001A9E  4EB9 00001D1A            992                     JSR      PRINTNULL               ; Prints A
00001AA4  3203                     993                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001AA6  4EB9 00001BD0            994                     JSR      PRINTNUM                ; Prints the Xn
00001AAC  6000 011C                995                     BRA      EA_TO_STRING_EXIT       ; exits
00001AB0                           996  
00001AB0                           997  * address register indirect
00001AB0  4BF9 0000202E            998  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001AB6  4EB9 00001D1A            999                     JSR      PRINTNULL               ; Prints (
00001ABC  4BF9 0000202C           1000                     LEA      MSG_AR,A5               ; Loads A into A5
00001AC2  4EB9 00001D1A           1001                     JSR      PRINTNULL               ; Prints A
00001AC8  3203                    1002                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001ACA  4EB9 00001BD0           1003                     JSR      PRINTNUM                ; Prints the Xn
00001AD0  4BF9 00002030           1004                     LEA      MSG_RB,A5               ; Loads ) into A5
00001AD6  4EB9 00001D1A           1005                     JSR      PRINTNULL               ; Prints )
00001ADC  6000 00EC               1006                     BRA      EA_TO_STRING_EXIT       ; exits
00001AE0                          1007  
00001AE0                          1008  * address register indirect post increment
00001AE0  4BF9 0000202E           1009  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001AE6  4EB9 00001D1A           1010                     JSR      PRINTNULL               ; Prints (
00001AEC  4BF9 0000202C           1011                     LEA      MSG_AR,A5               ; Loads A into A5
00001AF2  4EB9 00001D1A           1012                     JSR      PRINTNULL               ; Prints A
00001AF8  3203                    1013                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001AFA  4EB9 00001BD0           1014                     JSR      PRINTNUM                ; Prints the Xn
00001B00  4BF9 00002030           1015                     LEA      MSG_RB,A5               ; Loads ) into A5
00001B06  4EB9 00001D1A           1016                     JSR      PRINTNULL               ; Prints )
00001B0C  4BF9 00002032           1017                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001B12  4EB9 00001D1A           1018                     JSR      PRINTNULL               ; Prints +
00001B18  6000 00B0               1019                     BRA      EA_TO_STRING_EXIT       ; exits
00001B1C                          1020  
00001B1C                          1021  
00001B1C                          1022  * address register indirect pre increment
00001B1C  4BF9 00002034           1023  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001B22  4EB9 00001D1A           1024                     JSR      PRINTNULL               ; Prints -
00001B28  4BF9 0000202E           1025                     LEA      MSG_LB,A5               ; Loads ( into A5
00001B2E  4EB9 00001D1A           1026                     JSR      PRINTNULL               ; Prints (
00001B34  4BF9 0000202C           1027                     LEA      MSG_AR,A5               ; Loads A into A5
00001B3A  4EB9 00001D1A           1028                     JSR      PRINTNULL               ; Prints A
00001B40  3203                    1029                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001B42  4EB9 00001BD0           1030                     JSR      PRINTNUM                ; Prints the Xn
00001B48  4BF9 00002030           1031                     LEA      MSG_RB,A5               ; Loads ) into A5
00001B4E  4EB9 00001D1A           1032                     JSR      PRINTNULL               ; Prints )
00001B54  6000 0074               1033                     BRA      EA_TO_STRING_EXIT       ; exits
00001B58                          1034  
00001B58                          1035  * other (long, short, immediate) with Xn yes
00001B58  301A                    1036  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001B5A  B67C 0000               1037                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001B5E  6700 002E               1038                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001B62                          1039                     
00001B62  B67C 0001               1040                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001B66  6700 0042               1041                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001B6A                          1042  
00001B6A                          1043  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001B6A                          1044  * immediate
00001B6A  4BF9 00002036           1045  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001B70  4EB9 00001D1A           1046                     JSR      PRINTNULL               ; Prints #  
00001B76  4BF9 00002038           1047                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001B7C  4EB9 00001D1A           1048                     JSR      PRINTNULL               ; Prints $
00001B82  3200                    1049                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001B84  4EB9 00001BE0           1050                     JSR      PRINTHEXNUM 
00001B8A  6000 003E               1051                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001B8E                          1052                     
00001B8E                          1053  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001B8E                          1054  
00001B8E                          1055  * word address
00001B8E                          1056  CASE_WORD          
00001B8E  4BF9 00002038           1057                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001B94  4EB9 00001D1A           1058                     JSR      PRINTNULL               ; Prints $
00001B9A  3200                    1059                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001B9C  383C 0000               1060                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001BA0  4EB9 00001BF4           1061                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001BA6  6000 0022               1062                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001BAA                          1063  
00001BAA                          1064  * long address 
00001BAA                          1065  CASE_LONG          
00001BAA  4BF9 00002038           1066                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001BB0  4EB9 00001D1A           1067                     JSR      PRINTNULL               ; Prints $
00001BB6  3200                    1068                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001BB8  383C 0001               1069                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001BBC  4EB9 00001BF4           1070                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001BC2  321A                    1071                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001BC4  4EB9 00001BD0           1072                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001BCA                          1073  
00001BCA                          1074  
00001BCA                          1075  * exits subroutine
00001BCA  4CDF 2003               1076  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001BCE  4E75                    1077                      RTS                              ; returns from subroutine
00001BD0                          1078  
00001BD0                          1079  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001BD0                          1080  
00001BD0                          1081  * Prints out the content of D1 as a decimal number
00001BD0                          1082  * Input: number in D1 to be printed
00001BD0                          1083  * Output: contents of D1 printed
00001BD0  48E7 C000               1084  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001BD4  103C 0003               1085                   MOVE.B      #3,D0               ; prints D1
00001BD8  4E4F                    1086                   TRAP        #15                 ; is trap task 3
00001BDA                          1087              
00001BDA  4CDF 0003               1088                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001BDE  4E75                    1089                   RTS                             ; returns from subroutine
00001BE0                          1090                   
00001BE0                          1091  * Prints out the content of D1 as a hex number
00001BE0                          1092  * Input: number in D1 to be printed
00001BE0                          1093  * Output: contents of D1 printed
00001BE0  48E7 C000               1094  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001BE4  143C 0010               1095                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001BE8  103C 000F               1096                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001BEC  4E4F                    1097                   TRAP        #15                 ; is trap task 15
00001BEE  4CDF 0003               1098                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001BF2  4E75                    1099                   RTS                             ; returns from subroutine
00001BF4                          1100                   
00001BF4                          1101  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001BF4                          1102  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001BF4                          1103  * Output: contents of D1 printed
00001BF4  48E7 E000               1104  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001BF8  B83C 0001               1105                            CMP.B       #1,D4               ; checks size of number
00001BFC  6700 0042               1106                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001C00                          1107  
00001C00  3401                    1108  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001C02  C47C F000               1109                            AND.W       #$F000,D2           ; gets the first digit
00001C06  B47C 0000               1110                            CMP.W       #0, D2              ; checks if it is 0
00001C0A  6600 00DC               1111                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C0E  4EB9 00001CF8           1112                            JSR         PRINTZERO           ; prints a zero
00001C14                          1113                            
00001C14  3401                    1114                            MOVE.W      D1,D2               ; copies number to D2
00001C16  C47C 0F00               1115                            AND.W       #$0F00,D2           ; gets the second digit
00001C1A  B47C 0000               1116                            CMP.W       #0, D2              ; checks if it is 0
00001C1E  6600 00C8               1117                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C22  4EB9 00001CF8           1118                            JSR         PRINTZERO           ; prints a zero
00001C28                          1119                            
00001C28  3401                    1120                            MOVE.W      D1,D2               ; copies number to D2
00001C2A  C47C 00F0               1121                            AND.W       #$00F0,D2           ; gets the third digit
00001C2E  B47C 0000               1122                            CMP.W       #0, D2              ; checks if it is 0
00001C32  6600 00B4               1123                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C36  4EB9 00001CF8           1124                            JSR         PRINTZERO           ; prints a zero
00001C3C  6000 00AA               1125                            BRA         PRINTASHEX          ; prints last digit
00001C40                          1126                            
00001C40  2401                    1127  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001C42  C4BC F0000000           1128                            AND.L       #$F0000000,D2       ; gets the first digit
00001C48  B4BC 00000000           1129                            CMP.L       #0, D2              ; checks if it is 0
00001C4E  6600 0098               1130                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C52  4EB9 00001CF8           1131                            JSR         PRINTZERO           ; prints a zero
00001C58                          1132                            
00001C58  2401                    1133                            MOVE.L      D1,D2               ; copies number to D2
00001C5A  C4BC 0F000000           1134                            AND.L       #$0F000000,D2       ; gets the second digit
00001C60  B4BC 00000000           1135                            CMP.L       #0, D2              ; checks if it is 0
00001C66  6600 0080               1136                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C6A  4EB9 00001CF8           1137                            JSR         PRINTZERO           ; prints a zero
00001C70                          1138                            
00001C70  2401                    1139                            MOVE.L      D1,D2               ; copies number to D2
00001C72  C4BC 00F00000           1140                            AND.L       #$00F00000,D2       ; gets the third digit
00001C78  B4BC 00000000           1141                            CMP.L       #0, D2              ; checks if it is 0
00001C7E  6600 0068               1142                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C82  4EB9 00001CF8           1143                            JSR         PRINTZERO           ; prints a zero
00001C88                          1144                            
00001C88  2401                    1145                            MOVE.L      D1,D2               ; copies number to D2
00001C8A  C4BC 000F0000           1146                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001C90  B4BC 00000000           1147                            CMP.L       #0, D2              ; checks if it is 0
00001C96  6600 0050               1148                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C9A  4EB9 00001CF8           1149                            JSR         PRINTZERO           ; prints a zero
00001CA0                          1150                            
00001CA0  2401                    1151                            MOVE.L      D1,D2               ; copies number to D2
00001CA2  C4BC 0000F000           1152                            AND.L       #$0000F000,D2       ; gets the fith digit
00001CA8  B4BC 00000000           1153                            CMP.L       #0, D2              ; checks if it is 0
00001CAE  6600 0038               1154                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001CB2  4EB9 00001CF8           1155                            JSR         PRINTZERO           ; prints a zero
00001CB8                          1156                            
00001CB8  2401                    1157                            MOVE.L      D1,D2               ; copies number to D2
00001CBA  C4BC 00000F00           1158                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001CC0  B4BC 00000000           1159                            CMP.L       #0, D2              ; checks if it is 0
00001CC6  6600 0020               1160                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001CCA  4EB9 00001CF8           1161                            JSR         PRINTZERO           ; prints a zero
00001CD0                          1162                            
00001CD0  2401                    1163                            MOVE.L      D1,D2               ; copies number to D2
00001CD2  C4BC 000000F0           1164                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001CD8  B4BC 00000000           1165                            CMP.L       #0, D2              ; checks if it is 0
00001CDE  6600 0008               1166                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001CE2  4EB9 00001CF8           1167                            JSR         PRINTZERO           ; prints a zero
00001CE8                          1168  
00001CE8  143C 0010               1169  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001CEC  103C 000F               1170                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001CF0  4E4F                    1171                            TRAP        #15                 ; is trap task 15
00001CF2  4CDF 0007               1172                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001CF6  4E75                    1173                            RTS                             ; returns from subroutine    
00001CF8                          1174  * Prints a zero
00001CF8                          1175  * Input: nothing
00001CF8                          1176  * Output: 0 printed out to the console
00001CF8  2F01                    1177  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001CFA  7200                    1178                            MOVE.L      #0,D1               ; moves 0 to D1
00001CFC  4EB8 1BD0               1179                            JSR         PRINTNUM            ; prints the number
00001D00  221F                    1180                            MOVE.L      (SP)+,D1            ; restores D1
00001D02  4E75                    1181                            RTS                             ; returns from subroutine
00001D04                          1182              
00001D04                          1183  * Prints contents of things between a range
00001D04                          1184  * input: A5, A6 (the range)
00001D04                          1185  * output: prints memory contents from A5 to A6 as strings   
00001D04  48E7 C040               1186  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001D08  224D                    1187                  MOVEA.L     A5, A1           ; loads A5 into A1
00001D0A  9DCD                    1188                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001D0C  320E                    1189                  MOVE.W      A6, D1           ; move n into D1
00001D0E  103C 0001               1190                  MOVE.B      #1, D0           ; display n characters of string at A1
00001D12  4E4F                    1191                  TRAP        #15              ; is trap task 1
00001D14  4CDF 0203               1192                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001D18  4E75                    1193                  RTS                          ; returns
00001D1A                          1194      
00001D1A                          1195  * Prints null terminated string
00001D1A                          1196  * input: string pointed to by A5
00001D1A                          1197  * output: prints out the null terminated string
00001D1A  48E7 8040               1198  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001D1E  224D                    1199                  MOVE.L      A5,A1           ; loads A5 into A1
00001D20  103C 000E               1200                  MOVE.B      #14,D0          ; prints null terminated string
00001D24  4E4F                    1201                  TRAP        #15             ; is trap task 10
00001D26  4CDF 0201               1202                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001D2A  4E75                    1203                  RTS                         ; returns from subroutine
00001D2C                          1204                  
00001D2C  2F0D                    1205  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001D2E  4BF9 00001F36           1206                  LEA         NEW_LINE,A5     ; Prints null
00001D34  4EB8 1D1A               1207                  JSR         PRINTNULL       ; prints the new line
00001D38  2A5F                    1208                  MOVE.L      (SP)+,A5        ; returns A5
00001D3A  4E75                    1209                  RTS
00001D3C                          1210  
00001D3C                          1211  * Prints the size of the MOVE or MOVEA operation  
00001D3C                          1212  * input: D0
00001D3C                          1213  * output: prints out the size of a MOVE or MOVEA operation        
00001D3C  48E7 8004               1214  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001D40  3200                    1215                  MOVE.W  D0,D1               ; stores d0 in d1
00001D42  C07C 3000               1216                  AND.W   #$3000,D0           ; gets the size
00001D46  B07C 2000               1217                  CMP.W   #$2000,D0           ; checks if is long
00001D4A  6700 001E               1218                  BEQ     MOVE_LONG
00001D4E  B07C 3000               1219                  CMP.W   #$3000,D0           ; checks if is word
00001D52  6700 000C               1220                  BEQ     MOVE_WORD      
00001D56                          1221                  
00001D56  4BF9 00002041           1222  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001D5C  6000 0012               1223                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001D60                          1224  
00001D60  4BF9 00002047           1225  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001D66  6000 0008               1226                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001D6A                          1227  
00001D6A  4BF9 0000204D           1228  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001D70                          1229                  
00001D70  4EB8 1D1A               1230  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001D74  4CDF 2001               1231                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001D78  4E75                    1232                  RTS
00001D7A                          1233  
00001D7A  43F9 00001EFE           1234  ERROR           LEA     ERROR_MSG,A1
00001D80  103C 000E               1235                  MOVE.B  #14,D0
00001D84  4E4F                    1236                  TRAP    #15 
00001D86                          1237         
00001D86                          1238  * DELETE THIS: Test                
00001D86  2661                    1239  DELETEME        MOVEA.L  -(A1),A3
00001D88  6700 002E               1240                  BEQ      DELETEMEAGAIN  
00001D8C  6F00 002A               1241                  BLE      DELETEMEAGAIN
00001D90  6E00 0026               1242                  BGT      DELETEMEAGAIN
00001D94                          1243  
00001D94  E40A                    1244                  LSR.B      #2,D2
00001D96  E2E2                    1245                  LSR.W      -(A2)
00001D98  E2DA                    1246                  LSR.W      (A2)+
00001D9A  E4AA                    1247                  LSR.L      D2,D2 
00001D9C  E50A                    1248                  LSL.B      #2,D2
00001D9E  E3E2                    1249                  LSL.W      -(A2)
00001DA0  E3DA                    1250                  LSL.W      (A2)+
00001DA2  E5AA                    1251                  LSL.L      D2,D2
00001DA4  E51A                    1252                  ROL.B      #2,D2
00001DA6  E7E2                    1253                  ROL.W      -(A2)
00001DA8  E7DA                    1254                  ROL.W      (A2)+
00001DAA  E5BA                    1255                  ROL.L      D2,D2
00001DAC  E41A                    1256                  ROR.B      #2,D2
00001DAE  E6E2                    1257                  ROR.W      -(A2)
00001DB0  E6DA                    1258                  ROR.W      (A2)+
00001DB2  E4BA                    1259                  ROR.L      D2,D2
00001DB4                          1260                  
00001DB4  9642                    1261                  SUB.W      D2,D3
00001DB6  D6C2                    1262                  ADDA.W     D2,A3       
00001DB8                          1263                  
00001DB8                          1264  DELETEMEAGAIN                 
00001DB8                          1265            
00001DB8  FFFF FFFF               1266      SIMHALT             ; halt simulator
00001DBC                          1267  
00001DBC                          1268  * Put variables and constants here
00001DBC                          1269  
00001DBC  =0000000D               1270  CR                              EQU     $0D
00001DBC  =0000000A               1271  LF                              EQU     $0A 
00001DBC  =00000009               1272  TAB                             EQU     $09  
00001DBC                          1273  
00001DBC                          1274  * Addressing Modes
00001DBC  =00000000               1275  Dn                              EQU     0
00001DBC  =00000001               1276  An                              EQU     1
00001DBC  =00000002               1277  AnIndirect                      EQU     2
00001DBC  =00000003               1278  AnPost                          EQU     3
00001DBC  =00000004               1279  AnPre                           EQU     4
00001DBC  =00000007               1280  Other                           EQU     7           ; short, long, immediate
00001DBC                          1281  
00001DBC                          1282  * Xn
00001DBC  =00000000               1283  ABSShort                        EQU     0
00001DBC  =00000001               1284  ABSLong                         EQU     1
00001DBC  =00000004               1285  XnImmediate                     EQU     4
00001DBC                          1286  
00001DBC                          1287  * Valid Addressing Modes
00001DBC= 00 01 02 03 04 07 FF    1288  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001DC3                          1289  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001DC3= 00 02 03 04 07 FF       1290  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001DC9= 02 04 07 FF             1291  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001DCD= 02 03 07 FF             1292  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001DD1= 02 03 04 07 FF          1293  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001DD6= 00 02 03 04 07 FF       1294  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001DDC= 01 07 FF                1295  VALIDEA_LEA                     DC.B    An,Other,-1
00001DDF= 00 02 03 04 07 FF       1296  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001DE5= 02 03 04 07 FF          1297  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001DEA= 02 03 04 07 FF          1298  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001DEF= 02 07 FF                1299  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001DF2                          1300  
00001DF2                          1301  * Valid Xn
00001DF2= 00 01 04 FF             1302  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001DF6                          1303  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001DF6= 00 01 FF                1304  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001DF9                          1305  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001DF9                          1306  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001DF9                          1307  
00001DF9                          1308  * posible memory ASd/LSd rotation values
00001DF9  =00000000               1309  ASd_MEM                         EQU     0   
00001DF9  =00000001               1310  LSd_MEM                         EQU     1 
00001DF9  =00000003               1311  ROd_MEM                         EQU     3
00001DF9                          1312   
00001DF9  =00000000               1313  ASd_REG                         EQU     0   
00001DF9  =00000001               1314  LSd_REG                         EQU     1 
00001DF9  =00000003               1315  ROd_REG                         EQU     3
00001DF9                          1316  
00001DF9                          1317  * Starting messages
00001DF9= 57 65 6C 63 6F 6D ...   1318  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001E20= 46 6F 72 6D 61 74 ...   1319                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001E6F= 50 6C 65 61 73 65 ...   1320  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001EA6= 50 6C 65 61 73 65 ...   1321  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001EDC= 49 6E 76 61 6C 69 ...   1322  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001EFE= 45 72 72 6F 72 20 ...   1323  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001F1A= 45 72 72 6F 72 20 ...   1324  INVALID_INSTR                   DC.B    'Error while disassembling',CR,LF,0
00001F36= 0D 0A 00                1325  NEW_LINE                        DC.B    CR,LF,0
00001F39= 09 09 09 00             1326  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001F3D                          1327  
00001F3D                          1328  * Opcode Messages
00001F3D= 09 4E 4F 50 00          1329  MSG_NOP                         DC.B    TAB,'NOP',0
00001F42= 09 4D 4F 56 45 00       1330  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001F48= 09 4D 4F 56 45 41 00    1331  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001F4F= 09 4D 4F 56 45 51 00    1332  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001F56= 09 4D 4F 56 45 4D 00    1333  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001F5D= 09 41 44 44 00          1334  MSG_ADD                         DC.B    TAB,'ADD',0
00001F62= 09 41 44 44 41 00       1335  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001F68= 09 41 44 44 51 00       1336  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001F6E= 09 53 55 42 00          1337  MSG_SUB                         DC.B    TAB,'SUB',0
00001F73= 09 4D 55 4C 53 00       1338  MSG_MULS                        DC.B    TAB,'MULS',0
00001F79= 09 44 49 56 55 00       1339  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001F7F= 09 4C 45 41 09 09 ...   1340  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001F87= 09 41 4E 44 00          1341  MSG_AND                         DC.B    TAB,'AND',0
00001F8C= 09 4F 52 00             1342  MSG_OR                          DC.B    TAB,'OR',0
00001F90= 09 4E 4F 54 00          1343  MSG_NOT                         DC.B    TAB,'NOT',0
00001F95= 09 4C 53 00             1344  MSG_LSd                         DC.B    TAB,'LS',0
00001F99= 09 41 53 00             1345  MSG_ASd                         DC.B    TAB,'AS',0
00001F9D= 09 52 4F 00             1346  MSG_ROd                         DC.B    TAB,'RO',0
00001FA1= 09 42 43 43 09 09 ...   1347  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001FA9= 09 42 43 53 09 09 ...   1348  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001FB1= 09 42 45 51 09 09 ...   1349  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001FB9= 09 42 4E 45 09 09 ...   1350  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001FC1= 09 42 47 45 09 09 ...   1351  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001FC9= 09 42 47 54 09 09 ...   1352  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001FD1= 09 42 48 49 09 09 ...   1353  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001FD9= 09 42 4C 45 09 09 ...   1354  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001FE1= 09 42 4C 53 09 09 ...   1355  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001FE9= 09 42 4C 54 09 09 ...   1356  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001FF1= 09 42 4D 49 09 09 ...   1357  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001FF9= 09 42 50 4C 09 09 ...   1358  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00002001= 09 42 56 43 09 09 ...   1359  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00002009= 09 42 56 53 09 09 ...   1360  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00002011= 09 4A 53 52 09 09 ...   1361  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00002019= 09 52 54 53 00          1362  MSG_RTS                         DC.B    TAB,'RTS',0
0000201E= 09 42 52 41 09 09 ...   1363  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00002026                          1364  
00002026                          1365  * Direction for LSd and ASd
00002026= 52 00                   1366  MSG_RIGHT                       DC.B    'R',0
00002028= 4C 00                   1367  MSG_LEFT                        DC.B    'L',0
0000202A                          1368  
0000202A                          1369  * Effective Addresses Messages
0000202A= 44 00                   1370  MSG_DR                          DC.B    'D',0
0000202C= 41 00                   1371  MSG_AR                          DC.B    'A',0
0000202E= 28 00                   1372  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002030= 29 00                   1373  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00002032= 2B 00                   1374  MSG_PLUS                        DC.B    '+',0
00002034= 2D 00                   1375  MSG_MINUS                       DC.B    '-',0
00002036= 23 00                   1376  MSG_POUND                       DC.B    '#',0 
00002038= 24 00                   1377  MSG_HEX                         DC.B    '$',0 
0000203A= 2C 20 00                1378  MSG_COMMA                       DC.B    ', ',0 
0000203D= 20 00                   1379  MSG_SPACE                       DC.B    ' ',0
0000203F= 09 00                   1380  MSG_TAB                         DC.B    TAB,0
00002041                          1381  
00002041                          1382  * Size Messages
00002041= 2E 42 09 09 09 00       1383  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00002047= 2E 57 09 09 09 00       1384  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
0000204D= 2E 4C 09 09 09 00       1385  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00002053                          1386  
00002053                          1387  * Variables
00002053  =00000100               1388  STARTING_ADDRESS                EQU     $100
00002053  =00000150               1389  ENDING_ADDRESS                  EQU     $150
00002053  =00000200               1390  CURRENT_INSTR                   EQU     $200
00002053  =00000250               1391  REG_VAR                         EQU     $250 * Hold bits 11-9
00002053  =00000300               1392  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00002053  =00000350               1393  EA_MODE                         EQU     $350 * Hold bits 5-3
00002053  =00000400               1394  EA_REG                          EQU     $400 * Hold bits 2-0
00002053                          1395  
00002053                          1396              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           144C
ADDQ_BYTE           14E6
ADDQ_LONG           1506
ADDQ_WORD           14F6
ADD_SUB_BYTE        1388
ADD_SUB_HELP        130C
ADD_SUB_LONG        13A4
ADD_SUB_OPERAND     13BA
ADD_SUB_SIZE        1364
ADD_SUB_WORD        1396
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1EDC
CASE_ADD            12DE
CASE_ADDA           1420
CASE_ADDQ           1488
CASE_AND            167A
CASE_AR             1A98
CASE_ARI            1AB0
CASE_ARIPOST        1AE0
CASE_ARIPRE         1B1C
CASE_ASDMEM         16BA
CASE_ASDREG         1782
CASE_BCC            18BA
CASE_BEQ            18EC
CASE_BGT            1900
CASE_BLE            18F6
CASE_BRA            1896
CASE_DATA           1930
CASE_DR             1A80
CASE_EPICFAIL       1932
CASE_IMMEDIATE      1B6A
CASE_JSR            191A
CASE_LEA            15E8
CASE_LEFTMEM        16E0
CASE_LEFTREG        17A8
CASE_LONG           1BAA
CASE_LSDASD         167A
CASE_LSDMEM         16B0
CASE_LSDREG         1778
CASE_MOVE           1182
CASE_MOVEM          1224
CASE_MOVEQ          128A
CASE_NOP            116C
CASE_NOT            167A
CASE_OR             167A
CASE_OTHER          1B58
CASE_RIGHTMEM       16EA
CASE_RIGHTREG       17B2
CASE_RODMEM         16C4
CASE_RODREG         178C
CASE_RTS            191A
CASE_SHIFTMEM       1698
CASE_SHIFTREG       175E
CASE_SUB            155C
CASE_SUBA           15D2
CASE_WORD           1B8E
CHECKEAEXIT         1A50
CHECKEAMLOOP        1A22
CHECKEAXN_IFVALID   1A20
CHECKGET_EAXN       1988
CHECKMEMSOURE       171E
CHECKSHIFT_XN       1748
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            19B8
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1D86
DELETEMEAGAIN       1DB8
DESTEA              193E
DESTXN              1968
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          13F4
EASHIFT_VALID       173C
EAXN_INVALID        19CA
EAXN_VALID          19B0
EA_MODE             350
EA_REG              400
EA_TO_STRING        1A54
EA_TO_STRING_EXIT   1BCA
ENDING              1EA6
ENDING_ADDRESS      150
END_CHECKGET        19CE
ERROR               1D7A
ERROR_MSG           1EFE
FINDTYPEEA          1952
FINDTYPEXN          197C
FINISHMOVE          1D70
FINISH_ADD          13B2
FINISH_ADDA         145C
FINISH_ADDQ         1516
FINISH_SUB          1598
FINISH_SUBA         159E
GETDIRECTION        1A08
GETDISPLACEMENT     19D0
GETMEMSOURCE        1706
GETROTATION         19FE
GETROTATIONLOCATION  1A18
GETROTATIONSIZE     1A10
GET_EA              1934
GET_XN              195E
INPUT1              100C
INPUT2              1052
INSERTA             11F0
INVALID             112C
INVALIDEA           1A34
INVALID_INSTR       1F1A
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128A
MOVEM_REG2MEM       125A
MOVE_BYTE           1D56
MOVE_LONG           1D6A
MOVE_WORD           1D60
MSG_ADD             1F5D
MSG_ADDA            1F62
MSG_ADDQ            1F68
MSG_AND             1F87
MSG_AR              202C
MSG_ASD             1F99
MSG_B               2041
MSG_BCC             1FA1
MSG_BCS             1FA9
MSG_BEQ             1FB1
MSG_BGE             1FC1
MSG_BGT             1FC9
MSG_BHI             1FD1
MSG_BLE             1FD9
MSG_BLS             1FE1
MSG_BLT             1FE9
MSG_BMI             1FF1
MSG_BNE             1FB9
MSG_BPL             1FF9
MSG_BRA             201E
MSG_BVC             2001
MSG_BVS             2009
MSG_COMMA           203A
MSG_DIVU            1F79
MSG_DR              202A
MSG_HEX             2038
MSG_JSR             2011
MSG_L               204D
MSG_LB              202E
MSG_LEA             1F7F
MSG_LEFT            2028
MSG_LSD             1F95
MSG_MINUS           2034
MSG_MOVE            1F42
MSG_MOVEA           1F48
MSG_MOVEM           1F56
MSG_MOVEQ           1F4F
MSG_MULS            1F73
MSG_NOP             1F3D
MSG_NOT             1F90
MSG_OR              1F8C
MSG_PLUS            2032
MSG_POUND           2036
MSG_RB              2030
MSG_RIGHT           2026
MSG_ROD             1F9D
MSG_RTS             2019
MSG_SPACE           203D
MSG_SUB             1F6E
MSG_TAB             203F
MSG_W               2047
NEW_LINE            1F36
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OTHER               7
OTHEREA             1A4C
PRINTADD            1352
PRINTADDRESS        19E0
PRINTASHEX          1CE8
PRINTBCC            190A
PRINTENTER          1D2C
PRINTHEXNUM         1BE0
PRINTLONGZERO       1C40
PRINTMOVE           11F6
PRINTMOVESIZE       1D3C
PRINTNULL           1D1A
PRINTNUM            1BD0
PRINTRANGE          1D04
PRINTREGEA          17F4
PRINTREGSIZE        17C2
PRINTSHIFTMEM       16CA
PRINTSHIFTREG       1792
PRINTSHORTLONGNUM   1BF4
PRINTSHORTZERO      1C00
PRINTSUB            1578
PRINTZERO           1CF8
PRINT_8             1550
PRINT_ADDQ_DATA     1534
PRINT_MEMDIR        16F0
PRINT_MOVEQ         12AC
PRINT_REGDIR        17BC
REG2MEMXNCHECK      1274
REG_BYTE            17DA
REG_IMMEDIATE       180A
REG_LONG            17EE
REG_REGISTER        1850
REG_VAR             250
REG_WORD            17E4
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            194A
SOURCEXN            1974
START               1000
STARTING            1E6F
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           1F39
VALIDEA             1A3C
VALIDEA_ADDSUB_DESTOPERAND  1DD1
VALIDEA_ALL         1DBC
VALIDEA_ANDORNOT    1DDF
VALIDEA_ANDOR_DESTOPERAND  1DE5
VALIDEA_JSR         1DEF
VALIDEA_LEA         1DDC
VALIDEA_MOVEM_MEMTOREG  1DCD
VALIDEA_MOVEM_REGTOMEM  1DC9
VALIDEA_MOVEQ       1DC3
VALIDEA_MULSDIVU    1DD6
VALIDEA_SHIFT       1DEA
VALIDXN_ALL         1DF2
VALIDXN_SHORTLONG   1DF6
WELCOME             1DF9
XNIMMEDIATE         4
