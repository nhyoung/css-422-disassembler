00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 4:59:00 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/10/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00002365             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 0000238D             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 000023D8             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000023F8             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1        ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011DE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011F0             36                  JSR     CONVERT
00001052  4EB9 0000125C             37                  JSR     TEST_RANGE
00001058  4EB9 00001274             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 0000242F             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011DE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011F0             55                  JSR     CONVERT
0000109A  4EB9 0000125C             56                  JSR     TEST_RANGE
000010A0  4EB9 00001274             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0120                 64                  BLT     RESET_INPUT
000010B8  4BF9 00002518             65                  LEA     NEW_LINE,A5
000010BE  4EB9 000022B4             66                  JSR     PRINTNULL
000010C4                            67                  
000010C4  1439 00002619             68                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  143C 0007                 69                  MOVE.B  #7,D2               ; set variable to 0
000010CE  13C2 00002619             70                  MOVE.B  D2,LINE_COUNT       ; store back in the variabl
000010D4                            71                                 
000010D4  1439 00002619             72  DISASSEMBLE     MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010DA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010DC  13C2 00002619             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010E2                            75                  
000010E2  4EB9 00001288             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010E8                            77                  
000010E8  4EB9 00001186             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010EE                            79                  
000010EE  4EB9 000022C6             80                  JSR     PRINTENTER          ; prints a new line
000010F4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010F6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010F8                            83                  
000010F8                            84  
000010F8  4BF9 000024A9             85  FINISHED        LEA     DONE,A5
000010FE  4EB9 000022B4             86                  JSR     PRINTNULL
00001104  103C 0005                 87                  MOVE.B  #5,D0
00001108  4E4F                      88                  TRAP    #15
0000110A                            89                  
0000110A  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
0000110E  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001112                            92                  
00001112  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001116  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000111A                            95  
0000111A  103C 0009                 96                  MOVE.B  #9,D0
0000111E  4E4F                      97                  TRAP    #15
00001120                            98                  
00001120  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001124  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001128  4E4F                     101                  TRAP    #15                 Call Trap
0000112A                           102                  
0000112A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000112E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001132  4E4F                     105                  TRAP    #15
00001134                           106                  
00001134  1439 00002619            107                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
0000113A  143C 0000                108                  MOVE.B  #0,D2               ; set variable to 0
0000113E  13C2 00002619            109                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
00001144                           110   
00001144  207C 00000000            111                  MOVE.L  #$0000000, A0       ; Reset A1
0000114A  227C 00000000            112                  MOVE.L  #$0000000, A1       ; Reset A1
00001150  247C 00000000            113                  MOVE.L  #$0000000, A2       ; Reset A2
00001156  267C 00000000            114                  MOVE.L  #$0000000, A3       ; Reset A3
0000115C  287C 00000000            115                  MOVE.L  #$0000000, A4       ; Reset A4
00001162  2A7C 00000000            116                  MOVE.L  #$0000000, A5       ; Reset A5
00001168  2C7C 00000000            117                  MOVE.L  #$0000000, A6       ; Reset A6
0000116E  2E7C 01000000            118                  MOVEA.L #$01000000,A7       ; Reset A7
00001174  4281                     119                  CLR.L   D1                  ; Reset D1
00001176  4281                     120                  CLR.L   D1                  ; Reset D1
00001178  4282                     121                  CLR.L   D2                  ; Reset D2
0000117A  4283                     122                  CLR.L   D3                  ; Reset D3
0000117C  4284                     123                  CLR.L   D4                  ; Reset D4
0000117E  4285                     124                  CLR.L   D5                  ; Reset D5
00001180  4286                     125                  CLR.L   D6                  ; Reset D6
00001182  6000 FE7C                126                  BRA     START               ; branch to start of program
00001186                           127  
00001186                           128  *--------------------SUBROUTINES------------------
00001186  1439 00002619            129  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000118C  1639 0000261A            130                  MOVE.B  LINE_MAX,D3                
00001192  B602                     131                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001194  6F00 0004                132                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001198  4E75                     133                  RTS
0000119A                           134  
0000119A  4BF9 000024ED            135  NEXT_SCREEN     LEA     CONTINUE,A5
000011A0  4EB9 000022B4            136                  JSR     PRINTNULL
000011A6  6000 0002                137                  BRA     READ_KEY
000011AA                           138                  
000011AA  103C 0005                139  READ_KEY        MOVE.B  #5,D0
000011AE  4E4F                     140                  TRAP    #15
000011B0                           141                  
000011B0  B23C 000D                142                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000011B4  6700 0004                143                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
000011B8  60F0                     144                  BRA     READ_KEY
000011BA                           145                  
000011BA  103C 000B                146  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
000011BE  323C FF00                147                  MOVE.W  #$FF00, D1          Clear Screen
000011C2  4E4F                     148                  TRAP    #15                 Call Trap
000011C4                           149                  
000011C4                           150                  ; reset line counter
000011C4  1439 00002619            151                  MOVE.B  LINE_COUNT,D2
000011CA  143C 0000                152                  MOVE.B  #$0,D2
000011CE  13C2 00002619            153                  MOVE.B  D2,LINE_COUNT
000011D4  4E75                     154                  RTS       
000011D6                           155      
000011D6                           156  
000011D6  143C 0001                157  RESET_INPUT     MOVE.B  #1,D2
000011DA  6000 0062                158                  BRA     INVALID            
000011DE                           159                  
000011DE  7800                     160  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011E0  B204                     161                  CMP.B   D4,D1               ; D1 stores length
000011E2  6700 005A                162                  BEQ     INVALID             ; input is null
000011E6  0C41 0008                163                  CMPI    #$8,D1              ; check if input is longer than a longword
000011EA  6600 0052                164                  BNE     INVALID             ; input is longer than a longword
000011EE  4E75                     165                  RTS
000011F0                           166                              
000011F0  4283                     167  CONVERT         CLR.L   D3
000011F2  4284                     168                  CLR.L   D4
000011F4  1619                     169                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011F6  B63C 0039                170                  CMP.B   #57,D3
000011FA  6E00 0012                171                  BGT     NOTNUMBER
000011FE                           172                  
000011FE  B63C 002F                173                  CMP.B   #47,D3
00001202  6E00 0002                174                  BGT     ISNUMBER
00001206                           175                  
00001206  0603 00D0                176  ISNUMBER        ADD.B   #-48,D3             ; current char is number
0000120A  6000 001A                177                  BRA     CONCAT
0000120E                           178              
0000120E  B63C 0041                179  NOTNUMBER       CMP.B   #65,D3
00001212  6D00 002A                180                  BLT     INVALID
00001216  B63C 0046                181                  CMP.B   #70,D3
0000121A  6E00 0022                182                  BGT     INVALID  
0000121E  0603 00C9                183                  ADD.B   #-55,D3             ; is letter             
00001222  6000 0002                184                  BRA     CONCAT
00001226                           185              
00001226  BC3C 0000                186  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000122A  6D00 0010                187                  BLT     RETURN
0000122E  1806                     188                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001230  E50C                     189                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001232  E9AB                     190                  LSL.L   D4,D3               ; moves current char to correct position  
00001234  DA83                     191                  ADD.L   D3,D5               ; D5 stores converted input so far
00001236  0606 00FF                192                  ADD.B   #-1,D6  
0000123A  60B4                     193                  BRA     CONVERT             ; continue loop for remaining chars
0000123C                           194                  
0000123C  4E75                     195  RETURN          RTS
0000123E                           196                  
0000123E  227C 00000000            197  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001244  43F9 00002465            198                  LEA     BAD_INPUT,A1        ; output invalid message
0000124A  103C 000E                199                  MOVE.B  #14,D0
0000124E  4E4F                     200                  TRAP    #15
00001250  B47C 0001                201                  CMP     #1,D2
00001254  6700 FDCA                202                  BEQ     INPUT1
00001258  6000 FE0C                203                  BRA     INPUT2
0000125C                           204  
0000125C  4284                     205  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000125E  223C 00001000            206                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001264  BA81                     207                  CMP.L      D1,D5            ; Compare minimum address with input
00001266  6DD6                     208                  BLT        INVALID          ; input is too low. 
00001268  223C 00FFFFFE            209                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000126E  BA81                     210                  CMP.L      D1,D5            ; compare maximum address with input
00001270  6ECC                     211                  BGT        INVALID          ; input too large
00001272  4E75                     212                  RTS                         ; input is within range
00001274                           213             
00001274  0805 0000                214  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001278  66C4                     215                  BNE        INVALID
0000127A  4E75                     216                  RTS
0000127C                           217  
0000127C                           218  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
0000127C                           219  *                MOVE.L  A6,D1                   ; loads current address in D1
0000127C                           220  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
0000127C                           221  *                JSR     PRINTSHORTLONGNUM       ; prints out address
0000127C                           222  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
0000127C                           223  *                RTS
0000127C  220E                     224                  MOVE.L  A6,D1                   ; loads current address in D1
0000127E  7801                     225                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001280  4EB9 0000218E            226                  JSR     PRINTSHORTLONGNUM       ; prints out address
00001286  4E75                     227                  RTS
00001288                           228  
00001288                           229  
00001288                           230  
00001288                           231  * Checks every single possible opcode we could have. Jump table
00001288                           232  * Inputs: (A2) which is a pointer to intruction word to be translated
00001288                           233  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001288                           234  
00001288  3C4A                     235  OPCODE_DECODE   MOVE.W  A2,A6
0000128A  301A                     236                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000128C  4EB8 127C                237                  JSR     PRINT_ADDR
00001290                           238                  
00001290                           239  
00001290                           240  *---------------NOP opcode----------------------                
00001290  B07C 4E71                241  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001294  6600 0010                242                  BNE     CASE_MOVE               ; checks the next case if not equal
00001298                           243                  
00001298  4BF9 0000251F            244                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000129E  4EB9 000022B4            245                  JSR     PRINTNULL               ; prints NOP                
000012A4  4E75                     246                  RTS                             ; returns from the subroutine
000012A6                           247  
000012A6                           248  *---------------MOVE opcode----------------------              
000012A6                           249                  * if first two bits are 00, next two are not 00
000012A6  3200                     250  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
000012A8  C27C C000                251                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
000012AC  6600 00BE                252                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
000012B0  B07C 0FFF                253                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000012B4  6F00 00B6                254                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
000012B8                           255                  
000012B8                           256                  ; Check source
000012B8  4BF9 00002328            257                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012BE  4DF9 0000235E            258                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012C4  3E3C 0000                259                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012C8  4EB9 00001E54            260                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012CE  B27C 0001                261                  CMP.W   #1,D1                    ; checks if invalid
000012D2  6700 0B24                262                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012D6  3802                     263                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012D8  3A03                     264                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012DA                           265                  
000012DA                           266                  ; Check destination
000012DA  4BF9 00002328            267                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012E0  4DF9 00002362            268                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012E6  3E3C 0001                269                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012EA  4EB9 00001E54            270                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012F0  B27C 0001                271                  CMP.W   #1,D1                    ; checks if invalid
000012F4  6700 0B02                272                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012F8  3C02                     273                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012FA  3E03                     274                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012FC                           275                  
000012FC                           276                  ; Checking if it is MOVEA
000012FC  3200                     277                  MOVE.W  D0,D1                    ; stores d0 in d1
000012FE  C27C 01C0                278                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
00001302  B27C 0040                279                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
00001306  6700 0024                280                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
0000130A                           281                  
0000130A  4BF9 00002524            282                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001310  4EB9 000022B4            283                  JSR     PRINTNULL                ; prints out MOVE
00001316  4EB9 000022D6            284                  JSR     PRINTMOVESIZE            ; prints out the size 
0000131C  4BF9 000025F6            285                  LEA     MSG_4SPACES,A5           ; loads spaces
00001322  4EB9 000022B4            286                  JSR     PRINTNULL                ; prints out spaces
00001328  6000 0020                287                  BRA     PRINTMOVE                ; Branches to print move
0000132C                           288                  
0000132C  4BF9 0000252A            289  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001332  4EB9 000022B4            290                  JSR     PRINTNULL                ; prints out MOVEA
00001338  4EB9 000022D6            291                  JSR     PRINTMOVESIZE            ; prints out the size 
0000133E  4BF9 000025F2            292                  LEA     MSG_3SPACES,A5           ; loads spaces
00001344  4EB9 000022B4            293                  JSR     PRINTNULL                ; prints out spaces
0000134A                           294   
0000134A  3404                     295  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000134C  3605                     296                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000134E  4EB9 00001FC2            297                  JSR     EA_TO_STRING             ; outputs it into a string
00001354                           298                  
00001354                           299                  ; prints a comma to seperate
00001354  4BF9 000025E9            300                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000135A  4EB9 000022B4            301                  JSR     PRINTNULL                ; prints out MOVE
00001360                           302                  
00001360                           303                  ; print destination
00001360  3406                     304                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001362  3607                     305                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001364  4EB9 00001FC2            306                  JSR     EA_TO_STRING             ; outputs it into a string
0000136A  4E75                     307                  RTS                              ; exits subroutine                 
0000136C                           308                
0000136C                           309  *---------------MOVEM opcode----------------------                
0000136C  3200                     310  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000136E  C27C FB80                311                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001372  B27C 4880                312                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001376  6600 0100                313                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000137A                           314                  
0000137A                           315                  ; Check D
0000137A  3200                     316                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000137C  C27C 0400                317                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001380  3E01                     318                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001382  B27C 0400                319                  CMP.W   #$0400,D1                       ; checks if value is 1
00001386  6700 0076                320                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000138A                           321  
0000138A                           322  MOVEM_REG2MEM   ; loads EA and XN
0000138A  3E3C 0000                323                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000138E  4BF9 00002335            324                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001394  4DF9 00002362            325                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000139A  4EB9 00001E54            326                  JSR     CHECKGET_EAXN
000013A0  B27C 0001                327                  CMP.W   #1,D1                           ; checks if D1 invalid
000013A4  6700 0A52                328                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000013A8  4BF9 00002538            329                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000013AE  4EB9 000022B4            330                  JSR     PRINTNULL                       ; prints MOVEM
000013B4                           331                  
000013B4                           332                  ; finds and prints size
000013B4  3200                     333                  MOVE.W  D0,D1                           ; copies D0
000013B6  C27C 0040                334                  AND.W   #$0040,D1                       ; gets the size bit
000013BA  6600 000C                335                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000013BE                           336  
000013BE  4BF9 00002613            337  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013C4  6000 0008                338                  BRA     PRINTREG2MEM                    ; prints the registers           
000013C8                           339                  
000013C8  4BF9 00002616            340  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013CE                           341             
000013CE  4EB9 000022B4            342  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013D4  4BF9 000025F2            343                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013DA  4EB9 000022B4            344                  JSR     PRINTNULL                       ; prints out spaces
000013E0  383C 0001                345                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013E4  4EB9 00001EEC            346                  JSR     PRINTREGISTERS                  ; prints registers
000013EA  4BF9 000025E9            347                  LEA     MSG_COMMA,A5                    ; loads comma
000013F0  4EB9 000022B4            348                  JSR     PRINTNULL                       ; prints comma
000013F6  4EB9 00001FC2            349                  JSR     EA_TO_STRING                    ; prints EA
000013FC  4E75                     350                  RTS
000013FE                           351  
000013FE                           352  MOVEM_MEM2REG  ; loads EA and XN
000013FE  3E3C 0000                353                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001402  4BF9 00002339            354                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
00001408  4DF9 00002362            355                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000140E  4EB9 00001E54            356                  JSR     CHECKGET_EAXN
00001414  B27C 0001                357                  CMP.W   #1,D1                           ; checks if D1 invalid
00001418  6700 09DE                358                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000141C  4BF9 00002538            359                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001422  4EB9 000022B4            360                  JSR     PRINTNULL                       ; prints MOVEM
00001428                           361                  
00001428                           362                  ; finds and prints size
00001428  3200                     363                  MOVE.W  D0,D1                           ; copies D0
0000142A  C27C 0040                364                  AND.W   #$0040,D1                       ; gets the size bit
0000142E  6600 000C                365                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001432                           366  
00001432  4BF9 00002613            367  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001438  6000 000E                368                  BRA     PRINTMEM2REG                    ; prints the registers           
0000143C                           369                  
0000143C  4BF9 00002616            370  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001442  4EB9 000022B4            371                  JSR     PRINTNULL                       ; prints MOVEM 
00001448                           372             
00001448  4EB9 000022B4            373  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
0000144E  4BF9 000025F2            374                  LEA     MSG_3SPACES,A5                  ; loads spaces
00001454  4EB9 000022B4            375                  JSR     PRINTNULL                       ; prints out spaces
0000145A  4EB9 00001FC2            376                  JSR     EA_TO_STRING                    ; prints EA
00001460  4BF9 000025E9            377                  LEA     MSG_COMMA,A5                    ; loads comma
00001466  4EB9 000022B4            378                  JSR     PRINTNULL                       ; prints comma
0000146C  383C FFFF                379                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001470  4EB9 00001EEC            380                  JSR     PRINTREGISTERS                  ; prints registers
00001476  4E75                     381                  RTS
00001478                           382                          
00001478                           383  
00001478                           384  *---------------MOVEQ opcode----------------------
00001478  3200                     385  CASE_MOVEQ      MOVE.W  D0,D1
0000147A  C27C F100                386                  AND.W   #$F100,D1
0000147E  B27C 7000                387                  CMP.W   #$7000,D1
00001482  6600 007C                388                  BNE     CASE_ADD
00001486                           389                  
00001486                           390                  ;loads Register
00001486  323C 0001                391                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000148A  4EB9 00001E2A            392                  JSR     GET_XN                          ; gets XN and puts in D1
00001490  3601                     393                  MOVE.W  D1,D3                           ; copies Xn to D3 so it won't be overwritten
00001492                           394                  
00001492                           395                  ;loads DATA
00001492  3200                     396                  MOVE.W  D0,D1
00001494  C27C 00FF                397                  AND.W   #$00FF,D1                       ;bit mask to get DATA
00001498  3801                     398                  MOVE.W  D1,D4                           ;copy data into D4
0000149A                           399                                                          ;must convert bits to hex
0000149A                           400                                  
0000149A  4BF9 00002531            401  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000014A0  4EB9 000022B4            402                  JSR     PRINTNULL  
000014A6                           403                                  
000014A6  4BF9 00002616            404                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014AC  4EB9 000022B4            405                  JSR     PRINTNULL
000014B2                           406      
000014B2  4BF9 000025F2            407                  LEA     MSG_3SPACES,A5                  ;PRINT THREE TABS
000014B8  4EB9 000022B4            408                  JSR     PRINTNULL
000014BE                           409                  
000014BE  4BF9 000025E5            410                  LEA     MSG_POUND, A5                   ;PRINT HASHTAG
000014C4  4EB9 000022B4            411                  JSR     PRINTNULL
000014CA                           412                  
000014CA  4BF9 000025E7            413                  LEA     MSG_HEX, A5                     ;PRINT DOLLAR SIGN
000014D0  4EB9 000022B4            414                  JSR     PRINTNULL
000014D6                           415                  
000014D6  3204                     416                  MOVE.W  D4,D1                           ;PRINT DATA
000014D8  4EB9 0000217A            417                  JSR     PRINTHEXNUM                           
000014DE                           418                  
000014DE  4BF9 000025E9            419                  LEA     MSG_COMMA, A5                   ;PRINT COMMA
000014E4  4EB9 000022B4            420                  JSR     PRINTNULL
000014EA                           421                  
000014EA  4BF9 000025D9            422                  LEA     MSG_DR,A5                       ;PRINT D
000014F0  4EB9 000022B4            423                  JSR     PRINTNULL
000014F6                           424            
000014F6  3203                     425                  MOVE.W  D3,D1                           ;PRINT REGISTER NUMBER
000014F8  4EB9 0000216A            426                  JSR     PRINTNUM                         
000014FE                           427                  
000014FE  4E75                     428                  RTS
00001500                           429                  
00001500                           430  *---------------ADD opcode----------------------                
00001500                           431  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
00001500  3200                     432  CASE_ADD        MOVE.W  D0,D1
00001502  C27C F000                433                  AND.W   #$F000,D1
00001506  B27C D000                434                  CMP.W   #$D000,D1
0000150A  6600 01D0                435                  BNE     CASE_ADDQ
0000150E                           436                   
0000150E  4EB9 00001528            437                  JSR     ADD_SUB_HELP
00001514                           438                  
00001514                           439                  ; bits 7-8 determine if it is ADDA or ADD
00001514  3200                     440                  MOVE.W  D0,D1
00001516  E149                     441                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001518  E049                     442                  LSR.W   #8,D1
0000151A  EC49                     443                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000151C  B27C 0003                444                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001520  6700 0136                445                  BEQ     CASE_ADDA
00001524                           446                  
00001524  6000 0040                447                  BRA     PRINTADD                ; Branches to print add
00001528                           448                  
00001528                           449                  ; Check bits 0-5 
00001528  4BF9 00002328            450  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000152E  4DF9 0000235E            451                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001534  3E3C 0000                452                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001538  4EB9 00001E54            453                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000153E  B27C 0001                454                  CMP.W       #1,D1                    ; checks if invalid
00001542  6700 08B4                455                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001546  3802                     456                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001548  3A03                     457                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000154A                           458                  
0000154A                           459                  ; Check 6-11
0000154A  4BF9 00002328            460                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001550  4DF9 00002362            461                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001556  3E3C 0001                462                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000155A  4EB9 00001E54            463                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001560  3C02                     464                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001562  3E03                     465                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001564                           466    
00001564  4E75                     467                  RTS                
00001566                           468                    
00001566  4BF9 0000253F            469  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
0000156C  4EB9 000022B4            470                  JSR         PRINTNULL               ; print ADD
00001572  3200                     471                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001574  4EB9 0000158A            472                  JSR         ADD_SUB_SIZE            ; D1 = size
0000157A  4BF9 000025FB            473                  LEA         MSG_5SPACES,A5          ; loads spaces
00001580  4EB9 000022B4            474                  JSR         PRINTNULL               ; prints out spaces
00001586  6000 0050                475                  BRA         FINISH_ADD
0000158A                           476                    
0000158A  3200                     477  ADD_SUB_SIZE    MOVE.W      D0,D1
0000158C  E149                     478                  LSL.W       #8,D1
0000158E  E049                     479                  LSR.W       #8,D1
00001590  EC49                     480                  LSR.W       #6,D1                   ; gets bits 6-7
00001592                           481                    
00001592  B27C 0000                482                  CMP.W       #0,D1
00001596  6700 0016                483                  BEQ         ADD_SUB_BYTE
0000159A  B27C 0001                484                  CMP.W       #1,D1                   ; if 1, it is a word
0000159E  6700 001C                485                  BEQ         ADD_SUB_WORD
000015A2  B27C 0002                486                  CMP.W       #2,D1                   ; if 2, it is a long
000015A6  6700 0022                487                  BEQ         ADD_SUB_LONG
000015AA  6000 02AE                488                  BRA         CASE_SUBA               ; error
000015AE                           489                    
000015AE  4BF9 00002610            490  ADD_SUB_BYTE    LEA         MSG_B,A5
000015B4  4EB9 000022B4            491                  JSR         PRINTNULL
000015BA  4E75                     492                  RTS
000015BC                           493                    
000015BC  4BF9 00002613            494  ADD_SUB_WORD    LEA         MSG_W,A5
000015C2  4EB9 000022B4            495                  JSR         PRINTNULL
000015C8  4E75                     496                  RTS
000015CA                           497    
000015CA  4BF9 00002616            498  ADD_SUB_LONG    LEA         MSG_L,A5
000015D0  4EB9 000022B4            499                  JSR         PRINTNULL
000015D6  4E75                     500                  RTS
000015D8                           501        
000015D8  4EB9 000015E0            502  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015DE  4E75                     503                  RTS
000015E0                           504    
000015E0  3200                     505  ADD_SUB_OPERAND MOVE.W      D0,D1
000015E2  EF49                     506                  LSL.W       #7,D1
000015E4  EE49                     507                  LSR.W       #7,D1
000015E6  E049                     508                  LSR.W       #8,D1
000015E8  B27C 0001                509                  CMP.W       #1,D1
000015EC  6600 0036                510                  BNE         Dn_PLUS_EA          
000015F0                           511                    
000015F0                           512                  ; print Data Register
000015F0  4BF9 000025D9            513                  LEA         MSG_DR,A5
000015F6  4EB9 000022B4            514                  JSR         PRINTNULL
000015FC  3207                     515                  MOVE.W      D7,D1
000015FE  4EB9 0000216A            516                  JSR         PRINTNUM                
00001604                           517                  
00001604                           518                  ; prints a comma to seperate
00001604  4BF9 000025E9            519                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000160A  4EB9 000022B4            520                  JSR         PRINTNULL                ; prints out MOVE
00001610                           521                 
00001610                           522                  ; below is EA+Dn->Dn  
00001610  3404                     523                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001612  3605                     524                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3
00001614  3200                     525                  MOVE.W      D0,D1
00001616  E149                     526                  LSL.W       #8,D1
00001618  E049                     527                  LSR.W       #8,D1
0000161A  EC49                     528                  LSR.W       #6,D1                   ; gets bits 6-7 
0000161C  4EB9 00001FC2            529                  JSR         EA_TO_STRING             ; outputs it into a string
00001622  4E75                     530                  RTS                                 ; exits subroutine 
00001624                           531  
00001624                           532  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001624  3404                     533                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001626  3605                     534                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001628  3200                     535                  MOVE.W      D0,D1
0000162A  E149                     536                  LSL.W       #8,D1
0000162C  E049                     537                  LSR.W       #8,D1
0000162E  EC49                     538                  LSR.W       #6,D1                   ; gets bits 6-7
00001630  4EB9 00001FC2            539                  JSR         EA_TO_STRING             ; outputs it into a string   
00001636                           540                  
00001636                           541                  ; prints a comma to seperate
00001636  4BF9 000025E9            542                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000163C  4EB9 000022B4            543                  JSR         PRINTNULL                ; prints out MOVE
00001642                           544                  
00001642                           545                  ; below is Dn+EA->EA
00001642  4BF9 000025D9            546                  LEA         MSG_DR,A5                ; print data register
00001648  4EB9 000022B4            547                  JSR         PRINTNULL
0000164E  3207                     548                  MOVE.W      D7,D1
00001650  4EB9 0000216A            549                  JSR         PRINTNUM             
00001656  4E75                     550                  RTS                                  ; exits subroutine          
00001658                           551                        
00001658                           552  *---------------ADDA opcode----------------------
00001658                           553  CASE_ADDA       ; gets bit 8 (size bit)
00001658  3200                     554                  MOVE.W      D0,D1
0000165A  EF49                     555                  LSL.W       #7,D1
0000165C  EE49                     556                  LSR.W       #7,D1
0000165E  E049                     557                  LSR         #8,D1                   
00001660                           558                  
00001660  4BF9 00002544            559                  LEA         MSG_ADDA,A5             ; print ADDA
00001666  4EB9 000022B4            560                  JSR         PRINTNULL
0000166C                           561                   
0000166C  B27C 0001                562                  CMP.W       #1,D1
00001670  6700 001E                563                  BEQ         ADDA_LONG
00001674                           564                    
00001674  4BF9 00002613            565                  LEA         MSG_W,A5
0000167A  4EB9 000022B4            566                  JSR         PRINTNULL
00001680  4BF9 000025F6            567                  LEA         MSG_4SPACES,A5          ; loads spaces
00001686  4EB9 000022B4            568                  JSR         PRINTNULL               ; prints out spaces
0000168C  6000 0022                569                  BRA         FINISH_ADDA   
00001690                           570                    
00001690  323C 0002                571  ADDA_LONG       MOVE.W      #2,D1                   ;sets D1 to be word sized for EA to string
00001694  4BF9 00002616            572                  LEA         MSG_L,A5
0000169A  4EB9 000022B4            573                  JSR         PRINTNULL
000016A0  4BF9 000025F6            574                  LEA         MSG_4SPACES,A5          ; loads spaces
000016A6  4EB9 000022B4            575                  JSR         PRINTNULL               ; prints out spaces
000016AC  6000 0002                576                  BRA         FINISH_ADDA
000016B0                           577                    
000016B0  3404                     578  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016B2  3605                     579                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016B4  4EB9 00001FC2            580                  JSR         EA_TO_STRING             ; outputs it into a string
000016BA                           581                    
000016BA                           582                  ; prints a comma to seperate
000016BA  4BF9 000025E9            583                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016C0  4EB9 000022B4            584                  JSR         PRINTNULL                ; prints out MOVE
000016C6                           585            
000016C6  4BF9 000025DB            586                  LEA         MSG_AR,A5                ; print address register
000016CC  4EB9 000022B4            587                  JSR         PRINTNULL
000016D2  3207                     588                  MOVE.W      D7,D1
000016D4  4EB9 0000216A            589                  JSR         PRINTNUM             
000016DA  4E75                     590                  RTS                              ; exits subroutine
000016DC                           591                  
000016DC                           592  *---------------ADDQ opcode----------------------                  
000016DC  3200                     593  CASE_ADDQ       MOVE.W      D0,D1
000016DE  C27C F000                594                  AND.W       #$F000,D1       
000016E2  B27C 5000                595                  CMP.W       #$5000,D1
000016E6  6600 00F0                596                  BNE         CASE_SUB
000016EA                           597                                                      
000016EA                           598                  ; Check bits 0-5 
000016EA  4BF9 00002328            599                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016F0  4DF9 0000235E            600                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016F6  3E3C 0000                601                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016FA  4EB9 00001E54            602                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001700  B27C 0001                603                  CMP.W       #1,D1                    ; checks if invalid
00001704  6700 06F2                604                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001708                           605                  
00001708  4BF9 0000254A            606                  LEA         MSG_ADDQ,A5             ; print ADDQ
0000170E  4EB9 000022B4            607                  JSR         PRINTNULL
00001714                           608                  
00001714  3802                     609                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001716  3A03                     610                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001718                           611                  
00001718                           612                   ; get bits 6-7 (size bits)
00001718  3200                     613                  MOVE.W      D0,D1
0000171A  E149                     614                  LSL.W       #8,D1
0000171C  E049                     615                  LSR.W       #8,D1
0000171E  EC49                     616                  LSR.W       #6,D1
00001720  3207                     617                  MOVE.W      D7,D1                  ; stores D1 in D7 so it won't get overwritten
00001722  B27C 0001                618                  CMP.W       #1,D1
00001726  6700 0026                619                  BEQ         ADDQ_WORD
0000172A  B27C 0002                620                  CMP.W       #2,D1
0000172E  6700 003A                621                  BEQ         ADDQ_LONG
00001732                           622                    
00001732  4BF9 00002610            623  ADDQ_BYTE       LEA         MSG_B,A5
00001738  4EB9 000022B4            624                  JSR         PRINTNULL
0000173E  4BF9 000025F6            625                  LEA         MSG_4SPACES,A5          ; loads spaces
00001744  4EB9 000022B4            626                  JSR         PRINTNULL               ; prints out spaces
0000174A  6000 003A                627                  BRA         FINISH_ADDQ  
0000174E                           628   
0000174E  4BF9 00002613            629  ADDQ_WORD       LEA         MSG_W,A5
00001754  4EB9 000022B4            630                  JSR         PRINTNULL
0000175A  4BF9 000025F6            631                  LEA         MSG_4SPACES,A5          ; loads spaces
00001760  4EB9 000022B4            632                  JSR         PRINTNULL               ; prints out spaces
00001766  6000 001E                633                  BRA         FINISH_ADDQ                 
0000176A                           634    
0000176A  4BF9 00002616            635  ADDQ_LONG       LEA         MSG_L,A5
00001770  4EB9 000022B4            636                  JSR         PRINTNULL
00001776  4BF9 000025F6            637                  LEA         MSG_4SPACES,A5          ; loads spaces
0000177C  4EB9 000022B4            638                  JSR         PRINTNULL               ; prints out spaces
00001782  6000 0002                639                  BRA         FINISH_ADDQ                  
00001786                           640                    
00001786  4EB9 000017A6            641  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000178C                           642   
0000178C                           643                  ; prints a comma to seperate
0000178C  4BF9 000025E9            644                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001792  4EB9 000022B4            645                  JSR         PRINTNULL                ; prints out MOVE
00001798                           646                    
00001798                           647                  ; prints destination
00001798  3404                     648                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000179A  3605                     649                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000179C  3207                     650                  MOVE.W      D7,D1                    ; Moves size bit to D1
0000179E  4EB9 00001FC2            651                  JSR         EA_TO_STRING             ; outputs it into a string
000017A4                           652                 
000017A4  4E75                     653                  RTS
000017A6                           654   
000017A6  4BF9 000025E5            655  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
000017AC  4EB9 000022B4            656                  JSR         PRINTNULL
000017B2                           657                  ; gets bits 9-11 (data bits)
000017B2  3200                     658                  MOVE.W      D0,D1                               ; gets D0
000017B4  E949                     659                  LSL.W       #4,D1
000017B6  E849                     660                  LSR.W       #4,D1                               ; get rid of left 4 bits
000017B8  E049                     661                  LSR.W       #8,D1
000017BA  E249                     662                  LSR.W       #1,D1                               ; get rid of right 9 bits
000017BC                           663                  
000017BC  B27C 0000                664                  CMP.W       #0,D1
000017C0  6700 000A                665                  BEQ         PRINT_8
000017C4  4EB9 0000216A            666                  JSR         PRINTNUM
000017CA  4E75                     667                  RTS 
000017CC                           668  
000017CC  123C 0008                669  PRINT_8         MOVE.B      #8,D1
000017D0  4EB9 0000216A            670                  JSR         PRINTNUM
000017D6  4E75                     671                  RTS   
000017D8                           672         
000017D8                           673  *---------------SUB opcode---------------------- 
000017D8  3200                     674  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
000017DA  C27C F000                675                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000017DE  B27C 9000                676                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
000017E2  6600 008C                677                  BNE         CASE_LEA
000017E6                           678                 
000017E6  4EB8 1528                679                  JSR         ADD_SUB_HELP
000017EA                           680                  
000017EA  6000 0002                681                  BRA         PRINTSUB                            ; Branches to print sub
000017EE                           682  
000017EE  4BF9 00002550            683  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017F4  4EB9 000022B4            684                  JSR         PRINTNULL
000017FA  3200                     685                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017FC  4EB8 158A                686                  JSR         ADD_SUB_SIZE
00001800  4BF9 000025FB            687                  LEA         MSG_5SPACES,A5                      ; loads spaces
00001806  4EB9 000022B4            688                  JSR         PRINTNULL                           ; prints out spaces
0000180C  3200                     689                  MOVE.W      D0,D1
0000180E  E149                     690                  LSL.W       #8,D1
00001810  E049                     691                  LSR.W       #8,D1
00001812  EC49                     692                  LSR.W       #6,D1
00001814  B27C 0003                693                  CMP.W       #3,D1
00001818  6600 0006                694                  BNE         FINISH_SUB
0000181C  6000 0008                695                  BRA         FINISH_SUBA                         ; same as ADDA
00001820                           696                  
00001820  4EB8 15E0                697  FINISH_SUB      JSR         ADD_SUB_OPERAND
00001824  4E75                     698                  RTS
00001826                           699                    
00001826  3404                     700  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001828  3605                     701                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000182A  4EB9 00001FC2            702                  JSR         EA_TO_STRING             ; outputs it into a string
00001830                           703                
00001830                           704                  ; prints a comma to seperate
00001830  4BF9 000025E9            705                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001836  4EB9 000022B4            706                  JSR         PRINTNULL                ; prints out MOVE
0000183C                           707                  
0000183C  4BF9 000025DB            708                  LEA         MSG_AR,A5                ; print address register
00001842  4EB9 000022B4            709                  JSR         PRINTNULL
00001848  3200                     710                  MOVE.W      D0,D1
0000184A  E949                     711                  LSL.W       #4,D1
0000184C  E849                     712                  LSR.W       #4,D1
0000184E  E049                     713                  LSR.W       #8,D1
00001850  E249                     714                  LSR.W       #1,D1
00001852  4EB9 0000216A            715                  JSR         PRINTNUM             
00001858  4E75                     716                  RTS                              ; exits subroutine
0000185A                           717  
0000185A                           718  
0000185A                           719  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000185A  3200                     720  CASE_SUBA       MOVE.W      D0,D1
0000185C  EF49                     721                  LSL.W       #7,D1
0000185E  EE49                     722                  LSR.W       #7,D1
00001860  E049                     723                  LSR.W       #8,D1
00001862  B23C 0000                724                  CMP.B       #0,D1
00001866  6700 FD54                725                  BEQ         ADD_SUB_WORD
0000186A  6000 FD5E                726                  BRA         ADD_SUB_LONG
0000186E  4E75                     727                  RTS         
00001870                           728                   
00001870  3200                     729  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001872  C27C F000                730                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001876  B27C 4000                731                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000187A  6600 0092                732                  BNE.W   CASE_AND                             ; If its not, check AND
0000187E  3200                     733                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001880  C27C 01C0                734                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001884  B27C 01C0                735                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001888  6600 0084                736                  BNE.W   CASE_AND                             ; If its not, check AND
0000188C                           737                  
0000188C                           738                  ; Check source
0000188C  4BF9 00002348            739                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001892  4DF9 00002362            740                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001898  3E3C 0000                741                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
0000189C  4EB9 00001E54            742                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000018A2  3802                     743                  MOVE.W  D2,D4                                ; Saves D2 in D4
000018A4  3A03                     744                  MOVE.W  D3,D5                                ; Saves D2 in D4
000018A6                           745                  
000018A6                           746                  ; Check destination
000018A6  4BF9 00002348            747                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000018AC  4DF9 00002362            748                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000018B2  3E3C 0001                749                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000018B6  4EB9 00001E54            750                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000018BC  3C02                     751                  MOVE.W  D2,D6                                ; Saves D2 in D4
000018BE  3E03                     752                  MOVE.W  D3,D7                                ; Saves D2 in D4
000018C0                           753  
000018C0  4BF9 00002561            754                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000018C6  4EB9 000022B4            755                  JSR     PRINTNULL                            ; prints LEA
000018CC  4BF9 00002608            756                  LEA     MSG_7SPACES,A5                       ; loads spaces
000018D2  4EB9 000022B4            757                  JSR     PRINTNULL                            ; prints out spaces
000018D8                           758                  
000018D8                           759                  ; print source
000018D8  3404                     760                  MOVE.W  D4,D2
000018DA  3605                     761                  MOVE.W  D5,D3
000018DC  4EB9 00001FC2            762                  JSR     EA_TO_STRING                         ; Prints out the EA
000018E2                           763                  
000018E2                           764                  ; comma
000018E2  4BF9 000025E9            765                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000018E8  4EB9 000022B4            766                  JSR     PRINTNULL                       
000018EE                           767                   
000018EE                           768                  ; register
000018EE  4BF9 000025DB            769                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018F4  4EB9 000022B4            770                  JSR     PRINTNULL 
000018FA  3401                     771                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018FC  323C 0001                772                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
00001900  4EB9 00001E2A            773                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001906  4EB9 0000216A            774                  JSR     PRINTNUM                             ; Prints the number in D1
0000190C  4E75                     775                  RTS
0000190E                           776  
0000190E                           777  *---------------AND opcode----------------------
0000190E  3200                     778  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001910  C27C F000                779                  AND.W       #$F000,D1       
00001914  B27C C000                780                  CMP.W       #$C000,D1
00001918  6600 00D0                781                  BNE         CASE_OR
0000191C                           782                  
0000191C  3200                     783                  MOVE.W      D0,D1
0000191E  E149                     784                  LSL.W       #8,D1
00001920  E049                     785                  LSR.W       #8,D1
00001922  EC49                     786                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001924  3C01                     787                  MOVE.W      D1,D6
00001926  BC7C 0003                788                  CMP.W       #3,D6
0000192A  6700 0086                789                  BEQ         INV_INSTR
0000192E                           790                  
0000192E  4BF9 00002566            791                  LEA         MSG_AND,A5                      ; print AND
00001934  4EB9 000022B4            792                  JSR         PRINTNULL
0000193A                           793                  
0000193A  3206                     794                  MOVE.W      D6,D1
0000193C  B27C 0000                795                  CMP.W       #0,D1
00001940  6700 0012                796                  BEQ         AND_BYTE
00001944  B27C 0001                797                  CMP.W       #1,D1                   ; if 1, it is a word
00001948  6700 0026                798                  BEQ         AND_WORD
0000194C  B27C 0002                799                  CMP.W       #2,D1                   ; if 2, it is a long
00001950  6700 003A                800                  BEQ         AND_LONG
00001954                           801                  
00001954  4BF9 00002610            802  AND_BYTE        LEA         MSG_B,A5
0000195A  4EB9 000022B4            803                  JSR         PRINTNULL
00001960  4BF9 00002608            804                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001966  4EB9 000022B4            805                  JSR         PRINTNULL                       ; prints out spaces
0000196C  6000 003A                806                  BRA         FINISH_AND
00001970                           807                                    
00001970  4BF9 00002613            808  AND_WORD        LEA         MSG_W,A5
00001976  4EB9 000022B4            809                  JSR         PRINTNULL
0000197C  4BF9 00002608            810                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001982  4EB9 000022B4            811                  JSR         PRINTNULL                       ; prints out spaces
00001988  6000 001E                812                  BRA         FINISH_AND
0000198C                           813    
0000198C  4BF9 00002616            814  AND_LONG        LEA         MSG_L,A5
00001992  4EB9 000022B4            815                  JSR         PRINTNULL
00001998  4BF9 00002608            816                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000199E  4EB9 000022B4            817                  JSR         PRINTNULL                       ; prints out spaces
000019A4  6000 0002                818                  BRA         FINISH_AND
000019A8                           819        
000019A8  4EB8 1528                820  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
000019AC  4EB8 15E0                821                  JSR         ADD_SUB_OPERAND
000019B0  4E75                     822                  RTS
000019B2                           823                  
000019B2  4BF9 000024A3            824  INV_INSTR       LEA         INVALID_INSTR,A5
000019B8  4EB9 000022B4            825                  JSR         PRINTNULL
000019BE  4BF9 00002601            826                  LEA         MSG_6SPACES,A5
000019C4  4EB9 000022B4            827                  JSR         PRINTNULL
000019CA  4BF9 000025E7            828                  LEA         MSG_HEX,A5
000019D0  4EB9 000022B4            829                  JSR         PRINTNULL
000019D6  2200                     830                  MOVE.L      D0,D1
000019D8  383C 0000                831                  MOVE.W      #0,D4
000019DC  4EB9 0000218E            832                  JSR         PRINTSHORTLONGNUM
000019E2  4EB9 000022B4            833                  JSR         PRINTNULL
000019E8  4E75                     834                  RTS               
000019EA                           835                  
000019EA                           836  *---------------OR opcode----------------------            
000019EA  3200                     837  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019EC  C27C F000                838                  AND.W       #$F000,D1       
000019F0  B27C 8000                839                  CMP.W       #$8000,D1
000019F4  6600 0054                840                  BNE         CASE_NOT
000019F8                           841                                                
000019F8  3200                     842                  MOVE.W      D0,D1
000019FA  E149                     843                  LSL.W       #8,D1
000019FC  E049                     844                  LSR.W       #8,D1
000019FE  EC49                     845                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001A00  B27C 0003                846                  CMP.W       #3,D1
00001A04  3C01                     847                  MOVE.W      D1,D6
00001A06  67AA                     848                  BEQ         INV_INSTR
00001A08                           849                  
00001A08                           850                  
00001A08  4BF9 0000256B            851                  LEA         MSG_OR,A5
00001A0E  4EB9 000022B4            852                  JSR         PRINTNULL                       ; print "OR"
00001A14                           853                  
00001A14  3206                     854                  MOVE.W      D6,D1
00001A16  4EB9 00001A32            855                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A1C  4BF9 00002601            856                  LEA         MSG_6SPACES,A5                  ; loads spaces
00001A22  4EB9 000022B4            857                  JSR         PRINTNULL                       ; prints out spaces
00001A28                           858  
00001A28  4EB8 1528                859                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001A2C  4EB8 15E0                860                  JSR         ADD_SUB_OPERAND                 ; print 
00001A30  4E75                     861                  RTS
00001A32                           862  
00001A32  B27C 0000                863  OR_SIZE         CMP.W       #0,D1
00001A36  6700 FB76                864                  BEQ         ADD_SUB_BYTE
00001A3A  B27C 0001                865                  CMP.W       #1,D1                   ; if 1, it is a word
00001A3E  6700 FB7C                866                  BEQ         ADD_SUB_WORD
00001A42  B27C 0002                867                  CMP.W       #2,D1                   ; if 2, it is a long
00001A46  6700 FB82                868                  BEQ         ADD_SUB_LONG
00001A4A                           869                  ; no need for rts, since ADD_SUB_ already has                
00001A4A                           870  
00001A4A                           871  *---------------NOT opcode----------------------
00001A4A  3200                     872  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A4C  C27C FF00                873                  AND.W       #$FF00,D1       
00001A50  B27C 4600                874                  CMP.W       #$4600,D1
00001A54  6600 0058                875                  BNE         CASE_LSDASDROD
00001A58                           876                 
00001A58                           877                  ; get bits 6-7 (size)
00001A58  3200                     878                  MOVE.W      D0,D1
00001A5A  E149                     879                  LSL.W       #8,D1
00001A5C  E049                     880                  LSR.W       #8,D1
00001A5E  EC49                     881                  LSR.W       #6,D1 
00001A60  3C01                     882                  MOVE.W      D1,D6                         
00001A62  BC7C 0003                883                  CMP.W       #3,D6
00001A66  6700 FF4A                884                  BEQ         INV_INSTR
00001A6A                           885                                  
00001A6A  4BF9 0000256F            886                  LEA         MSG_NOT,A5
00001A70  4EB9 000022B4            887                  JSR         PRINTNULL                       ; print "NOT"
00001A76                           888                                 
00001A76  3206                     889                  MOVE.W      D6,D1
00001A78                           890  
00001A78  4EB8 1A32                891                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A7C  4BF9 000025FB            892                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A82  4EB9 000022B4            893                  JSR         PRINTNULL                       ; prints out spaces
00001A88                           894                  
00001A88                           895                  ; get bits 0-5 
00001A88  4BF9 00002328            896                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A8E  4DF9 0000235E            897                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A94  3E3C 0000                898                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A98  4EB9 00001E54            899                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A9E  B27C 0001                900                  CMP.W       #1,D1                    ; checks if invalid
00001AA2  6700 0354                901                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001AA6  4EB9 00001FC2            902                  JSR         EA_TO_STRING             ; outputs it into a string
00001AAC                           903    
00001AAC  4E75                     904                  RTS
00001AAE                           905  
00001AAE  3200                     906  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001AB0  C27C F000                907                  AND.W       #$F000, D1                       ; gets first 4 bits
00001AB4  B27C E000                908                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001AB8  6600 0240                909                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001ABC  3400                     910                  MOVE.W      D0,D2                            ; copies D0 to D2
00001ABE  4EB9 00001EDC            911                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AC4  B47C 0003                912                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001AC8  6600 00D4                913                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001ACC                           914                  
00001ACC  3400                     915  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001ACE  4EB9 00001ECA            916                  JSR         GETROTATION                      ; gets rotation value of D2
00001AD4  B47C 0000                917                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001AD8  6700 0014                918                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001ADC  B47C 0003                919                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001AE0  6700 0016                920                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001AE4                           921                  
00001AE4  4BF9 00002574            922  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001AEA  6000 0012                923                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AEE                           924  
00001AEE  4BF9 00002578            925  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001AF4  6000 0008                926                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AF8                           927  
00001AF8  4BF9 0000257C            928  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AFE                           929                  
00001AFE  4EB9 000022B4            930  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001B04  3400                     931                  MOVE.W      D0,D2                            ; copies D0 to D2
00001B06  4EB9 00001ED4            932                  JSR         GETDIRECTION                     ; gets direction
00001B0C  B47C 0000                933                  CMP.W       #0,D2                            ; checking if its right
00001B10  6700 000C                934                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001B14                           935  
00001B14  4BF9 000025D7            936  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001B1A  6000 0008                937                  BRA         PRINT_MEMDIR                     ; branches for printing
00001B1E                           938          
00001B1E  4BF9 000025D5            939  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001B24                           940  
00001B24  4EB9 000022B4            941  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001B2A  4BF9 00002613            942                  LEA         MSG_W,A5                         ; loads .W into A5
00001B30  4EB9 000022B4            943                  JSR         PRINTNULL                        ; Prints .W
00001B36  4BF9 000025FB            944                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001B3C  4EB9 000022B4            945                  JSR         PRINTNULL                        ; prints out spaces
00001B42  6000 0002                946                  BRA         GETMEMSOURCE                     ; checks the source 
00001B46                           947                  
00001B46                           948  ; get source addressing mode       
00001B46                           949  GETMEMSOURCE                                                 
00001B46  323C 0000                950                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B4A  4EB9 00001E00            951                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B50  3801                     952                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B52  323C 0000                953                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B56  4EB9 00001E2A            954                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B5C  3A01                     955                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B5E                           956  
00001B5E  4BF9 00002356            957  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B64  3204                     958                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B66  4EB9 00001F8E            959                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B6C  B27C 0002                960                  CMP.W       #2,D1                            ; checks if it is Xn
00001B70  6700 0016                961                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B74  B27C 0001                962                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B78  6700 027E                963                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B7C                           964  
00001B7C  3404                     965  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B7E  3605                     966                  MOVE.W      D5,D3                            ; moves EA to D3
00001B80  4EB9 00001FC2            967                  JSR         EA_TO_STRING                     ; prints out the EA
00001B86  4E75                     968                  RTS                
00001B88                           969                  
00001B88                           970                  
00001B88  4BF9 00002362            971  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B8E  3205                     972                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B90  4EB9 00001F8E            973                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B96  4A41                     974                  TST.W       D1                               ; checks if it is valid
00001B98  67E2                     975                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B9A  6000 025C                976                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B9E                           977  
00001B9E                           978  
00001B9E  3602                     979  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001BA0  3200                     980                  MOVE.W      D0,D1                            ; copies D0 to D1
00001BA2  C27C 0018                981                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001BA6  E649                     982                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001BA8  B27C 0000                983                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001BAC  6700 0014                984                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001BB0  B27C 0003                985                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001BB4  6700 0016                986                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001BB8                           987                  
00001BB8  4BF9 00002574            988  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001BBE  6000 0012                989                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BC2                           990  
00001BC2  4BF9 00002578            991  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001BC8  6000 0008                992                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BCC                           993  
00001BCC  4BF9 0000257C            994  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001BD2                           995                  
00001BD2  4EB9 000022B4            996  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001BD8  3400                     997                  MOVE.W      D0,D2                            ; copies D0 to D2
00001BDA  4EB9 00001ED4            998                  JSR         GETDIRECTION                     ; gets direction
00001BE0  B47C 0000                999                  CMP.W       #0,D2                            ; checking if its right
00001BE4  6700 000C               1000                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BE8                          1001  
00001BE8  4BF9 000025D7           1002  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BEE  6000 000C               1003                  BRA         PRINT_REGDIR                     ; branches for printing
00001BF2                          1004          
00001BF2  4BF9 000025D5           1005  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BF8  6000 0002               1006                  BRA         PRINT_REGDIR                     ; branches for printing
00001BFC                          1007                  
00001BFC  4EB9 000022B4           1008  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001C02                          1009  
00001C02  3400                    1010  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001C04  4EB9 00001EDC           1011                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C0A  B47C 0001               1012                  CMP.W       #1,D2                            ; Checks if it is word size
00001C0E  6700 0014               1013                  BEQ         REG_WORD                         ; Prints .W
00001C12  B47C 0002               1014                  CMP.W       #2,D2                            ; Checks if it is long size
00001C16  6700 0016               1015                  BEQ         REG_LONG                         ; Prints .L
00001C1A                          1016  
00001C1A  4BF9 00002610           1017  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001C20  6000 0012               1018                  BRA         PRINTREGEA      
00001C24                          1019  
00001C24  4BF9 00002613           1020  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001C2A  6000 0008               1021                  BRA         PRINTREGEA      
00001C2E                          1022                             
00001C2E  4BF9 00002616           1023  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001C34                          1024  
00001C34  4EB9 000022B4           1025  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001C3A  4BF9 000025FB           1026                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001C40  4EB9 000022B4           1027                  JSR         PRINTNULL                        ; prints out spaces
00001C46  3400                    1028                  MOVE.W      D0,D2                            ; copies D0 to D2
00001C48  4EB9 00001EE4           1029                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C4E  B47C 0001               1030                  CMP.W       #$1,D2                           ; Compares D1 to 1, if it is 1, it is a data register
00001C52  6700 0060               1031                  BEQ         REG_REGISTER                     ; goes to register case if so
00001C56                          1032                                  
00001C56  3400                    1033  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C58  4EB9 00001ECA           1034                  JSR         GETROTATION                      ; gets the rotation size
00001C5E  B47C 0000               1035                  CMP.W       #0,D2                            ; checks if D2 is 0 (shift count of 8)
00001C62  6600 0006               1036                  BNE         COMPLETE_REGIM                   ; if not shigt count of 8, then branch to start printing
00001C66                          1037                  
00001C66  343C 0008               1038  MAKESHIFT8      MOVE.W      #8,D2                            ; sets shift cound to 8 (shift count of 8 is 000 in the opcode)
00001C6A                          1039                  
00001C6A  4BF9 000025E5           1040  COMPLETE_REGIM  LEA         MSG_POUND, A5                    ; loads # into A5
00001C70  4EB9 000022B4           1041                  JSR         PRINTNULL                        ; prints #
00001C76  4BF9 000025E7           1042                  LEA         MSG_HEX, A5                      ; loads $ into A5
00001C7C  4EB9 000022B4           1043                  JSR         PRINTNULL                        ; prints $
00001C82  3202                    1044                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C84  4EB9 0000217A           1045                  JSR         PRINTHEXNUM                      ; prints shift count
00001C8A  4BF9 000025E9           1046                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C90  4EB9 000022B4           1047                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C96  4BF9 000025D9           1048                  LEA         MSG_DR, A5                       ; loads D into A5
00001C9C  4EB9 000022B4           1049                  JSR         PRINTNULL                        ; prints out D 
00001CA2  323C 0000               1050                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CA6  4EB9 00001E2A           1051                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CAC  4EB9 0000216A           1052                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CB2  4E75                    1053                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CB4                          1054                  
00001CB4  3400                    1055  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001CB6  4EB9 00001EDC           1056                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001CBC  3202                    1057                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001CBE  4BF9 000025D9           1058                  LEA         MSG_DR, A5                       ; loads D into A5
00001CC4  4EB9 000022B4           1059                  JSR         PRINTNULL                        ; prints D
00001CCA  4EB9 0000216A           1060                  JSR         PRINTNUM                         ; prints register number
00001CD0  4BF9 000025E9           1061                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001CD6  4EB9 000022B4           1062                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001CDC  4BF9 000025D9           1063                  LEA         MSG_DR, A5                       ; loads D into A5
00001CE2  4EB9 000022B4           1064                  JSR         PRINTNULL                        ; prints out D 
00001CE8  323C 0000               1065                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CEC  4EB9 00001E2A           1066                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CF2  4EB9 0000216A           1067                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CF8  4E75                    1068                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CFA                          1069               
00001CFA  3200                    1070  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001CFC  C27C FF00               1071                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001D00  B27C 6000               1072                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001D04  6600 0024               1073                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001D08                          1074                  
00001D08  4BF9 000025D0           1075                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001D0E  4EB9 000022B4           1076                  JSR     PRINTNULL                            ; prints BRA
00001D14  4BF9 00002608           1077                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D1A  4EB9 000022B4           1078                  JSR     PRINTNULL                            ; prints out spaces
00001D20                          1079  
00001D20  3400                    1080                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D22  4EB9 00001E9C           1081                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D28  4E75                    1082                  RTS
00001D2A                          1083                  
00001D2A                          1084  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001D2A  3200                    1085  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D2C  C27C F000               1086                  AND.W   #$F000,D1                            ; get top 4 bits
00001D30  B27C 6000               1087                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001D34  6600 0060               1088                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001D38  3200                    1089                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D3A  C27C 0F00               1090                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001D3E  E049                    1091                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001D40                          1092                  
00001D40  B27C 000E               1093                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001D44  6700 002A               1094                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001D48                          1095                  
00001D48  B27C 000F               1096                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001D4C  6700 0018               1097                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001D50                          1098                      
00001D50  B27C 0007               1099                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001D54  6700 0006               1100                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001D58  6000 009E               1101                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001D5C                          1102     
00001D5C  4BF9 0000258A           1103  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D62  6000 0016               1104                  BRA     PRINTBCC
00001D66                          1105  
00001D66  4BF9 000025A3           1106  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D6C  6000 000C               1107                  BRA     PRINTBCC
00001D70                          1108                  
00001D70  4BF9 00002599           1109  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D76  6000 0002               1110                  BRA     PRINTBCC
00001D7A                          1111  
00001D7A  4EB9 000022B4           1112  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D80  4BF9 00002608           1113                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D86  4EB9 000022B4           1114                  JSR     PRINTNULL                            ; prints out spaces
00001D8C  3400                    1115                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D8E  4EB9 00001E9C           1116                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D94  4E75                    1117                  RTS              
00001D96                          1118                  
00001D96                          1119  
00001D96  3200                    1120  CASE_JSR        MOVE.W  D0,D1                                ; check if JSR mandatory bits exist
00001D98  C27C FFC0               1121                  AND.W   #$FFC0,D1
00001D9C  B27C 4E80               1122                  CMP.W   #$4E80,D1
00001DA0  6600 0040               1123                  BNE     CASE_RTS
00001DA4                          1124                  
00001DA4  1E3C 0000               1125                  MOVE.B  #0,D7
00001DA8  4BF9 0000235B           1126                  LEA     VALIDEA_JSR,A5                       ; loads string of valid addresses
00001DAE  4DF9 00002362           1127                  LEA     VALIDXN_SHORTLONG,A6                 ; loads string of valid addresses
00001DB4  4EB9 00001E54           1128                  JSR     CHECKGET_EAXN                        ; checks if has valid effective address
00001DBA  B27C 0001               1129                  CMP     #1,D1
00001DBE  6700 0038               1130                  BEQ     CASE_DATA                            ; goes to case data if EA is invalid
00001DC2                          1131                  
00001DC2                          1132  PRINT_JSR       ;print JSR
00001DC2  4BF9 000025C6           1133                  LEA     MSG_JSR,A5
00001DC8  4EB9 000022B4           1134                  JSR     PRINTNULL
00001DCE                          1135                  
00001DCE                          1136                  ;print spaces
00001DCE  4BF9 00002608           1137                  LEA     MSG_7SPACES,A5
00001DD4  4EB9 000022B4           1138                  JSR     PRINTNULL
00001DDA                          1139                                  
00001DDA                          1140                  ;print address
00001DDA  4EB9 00001FC2           1141                  JSR     EA_TO_STRING
00001DE0  4E75                    1142                  RTS     
00001DE2                          1143  
00001DE2  B07C 4E75               1144  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001DE6  6600 0010               1145                  BNE     CASE_DATA           ; checks the next case if not equal
00001DEA  4BF9 000025CB           1146                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001DF0  4EB9 000022B4           1147                  JSR     PRINTNULL           ; prints RTS                
00001DF6  4E75                    1148                  RTS                         ; returns from the subroutine
00001DF8                          1149  
00001DF8  4EB8 19B2               1150  CASE_DATA       JSR INV_INSTR  
00001DFC  4E75                    1151                  RTS               
00001DFE                          1152  
00001DFE  4E75                    1153  CASE_EPICFAIL   RTS
00001E00                          1154  
00001E00                          1155  
00001E00                          1156  * Finds the EA type
00001E00                          1157  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001E00                          1158  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001E00  48E7 3000               1159  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001E04  4A41                    1160                      TST.W     D1                    ; compares D1 to 0
00001E06  6700 000E               1161                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001E0A                          1162                      
00001E0A  343C 01C0               1163  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001E0E  363C 0006               1164                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001E12  6000 000A               1165                      BRA       FINDTYPEEA            
00001E16                          1166  
00001E16  343C 0038               1167  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001E1A  363C 0003               1168                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001E1E                          1169  
00001E1E                          1170  
00001E1E  3200                    1171  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001E20  C242                    1172                      AND.W     D2,D1                 ; applies bitmask to D1
00001E22  E669                    1173                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E24  4CDF 000C               1174                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E28  4E75                    1175                      RTS                             ; returns from subroutine    
00001E2A                          1176                      
00001E2A                          1177  * Finds Xn type
00001E2A                          1178  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001E2A                          1179  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001E2A  48E7 3000               1180  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001E2E  4A41                    1181                      TST.W     D1                    ; compares D1 to 0
00001E30  6700 000E               1182                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001E34                          1183  
00001E34  343C 0E00               1184  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001E38  363C 0009               1185                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001E3C  6000 000A               1186                      BRA       FINDTYPEXN            ; finds the type of Xn
00001E40                          1187  
00001E40  343C 0007               1188  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001E44  363C 0000               1189                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001E48                          1190                      
00001E48  3200                    1191  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001E4A  C242                    1192                      AND.W     D2,D1                 ; applies bitmask to D1
00001E4C  E669                    1193                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E4E  4CDF 000C               1194                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E52  4E75                    1195                      RTS                             ; returns from subroutine 
00001E54                          1196                      
00001E54                          1197  * Checks and gets the EA and Xn
00001E54                          1198  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001E54                          1199  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001E54  3207                    1200  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001E56  4EB8 1E00               1201                  JSR     GET_EA                  ; Gets EA
00001E5A  3401                    1202                  MOVE.W  D1,D2                   ; Stores EA in D2
00001E5C  3207                    1203                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001E5E  4EB8 1E2A               1204                  JSR     GET_XN                  ; Gets Xn
00001E62  3601                    1205                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001E64  3202                    1206                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001E66                          1207                  
00001E66  4EB9 00001F8E           1208                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001E6C  B27C 0002               1209                  CMP.W   #2,D1                   ; checks if it is Xn
00001E70  6700 0012               1210                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001E74  B27C 0001               1211                  CMP.W   #1,D1                   ; Checks if it is invalid
00001E78  6700 001C               1212                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001E7C                          1213                  
00001E7C                          1214                  
00001E7C  323C 0000               1215  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001E80  6000 0018               1216                  BRA     END_CHECKGET
00001E84                          1217        
00001E84                          1218  ; need XN
00001E84  2A4E                    1219  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001E86  3203                    1220                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001E88  4EB9 00001F8E           1221                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001E8E  4A41                    1222                  TST.W   D1                      ; checks if it is valid
00001E90  67EA                    1223                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001E92  6000 0002               1224                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001E96                          1225   
00001E96  323C 0001               1226  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001E9A                          1227  
00001E9A  4E75                    1228  END_CHECKGET    RTS          
00001E9C                          1229                                            
00001E9C                          1230                                            
00001E9C                          1231  * Gets the displacement and pritns it 
00001E9C                          1232  * Inputs: D2 = instruction word, A2 = address of next word
00001E9C                          1233  * Outputs: prints out displacement
00001E9C  48E7 4004               1234  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001EA0  3A4A                    1235                      MOVE.W    A2,A5                 ; copies A2 to A5
00001EA2  C47C 00FF               1236                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001EA6  6600 0004               1237                      BNE       PRINTADDRESS          ; prints address if not 0
00001EAA  341A                    1238                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001EAC                          1239                      
00001EAC  D44D                    1240  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001EAE  3202                    1241                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001EB0  183C 0000               1242                      MOVE.B    #0,D4                 ; marks address as word length
00001EB4  4BF9 000025E7           1243                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001EBA  4EB9 000022B4           1244                      JSR       PRINTNULL             ; prints null
00001EC0  4EB9 0000218E           1245                      JSR       PRINTSHORTLONGNUM     ; prints address
00001EC6                          1246                      
00001EC6  4CDF 2002               1247                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001ECA                          1248                      
00001ECA                          1249                     
00001ECA                          1250  * Gets the rotation value for ASd and LSd
00001ECA                          1251  * Input: D2 = instruction word copy (of D0)                                    
00001ECA                          1252  * Output: rotation  value in D2             
00001ECA  C47C 0E00               1253  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001ECE  E04A                    1254                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001ED0  E24A                    1255                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001ED2  4E75                    1256                      RTS                             ; return from subroutine
00001ED4                          1257  
00001ED4                          1258  * Gets the direction value for ASd and LSd
00001ED4                          1259  * Input: D2 = instruction word copy (of D0)                                    
00001ED4                          1260  * Output: direction value in D2             
00001ED4  C47C 0100               1261  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001ED8  E04A                    1262                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001EDA  4E75                    1263                      RTS                             ; return from subroutine
00001EDC                          1264  
00001EDC                          1265  * Gets the rotation size value for ASd and LSd
00001EDC                          1266  * Input: D2 = instruction word copy (of D0)                                    
00001EDC                          1267  * Output: rotation size value in D2             
00001EDC  C47C 00C0               1268  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001EE0  EC4A                    1269                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001EE2  4E75                    1270                      RTS                             ; return from subroutine
00001EE4                          1271  
00001EE4                          1272  * Gets the rotation location  value for ASd and LSd
00001EE4                          1273  * Input: D2 = instruction word copy (of D0)                                    
00001EE4                          1274  * Output: rotation location value in D2             
00001EE4  C47C 0020               1275  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001EE8  EA4A                    1276                      LSR.W      #5,D2                ; shifts 5 bits to the right to only have the rotation bits
00001EEA  4E75                    1277                      RTS                             ; return from subroutine
00001EEC                          1278  
00001EEC                          1279  * Prints out registers for MOVEM
00001EEC                          1280  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001EEC                          1281  * Output: printed out registers
00001EEC                          1282  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001EEC  48E7 4706               1283  PRINTREGISTERS      MOVEM.L    D1/D5-D7/A5-A6,-(SP) ; saves D1/D5-D7/A5-A6
00001EF0  3A3C 0000               1284                      MOVE.W     #0,D5                ; sets counter to 0
00001EF4  3E1A                    1285                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001EF6  B83C 0001               1286                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EFA  6600 0010               1287                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001EFE                          1288  
00001EFE  3C3C 0000               1289  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001F02  4BF9 000025D9           1290                      LEA        MSG_DR,A5            ; loads D to A5
00001F08  6000 000C               1291                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001F0C                          1292                      
00001F0C  3C3C 0007               1293  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001F10  4BF9 000025DB           1294                      LEA        MSG_AR,A5            ; loads A to A5
00001F16                          1295                      
00001F16  E34F                    1296  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001F18  6500 0018               1297                      BCS        PRINTREG             ; if pushes out a 1
00001F1C  DC44                    1298                      ADD.W      D4,D6                ; decrements or increments
00001F1E  5245                    1299                      ADD.W      #1,D5                ; increments D5
00001F20  BA7C 0008               1300                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F24  66F0                    1301                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F26  B83C 0001               1302                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F2A  6600 0052               1303                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F2E  6000 0042               1304                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001F32                          1305                      
00001F32  4EB9 000022B4           1306  PRINTREG            JSR        PRINTNULL
00001F38  3206                    1307                      MOVE.W     D6,D1
00001F3A  4EB9 0000216A           1308                      JSR        PRINTNUM 
00001F40                          1309    
00001F40  BE7C 0000               1310  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001F44  6600 0006               1311                      BNE        PRINTMORE            ; continue if there is more
00001F48  6000 0040               1312                      BRA        DONEPRINTINGREG      ; exit case
00001F4C                          1313  
00001F4C  2C4D                    1314  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001F4E  4BF9 000025EC           1315                      LEA        MSG_SLASH,A5         ; leads / into A5
00001F54  4EB9 000022B4           1316                      JSR        PRINTNULL            ; prints the slash
00001F5A  2A4E                    1317                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001F5C  DC44                    1318                      ADD.W      D4,D6                ; decrements or increments
00001F5E  5245                    1319                      ADD.W      #1,D5                ; increments D5
00001F60  BA7C 0008               1320                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F64  66B0                    1321                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F66  B83C 0001               1322                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F6A  6600 0012               1323                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F6E  6000 0002               1324                      BRA        REGTOMEM2            ; loops
00001F72                          1325  
00001F72  3C3C 0000               1326  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001F76  4BF9 000025DB           1327                      LEA        MSG_AR,A5            ; loads A to A5
00001F7C  6098                    1328                      BRA        PRINTREGISTERLOOP    ; loops
00001F7E                          1329  
00001F7E  3C3C 0007               1330  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001F82  4BF9 000025D9           1331                      LEA        MSG_DR,A5            ; loads D to A5
00001F88  608C                    1332                      BRA        PRINTREGISTERLOOP    ; loops
00001F8A                          1333  
00001F8A  4CDF 60E2               1334  DONEPRINTINGREG     MOVEM.L    (SP)+,D1/D5-D7/A5-A6 ; saves D1/D5-D7/A5-A6
00001F8E                          1335  
00001F8E                          1336                          
00001F8E                          1337  * Checks if EA or Xn is valid
00001F8E                          1338  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001F8E                          1339  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001F8E  2F02                    1340  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001F90                          1341  
00001F90  141D                    1342  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001F92  B43C 00FF               1343                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001F96  6700 000A               1344                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001F9A  B202                    1345                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001F9C  6700 000C               1346                     BEQ        VALIDEA               ; branches to valid EA
00001FA0  60EE                    1347                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001FA2                          1348                     
00001FA2  323C 0001               1349  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001FA6  6000 0016               1350                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001FAA                          1351                    
00001FAA  B43C 0007               1352  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001FAE  6700 000A               1353                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001FB2  323C 0000               1354                     MOVE.W     #$0,D1                ; marks that it is valid
00001FB6  6000 0006               1355                     BRA        CHECKEAEXIT           ; exits the subroutine
00001FBA                          1356  
00001FBA  323C 0002               1357  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001FBE                          1358  
00001FBE  241F                    1359  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001FC0  4E75                    1360                     RTS                              ; returns from subroutine
00001FC2                          1361  
00001FC2                          1362  * Converts EA and Xn into a string                                
00001FC2                          1363  * Inputs: D1 = operation size, D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001FC2                          1364  * Outputs: Prints out EA and Xn into a string
00001FC2  48E7 C004               1365  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001FC6  B47C 0001               1366                     CMP.W    #An,D2                  ; checks if it is An
00001FCA  6700 003A               1367                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001FCE                          1368                     
00001FCE  B47C 0002               1369                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001FD2  6700 004A               1370                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001FD6                          1371                     
00001FD6  B47C 0003               1372                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001FDA  6700 0072               1373                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001FDE                          1374                     
00001FDE  B47C 0004               1375                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001FE2  6700 00A6               1376                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001FE6                          1377                     
00001FE6  B47C 0007               1378                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001FEA  6700 00DA               1379                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001FEE                          1380                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001FEE                          1381  
00001FEE                          1382  * data register, Dn
00001FEE  4BF9 000025D9           1383  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001FF4  4EB9 000022B4           1384                     JSR      PRINTNULL               ; Prints D
00001FFA  3203                    1385                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FFC  4EB9 0000216A           1386                     JSR      PRINTNUM                ; Prints the Xn
00002002  6000 0160               1387                     BRA      EA_TO_STRING_EXIT       ; exits           
00002006                          1388  
00002006                          1389  
00002006                          1390  * address register
00002006  4BF9 000025DB           1391  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
0000200C  4EB9 000022B4           1392                     JSR      PRINTNULL               ; Prints A
00002012  3203                    1393                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002014  4EB9 0000216A           1394                     JSR      PRINTNUM                ; Prints the Xn
0000201A  6000 0148               1395                     BRA      EA_TO_STRING_EXIT       ; exits
0000201E                          1396  
0000201E                          1397  * address register indirect
0000201E  4BF9 000025DD           1398  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00002024  4EB9 000022B4           1399                     JSR      PRINTNULL               ; Prints (
0000202A  4BF9 000025DB           1400                     LEA      MSG_AR,A5               ; Loads A into A5
00002030  4EB9 000022B4           1401                     JSR      PRINTNULL               ; Prints A
00002036  3203                    1402                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002038  4EB9 0000216A           1403                     JSR      PRINTNUM                ; Prints the Xn
0000203E  4BF9 000025DF           1404                     LEA      MSG_RB,A5               ; Loads ) into A5
00002044  4EB9 000022B4           1405                     JSR      PRINTNULL               ; Prints )
0000204A  6000 0118               1406                     BRA      EA_TO_STRING_EXIT       ; exits
0000204E                          1407  
0000204E                          1408  * address register indirect post increment
0000204E  4BF9 000025DD           1409  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00002054  4EB9 000022B4           1410                     JSR      PRINTNULL               ; Prints (
0000205A  4BF9 000025DB           1411                     LEA      MSG_AR,A5               ; Loads A into A5
00002060  4EB9 000022B4           1412                     JSR      PRINTNULL               ; Prints A
00002066  3203                    1413                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002068  4EB9 0000216A           1414                     JSR      PRINTNUM                ; Prints the Xn
0000206E  4BF9 000025DF           1415                     LEA      MSG_RB,A5               ; Loads ) into A5
00002074  4EB9 000022B4           1416                     JSR      PRINTNULL               ; Prints )
0000207A  4BF9 000025E1           1417                     LEA      MSG_PLUS,A5             ; Loads + into A5
00002080  4EB9 000022B4           1418                     JSR      PRINTNULL               ; Prints +
00002086  6000 00DC               1419                     BRA      EA_TO_STRING_EXIT       ; exits
0000208A                          1420  
0000208A                          1421  
0000208A                          1422  * address register indirect pre increment
0000208A  4BF9 000025E3           1423  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00002090  4EB9 000022B4           1424                     JSR      PRINTNULL               ; Prints -
00002096  4BF9 000025DD           1425                     LEA      MSG_LB,A5               ; Loads ( into A5
0000209C  4EB9 000022B4           1426                     JSR      PRINTNULL               ; Prints (
000020A2  4BF9 000025DB           1427                     LEA      MSG_AR,A5               ; Loads A into A5
000020A8  4EB9 000022B4           1428                     JSR      PRINTNULL               ; Prints A
000020AE  3203                    1429                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000020B0  4EB9 0000216A           1430                     JSR      PRINTNUM                ; Prints the Xn
000020B6  4BF9 000025DF           1431                     LEA      MSG_RB,A5               ; Loads ) into A5
000020BC  4EB9 000022B4           1432                     JSR      PRINTNULL               ; Prints )
000020C2  6000 00A0               1433                     BRA      EA_TO_STRING_EXIT       ; exits
000020C6                          1434  
000020C6                          1435  * other (long, short, immediate) with Xn yes
000020C6  301A                    1436  CASE_OTHER         MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000020C8  B67C 0000               1437                     CMP.W    #ABSShort,D3            ; checks if it is a word
000020CC  6700 0054               1438                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000020D0                          1439                     
000020D0  B67C 0001               1440                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000020D4  6700 0068               1441                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000020D8                          1442  
000020D8                          1443  * immediate
000020D8  4BF9 000025E5           1444  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000020DE  4EB9 000022B4           1445                     JSR      PRINTNULL               ; Prints #  
000020E4  4BF9 000025E7           1446                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020EA  4EB9 000022B4           1447                     JSR      PRINTNULL               ; Prints $
000020F0                          1448                     
000020F0  B27C 0002               1449                     CMP.W    #2,D1                   ; checks if it is long size
000020F4  6700 000E               1450                     BEQ      IMMEDIATE_LONG          ; branches if it is a long
000020F8                          1451                     
000020F8  3200                    1452                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020FA  4EB9 0000217A           1453                     JSR      PRINTHEXNUM 
00002100  6000 0062               1454                     BRA      EA_TO_STRING_EXIT       ; exits subroutine  
00002104                          1455  
00002104  3200                    1456  IMMEDIATE_LONG     MOVE.W   D0, D1                  ; moves instruction word into d1
00002106  383C 0000               1457                     MOVE.W   #0, D4                  ; moves word size into d4
0000210A  4EB9 0000218E           1458                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002110  301A                    1459                     MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002112  3200                    1460                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002114  383C 0000               1461                     MOVE.W   #0, D4                  ; moves word size into d4
00002118  4EB9 0000218E           1462                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000211E                          1463                     *MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
0000211E  6000 0044               1464                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00002122                          1465                     
00002122                          1466  * word address
00002122                          1467  CASE_WORD          
00002122  4BF9 000025E7           1468                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002128  4EB9 000022B4           1469                     JSR      PRINTNULL               ; Prints $
0000212E  3200                    1470                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002130  383C 0000               1471                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00002134  4EB9 0000218E           1472                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000213A  6000 0028               1473                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000213E                          1474  
0000213E                          1475  * long address 
0000213E                          1476  CASE_LONG          
0000213E  4BF9 000025E7           1477                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002144  4EB9 000022B4           1478                     JSR      PRINTNULL               ; Prints $
0000214A  3200                    1479                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000214C  383C 0000               1480                     MOVE.W   #0, D4                  ; moves word size into d4
00002150  4EB9 0000218E           1481                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002156  301A                    1482                     MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002158  3200                    1483                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000215A  383C 0000               1484                     MOVE.W   #0, D4                  ; moves word size into d4
0000215E  4EB9 0000218E           1485                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002164                          1486                     *MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002164                          1487                     
00002164                          1488  * exits subroutine
00002164  4CDF 2003               1489  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00002168  4E75                    1490                      RTS                              ; returns from subroutine
0000216A                          1491  
0000216A                          1492  * Prints out the content of D1 as a decimal number
0000216A                          1493  * Input: number in D1 to be printed
0000216A                          1494  * Output: contents of D1 printed
0000216A  48E7 C000               1495  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000216E  103C 0003               1496                   MOVE.B      #3,D0               ; prints D1
00002172  4E4F                    1497                   TRAP        #15                 ; is trap task 3
00002174                          1498              
00002174  4CDF 0003               1499                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00002178  4E75                    1500                   RTS                             ; returns from subroutine
0000217A                          1501                   
0000217A                          1502  * Prints out the content of D1 as a hex number
0000217A                          1503  * Input: number in D1 to be printed
0000217A                          1504  * Output: contents of D1 printed
0000217A  48E7 C000               1505  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000217E  143C 0010               1506                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002182  103C 000F               1507                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002186  4E4F                    1508                   TRAP        #15                 ; is trap task 15
00002188  4CDF 0003               1509                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000218C  4E75                    1510                   RTS                             ; returns from subroutine
0000218E                          1511                   
0000218E                          1512  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
0000218E                          1513  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
0000218E                          1514  * Output: contents of D1 printed
0000218E  48E7 E000               1515  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00002192  B83C 0001               1516                            CMP.B       #1,D4               ; checks size of number
00002196  6700 0042               1517                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
0000219A                          1518  
0000219A  3401                    1519  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
0000219C  C47C F000               1520                            AND.W       #$F000,D2           ; gets the first digit
000021A0  B47C 0000               1521                            CMP.W       #0, D2              ; checks if it is 0
000021A4  6600 00DC               1522                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021A8  4EB9 00002292           1523                            JSR         PRINTZERO           ; prints a zero
000021AE                          1524                            
000021AE  3401                    1525                            MOVE.W      D1,D2               ; copies number to D2
000021B0  C47C 0F00               1526                            AND.W       #$0F00,D2           ; gets the second digit
000021B4  B47C 0000               1527                            CMP.W       #0, D2              ; checks if it is 0
000021B8  6600 00C8               1528                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021BC  4EB9 00002292           1529                            JSR         PRINTZERO           ; prints a zero
000021C2                          1530                            
000021C2  3401                    1531                            MOVE.W      D1,D2               ; copies number to D2
000021C4  C47C 00F0               1532                            AND.W       #$00F0,D2           ; gets the third digit
000021C8  B47C 0000               1533                            CMP.W       #0, D2              ; checks if it is 0
000021CC  6600 00B4               1534                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021D0  4EB9 00002292           1535                            JSR         PRINTZERO           ; prints a zero
000021D6  6000 00AA               1536                            BRA         PRINTASHEX          ; prints last digit
000021DA                          1537                            
000021DA  2401                    1538  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
000021DC  C4BC F0000000           1539                            AND.L       #$F0000000,D2       ; gets the first digit
000021E2  B4BC 00000000           1540                            CMP.L       #0, D2              ; checks if it is 0
000021E8  6600 0098               1541                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021EC  4EB9 00002292           1542                            JSR         PRINTZERO           ; prints a zero
000021F2                          1543                            
000021F2  2401                    1544                            MOVE.L      D1,D2               ; copies number to D2
000021F4  C4BC 0F000000           1545                            AND.L       #$0F000000,D2       ; gets the second digit
000021FA  B4BC 00000000           1546                            CMP.L       #0, D2              ; checks if it is 0
00002200  6600 0080               1547                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002204  4EB9 00002292           1548                            JSR         PRINTZERO           ; prints a zero
0000220A                          1549                            
0000220A  2401                    1550                            MOVE.L      D1,D2               ; copies number to D2
0000220C  C4BC 00F00000           1551                            AND.L       #$00F00000,D2       ; gets the third digit
00002212  B4BC 00000000           1552                            CMP.L       #0, D2              ; checks if it is 0
00002218  6600 0068               1553                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000221C  4EB9 00002292           1554                            JSR         PRINTZERO           ; prints a zero
00002222                          1555                            
00002222  2401                    1556                            MOVE.L      D1,D2               ; copies number to D2
00002224  C4BC 000F0000           1557                            AND.L       #$000F0000,D2       ; gets the fourth digit
0000222A  B4BC 00000000           1558                            CMP.L       #0, D2              ; checks if it is 0
00002230  6600 0050               1559                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002234  4EB9 00002292           1560                            JSR         PRINTZERO           ; prints a zero
0000223A                          1561                            
0000223A  2401                    1562                            MOVE.L      D1,D2               ; copies number to D2
0000223C  C4BC 0000F000           1563                            AND.L       #$0000F000,D2       ; gets the fith digit
00002242  B4BC 00000000           1564                            CMP.L       #0, D2              ; checks if it is 0
00002248  6600 0038               1565                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000224C  4EB9 00002292           1566                            JSR         PRINTZERO           ; prints a zero
00002252                          1567                            
00002252  2401                    1568                            MOVE.L      D1,D2               ; copies number to D2
00002254  C4BC 00000F00           1569                            AND.L       #$00000F00,D2       ; gets the sixth digit
0000225A  B4BC 00000000           1570                            CMP.L       #0, D2              ; checks if it is 0
00002260  6600 0020               1571                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002264  4EB9 00002292           1572                            JSR         PRINTZERO           ; prints a zero
0000226A                          1573                            
0000226A  2401                    1574                            MOVE.L      D1,D2               ; copies number to D2
0000226C  C4BC 000000F0           1575                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002272  B4BC 00000000           1576                            CMP.L       #0, D2              ; checks if it is 0
00002278  6600 0008               1577                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000227C  4EB9 00002292           1578                            JSR         PRINTZERO           ; prints a zero
00002282                          1579  
00002282  143C 0010               1580  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002286  103C 000F               1581                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000228A  4E4F                    1582                            TRAP        #15                 ; is trap task 15
0000228C  4CDF 0007               1583                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002290  4E75                    1584                            RTS                             ; returns from subroutine    
00002292                          1585  * Prints a zero
00002292                          1586  * Input: nothing
00002292                          1587  * Output: 0 printed out to the console
00002292  2F01                    1588  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002294  7200                    1589                            MOVE.L      #0,D1               ; moves 0 to D1
00002296  4EB8 216A               1590                            JSR         PRINTNUM            ; prints the number
0000229A  221F                    1591                            MOVE.L      (SP)+,D1            ; restores D1
0000229C  4E75                    1592                            RTS                             ; returns from subroutine
0000229E                          1593              
0000229E                          1594  * Prints contents of things between a range
0000229E                          1595  * input: A5, A6 (the range)
0000229E                          1596  * output: prints memory contents from A5 to A6 as strings   
0000229E  48E7 C040               1597  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
000022A2  224D                    1598                  MOVEA.L     A5, A1           ; loads A5 into A1
000022A4  9DCD                    1599                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
000022A6  320E                    1600                  MOVE.W      A6, D1           ; move n into D1
000022A8  103C 0001               1601                  MOVE.B      #1, D0           ; display n characters of string at A1
000022AC  4E4F                    1602                  TRAP        #15              ; is trap task 1
000022AE  4CDF 0203               1603                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
000022B2  4E75                    1604                  RTS                          ; returns
000022B4                          1605      
000022B4                          1606  * Prints null terminated string
000022B4                          1607  * input: string pointed to by A5
000022B4                          1608  * output: prints out the null terminated string
000022B4  48E7 8040               1609  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
000022B8  224D                    1610                  MOVE.L      A5,A1           ; loads A5 into A1
000022BA  103C 000E               1611                  MOVE.B      #14,D0          ; prints null terminated string
000022BE  4E4F                    1612                  TRAP        #15             ; is trap task 10
000022C0  4CDF 0201               1613                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
000022C4  4E75                    1614                  RTS                         ; returns from subroutine
000022C6                          1615                  
000022C6  2F0D                    1616  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
000022C8  4BF9 00002518           1617                  LEA         NEW_LINE,A5     ; Prints null
000022CE  4EB8 22B4               1618                  JSR         PRINTNULL       ; prints the new line
000022D2  2A5F                    1619                  MOVE.L      (SP)+,A5        ; returns A5
000022D4  4E75                    1620                  RTS
000022D6                          1621  
000022D6                          1622  * Prints the size of the MOVE or MOVEA operation  
000022D6                          1623  * input: D0
000022D6                          1624  * output: prints out the size of a MOVE or MOVEA operation        
000022D6  48E7 0004               1625  PRINTMOVESIZE   MOVEM.L A5,-(SP)         ; saves D0 and A5
000022DA  3200                    1626                  MOVE.W  D0,D1               ; stores d0 in d1
000022DC  C27C 3000               1627                  AND.W   #$3000,D1           ; gets the size
000022E0  B27C 2000               1628                  CMP.W   #$2000,D1           ; checks if is long
000022E4  6700 001E               1629                  BEQ     MOVE_LONG
000022E8  B27C 3000               1630                  CMP.W   #$3000,D1           ; checks if is word
000022EC  6700 000C               1631                  BEQ     MOVE_WORD      
000022F0                          1632                  
000022F0  4BF9 00002610           1633  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000022F6  6000 0012               1634                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000022FA                          1635  
000022FA  4BF9 00002613           1636  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00002300  6000 0008               1637                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002304                          1638  
00002304  4BF9 00002616           1639  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
0000230A                          1640                  
0000230A  4EB8 22B4               1641  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
0000230E  E049                    1642                  LSR.W   #8,D1               ; shifts bytes 8 to the right
00002310  E849                    1643                  LSR.W   #4,D1               ; shifts bytes 4 to the right
00002312  4CDF 2000               1644                  MOVEM.L (SP)+,A5            ; restores D0 and A5
00002316  4E75                    1645                  RTS
00002318                          1646  
00002318  43F9 00002487           1647  ERROR           LEA     ERROR_MSG,A1
0000231E  103C 000E               1648                  MOVE.B  #14,D0
00002322  4E4F                    1649                  TRAP    #15 
00002324                          1650            
00002324  FFFF FFFF               1651      SIMHALT             ; halt simulator
00002328                          1652  
00002328                          1653  * Put variables and constants here
00002328                          1654  
00002328  =0000000D               1655  CR                              EQU     $0D
00002328  =0000000A               1656  LF                              EQU     $0A 
00002328  =00000009               1657  TAB                             EQU     $09  
00002328                          1658  
00002328                          1659  * Addressing Modes
00002328  =00000000               1660  Dn                              EQU     0
00002328  =00000001               1661  An                              EQU     1
00002328  =00000002               1662  AnIndirect                      EQU     2
00002328  =00000003               1663  AnPost                          EQU     3
00002328  =00000004               1664  AnPre                           EQU     4
00002328  =00000007               1665  Other                           EQU     7           ; short, long, immediate
00002328                          1666  
00002328                          1667  * Xn
00002328  =00000000               1668  ABSShort                        EQU     0
00002328  =00000001               1669  ABSLong                         EQU     1
00002328  =00000004               1670  XnImmediate                     EQU     4
00002328                          1671  
00002328                          1672  * Valid Addressing Modes
00002328= 00 01 02 03 04 07 FF    1673  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
0000232F                          1674  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
0000232F= 00 02 03 04 07 FF       1675  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002335= 02 04 07 FF             1676  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002339= 02 03 07 FF             1677  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000233D= 02 03 04 07 FF          1678  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002342= 00 02 03 04 07 FF       1679  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002348= 01 07 FF                1680  VALIDEA_LEA                     DC.B    An,Other,-1
0000234B= 00 02 03 04 07 FF       1681  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002351= 02 03 04 07 FF          1682  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002356= 02 03 04 07 FF          1683  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
0000235B= 02 07 FF                1684  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
0000235E                          1685  
0000235E                          1686  * Valid Xn
0000235E= 00 01 04 FF             1687  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00002362                          1688  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00002362= 00 01 FF                1689  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00002365                          1690  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00002365                          1691  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00002365                          1692  
00002365                          1693  * posible memory ASd/LSd rotation values
00002365  =00000000               1694  ASd_MEM                         EQU     0   
00002365  =00000001               1695  LSd_MEM                         EQU     1 
00002365  =00000003               1696  ROd_MEM                         EQU     3
00002365                          1697   
00002365  =00000000               1698  ASd_REG                         EQU     0   
00002365  =00000001               1699  LSd_REG                         EQU     1 
00002365  =00000003               1700  ROd_REG                         EQU     3
00002365                          1701  
00002365                          1702  * Messages
00002365= 57 65 6C 63 6F 6D ...   1703  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
0000238D= 46 6F 72 6D 61 74 ...   1704  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
000023D8= 4C 65 74 74 65 72 ...   1705  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000023F8= 50 6C 65 61 73 65 ...   1706  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
0000242F= 50 6C 65 61 73 65 ...   1707  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00002465= 49 6E 76 61 6C 69 ...   1708  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002487= 45 72 72 6F 72 20 ...   1709  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
000024A3= 09 44 41 54 41 00       1710  INVALID_INSTR                   DC.B    TAB,'DATA',0
000024A9= 46 69 6E 69 73 68 ...   1711  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
000024ED= 0D 0A 50 72 65 73 ...   1712  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
00002518= 0D 0A 00                1713  NEW_LINE                        DC.B    CR,LF,0
0000251B= 09 09 09 00             1714  THREE_TAB                       DC.B    TAB,TAB,TAB,0
0000251F                          1715  
0000251F                          1716  * Opcode Messages
0000251F= 09 4E 4F 50 00          1717  MSG_NOP                         DC.B    TAB,'NOP',0
00002524= 09 4D 4F 56 45 00       1718  MSG_MOVE                        DC.B    TAB,'MOVE',0  
0000252A= 09 4D 4F 56 45 41 00    1719  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00002531= 09 4D 4F 56 45 51 00    1720  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00002538= 09 4D 4F 56 45 4D 00    1721  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
0000253F= 09 41 44 44 00          1722  MSG_ADD                         DC.B    TAB,'ADD',0
00002544= 09 41 44 44 41 00       1723  MSG_ADDA                        DC.B    TAB,'ADDA',0
0000254A= 09 41 44 44 51 00       1724  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00002550= 09 53 55 42 00          1725  MSG_SUB                         DC.B    TAB,'SUB',0
00002555= 09 4D 55 4C 53 00       1726  MSG_MULS                        DC.B    TAB,'MULS',0
0000255B= 09 44 49 56 55 00       1727  MSG_DIVU                        DC.B    TAB,'DIVU',0
00002561= 09 4C 45 41 00          1728  MSG_LEA                         DC.B    TAB,'LEA',0
00002566= 09 41 4E 44 00          1729  MSG_AND                         DC.B    TAB,'AND',0
0000256B= 09 4F 52 00             1730  MSG_OR                          DC.B    TAB,'OR',0
0000256F= 09 4E 4F 54 00          1731  MSG_NOT                         DC.B    TAB,'NOT',0
00002574= 09 4C 53 00             1732  MSG_LSd                         DC.B    TAB,'LS',0
00002578= 09 41 53 00             1733  MSG_ASd                         DC.B    TAB,'AS',0
0000257C= 09 52 4F 00             1734  MSG_ROd                         DC.B    TAB,'RO',0
00002580= 09 42 43 43 00          1735  MSG_BCC                         DC.B    TAB,'BCC',0
00002585= 09 42 43 53 00          1736  MSG_BCS                         DC.B    TAB,'BCS',0
0000258A= 09 42 45 51 00          1737  MSG_BEQ                         DC.B    TAB,'BEQ',0
0000258F= 09 42 4E 45 00          1738  MSG_BNE                         DC.B    TAB,'BNE',0
00002594= 09 42 47 45 00          1739  MSG_BGE                         DC.B    TAB,'BGE',0
00002599= 09 42 47 54 00          1740  MSG_BGT                         DC.B    TAB,'BGT',0
0000259E= 09 42 48 49 00          1741  MSG_BHI                         DC.B    TAB,'BHI',0
000025A3= 09 42 4C 45 00          1742  MSG_BLE                         DC.B    TAB,'BLE',0
000025A8= 09 42 4C 53 00          1743  MSG_BLS                         DC.B    TAB,'BLS',0
000025AD= 09 42 4C 54 00          1744  MSG_BLT                         DC.B    TAB,'BLT',0
000025B2= 09 42 4D 49 00          1745  MSG_BMI                         DC.B    TAB,'BMI',0
000025B7= 09 42 50 4C 00          1746  MSG_BPL                         DC.B    TAB,'BPL',0
000025BC= 09 42 56 43 00          1747  MSG_BVC                         DC.B    TAB,'BVC',0
000025C1= 09 42 56 53 00          1748  MSG_BVS                         DC.B    TAB,'BVS',0
000025C6= 09 4A 53 52 00          1749  MSG_JSR                         DC.B    TAB,'JSR',0
000025CB= 09 52 54 53 00          1750  MSG_RTS                         DC.B    TAB,'RTS',0
000025D0= 09 42 52 41 00          1751  MSG_BRA                         DC.B    TAB,'BRA',0
000025D5                          1752  
000025D5                          1753  * Direction for LSd and ASd
000025D5= 52 00                   1754  MSG_RIGHT                       DC.B    'R',0
000025D7= 4C 00                   1755  MSG_LEFT                        DC.B    'L',0
000025D9                          1756  
000025D9                          1757  * Effective Addresses Messages
000025D9= 44 00                   1758  MSG_DR                          DC.B    'D',0
000025DB= 41 00                   1759  MSG_AR                          DC.B    'A',0
000025DD= 28 00                   1760  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000025DF= 29 00                   1761  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000025E1= 2B 00                   1762  MSG_PLUS                        DC.B    '+',0
000025E3= 2D 00                   1763  MSG_MINUS                       DC.B    '-',0
000025E5= 23 00                   1764  MSG_POUND                       DC.B    '#',0 
000025E7= 24 00                   1765  MSG_HEX                         DC.B    '$',0 
000025E9= 2C 20 00                1766  MSG_COMMA                       DC.B    ', ',0
000025EC= 2F 00                   1767  MSG_SLASH                       DC.B    '/',0  
000025EE= 20 00                   1768  MSG_SPACE                       DC.B    ' ',0
000025F0= 09 00                   1769  MSG_TAB                         DC.B    TAB,0
000025F2= 20 20 20 00             1770  MSG_3SPACES                     DC.B    '   ',0
000025F6= 20 20 20 20 00          1771  MSG_4SPACES                     DC.B    '    ',0
000025FB= 20 20 20 20 20 00       1772  MSG_5SPACES                     DC.B    '     ',0
00002601= 20 20 20 20 20 20 00    1773  MSG_6SPACES                     DC.B    '      ',0
00002608= 20 20 20 20 20 20 ...   1774  MSG_7SPACES                     DC.B    '       ',0
00002610                          1775  
00002610                          1776  * Size Messages
00002610= 2E 42 00                1777  MSG_B                           DC.B    '.B',0
00002613= 2E 57 00                1778  MSG_W                           DC.B    '.W',0
00002616= 2E 4C 00                1779  MSG_L                           DC.B    '.L',0
00002619                          1780  
00002619                          1781  * Variables
00002619  =00000100               1782  STARTING_ADDRESS                EQU     $100
00002619  =00000150               1783  ENDING_ADDRESS                  EQU     $150
00002619  =00000200               1784  CURRENT_INSTR                   EQU     $200
00002619  =00000250               1785  REG_VAR                         EQU     $250 * Hold bits 11-9
00002619  =00000300               1786  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00002619  =00000350               1787  EA_MODE                         EQU     $350 * Hold bits 5-3
00002619  =00000400               1788  EA_REG                          EQU     $400 * Hold bits 2-0
00002619= 00                      1789  LINE_COUNT                      DC.B     0
0000261A= 19                      1790  LINE_MAX                        DC.B     25
0000261B                          1791              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1690
ADDQ_BYTE           1732
ADDQ_LONG           176A
ADDQ_WORD           174E
ADD_SUB_BYTE        15AE
ADD_SUB_HELP        1528
ADD_SUB_LONG        15CA
ADD_SUB_OPERAND     15E0
ADD_SUB_SIZE        158A
ADD_SUB_WORD        15BC
AN                  1
AND_BYTE            1954
AND_LONG            198C
AND_WORD            1970
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           2465
CASE_ADD            1500
CASE_ADDA           1658
CASE_ADDQ           16DC
CASE_AND            190E
CASE_AR             2006
CASE_ARI            201E
CASE_ARIPOST        204E
CASE_ARIPRE         208A
CASE_ASDMEM         1AEE
CASE_ASDREG         1BC2
CASE_BCC            1D2A
CASE_BEQ            1D5C
CASE_BGT            1D70
CASE_BLE            1D66
CASE_BRA            1CFA
CASE_DATA           1DF8
CASE_DR             1FEE
CASE_EPICFAIL       1DFE
CASE_IMMEDIATE      20D8
CASE_JSR            1D96
CASE_LEA            1870
CASE_LEFTMEM        1B14
CASE_LEFTREG        1BE8
CASE_LONG           213E
CASE_LSDASDROD      1AAE
CASE_LSDMEM         1AE4
CASE_LSDREG         1BB8
CASE_MOVE           12A6
CASE_MOVEM          136C
CASE_MOVEQ          1478
CASE_NOP            1290
CASE_NOT            1A4A
CASE_OR             19EA
CASE_OTHER          20C6
CASE_RIGHTMEM       1B1E
CASE_RIGHTREG       1BF2
CASE_RODMEM         1AF8
CASE_RODREG         1BCC
CASE_RTS            1DE2
CASE_SHIFTMEM       1ACC
CASE_SHIFTREG       1B9E
CASE_SUB            17D8
CASE_SUBA           185A
CASE_WORD           2122
CHECKEAEXIT         1FBE
CHECKEAMLOOP        1F90
CHECKEAXN_IFVALID   1F8E
CHECKGET_EAXN       1E54
CHECKMEMSOURE       1B5E
CHECKMOREBITS       1F40
CHECKSHIFT_XN       1B88
CHECK_LENGTH        11DE
CHECK_LINE          1186
CHECK_ODD           1274
CHECK_ORDER         10AE
CHECK_XN            1E84
CLEAR_SCREEN        11BA
COMPLETE_REGIM      1C6A
CONCAT              1226
CONTINUE            24ED
CONVERT             11F0
CR                  D
CURRENT_INSTR       200
DESTEA              1E0A
DESTXN              1E34
DISASSEMBLE         10D4
DN                  0
DN_PLUS_EA          1624
DONE                24A9
DONEPRINTINGREG     1F8A
EASHIFT_VALID       1B7C
EAXN_INVALID        1E96
EAXN_VALID          1E7C
EA_MODE             350
EA_REG              400
EA_TO_STRING        1FC2
EA_TO_STRING_EXIT   2164
ENDING              242F
ENDING_ADDRESS      150
END_CHECKGET        1E9A
ERROR               2318
ERROR_MSG           2487
FINDTYPEEA          1E1E
FINDTYPEXN          1E48
FINISHED            10F8
FINISHMOVE          230A
FINISH_ADD          15D8
FINISH_ADDA         16B0
FINISH_ADDQ         1786
FINISH_AND          19A8
FINISH_SUB          1820
FINISH_SUBA         1826
FORMAT1             238D
FORMAT2             23D8
GETDIRECTION        1ED4
GETDISPLACEMENT     1E9C
GETMEMSOURCE        1B46
GETROTATION         1ECA
GETROTATIONLOCATION  1EE4
GETROTATIONSIZE     1EDC
GET_EA              1E00
GET_XN              1E2A
IMMEDIATE_LONG      2104
INPUT1              1020
INPUT2              1066
INSERTA             132C
INVALID             123E
INVALIDEA           1FA2
INVALID_INSTR       24A3
INV_INSTR           19B2
ISNUMBER            1206
LF                  A
LINE_COUNT          2619
LINE_MAX            261A
LSD_MEM             1
LSD_REG             1
MAKESHIFT8          1C66
MEM2REGLONG         143C
MEM2REGWORD         1432
MEMTOREG1           1F0C
MEMTOREG2           1F7E
MOVEM_MEM2REG       13FE
MOVEM_REG2MEM       138A
MOVE_BYTE           22F0
MOVE_LONG           2304
MOVE_WORD           22FA
MSG_3SPACES         25F2
MSG_4SPACES         25F6
MSG_5SPACES         25FB
MSG_6SPACES         2601
MSG_7SPACES         2608
MSG_ADD             253F
MSG_ADDA            2544
MSG_ADDQ            254A
MSG_AND             2566
MSG_AR              25DB
MSG_ASD             2578
MSG_B               2610
MSG_BCC             2580
MSG_BCS             2585
MSG_BEQ             258A
MSG_BGE             2594
MSG_BGT             2599
MSG_BHI             259E
MSG_BLE             25A3
MSG_BLS             25A8
MSG_BLT             25AD
MSG_BMI             25B2
MSG_BNE             258F
MSG_BPL             25B7
MSG_BRA             25D0
MSG_BVC             25BC
MSG_BVS             25C1
MSG_COMMA           25E9
MSG_DIVU            255B
MSG_DR              25D9
MSG_HEX             25E7
MSG_JSR             25C6
MSG_L               2616
MSG_LB              25DD
MSG_LEA             2561
MSG_LEFT            25D7
MSG_LSD             2574
MSG_MINUS           25E3
MSG_MOVE            2524
MSG_MOVEA           252A
MSG_MOVEM           2538
MSG_MOVEQ           2531
MSG_MULS            2555
MSG_NOP             251F
MSG_NOT             256F
MSG_OR              256B
MSG_PLUS            25E1
MSG_POUND           25E5
MSG_RB              25DF
MSG_RIGHT           25D5
MSG_ROD             257C
MSG_RTS             25CB
MSG_SLASH           25EC
MSG_SPACE           25EE
MSG_SUB             2550
MSG_TAB             25F0
MSG_W               2613
NEW_LINE            2518
NEXT_SCREEN         119A
NOTNUMBER           120E
OPCODE_DECODE       1288
OPMODE_VAR          300
OR_SIZE             1A32
OTHER               7
OTHEREA             1FBA
PRINTADD            1566
PRINTADDRESS        1EAC
PRINTASHEX          2282
PRINTBCC            1D7A
PRINTENTER          22C6
PRINTHEXNUM         217A
PRINTLONGZERO       21DA
PRINTMEM2REG        1448
PRINTMORE           1F4C
PRINTMOVE           134A
PRINTMOVESIZE       22D6
PRINTNULL           22B4
PRINTNUM            216A
PRINTRANGE          229E
PRINTREG            1F32
PRINTREG2MEM        13CE
PRINTREGEA          1C34
PRINTREGISTERLOOP   1F16
PRINTREGISTERS      1EEC
PRINTREGSIZE        1C02
PRINTSHIFTMEM       1AFE
PRINTSHIFTREG       1BD2
PRINTSHORTLONGNUM   218E
PRINTSHORTZERO      219A
PRINTSUB            17EE
PRINTZERO           2292
PRINT_8             17CC
PRINT_ADDQ_DATA     17A6
PRINT_ADDR          127C
PRINT_JSR           1DC2
PRINT_MEMDIR        1B24
PRINT_MOVEQ         149A
PRINT_REGDIR        1BFC
READ_KEY            11AA
REG2MEMLONG         13C8
REG2MEMWORD         13BE
REGTOMEM1           1EFE
REGTOMEM2           1F72
REG_BYTE            1C1A
REG_IMMEDIATE       1C56
REG_LONG            1C2E
REG_REGISTER        1CB4
REG_VAR             250
REG_WORD            1C24
RESET_INPUT         11D6
RESTART             1120
RETURN              123C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1E16
SOURCEXN            1E40
START               1000
STARTING            23F8
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          125C
THREE_TAB           251B
VALIDEA             1FAA
VALIDEA_ADDSUB_DESTOPERAND  233D
VALIDEA_ALL         2328
VALIDEA_ANDORNOT    234B
VALIDEA_ANDOR_DESTOPERAND  2351
VALIDEA_JSR         235B
VALIDEA_LEA         2348
VALIDEA_MOVEM_MEMTOREG  2339
VALIDEA_MOVEM_REGTOMEM  2335
VALIDEA_MOVEQ       232F
VALIDEA_MULSDIVU    2342
VALIDEA_SHIFT       2356
VALIDXN_ALL         235E
VALIDXN_SHORTLONG   2362
WELCOME             2365
XNIMMEDIATE         4
