00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/7/2020 10:19:32 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001FD5             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 0000204B             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 00001132             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 00001144             28                  JSR     CONVERT
0000103E  4EB9 000011B0             29                  JSR     TEST_RANGE
00001044  4EB9 000011C8             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00002082             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 00001132             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 00001144             47                  JSR     CONVERT
00001086  4EB9 000011B0             48                  JSR     TEST_RANGE
0000108C  4EB9 000011C8             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0088                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4                            58  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010A4                            59                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A4                            60                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010A4  4EB9 000011DC             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010AA  4EB9 00001EFE             62                  JSR     PRINTENTER          ; prints a new line
000010B0  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010B2  6FF0                      64                  BLE     DISASSEMBLE         ; if not, loop
000010B4                            65  
000010B4  4BF9 00002104             66  FINISHED        LEA     DONE,A5
000010BA  4EB9 00001EEC             67                  JSR     PRINTNULL
000010C0  103C 0005                 68                  MOVE.B  #5,D0
000010C4  4E4F                      69                  TRAP    #15
000010C6                            70                  
000010C6  B23C 000D                 71                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010CA  6700 0008                 72                  BEQ     RESTART             ; it's Enter, restart
000010CE                            73                  
000010CE  103C 0009                 74                  MOVE.B  #9,D0
000010D2  4E4F                      75                  TRAP    #15
000010D4                            76                  
000010D4  103C 000B                 77  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010D8  323C FF00                 78                  MOVE.W  #$FF00, D1          Clear Screen
000010DC  4E4F                      79                  TRAP    #15                 Call Trap
000010DE                            80                  
000010DE  103C 000C                 81                  MOVE.B  #12,D0              Keyboard echo
000010E2  123C 0001                 82                  MOVE.B  #1,D1               Visible
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  207C 00000000             85                  MOVE.L  #$0000000, A0       Reset A1
000010EE  227C 00000000             86                  MOVE.L  #$0000000, A1       Reset A1
000010F4  247C 00000000             87                  MOVE.L  #$0000000, A2       Reset A2
000010FA  267C 00000000             88                  MOVE.L  #$0000000, A3       Reset the Good Buffer
00001100  287C 00000000             89                  MOVE.L  #$0000000, A4       Reset A4
00001106  2A7C 00000000             90                  MOVE.L  #$0000000, A5       Reset the Starting address
0000110C  2C7C 00000000             91                  MOVE.L  #$0000000, A6       Reset the Ending Address
00001112  2E7C 01000000             92                  MOVEA.L #$01000000,A7       Reset stack pointer
00001118  4281                      93                  CLR.L   D1                  Reset D1
0000111A  4281                      94                  CLR.L   D1                  Reset D1
0000111C  4282                      95                  CLR.L   D2                  Reset D2
0000111E  4283                      96                  CLR.L   D3                  Reset D3
00001120  4284                      97                  CLR.L   D4                  Reset D4
00001122  4285                      98                  CLR.L   D5                  Reset D5
00001124  4286                      99                  CLR.L   D6                  Reset D6
00001126  6000 FED8                100                  BRA     START               Restart the program
0000112A                           101  
0000112A                           102  *--------------------SUBROUTINES------------------    
0000112A                           103  
0000112A  143C 0001                104  RESET_INPUT     MOVE.B  #1,D2
0000112E  6000 0062                105                  BRA     INVALID            
00001132                           106                  
00001132  7800                     107  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001134  B204                     108                  CMP.B   D4,D1               ; D1 stores length
00001136  6700 005A                109                  BEQ     INVALID             ; input is null
0000113A  0C41 0008                110                  CMPI    #$8,D1              ; check if input is longer than a longword
0000113E  6600 0052                111                  BNE     INVALID             ; input is longer than a longword
00001142  4E75                     112                  RTS
00001144                           113                              
00001144  4283                     114  CONVERT         CLR.L   D3
00001146  4284                     115                  CLR.L   D4
00001148  1619                     116                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000114A  B63C 0039                117                  CMP.B   #57,D3
0000114E  6E00 0012                118                  BGT     NOTNUMBER
00001152                           119                  
00001152  B63C 002F                120                  CMP.B   #47,D3
00001156  6E00 0002                121                  BGT     ISNUMBER
0000115A                           122                  
0000115A  0603 00D0                123  ISNUMBER        ADD.B   #-48,D3             ; current char is number
0000115E  6000 001A                124                  BRA     CONCAT
00001162                           125              
00001162  B63C 0041                126  NOTNUMBER       CMP.B   #65,D3
00001166  6D00 002A                127                  BLT     INVALID
0000116A  B63C 0046                128                  CMP.B   #70,D3
0000116E  6E00 0022                129                  BGT     INVALID  
00001172  0603 00C9                130                  ADD.B   #-55,D3             ; is letter             
00001176  6000 0002                131                  BRA     CONCAT
0000117A                           132              
0000117A  BC3C 0000                133  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000117E  6D00 0010                134                  BLT     RETURN
00001182  1806                     135                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001184  E50C                     136                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001186  E9AB                     137                  LSL.L   D4,D3               ; moves current char to correct position  
00001188  DA83                     138                  ADD.L   D3,D5               ; D5 stores converted input so far
0000118A  0606 00FF                139                  ADD.B   #-1,D6  
0000118E  60B4                     140                  BRA     CONVERT             ; continue loop for remaining chars
00001190                           141                  
00001190  4E75                     142  RETURN          RTS
00001192                           143                  
00001192  227C 00000000            144  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001198  43F9 000020B8            145                  LEA     BAD_INPUT,A1        ; output invalid message
0000119E  103C 000E                146                  MOVE.B  #14,D0
000011A2  4E4F                     147                  TRAP    #15
000011A4  B47C 0001                148                  CMP     #1,D2
000011A8  6700 FE62                149                  BEQ     INPUT1
000011AC  6000 FEA4                150                  BRA     INPUT2
000011B0                           151  
000011B0  4284                     152  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011B2  223C 00001000            153                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011B8  BA81                     154                  CMP.L      D1,D5            ; Compare minimum address with input
000011BA  6DD6                     155                  BLT        INVALID          ; input is too low. 
000011BC  223C 00FFFFFE            156                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011C2  BA81                     157                  CMP.L      D1,D5            ; compare maximum address with input
000011C4  6ECC                     158                  BGT        INVALID          ; input too large
000011C6  4E75                     159                  RTS                         ; input is within range
000011C8                           160             
000011C8  0805 0000                161  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011CC  66C4                     162                  BNE        INVALID
000011CE  4E75                     163                  RTS
000011D0                           164  
000011D0  220E                     165  PRINT_ADDR      MOVE.L  A6,D1                   ; loads current address in D1
000011D2  7801                     166                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011D4  4EB9 00001DC6            167                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011DA  4E75                     168                  RTS
000011DC                           169  
000011DC                           170  
000011DC                           171  * Checks every single possible opcode we could have. Jump table
000011DC                           172  * Inputs: (A2) which is a pointer to intruction word to be translated
000011DC                           173  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011DC                           174  
000011DC  3C4A                     175  OPCODE_DECODE   MOVE.W  A2,A6
000011DE  301A                     176                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011E0                           177                  
000011E0                           178  
000011E0                           179  *---------------NOP opcode----------------------                
000011E0  B07C 4E71                180  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011E4  6600 0014                181                  BNE     CASE_MOVE               ; checks the next case if not equal
000011E8                           182                  
000011E8  4EB8 11D0                183                  JSR     PRINT_ADDR
000011EC                           184                  
000011EC  4BF9 0000213D            185                  LEA     MSG_NOP,A5              ; loads string pointer into A5
000011F2  4EB9 00001EEC            186                  JSR     PRINTNULL               ; prints NOP                
000011F8  4E75                     187                  RTS                             ; returns from the subroutine
000011FA                           188  
000011FA                           189  *---------------MOVE opcode----------------------              
000011FA                           190                  * if first two bits are 00, next two are not 00
000011FA  3200                     191  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
000011FC  C27C C000                192                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001200  6600 009E                193                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001204  B07C 0FFF                194                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001208  6F00 0096                195                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
0000120C                           196                  
0000120C                           197                  ; Check source
0000120C  4BF9 00001F98            198                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001212  4DF9 00001FCE            199                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001218  3E3C 0000                200                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000121C  4EB9 00001B5A            201                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001222  B27C 0001                202                  CMP.W   #1,D1                    ; checks if invalid
00001226  6700 08DA                203                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000122A  3802                     204                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000122C  3A03                     205                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000122E                           206                  
0000122E                           207                  ; Check destination
0000122E  4BF9 00001F98            208                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001234  4DF9 00001FD2            209                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000123A  3E3C 0001                210                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000123E  4EB9 00001B5A            211                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001244  B27C 0001                212                  CMP.W   #1,D1                    ; checks if invalid
00001248  6700 08B8                213                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000124C  3C02                     214                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
0000124E  3E03                     215                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001250                           216                  
00001250                           217                  ; Checking if it is MOVEA
00001250  3200                     218                  MOVE.W  D0,D1                    ; stores d0 in d1
00001252  C27C 01C0                219                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
00001256  B27C 0040                220                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000125A  6700 0010                221                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
0000125E                           222                  
0000125E  4EB8 11D0                223                  JSR     PRINT_ADDR              ; print address
00001262                           224   
00001262  4BF9 00002142            225                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001268  6000 0008                226                  BRA     PRINTMOVE                ; Branches to print move
0000126C                           227                  
0000126C  4BF9 00002148            228  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001272                           229   
00001272  4EB9 00001EEC            230  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001278  4EB9 00001F0E            231                  JSR     PRINTMOVESIZE            ; prints out the size  
0000127E  3404                     232                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001280  3605                     233                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001282  4EB9 00001C26            234                  JSR     EA_TO_STRING             ; outputs it into a string
00001288                           235                  
00001288                           236                  ; prints a comma to seperate
00001288  4BF9 0000223A            237                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000128E  4EB9 00001EEC            238                  JSR     PRINTNULL                ; prints out MOVE
00001294                           239                  
00001294                           240                  ; print destination
00001294  3406                     241                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001296  3607                     242                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001298  4EB9 00001C26            243                  JSR     EA_TO_STRING             ; outputs it into a string
0000129E  4E75                     244                  RTS                              ; exits subroutine                 
000012A0                           245                
000012A0                           246  *---------------MOVEM opcode----------------------                
000012A0  3200                     247  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012A2  C27C FB80                248                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012A6  B27C 4880                249                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012AA  6600 005A                250                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012AE                           251                  
000012AE                           252                  ; loads EA and XN
000012AE  323C 0000                253                  MOVE.W  #0,D1                           ; copies instruction word to D1
000012B2  4EB9 00001B06            254                  JSR     GET_EA                          ; gets EA and puts in D1
000012B8  3401                     255                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
000012BA  323C 0000                256                  MOVE.W  #0,D1                           ; copies instruction word to D1
000012BE  4EB9 00001B30            257                  JSR     GET_XN                          ; gets XN and puts in D1
000012C4  3601                     258                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
000012C6                           259                  
000012C6                           260                  ; Check D
000012C6  3200                     261                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012C8  C27C 0400                262                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012CC  3E01                     263                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012CE  B27C 0400                264                  CMP.W   #$0400,D1                       ; checks if value is 1
000012D2  6700 0032                265                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012D6                           266  
000012D6  4BF9 00001FA5            267  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
000012DC  3202                     268                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
000012DE  4EB9 00001BF2            269                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
000012E4  B27C 0001                270                  CMP.W   #1,D1                           ; checks if D1 invalid
000012E8  6700 0818                271                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000012EC  B27C 0002                272                  CMP.W   #2,D1                           ; checks if we need to check Xn
000012F0                           273                  
000012F0  4BF9 00001FA5            274  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
000012F6  3203                     275                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
000012F8  4EB9 00001BF2            276                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
000012FE  B27C 0001                277                  CMP.W   #1,D1                           ; checks if D1 invalid
00001302  6700 07FE                278                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001306                           279  
00001306                           280                  
00001306                           281  
00001306                           282  MOVEM_MEM2REG    
00001306                           283                          
00001306                           284  
00001306                           285  *---------------MOVEQ opcode----------------------
00001306  3200                     286  CASE_MOVEQ      MOVE.W  D0,D1
00001308  C27C F100                287                  AND.W   #$F100,D1
0000130C  B27C 7000                288                  CMP.W   #$7000,D1
00001310  6600 004C                289                  BNE     CASE_ADD
00001314                           290                  
00001314                           291                  ;loads Register
00001314  323C 0001                292                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001318  4EB9 00001B30            293                  JSR     GET_XN                          ; gets XN and puts in D1
0000131E  3401                     294                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
00001320                           295                  
00001320                           296                  ;loads DATA
00001320  3200                     297                  MOVE.W  D0,D1
00001322  C27C 00FF                298                  AND.W   #$00FF,D1                       ;bit mask to get DATA
00001326  3601                     299                  MOVE.W  D1,D3                          ;copy data into D3
00001328                           300                                                        ;must convert bits to hex
00001328                           301                                  
00001328  4EB8 11D0                302  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
0000132C                           303  
0000132C  4BF9 0000214F            304                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
00001332  4EB9 00001EEC            305                  JSR     PRINTNULL  
00001338                           306                  
00001338  4BF9 0000224D            307                  LEA     MSG_L,A5                        ;PRINT SIZE L
0000133E  4EB9 00001EEC            308                  JSR     PRINTNULL
00001344                           309      
00001344  4BF9 00002139            310                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
0000134A  4EB9 00001EEC            311                  JSR     PRINTNULL
00001350                           312                  
00001350  4BF9 00002236            313                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
00001356  4EB9 00001EEC            314                  JSR     PRINTNULL
0000135C  4E75                     315                  RTS
0000135E                           316                  
0000135E                           317  *---------------ADD opcode----------------------                
0000135E                           318  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
0000135E  3200                     319  CASE_ADD        MOVE.W  D0,D1
00001360  C27C F000                320                  AND.W   #$F000,D1
00001364  B27C D000                321                  CMP.W   #$D000,D1
00001368  6600 01A2                322                  BNE     CASE_ADDQ
0000136C                           323                  
0000136C  4EB8 11D0                324                  JSR     PRINT_ADDR              ; print address
00001370                           325                  
00001370  4EB9 0000138A            326                  JSR     ADD_SUB_HELP
00001376                           327                  
00001376                           328                  ; bits 7-8 determine if it is ADDA or ADD
00001376  3200                     329                  MOVE.W  D0,D1
00001378  E149                     330                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000137A  E049                     331                  LSR.W   #8,D1
0000137C  EC49                     332                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000137E  B27C 0003                333                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001382  6700 0120                334                  BEQ     CASE_ADDA
00001386                           335                  
00001386  6000 0048                336                  BRA     PRINTADD                ; Branches to print add
0000138A                           337                  
0000138A                           338                  ; Check bits 0-5 
0000138A  4BF9 00001F98            339  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001390  4DF9 00001FCE            340                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001396  3E3C 0000                341                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000139A  4EB9 00001B5A            342                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000013A0  B27C 0001                343                  CMP.W       #1,D1                    ; checks if invalid
000013A4  6700 075C                344                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000013A8  3802                     345                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000013AA  3A03                     346                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000013AC                           347                  
000013AC                           348                  ; Check 6-11
000013AC  4BF9 00001F98            349                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000013B2  4DF9 00001FD2            350                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000013B8  3E3C 0001                351                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
000013BC  4EB9 00001B5A            352                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000013C2  B27C 0001                353                  CMP.W       #1,D1                    ; checks if invalid
000013C6  6700 073A                354                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000013CA  3C02                     355                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
000013CC  3E03                     356                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
000013CE                           357    
000013CE  4E75                     358                  RTS                
000013D0                           359                    
000013D0  4BF9 0000215D            360  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
000013D6  4EB9 00001EEC            361                  JSR         PRINTNULL               ; print ADD
000013DC  3200                     362                  MOVE.W      D0,D1                   ; bits 7-8 contain size
000013DE  4EB9 000013E8            363                  JSR         ADD_SUB_SIZE
000013E4  6000 0050                364                  BRA         FINISH_ADD
000013E8                           365                    
000013E8  3200                     366  ADD_SUB_SIZE    MOVE.W      D0,D1
000013EA  E149                     367                  LSL.W       #8,D1
000013EC  E049                     368                  LSR.W       #8,D1
000013EE  EC49                     369                  LSR.W       #6,D1                   ; gets bits 6-7
000013F0                           370                    
000013F0  B27C 0000                371                  CMP.W       #0,D1
000013F4  6700 0016                372                  BEQ         ADD_SUB_BYTE
000013F8  B27C 0001                373                  CMP.W       #1,D1                   ; if 1, it is a word
000013FC  6700 001C                374                  BEQ         ADD_SUB_WORD
00001400  B27C 0002                375                  CMP.W       #2,D1                   ; if 2, it is a long
00001404  6700 0022                376                  BEQ         ADD_SUB_LONG
00001408  6000 0254                377                  BRA         CASE_SUBA                    ; error
0000140C                           378                    
0000140C  4BF9 00002241            379  ADD_SUB_BYTE    LEA         MSG_B,A5
00001412  4EB9 00001EEC            380                  JSR         PRINTNULL
00001418  4E75                     381                  RTS
0000141A                           382                    
0000141A  4BF9 00002247            383  ADD_SUB_WORD    LEA         MSG_W,A5
00001420  4EB9 00001EEC            384                  JSR         PRINTNULL
00001426  4E75                     385                  RTS
00001428                           386    
00001428  4BF9 0000224D            387  ADD_SUB_LONG    LEA         MSG_L,A5
0000142E  4EB9 00001EEC            388                  JSR         PRINTNULL
00001434  4E75                     389                  RTS
00001436                           390        
00001436  4EB9 0000143E            391  FINISH_ADD      JSR         ADD_SUB_OPERAND
0000143C  4E75                     392                  RTS
0000143E                           393    
0000143E  EF49                     394  ADD_SUB_OPERAND LSL.W       #7,D1
00001440  EE49                     395                  LSR.W       #7,D1
00001442  E049                     396                  LSR.W       #8,D1
00001444  B27C 0001                397                  CMP.W       #1,D1
00001448  6600 002E                398                  BNE         Dn_PLUS_EA          
0000144C                           399                    
0000144C                           400                  ; print Data Register
0000144C  4BF9 0000222A            401                  LEA         MSG_DR,A5
00001452  4EB9 00001EEC            402                  JSR         PRINTNULL
00001458  3207                     403                  MOVE.W      D7,D1
0000145A  4EB9 00001DA2            404                  JSR         PRINTNUM                
00001460                           405                  
00001460                           406                  ; prints a comma to seperate
00001460  4BF9 0000223A            407                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001466  4EB9 00001EEC            408                  JSR         PRINTNULL                ; prints out MOVE
0000146C                           409                 
0000146C                           410                  ; below is EA+Dn->Dn  
0000146C  3404                     411                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000146E  3605                     412                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001470  4EB9 00001C26            413                  JSR         EA_TO_STRING             ; outputs it into a string
00001476  4E75                     414                  RTS                                 ; exits subroutine 
00001478                           415  
00001478                           416  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001478  3404                     417                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000147A  3605                     418                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000147C  4EB9 00001C26            419                  JSR         EA_TO_STRING             ; outputs it into a string   
00001482                           420                  
00001482                           421                  ; prints a comma to seperate
00001482  4BF9 0000223A            422                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001488  4EB9 00001EEC            423                  JSR         PRINTNULL                ; prints out MOVE
0000148E                           424                  
0000148E                           425                  ; below is Dn+EA->EA
0000148E  4BF9 0000222A            426                  LEA         MSG_DR,A5                ; print data register
00001494  4EB9 00001EEC            427                  JSR         PRINTNULL
0000149A  3207                     428                  MOVE.W      D7,D1
0000149C  4EB9 00001DA2            429                  JSR         PRINTNUM             
000014A2  4E75                     430                  RTS                                  ; exits subroutine          
000014A4                           431                        
000014A4                           432  *---------------ADDA opcode----------------------
000014A4                           433  CASE_ADDA       ; gets bit 8 (size bit)
000014A4  3200                     434                  MOVE.W      D0,D1
000014A6  EF49                     435                  LSL.W       #7,D1
000014A8  EE49                     436                  LSR.W       #7,D1
000014AA  E049                     437                  LSR         #8,D1                   
000014AC                           438                  
000014AC  4BF9 00002162            439                  LEA         MSG_ADDA,A5             ; print ADDA
000014B2  4EB9 00001EEC            440                  JSR         PRINTNULL
000014B8                           441                   
000014B8  B27C 0001                442                  CMP.W       #1,D1
000014BC  6700 0012                443                  BEQ         ADDA_LONG
000014C0                           444                    
000014C0  4BF9 00002247            445                  LEA         MSG_W,A5
000014C6  4EB9 00001EEC            446                  JSR         PRINTNULL
000014CC  6000 0012                447                  BRA         FINISH_ADDA   
000014D0                           448                    
000014D0  4BF9 0000224D            449  ADDA_LONG       LEA         MSG_L,A5
000014D6  4EB9 00001EEC            450                  JSR         PRINTNULL
000014DC  6000 0002                451                  BRA         FINISH_ADDA
000014E0                           452                    
000014E0  3404                     453  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000014E2  3605                     454                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000014E4  4EB9 00001C26            455                  JSR         EA_TO_STRING             ; outputs it into a string
000014EA                           456                    
000014EA                           457                  ; prints a comma to seperate
000014EA  4BF9 0000223A            458                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000014F0  4EB9 00001EEC            459                  JSR         PRINTNULL                ; prints out MOVE
000014F6                           460            
000014F6  4BF9 0000222C            461                  LEA         MSG_AR,A5                ; print address register
000014FC  4EB9 00001EEC            462                  JSR         PRINTNULL
00001502  3207                     463                  MOVE.W      D7,D1
00001504  4EB9 00001DA2            464                  JSR         PRINTNUM             
0000150A  4E75                     465                  RTS                              ; exits subroutine
0000150C                           466                  
0000150C                           467  *---------------ADDQ opcode----------------------                  
0000150C  3200                     468  CASE_ADDQ       MOVE.W      D0,D1
0000150E  C27C F000                469                  AND.W       #$F000,D1       
00001512  B27C 5000                470                  CMP.W       #$5000,D1
00001516  6600 00CC                471                  BNE         CASE_SUB
0000151A                           472                                                   
0000151A  4EB8 11D0                473                  JSR         PRINT_ADDR              ; print address  
0000151E  4BF9 00002168            474                  LEA         MSG_ADDQ,A5             ; print ADDQ
00001524  4EB9 00001EEC            475                  JSR         PRINTNULL
0000152A                           476                  
0000152A                           477                  ; get bits 6-7 (size bits)
0000152A  3200                     478                  MOVE.W      D0,D1
0000152C  E149                     479                  LSL.W       #8,D1
0000152E  E049                     480                  LSR.W       #8,D1
00001530  EC49                     481                  LSR.W       #6,D1
00001532  3401                     482                  MOVE.W      D1,D2
00001534                           483                  
00001534                           484                  ; Check bits 0-5 
00001534  4BF9 00001F98            485                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000153A  4DF9 00001FCE            486                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001540  3E3C 0000                487                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001544  4EB9 00001B5A            488                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000154A  B27C 0001                489                  CMP.W       #1,D1                    ; checks if invalid
0000154E  6700 05B2                490                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001552  3802                     491                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001554  3A03                     492                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001556                           493                  
00001556  B47C 0001                494                  CMP.W       #1,D2
0000155A  6700 001A                495                  BEQ         ADDQ_WORD
0000155E  B47C 0002                496                  CMP.W       #2,D2
00001562  6700 0022                497                  BEQ         ADDQ_LONG
00001566                           498                    
00001566  4BF9 00002241            499  ADDQ_BYTE       LEA         MSG_B,A5
0000156C  4EB9 00001EEC            500                  JSR         PRINTNULL
00001572  6000 0022                501                  BRA         FINISH_ADDQ  
00001576                           502   
00001576  4BF9 00002247            503  ADDQ_WORD       LEA         MSG_W,A5
0000157C  4EB9 00001EEC            504                  JSR         PRINTNULL
00001582  6000 0012                505                  BRA         FINISH_ADDQ                 
00001586                           506    
00001586  4BF9 0000224D            507  ADDQ_LONG       LEA         MSG_L,A5
0000158C  4EB9 00001EEC            508                  JSR         PRINTNULL
00001592  6000 0002                509                  BRA         FINISH_ADDQ                  
00001596                           510                    
00001596  4EB9 000015B4            511  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000159C                           512   
0000159C                           513                  ; prints a comma to seperate
0000159C  4BF9 0000223A            514                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015A2  4EB9 00001EEC            515                  JSR         PRINTNULL                ; prints out MOVE
000015A8                           516                    
000015A8                           517                  ; prints destination
000015A8  3404                     518                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015AA  3605                     519                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015AC  4EB9 00001C26            520                  JSR         EA_TO_STRING             ; outputs it into a string
000015B2                           521                 
000015B2  4E75                     522                  RTS
000015B4                           523   
000015B4  4BF9 00002236            524  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
000015BA  4EB9 00001EEC            525                  JSR         PRINTNULL
000015C0                           526                  ; gets bits 9-11 (data bits)
000015C0  E949                     527                  LSL.W       #4,D1
000015C2  E849                     528                  LSR.W       #4,D1                               ; get rid of left 4 bits
000015C4  E049                     529                  LSR.W       #8,D1
000015C6  E249                     530                  LSR.W       #1,D1                               ; get rid of right 9 bits
000015C8                           531                  
000015C8  B27C 0000                532                  CMP.W       #0,D1
000015CC  6700 000A                533                  BEQ         PRINT_8
000015D0  4EB9 00001DA2            534                  JSR         PRINTNUM
000015D6  4E75                     535                  RTS 
000015D8                           536  
000015D8  123C 0008                537  PRINT_8         MOVE.B      #8,D1
000015DC  4EB9 00001DA2            538                  JSR         PRINTNUM
000015E2  4E75                     539                  RTS   
000015E4                           540         
000015E4                           541  *---------------SUB opcode---------------------- 
000015E4  3200                     542  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
000015E6  C27C F000                543                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000015EA  B27C 9000                544                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
000015EE  6600 0084                545                  BNE         CASE_LEA
000015F2                           546                 
000015F2  4EB8 138A                547                  JSR         ADD_SUB_HELP
000015F6  4EB8 11D0                548                  JSR         PRINT_ADDR                          ; print address               
000015FA                           549                  
000015FA  6000 0002                550                  BRA         PRINTSUB                            ; Branches to print move
000015FE                           551  
000015FE  4BF9 0000216E            552  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
00001604  4EB9 00001EEC            553                  JSR         PRINTNULL
0000160A  3200                     554                  MOVE.W      D0,D1                               ; bits 6-7 contain size
0000160C  4EB8 13E8                555                  JSR         ADD_SUB_SIZE
00001610  3200                     556                  MOVE.W      D0,D1
00001612  E149                     557                  LSL.W       #8,D1
00001614  E049                     558                  LSR.W       #8,D1
00001616  EC49                     559                  LSR.W       #6,D1
00001618  B27C 0003                560                  CMP.W       #3,D1
0000161C  6600 0006                561                  BNE         FINISH_SUB
00001620  6000 0008                562                  BRA         FINISH_SUBA                         ; same as ADDA
00001624                           563                  
00001624  4EB8 143E                564  FINISH_SUB      JSR     ADD_SUB_OPERAND
00001628  4E75                     565                  RTS
0000162A                           566                    
0000162A  3404                     567  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000162C  3605                     568                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000162E  4EB9 00001C26            569                  JSR         EA_TO_STRING             ; outputs it into a string
00001634                           570                
00001634                           571                  ; prints a comma to seperate
00001634  4BF9 0000223A            572                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000163A  4EB9 00001EEC            573                  JSR         PRINTNULL                ; prints out MOVE
00001640                           574          
00001640  4BF9 0000222C            575                  LEA         MSG_AR,A5                ; print address register
00001646  4EB9 00001EEC            576                  JSR         PRINTNULL
0000164C  3200                     577                  MOVE.W      D0,D1
0000164E  E949                     578                  LSL.W       #4,D1
00001650  E849                     579                  LSR.W       #4,D1
00001652  E049                     580                  LSR.W       #8,D1
00001654  E249                     581                  LSR.W       #1,D1
00001656  4EB9 00001DA2            582                  JSR         PRINTNUM             
0000165C  4E75                     583                  RTS                              ; exits subroutine
0000165E                           584  
0000165E                           585  
0000165E                           586  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000165E  3200                     587  CASE_SUBA       MOVE.W      D0,D1
00001660  EF49                     588                  LSL.W       #7,D1
00001662  EE49                     589                  LSR.W       #7,D1
00001664  E049                     590                  LSR.W       #8,D1
00001666  B23C 0000                591                  CMP.B       #0,D1
0000166A  6700 FDAE                592                  BEQ         ADD_SUB_WORD
0000166E  6000 FDB8                593                  BRA         ADD_SUB_LONG
00001672  4E75                     594                  RTS         
00001674                           595                   
00001674  3200                     596  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001676  C27C F000                597                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000167A  B27C 4000                598                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000167E  6600 0086                599                  BNE.W   CASE_AND                             ; If its not, check AND
00001682  3200                     600                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001684  C27C 01C0                601                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001688  B27C 01C0                602                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000168C  6600 0078                603                  BNE.W   CASE_AND                             ; If its not, check AND
00001690                           604                  
00001690                           605                  ; Check source
00001690  4BF9 00001FB8            606                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001696  4DF9 00001FD2            607                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000169C  3E3C 0000                608                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
000016A0  4EB9 00001B5A            609                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000016A6  3802                     610                  MOVE.W  D2,D4                                ; Saves D2 in D4
000016A8  3A03                     611                  MOVE.W  D3,D5                                ; Saves D2 in D4
000016AA                           612                  
000016AA                           613                  ; Check destination
000016AA  4BF9 00001FB8            614                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000016B0  4DF9 00001FD2            615                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000016B6  3E3C 0001                616                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000016BA  4EB9 00001B5A            617                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000016C0  3C02                     618                  MOVE.W  D2,D6                                ; Saves D2 in D4
000016C2  3E03                     619                  MOVE.W  D3,D7                                ; Saves D2 in D4
000016C4                           620  
000016C4  4BF9 0000217F            621                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000016CA  4EB9 00001EEC            622                  JSR     PRINTNULL                            ; prints LEA
000016D0                           623                  
000016D0                           624                  ; print source
000016D0  3404                     625                  MOVE.W  D4,D2
000016D2  3605                     626                  MOVE.W  D5,D3
000016D4  4EB9 00001C26            627                  JSR     EA_TO_STRING                         ; Prints out the EA
000016DA                           628                  
000016DA                           629                  ; comma
000016DA  4BF9 0000223A            630                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000016E0  4EB9 00001EEC            631                  JSR     PRINTNULL                       
000016E6                           632                   
000016E6                           633                  ; register
000016E6  4BF9 0000222C            634                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000016EC  4EB9 00001EEC            635                  JSR     PRINTNULL 
000016F2  3401                     636                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000016F4  323C 0001                637                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000016F8  4EB9 00001B30            638                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000016FE  4EB9 00001DA2            639                  JSR     PRINTNUM                             ; Prints the number in D1
00001704  4E75                     640                  RTS
00001706                           641  
00001706                           642  *---------------AND opcode----------------------
00001706  3200                     643  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001708  C27C F000                644                  AND.W       #$F000,D1       
0000170C  B27C C000                645                  CMP.W       #$C000,D1
00001710  6600 0086                646                  BNE         CASE_OR
00001714                           647                  
00001714  3200                     648                  MOVE.W      D0,D1
00001716  E149                     649                  LSL.W       #8,D1
00001718  E049                     650                  LSR.W       #8,D1
0000171A  EC49                     651                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000171C  3C01                     652                  MOVE.W      D1,D6
0000171E  BC7C 0003                653                  CMP.W       #3,D6
00001722  6700 0066                654                  BEQ         INV_INSTR
00001726                           655                  
00001726  4EB8 11D0                656                  JSR         PRINT_ADDR                      ; print address
0000172A  4BF9 00002187            657                  LEA         MSG_AND,A5                      ; print AND
00001730  4EB9 00001EEC            658                  JSR         PRINTNULL
00001736                           659                  
00001736  3206                     660                  MOVE.W      D6,D1
00001738  B27C 0000                661                  CMP.W       #0,D1
0000173C  6700 0012                662                  BEQ         AND_BYTE
00001740  B27C 0001                663                  CMP.W       #1,D1                   ; if 1, it is a word
00001744  6700 001A                664                  BEQ         AND_WORD
00001748  B27C 0002                665                  CMP.W       #2,D1                   ; if 2, it is a long
0000174C  6700 0022                666                  BEQ         AND_LONG
00001750                           667                  
00001750  4BF9 00002241            668  AND_BYTE        LEA         MSG_B,A5
00001756  4EB9 00001EEC            669                  JSR         PRINTNULL
0000175C  6000 0022                670                  BRA         FINISH_AND
00001760                           671                                    
00001760  4BF9 00002247            672  AND_WORD        LEA         MSG_W,A5
00001766  4EB9 00001EEC            673                  JSR         PRINTNULL
0000176C  6000 0012                674                  BRA         FINISH_AND
00001770                           675    
00001770  4BF9 0000224D            676  AND_LONG        LEA         MSG_L,A5
00001776  4EB9 00001EEC            677                  JSR         PRINTNULL
0000177C  6000 0002                678                  BRA         FINISH_AND
00001780                           679        
00001780  4EB8 138A                680  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001784  4EB8 143E                681                  JSR         ADD_SUB_OPERAND
00001788  4E75                     682                  RTS
0000178A                           683                  
0000178A  4BF9 000020F6            684  INV_INSTR       LEA         INVALID_INSTR,A5
00001790  4EB9 00001EEC            685                  JSR         PRINTNULL
00001796                           686                  ;MOVE.W      D0,A1
00001796  4E75                     687                  RTS               
00001798                           688                  
00001798                           689  *---------------OR opcode----------------------            
00001798  3200                     690  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
0000179A  C27C F000                691                  AND.W       #$F000,D1       
0000179E  B27C 8000                692                  CMP.W       #$8000,D1
000017A2  6600 004C                693                  BNE         CASE_NOT
000017A6                           694                                                
000017A6  3200                     695                  MOVE.W      D0,D1
000017A8  E149                     696                  LSL.W       #8,D1
000017AA  E049                     697                  LSR.W       #8,D1
000017AC  EC49                     698                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000017AE  B27C 0003                699                  CMP.W       #3,D1
000017B2  3C01                     700                  MOVE.W      D1,D6
000017B4  67D4                     701                  BEQ         INV_INSTR
000017B6                           702                  
000017B6  4EB8 11D0                703                  JSR         PRINT_ADDR                      ; print address
000017BA                           704                  
000017BA  4BF9 0000218C            705                  LEA         MSG_OR,A5
000017C0  4EB9 00001EEC            706                  JSR         PRINTNULL                       ; print "OR"
000017C6                           707                  
000017C6  3206                     708                  MOVE.W      D6,D1
000017C8  4EB9 000017D8            709                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000017CE  4EB8 138A                710                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
000017D2  4EB8 143E                711                  JSR         ADD_SUB_OPERAND                 ; print 
000017D6  4E75                     712                  RTS
000017D8                           713  
000017D8  B27C 0000                714  OR_SIZE         CMP.W       #0,D1
000017DC  6700 FC2E                715                  BEQ         ADD_SUB_BYTE
000017E0  B27C 0001                716                  CMP.W       #1,D1                   ; if 1, it is a word
000017E4  6700 FC34                717                  BEQ         ADD_SUB_WORD
000017E8  B27C 0002                718                  CMP.W       #2,D1                   ; if 2, it is a long
000017EC  6700 FC3A                719                  BEQ         ADD_SUB_LONG
000017F0                           720                  ; no need for rts, since ADD_SUB_ already has                
000017F0                           721  
000017F0                           722  *---------------NOT opcode----------------------
000017F0  3200                     723  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017F2  C27C FF00                724                  AND.W       #$FF00,D1       
000017F6  B27C 4600                725                  CMP.W       #$4600,D1
000017FA  6600 0050                726                  BNE         CASE_LSDASD
000017FE                           727                 
000017FE                           728                  ; get bits 6-7 (size)
000017FE  3200                     729                  MOVE.W      D0,D1
00001800  E149                     730                  LSL.W       #8,D1
00001802  E049                     731                  LSR.W       #8,D1
00001804  EC49                     732                  LSR.W       #6,D1 
00001806  3C01                     733                  MOVE.W      D1,D6                         
00001808  BC7C 0003                734                  CMP.W       #3,D6
0000180C  6700 FF7C                735                  BEQ         INV_INSTR
00001810                           736                  
00001810  4EB8 11D0                737                  JSR         PRINT_ADDR
00001814                           738                  
00001814  4BF9 00002190            739                  LEA         MSG_NOT,A5
0000181A  4EB9 00001EEC            740                  JSR         PRINTNULL                       ; print "NOT"
00001820                           741                                 
00001820  3206                     742                  MOVE.W      D6,D1
00001822                           743  
00001822  4EB8 17D8                744                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001826                           745                  
00001826                           746                  ; get bits 0-5 
00001826  4BF9 00001F98            747                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000182C  4DF9 00001FCE            748                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001832  3E3C 0000                749                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001836  4EB9 00001B5A            750                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000183C  B27C 0001                751                  CMP.W       #1,D1                    ; checks if invalid
00001840  6700 02C0                752                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001844  4EB9 00001C26            753                  JSR         EA_TO_STRING             ; outputs it into a string
0000184A                           754    
0000184A  4E75                     755                  RTS
0000184C                           756  
0000184C  3200                     757  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
0000184E  C27C F000                758                  AND.W       #$F000, D1                       ; gets first 4 bits
00001852  B27C E000                759                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001856  6600 0210                760                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
0000185A  3400                     761                  MOVE.W      D0,D2                            ; copies D0 to D2
0000185C  4EB9 00001BE2            762                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001862  B47C 0003                763                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001866  6600 00C8                764                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
0000186A                           765                  
0000186A  3400                     766  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000186C  4EB9 00001BD0            767                  JSR         GETROTATION                      ; gets rotation value of D2
00001872  B47C 0000                768                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001876  6700 0014                769                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
0000187A  B47C 0003                770                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
0000187E  6700 0016                771                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001882                           772                  
00001882  4BF9 00002195            773  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001888  6000 0012                774                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000188C                           775  
0000188C  4BF9 00002199            776  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001892  6000 0008                777                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001896                           778  
00001896  4BF9 0000219D            779  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000189C                           780                  
0000189C  4EB9 00001EEC            781  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
000018A2  3400                     782                  MOVE.W      D0,D2                            ; copies D0 to D2
000018A4  4EB9 00001BDA            783                  JSR         GETDIRECTION                     ; gets direction
000018AA  B47C 0000                784                  CMP.W       #0,D2                            ; checking if its right
000018AE  6700 000C                785                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
000018B2                           786  
000018B2  4BF9 00002228            787  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
000018B8  6000 0008                788                  BRA         PRINT_MEMDIR                     ; branches for printing
000018BC                           789          
000018BC  4BF9 00002226            790  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
000018C2                           791  
000018C2  4EB9 00001EEC            792  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
000018C8  4BF9 00002247            793                  LEA         MSG_W,A5                         ; loads .W into A5
000018CE  4EB9 00001EEC            794                  JSR         PRINTNULL                        ; Prints .W
000018D4  6000 0002                795                  BRA         GETMEMSOURCE                     ; checks the source 
000018D8                           796                  
000018D8                           797  ; get source addressing mode       
000018D8                           798  GETMEMSOURCE                                                 
000018D8  323C 0000                799                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
000018DC  4EB9 00001B06            800                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
000018E2  3801                     801                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
000018E4  323C 0000                802                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
000018E8  4EB9 00001B30            803                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000018EE  3A01                     804                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000018F0                           805  
000018F0  4BF9 00001FC6            806  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000018F6  3204                     807                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000018F8  4EB9 00001BF2            808                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000018FE  B27C 0002                809                  CMP.W       #2,D1                            ; checks if it is Xn
00001902  6700 0016                810                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001906  B27C 0001                811                  CMP.W       #1,D1                            ; Checks if it is invalid
0000190A  6700 01F6                812                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
0000190E                           813  
0000190E  3404                     814  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001910  3605                     815                  MOVE.W      D5,D3                            ; moves EA to D3
00001912  4EB9 00001C26            816                  JSR         EA_TO_STRING                     ; prints out the EA
00001918  4E75                     817                  RTS                
0000191A                           818                  
0000191A                           819                  
0000191A  4BF9 00001FD2            820  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001920  3205                     821                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001922  4EB9 00001BF2            822                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001928  4A41                     823                  TST.W       D1                               ; checks if it is valid
0000192A  67E2                     824                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
0000192C  6000 01D4                825                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001930                           826  
00001930                           827  
00001930  3602                     828  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001932  3200                     829                  MOVE.W      D0,D1                            ; copies D0 to D1
00001934  C27C 0018                830                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001938  E649                     831                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
0000193A  B27C 0000                832                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
0000193E  6700 0014                833                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001942  B27C 0003                834                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001946  6700 0016                835                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
0000194A                           836                  
0000194A  4BF9 00002195            837  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001950  6000 0012                838                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001954                           839  
00001954  4BF9 00002199            840  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
0000195A  6000 0008                841                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
0000195E                           842  
0000195E  4BF9 0000219D            843  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001964                           844                  
00001964  4EB9 00001EEC            845  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
0000196A  3400                     846                  MOVE.W      D0,D2                            ; copies D0 to D2
0000196C  4EB9 00001BDA            847                  JSR         GETDIRECTION                     ; gets direction
00001972  B47C 0000                848                  CMP.W       #0,D2                            ; checking if its right
00001976  6700 000C                849                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
0000197A                           850  
0000197A  4BF9 00002228            851  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001980  6000 000C                852                  BRA         PRINT_REGDIR                     ; branches for printing
00001984                           853          
00001984  4BF9 00002226            854  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
0000198A  6000 0002                855                  BRA         PRINT_REGDIR                     ; branches for printing
0000198E                           856                  
0000198E  4EB9 00001EEC            857  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001994                           858  
00001994  3400                     859  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001996  4EB9 00001BE2            860                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000199C  B47C 0001                861                  CMP.W       #1,D2                            ; Checks if it is word size
000019A0  6700 0014                862                  BEQ         REG_WORD                         ; Prints .W
000019A4  B47C 0002                863                  CMP.W       #2,D2                            ; Checks if it is long size
000019A8  6700 0016                864                  BEQ         REG_LONG                         ; Prints .L
000019AC                           865  
000019AC  4BF9 00002241            866  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
000019B2  6000 0012                867                  BRA         PRINTREGEA      
000019B6                           868  
000019B6  4BF9 00002247            869  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
000019BC  6000 0008                870                  BRA         PRINTREGEA      
000019C0                           871                             
000019C0  4BF9 0000224D            872  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
000019C6                           873  
000019C6  4EB9 00001EEC            874  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
000019CC  3400                     875                  MOVE.W      D0,D2                            ; copies D0 to D1
000019CE  4EB9 00001BEA            876                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
000019D4  B27C 0001                877                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
000019D8  6700 0048                878                  BEQ         REG_REGISTER                     ; goes to ASd case if so
000019DC                           879                                  
000019DC  3400                     880  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
000019DE  4EB9 00001BE2            881                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000019E4  3202                     882                  MOVE.W      D2, D1                           ; moves rotation size to D1
000019E6  4BF9 00002236            883                  LEA         MSG_POUND, A5                    ; loads # into A5
000019EC  4EB9 00001EEC            884                  JSR         PRINTNULL                        ; prints #
000019F2  4EB9 00001DA2            885                  JSR         PRINTNUM                         ; prints shift count
000019F8  4BF9 0000223A            886                  LEA         MSG_COMMA, A5                    ; loads , into A5
000019FE  4EB9 00001EEC            887                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001A04  4BF9 0000222A            888                  LEA         MSG_DR, A5                       ; loads D into A5
00001A0A  4EB9 00001EEC            889                  JSR         PRINTNULL                        ; prints out D 
00001A10  323C 0000                890                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001A14  4EB9 00001B30            891                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001A1A  4EB9 00001DA2            892                  JSR         PRINTNUM                         ; prints data register number in D1          
00001A20  4E75                     893                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001A22                           894                  
00001A22  3400                     895  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001A24  4EB9 00001BE2            896                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A2A  3202                     897                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001A2C  4BF9 0000222A            898                  LEA         MSG_DR, A5                       ; loads D into A5
00001A32  4EB9 00001EEC            899                  JSR         PRINTNULL                        ; prints D
00001A38  4EB9 00001DA2            900                  JSR         PRINTNUM                         ; prints register number
00001A3E  4BF9 0000223A            901                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001A44  4EB9 00001EEC            902                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001A4A  4BF9 0000222A            903                  LEA         MSG_DR, A5                       ; loads D into A5
00001A50  4EB9 00001EEC            904                  JSR         PRINTNULL                        ; prints out D 
00001A56  323C 0000                905                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001A5A  4EB9 00001B30            906                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001A60  4EB9 00001DA2            907                  JSR         PRINTNUM                         ; prints data register number in D1          
00001A66  4E75                     908                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001A68                           909               
00001A68  3200                     910  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001A6A  C27C FF00                911                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001A6E  B27C 6000                912                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001A72  6600 0018                913                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001A76                           914                  
00001A76  4BF9 0000221E            915                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001A7C  4EB9 00001EEC            916                  JSR     PRINTNULL                            ; prints BRA
00001A82                           917  
00001A82  3400                     918                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001A84  4EB9 00001BA2            919                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001A8A  4E75                     920                  RTS
00001A8C                           921                  
00001A8C                           922  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001A8C                           923  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001A8C  3200                     924  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001A8E  C27C F000                925                  AND.W   #$F000,D1                            ; get top 4 bits
00001A92  B27C 6000                926                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001A96  6600 0054                927                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001A9A  3200                     928                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001A9C  C27C 0F00                929                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001AA0  E049                     930                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001AA2                           931                  
00001AA2  B27C 000E                932                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001AA6  6700 002A                933                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001AAA                           934                  
00001AAA  B27C 000F                935                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001AAE  6700 0018                936                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001AB2                           937                      
00001AB2  B27C 0007                938                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001AB6  6700 0006                939                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001ABA  6000 0046                940                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001ABE                           941     
00001ABE  4BF9 000021B1            942  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001AC4  6000 0016                943                  BRA     PRINTBCC
00001AC8                           944  
00001AC8  4BF9 000021D9            945  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001ACE  6000 000C                946                  BRA     PRINTBCC
00001AD2                           947                  
00001AD2  4BF9 000021C9            948  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001AD8  6000 0002                949                  BRA     PRINTBCC
00001ADC                           950  
00001ADC  4EB9 00001EEC            951  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001AE2  3400                     952                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001AE4  4EB9 00001BA2            953                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001AEA  4E75                     954                  RTS              
00001AEC                           955                  
00001AEC                           956  
00001AEC                           957  CASE_JSR       
00001AEC                           958  
00001AEC  B07C 4E75                959  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001AF0  6600 F708                960                  BNE     CASE_MOVE           ; checks the next case if not equal
00001AF4  4BF9 00002219            961                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001AFA  4EB9 00001EEC            962                  JSR     PRINTNULL           ; prints RTS                
00001B00  4E75                     963                  RTS                         ; returns from the subroutine
00001B02                           964  
00001B02                           965                  
00001B02                           966  
00001B02                           967  CASE_DATA           
00001B02  4E75                     968                      RTS               
00001B04                           969  
00001B04  4E75                     970  CASE_EPICFAIL       RTS
00001B06                           971  
00001B06                           972  
00001B06                           973  * Finds the EA type
00001B06                           974  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001B06                           975  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001B06  48E7 3000                976  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001B0A  4A41                     977                      TST.W     D1                    ; compares D1 to 0
00001B0C  6700 000E                978                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001B10                           979                      
00001B10  343C 01C0                980  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001B14  363C 0006                981                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001B18  6000 000A                982                      BRA       FINDTYPEEA            
00001B1C                           983  
00001B1C  343C 0038                984  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001B20  363C 0003                985                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001B24                           986  
00001B24                           987  
00001B24  3200                     988  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001B26  C242                     989                      AND.W     D2,D1                 ; applies bitmask to D1
00001B28  E669                     990                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001B2A  4CDF 000C                991                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001B2E  4E75                     992                      RTS                             ; returns from subroutine    
00001B30                           993                      
00001B30                           994  * Finds Xn type
00001B30                           995  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001B30                           996  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001B30  48E7 3000                997  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001B34  4A41                     998                      TST.W     D1                    ; compares D1 to 0
00001B36  6700 000E                999                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001B3A                          1000  
00001B3A  343C 0E00               1001  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001B3E  363C 0009               1002                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001B42  6000 000A               1003                      BRA       FINDTYPEXN            ; finds the type of Xn
00001B46                          1004  
00001B46  343C 0007               1005  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001B4A  363C 0000               1006                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001B4E                          1007                      
00001B4E  3200                    1008  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001B50  C242                    1009                      AND.W     D2,D1                 ; applies bitmask to D1
00001B52  E669                    1010                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001B54  4CDF 000C               1011                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001B58  4E75                    1012                      RTS                             ; returns from subroutine 
00001B5A                          1013                      
00001B5A                          1014  * Checks and gets the EA and Xn
00001B5A                          1015  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001B5A                          1016  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001B5A  3207                    1017  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001B5C  4EB8 1B06               1018                  JSR     GET_EA                  ; Gets EA
00001B60  3401                    1019                  MOVE.W  D1,D2                   ; Stores EA in D2
00001B62  3207                    1020                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001B64  4EB8 1B30               1021                  JSR     GET_XN                  ; Gets Xn
00001B68  3601                    1022                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001B6A  3202                    1023                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001B6C                          1024                  
00001B6C  4EB9 00001BF2           1025                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001B72  B27C 0002               1026                  CMP.W   #2,D1                   ; checks if it is Xn
00001B76  6700 0012               1027                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001B7A  B27C 0001               1028                  CMP.W   #1,D1                   ; Checks if it is invalid
00001B7E  6700 001C               1029                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001B82                          1030                  
00001B82                          1031                  
00001B82  323C 0000               1032  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001B86  6000 0018               1033                  BRA     END_CHECKGET
00001B8A                          1034        
00001B8A                          1035  ; need XN
00001B8A  2A4E                    1036  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001B8C  3203                    1037                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001B8E  4EB9 00001BF2           1038                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001B94  4A41                    1039                  TST.W   D1                      ; checks if it is valid
00001B96  67EA                    1040                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001B98  6000 0002               1041                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001B9C                          1042   
00001B9C  323C 0001               1043  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001BA0                          1044  
00001BA0  4E75                    1045  END_CHECKGET    RTS          
00001BA2                          1046                                            
00001BA2                          1047                                            
00001BA2                          1048  * Gets the displacement and pritns it 
00001BA2                          1049  * Inputs: D2 = instruction word, A2 = address of next word
00001BA2                          1050  * Outputs: prints out displacement
00001BA2  48E7 4004               1051  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001BA6  3A4A                    1052                      MOVE.W    A2,A5                 ; copies A2 to A5
00001BA8  C47C 00FF               1053                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001BAC  6600 0004               1054                      BNE       PRINTADDRESS          ; prints address if not 0
00001BB0  341A                    1055                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001BB2                          1056                      
00001BB2  D44D                    1057  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001BB4  3202                    1058                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001BB6  183C 0000               1059                      MOVE.B    #0,D4                 ; marks address as word  length
00001BBA  4BF9 00002238           1060                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001BC0  4EB9 00001EEC           1061                      JSR       PRINTNULL             ; prints null
00001BC6  4EB9 00001DC6           1062                      JSR       PRINTSHORTLONGNUM     ; prints address
00001BCC                          1063                      
00001BCC  4CDF 2002               1064                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001BD0                          1065                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001BD0                          1066  
00001BD0                          1067  * Gets the rotation value for ASd and LSd
00001BD0                          1068  * Input: D2 = instruction word copy (of D0)                                    
00001BD0                          1069  * Output: rotation  value in D2             
00001BD0  C47C 0E00               1070  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001BD4  E04A                    1071                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001BD6  E24A                    1072                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001BD8  4E75                    1073                      RTS                             ; return from subroutine
00001BDA                          1074  
00001BDA                          1075  * Gets the direction value for ASd and LSd
00001BDA                          1076  * Input: D2 = instruction word copy (of D0)                                    
00001BDA                          1077  * Output: direction value in D2             
00001BDA  C47C 0100               1078  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001BDE  E04A                    1079                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001BE0  4E75                    1080                      RTS                             ; return from subroutine
00001BE2                          1081  
00001BE2                          1082  * Gets the rotation size value for ASd and LSd
00001BE2                          1083  * Input: D2 = instruction word copy (of D0)                                    
00001BE2                          1084  * Output: rotation size value in D2             
00001BE2  C47C 00C0               1085  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001BE6  EC4A                    1086                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001BE8  4E75                    1087                      RTS                             ; return from subroutine
00001BEA                          1088  
00001BEA                          1089  * Gets the rotation location  value for ASd and LSd
00001BEA                          1090  * Input: D2 = instruction word copy (of D0)                                    
00001BEA                          1091  * Output: rotation location value in D2             
00001BEA  C47C 0020               1092  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001BEE  EA4A                    1093                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001BF0  4E75                    1094                      RTS                             ; return from subroutine
00001BF2                          1095  
00001BF2                          1096                          
00001BF2                          1097  * Checks if EA or Xn is valid
00001BF2                          1098  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001BF2                          1099  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001BF2  2F02                    1100  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001BF4                          1101  
00001BF4  141D                    1102  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001BF6  B43C 00FF               1103                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001BFA  6700 000A               1104                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001BFE  B202                    1105                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001C00  6700 000C               1106                     BEQ        VALIDEA               ; branches to valid EA
00001C04  60EE                    1107                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001C06                          1108                     
00001C06  323C 0001               1109  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001C0A  6000 0016               1110                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001C0E                          1111                    
00001C0E  B43C 0007               1112  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001C12  6700 000A               1113                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001C16  323C 0000               1114                     MOVE.W     #$0,D1                ; marks that it is valid
00001C1A  6000 0006               1115                     BRA        CHECKEAEXIT           ; exits the subroutine
00001C1E                          1116  
00001C1E  323C 0002               1117  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001C22                          1118  
00001C22  241F                    1119  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001C24  4E75                    1120                     RTS                              ; returns from subroutine
00001C26                          1121  
00001C26                          1122  * Converts EA and Xn into a string                                
00001C26                          1123  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001C26                          1124  * Outputs: Prints out EA and Xn into a string
00001C26  48E7 C004               1125  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001C2A  B47C 0001               1126                     CMP.W    #An,D2                  ; checks if it is An
00001C2E  6700 003A               1127                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001C32                          1128                     
00001C32  B47C 0002               1129                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001C36  6700 004A               1130                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001C3A                          1131                     
00001C3A  B47C 0003               1132                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001C3E  6700 0072               1133                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001C42                          1134                     
00001C42  B47C 0004               1135                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001C46  6700 00A6               1136                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001C4A                          1137                     
00001C4A  B47C 0007               1138                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001C4E  6700 00DA               1139                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001C52                          1140                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001C52                          1141  
00001C52                          1142  * data register, Dn
00001C52  4BF9 0000222A           1143  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001C58  4EB9 00001EEC           1144                     JSR      PRINTNULL               ; Prints D
00001C5E  3203                    1145                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C60  4EB9 00001DA2           1146                     JSR      PRINTNUM                ; Prints the Xn
00001C66  6000 0134               1147                     BRA      EA_TO_STRING_EXIT       ; exits           
00001C6A                          1148  
00001C6A                          1149  
00001C6A                          1150  * address register
00001C6A  4BF9 0000222C           1151  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001C70  4EB9 00001EEC           1152                     JSR      PRINTNULL               ; Prints A
00001C76  3203                    1153                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C78  4EB9 00001DA2           1154                     JSR      PRINTNUM                ; Prints the Xn
00001C7E  6000 011C               1155                     BRA      EA_TO_STRING_EXIT       ; exits
00001C82                          1156  
00001C82                          1157  * address register indirect
00001C82  4BF9 0000222E           1158  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001C88  4EB9 00001EEC           1159                     JSR      PRINTNULL               ; Prints (
00001C8E  4BF9 0000222C           1160                     LEA      MSG_AR,A5               ; Loads A into A5
00001C94  4EB9 00001EEC           1161                     JSR      PRINTNULL               ; Prints A
00001C9A  3203                    1162                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C9C  4EB9 00001DA2           1163                     JSR      PRINTNUM                ; Prints the Xn
00001CA2  4BF9 00002230           1164                     LEA      MSG_RB,A5               ; Loads ) into A5
00001CA8  4EB9 00001EEC           1165                     JSR      PRINTNULL               ; Prints )
00001CAE  6000 00EC               1166                     BRA      EA_TO_STRING_EXIT       ; exits
00001CB2                          1167  
00001CB2                          1168  * address register indirect post increment
00001CB2  4BF9 0000222E           1169  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001CB8  4EB9 00001EEC           1170                     JSR      PRINTNULL               ; Prints (
00001CBE  4BF9 0000222C           1171                     LEA      MSG_AR,A5               ; Loads A into A5
00001CC4  4EB9 00001EEC           1172                     JSR      PRINTNULL               ; Prints A
00001CCA  3203                    1173                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001CCC  4EB9 00001DA2           1174                     JSR      PRINTNUM                ; Prints the Xn
00001CD2  4BF9 00002230           1175                     LEA      MSG_RB,A5               ; Loads ) into A5
00001CD8  4EB9 00001EEC           1176                     JSR      PRINTNULL               ; Prints )
00001CDE  4BF9 00002232           1177                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001CE4  4EB9 00001EEC           1178                     JSR      PRINTNULL               ; Prints +
00001CEA  6000 00B0               1179                     BRA      EA_TO_STRING_EXIT       ; exits
00001CEE                          1180  
00001CEE                          1181  
00001CEE                          1182  * address register indirect pre increment
00001CEE  4BF9 00002234           1183  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001CF4  4EB9 00001EEC           1184                     JSR      PRINTNULL               ; Prints -
00001CFA  4BF9 0000222E           1185                     LEA      MSG_LB,A5               ; Loads ( into A5
00001D00  4EB9 00001EEC           1186                     JSR      PRINTNULL               ; Prints (
00001D06  4BF9 0000222C           1187                     LEA      MSG_AR,A5               ; Loads A into A5
00001D0C  4EB9 00001EEC           1188                     JSR      PRINTNULL               ; Prints A
00001D12  3203                    1189                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001D14  4EB9 00001DA2           1190                     JSR      PRINTNUM                ; Prints the Xn
00001D1A  4BF9 00002230           1191                     LEA      MSG_RB,A5               ; Loads ) into A5
00001D20  4EB9 00001EEC           1192                     JSR      PRINTNULL               ; Prints )
00001D26  6000 0074               1193                     BRA      EA_TO_STRING_EXIT       ; exits
00001D2A                          1194  
00001D2A                          1195  * other (long, short, immediate) with Xn yes
00001D2A  301A                    1196  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001D2C  B67C 0000               1197                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001D30  6700 002E               1198                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001D34                          1199                     
00001D34  B67C 0001               1200                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001D38  6700 0042               1201                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001D3C                          1202  
00001D3C                          1203  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001D3C                          1204  * immediate
00001D3C  4BF9 00002236           1205  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001D42  4EB9 00001EEC           1206                     JSR      PRINTNULL               ; Prints #  
00001D48  4BF9 00002238           1207                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001D4E  4EB9 00001EEC           1208                     JSR      PRINTNULL               ; Prints $
00001D54  3200                    1209                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001D56  4EB9 00001DB2           1210                     JSR      PRINTHEXNUM 
00001D5C  6000 003E               1211                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001D60                          1212                     
00001D60                          1213  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001D60                          1214  
00001D60                          1215  * word address
00001D60                          1216  CASE_WORD          
00001D60  4BF9 00002238           1217                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001D66  4EB9 00001EEC           1218                     JSR      PRINTNULL               ; Prints $
00001D6C  3200                    1219                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001D6E  383C 0000               1220                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001D72  4EB9 00001DC6           1221                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001D78  6000 0022               1222                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001D7C                          1223  
00001D7C                          1224  * long address 
00001D7C                          1225  CASE_LONG          
00001D7C  4BF9 00002238           1226                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001D82  4EB9 00001EEC           1227                     JSR      PRINTNULL               ; Prints $
00001D88  3200                    1228                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001D8A  383C 0001               1229                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001D8E  4EB9 00001DC6           1230                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001D94  321A                    1231                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001D96  4EB9 00001DA2           1232                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001D9C                          1233  
00001D9C                          1234  
00001D9C                          1235  * exits subroutine
00001D9C  4CDF 2003               1236  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001DA0  4E75                    1237                      RTS                              ; returns from subroutine
00001DA2                          1238  
00001DA2                          1239  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001DA2                          1240  
00001DA2                          1241  * Prints out the content of D1 as a decimal number
00001DA2                          1242  * Input: number in D1 to be printed
00001DA2                          1243  * Output: contents of D1 printed
00001DA2  48E7 C000               1244  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001DA6  103C 0003               1245                   MOVE.B      #3,D0               ; prints D1
00001DAA  4E4F                    1246                   TRAP        #15                 ; is trap task 3
00001DAC                          1247              
00001DAC  4CDF 0003               1248                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001DB0  4E75                    1249                   RTS                             ; returns from subroutine
00001DB2                          1250                   
00001DB2                          1251  * Prints out the content of D1 as a hex number
00001DB2                          1252  * Input: number in D1 to be printed
00001DB2                          1253  * Output: contents of D1 printed
00001DB2  48E7 C000               1254  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001DB6  143C 0010               1255                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001DBA  103C 000F               1256                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001DBE  4E4F                    1257                   TRAP        #15                 ; is trap task 15
00001DC0  4CDF 0003               1258                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001DC4  4E75                    1259                   RTS                             ; returns from subroutine
00001DC6                          1260                   
00001DC6                          1261  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001DC6                          1262  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001DC6                          1263  * Output: contents of D1 printed
00001DC6  48E7 E000               1264  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001DCA  B83C 0001               1265                            CMP.B       #1,D4               ; checks size of number
00001DCE  6700 0042               1266                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001DD2                          1267  
00001DD2  3401                    1268  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001DD4  C47C F000               1269                            AND.W       #$F000,D2           ; gets the first digit
00001DD8  B47C 0000               1270                            CMP.W       #0, D2              ; checks if it is 0
00001DDC  6600 00DC               1271                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DE0  4EB9 00001ECA           1272                            JSR         PRINTZERO           ; prints a zero
00001DE6                          1273                            
00001DE6  3401                    1274                            MOVE.W      D1,D2               ; copies number to D2
00001DE8  C47C 0F00               1275                            AND.W       #$0F00,D2           ; gets the second digit
00001DEC  B47C 0000               1276                            CMP.W       #0, D2              ; checks if it is 0
00001DF0  6600 00C8               1277                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DF4  4EB9 00001ECA           1278                            JSR         PRINTZERO           ; prints a zero
00001DFA                          1279                            
00001DFA  3401                    1280                            MOVE.W      D1,D2               ; copies number to D2
00001DFC  C47C 00F0               1281                            AND.W       #$00F0,D2           ; gets the third digit
00001E00  B47C 0000               1282                            CMP.W       #0, D2              ; checks if it is 0
00001E04  6600 00B4               1283                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E08  4EB9 00001ECA           1284                            JSR         PRINTZERO           ; prints a zero
00001E0E  6000 00AA               1285                            BRA         PRINTASHEX          ; prints last digit
00001E12                          1286                            
00001E12  2401                    1287  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001E14  C4BC F0000000           1288                            AND.L       #$F0000000,D2       ; gets the first digit
00001E1A  B4BC 00000000           1289                            CMP.L       #0, D2              ; checks if it is 0
00001E20  6600 0098               1290                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E24  4EB9 00001ECA           1291                            JSR         PRINTZERO           ; prints a zero
00001E2A                          1292                            
00001E2A  2401                    1293                            MOVE.L      D1,D2               ; copies number to D2
00001E2C  C4BC 0F000000           1294                            AND.L       #$0F000000,D2       ; gets the second digit
00001E32  B4BC 00000000           1295                            CMP.L       #0, D2              ; checks if it is 0
00001E38  6600 0080               1296                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E3C  4EB9 00001ECA           1297                            JSR         PRINTZERO           ; prints a zero
00001E42                          1298                            
00001E42  2401                    1299                            MOVE.L      D1,D2               ; copies number to D2
00001E44  C4BC 00F00000           1300                            AND.L       #$00F00000,D2       ; gets the third digit
00001E4A  B4BC 00000000           1301                            CMP.L       #0, D2              ; checks if it is 0
00001E50  6600 0068               1302                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E54  4EB9 00001ECA           1303                            JSR         PRINTZERO           ; prints a zero
00001E5A                          1304                            
00001E5A  2401                    1305                            MOVE.L      D1,D2               ; copies number to D2
00001E5C  C4BC 000F0000           1306                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001E62  B4BC 00000000           1307                            CMP.L       #0, D2              ; checks if it is 0
00001E68  6600 0050               1308                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E6C  4EB9 00001ECA           1309                            JSR         PRINTZERO           ; prints a zero
00001E72                          1310                            
00001E72  2401                    1311                            MOVE.L      D1,D2               ; copies number to D2
00001E74  C4BC 0000F000           1312                            AND.L       #$0000F000,D2       ; gets the fith digit
00001E7A  B4BC 00000000           1313                            CMP.L       #0, D2              ; checks if it is 0
00001E80  6600 0038               1314                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E84  4EB9 00001ECA           1315                            JSR         PRINTZERO           ; prints a zero
00001E8A                          1316                            
00001E8A  2401                    1317                            MOVE.L      D1,D2               ; copies number to D2
00001E8C  C4BC 00000F00           1318                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001E92  B4BC 00000000           1319                            CMP.L       #0, D2              ; checks if it is 0
00001E98  6600 0020               1320                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E9C  4EB9 00001ECA           1321                            JSR         PRINTZERO           ; prints a zero
00001EA2                          1322                            
00001EA2  2401                    1323                            MOVE.L      D1,D2               ; copies number to D2
00001EA4  C4BC 000000F0           1324                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001EAA  B4BC 00000000           1325                            CMP.L       #0, D2              ; checks if it is 0
00001EB0  6600 0008               1326                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001EB4  4EB9 00001ECA           1327                            JSR         PRINTZERO           ; prints a zero
00001EBA                          1328  
00001EBA  143C 0010               1329  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001EBE  103C 000F               1330                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001EC2  4E4F                    1331                            TRAP        #15                 ; is trap task 15
00001EC4  4CDF 0007               1332                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001EC8  4E75                    1333                            RTS                             ; returns from subroutine    
00001ECA                          1334  * Prints a zero
00001ECA                          1335  * Input: nothing
00001ECA                          1336  * Output: 0 printed out to the console
00001ECA  2F01                    1337  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001ECC  7200                    1338                            MOVE.L      #0,D1               ; moves 0 to D1
00001ECE  4EB8 1DA2               1339                            JSR         PRINTNUM            ; prints the number
00001ED2  221F                    1340                            MOVE.L      (SP)+,D1            ; restores D1
00001ED4  4E75                    1341                            RTS                             ; returns from subroutine
00001ED6                          1342              
00001ED6                          1343  * Prints contents of things between a range
00001ED6                          1344  * input: A5, A6 (the range)
00001ED6                          1345  * output: prints memory contents from A5 to A6 as strings   
00001ED6  48E7 C040               1346  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001EDA  224D                    1347                  MOVEA.L     A5, A1           ; loads A5 into A1
00001EDC  9DCD                    1348                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001EDE  320E                    1349                  MOVE.W      A6, D1           ; move n into D1
00001EE0  103C 0001               1350                  MOVE.B      #1, D0           ; display n characters of string at A1
00001EE4  4E4F                    1351                  TRAP        #15              ; is trap task 1
00001EE6  4CDF 0203               1352                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001EEA  4E75                    1353                  RTS                          ; returns
00001EEC                          1354      
00001EEC                          1355  * Prints null terminated string
00001EEC                          1356  * input: string pointed to by A5
00001EEC                          1357  * output: prints out the null terminated string
00001EEC  48E7 8040               1358  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001EF0  224D                    1359                  MOVE.L      A5,A1           ; loads A5 into A1
00001EF2  103C 000E               1360                  MOVE.B      #14,D0          ; prints null terminated string
00001EF6  4E4F                    1361                  TRAP        #15             ; is trap task 10
00001EF8  4CDF 0201               1362                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001EFC  4E75                    1363                  RTS                         ; returns from subroutine
00001EFE                          1364                  
00001EFE  2F0D                    1365  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001F00  4BF9 00002136           1366                  LEA         NEW_LINE,A5     ; Prints null
00001F06  4EB8 1EEC               1367                  JSR         PRINTNULL       ; prints the new line
00001F0A  2A5F                    1368                  MOVE.L      (SP)+,A5        ; returns A5
00001F0C  4E75                    1369                  RTS
00001F0E                          1370  
00001F0E                          1371  * Prints the size of the MOVE or MOVEA operation  
00001F0E                          1372  * input: D0
00001F0E                          1373  * output: prints out the size of a MOVE or MOVEA operation        
00001F0E  48E7 8004               1374  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001F12  3200                    1375                  MOVE.W  D0,D1               ; stores d0 in d1
00001F14  C07C 3000               1376                  AND.W   #$3000,D0           ; gets the size
00001F18  B07C 2000               1377                  CMP.W   #$2000,D0           ; checks if is long
00001F1C  6700 001E               1378                  BEQ     MOVE_LONG
00001F20  B07C 3000               1379                  CMP.W   #$3000,D0           ; checks if is word
00001F24  6700 000C               1380                  BEQ     MOVE_WORD      
00001F28                          1381                  
00001F28  4BF9 00002241           1382  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001F2E  6000 0012               1383                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001F32                          1384  
00001F32  4BF9 00002247           1385  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001F38  6000 0008               1386                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001F3C                          1387  
00001F3C  4BF9 0000224D           1388  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001F42                          1389                  
00001F42  4EB8 1EEC               1390  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001F46  4CDF 2001               1391                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001F4A  4E75                    1392                  RTS
00001F4C                          1393  
00001F4C  43F9 000020DA           1394  ERROR           LEA     ERROR_MSG,A1
00001F52  103C 000E               1395                  MOVE.B  #14,D0
00001F56  4E4F                    1396                  TRAP    #15 
00001F58                          1397         
00001F58                          1398  * DELETE THIS: Test                
00001F58  2661                    1399  DELETEME        MOVEA.L  -(A1),A3
00001F5A  6700 0038               1400                  BEQ      DELETEMEAGAIN  
00001F5E  6F00 0034               1401                  BLE      DELETEMEAGAIN
00001F62  6E00 0030               1402                  BGT      DELETEMEAGAIN
00001F66                          1403  
00001F66  E40A                    1404                  LSR.B      #2,D2
00001F68  E2E2                    1405                  LSR.W      -(A2)
00001F6A  E2DA                    1406                  LSR.W      (A2)+
00001F6C  E4AA                    1407                  LSR.L      D2,D2 
00001F6E  E50A                    1408                  LSL.B      #2,D2
00001F70  E3E2                    1409                  LSL.W      -(A2)
00001F72  E3DA                    1410                  LSL.W      (A2)+
00001F74  E5AA                    1411                  LSL.L      D2,D2
00001F76  E51A                    1412                  ROL.B      #2,D2
00001F78  E7E2                    1413                  ROL.W      -(A2)
00001F7A  E7DA                    1414                  ROL.W      (A2)+
00001F7C  E5BA                    1415                  ROL.L      D2,D2
00001F7E  E41A                    1416                  ROR.B      #2,D2
00001F80  E6E2                    1417                  ROR.W      -(A2)
00001F82  E6DA                    1418                  ROR.W      (A2)+
00001F84  E4BA                    1419                  ROR.L      D2,D2
00001F86                          1420                  
00001F86  504D                    1421                  ADDQ.W      #8,A5
00001F88  D6C2                    1422                  ADDA.W      D2,A3
00001F8A  9BCB                    1423                  SUB.L       A3,A5        
00001F8C  8A43                    1424                  OR.W        D3,D5
00001F8E  4642                    1425                  NOT.W       D2
00001F90                          1426                  
00001F90  C5FC 0010               1427                  MULS.W    #$0010,D2
00001F94                          1428                  
00001F94                          1429  DELETEMEAGAIN                 
00001F94                          1430            
00001F94  FFFF FFFF               1431      SIMHALT             ; halt simulator
00001F98                          1432  
00001F98                          1433  * Put variables and constants here
00001F98                          1434  
00001F98  =0000000D               1435  CR                              EQU     $0D
00001F98  =0000000A               1436  LF                              EQU     $0A 
00001F98  =00000009               1437  TAB                             EQU     $09  
00001F98                          1438  
00001F98                          1439  * Addressing Modes
00001F98  =00000000               1440  Dn                              EQU     0
00001F98  =00000001               1441  An                              EQU     1
00001F98  =00000002               1442  AnIndirect                      EQU     2
00001F98  =00000003               1443  AnPost                          EQU     3
00001F98  =00000004               1444  AnPre                           EQU     4
00001F98  =00000007               1445  Other                           EQU     7           ; short, long, immediate
00001F98                          1446  
00001F98                          1447  * Xn
00001F98  =00000000               1448  ABSShort                        EQU     0
00001F98  =00000001               1449  ABSLong                         EQU     1
00001F98  =00000004               1450  XnImmediate                     EQU     4
00001F98                          1451  
00001F98                          1452  * Valid Addressing Modes
00001F98= 00 01 02 03 04 07 FF    1453  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001F9F                          1454  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001F9F= 00 02 03 04 07 FF       1455  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001FA5= 02 04 07 FF             1456  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001FA9= 02 03 07 FF             1457  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001FAD= 02 03 04 07 FF          1458  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001FB2= 00 02 03 04 07 FF       1459  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001FB8= 01 07 FF                1460  VALIDEA_LEA                     DC.B    An,Other,-1
00001FBB= 00 02 03 04 07 FF       1461  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001FC1= 02 03 04 07 FF          1462  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001FC6= 02 03 04 07 FF          1463  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001FCB= 02 07 FF                1464  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001FCE                          1465  
00001FCE                          1466  * Valid Xn
00001FCE= 00 01 04 FF             1467  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001FD2                          1468  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001FD2= 00 01 FF                1469  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001FD5                          1470  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001FD5                          1471  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001FD5                          1472  
00001FD5                          1473  * posible memory ASd/LSd rotation values
00001FD5  =00000000               1474  ASd_MEM                         EQU     0   
00001FD5  =00000001               1475  LSd_MEM                         EQU     1 
00001FD5  =00000003               1476  ROd_MEM                         EQU     3
00001FD5                          1477   
00001FD5  =00000000               1478  ASd_REG                         EQU     0   
00001FD5  =00000001               1479  LSd_REG                         EQU     1 
00001FD5  =00000003               1480  ROd_REG                         EQU     3
00001FD5                          1481  
00001FD5                          1482  * Messages
00001FD5= 57 65 6C 63 6F 6D ...   1483  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001FFC= 46 6F 72 6D 61 74 ...   1484                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
0000204B= 50 6C 65 61 73 65 ...   1485  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002082= 50 6C 65 61 73 65 ...   1486  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
000020B8= 49 6E 76 61 6C 69 ...   1487  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
000020DA= 45 72 72 6F 72 20 ...   1488  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
000020F6= 31 30 30 30 09 44 ...   1489  INVALID_INSTR                   DC.B    '1000',TAB,'DATA',TAB,'$',CR,LF,0
00002104= 46 69 6E 69 73 68 ...   1490  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
00002136= 0D 0A 00                1491  NEW_LINE                        DC.B    CR,LF,0
00002139= 09 09 09 00             1492  THREE_TAB                       DC.B    TAB,TAB,TAB,0
0000213D                          1493  
0000213D                          1494  * Opcode Messages
0000213D= 09 4E 4F 50 00          1495  MSG_NOP                         DC.B    TAB,'NOP',0
00002142= 09 4D 4F 56 45 00       1496  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00002148= 09 4D 4F 56 45 41 00    1497  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
0000214F= 09 4D 4F 56 45 51 00    1498  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00002156= 09 4D 4F 56 45 4D 00    1499  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
0000215D= 09 41 44 44 00          1500  MSG_ADD                         DC.B    TAB,'ADD',0
00002162= 09 41 44 44 41 00       1501  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002168= 09 41 44 44 51 00       1502  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
0000216E= 09 53 55 42 00          1503  MSG_SUB                         DC.B    TAB,'SUB',0
00002173= 09 4D 55 4C 53 00       1504  MSG_MULS                        DC.B    TAB,'MULS',0
00002179= 09 44 49 56 55 00       1505  MSG_DIVU                        DC.B    TAB,'DIVU',0
0000217F= 09 4C 45 41 09 09 ...   1506  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00002187= 09 41 4E 44 00          1507  MSG_AND                         DC.B    TAB,'AND',0
0000218C= 09 4F 52 00             1508  MSG_OR                          DC.B    TAB,'OR',0
00002190= 09 4E 4F 54 00          1509  MSG_NOT                         DC.B    TAB,'NOT',0
00002195= 09 4C 53 00             1510  MSG_LSd                         DC.B    TAB,'LS',0
00002199= 09 41 53 00             1511  MSG_ASd                         DC.B    TAB,'AS',0
0000219D= 09 52 4F 00             1512  MSG_ROd                         DC.B    TAB,'RO',0
000021A1= 09 42 43 43 09 09 ...   1513  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
000021A9= 09 42 43 53 09 09 ...   1514  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
000021B1= 09 42 45 51 09 09 ...   1515  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
000021B9= 09 42 4E 45 09 09 ...   1516  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
000021C1= 09 42 47 45 09 09 ...   1517  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
000021C9= 09 42 47 54 09 09 ...   1518  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
000021D1= 09 42 48 49 09 09 ...   1519  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
000021D9= 09 42 4C 45 09 09 ...   1520  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
000021E1= 09 42 4C 53 09 09 ...   1521  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
000021E9= 09 42 4C 54 09 09 ...   1522  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
000021F1= 09 42 4D 49 09 09 ...   1523  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
000021F9= 09 42 50 4C 09 09 ...   1524  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00002201= 09 42 56 43 09 09 ...   1525  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00002209= 09 42 56 53 09 09 ...   1526  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00002211= 09 4A 53 52 09 09 ...   1527  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00002219= 09 52 54 53 00          1528  MSG_RTS                         DC.B    TAB,'RTS',0
0000221E= 09 42 52 41 09 09 ...   1529  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00002226                          1530  
00002226                          1531  * Direction for LSd and ASd
00002226= 52 00                   1532  MSG_RIGHT                       DC.B    'R',0
00002228= 4C 00                   1533  MSG_LEFT                        DC.B    'L',0
0000222A                          1534  
0000222A                          1535  * Effective Addresses Messages
0000222A= 44 00                   1536  MSG_DR                          DC.B    'D',0
0000222C= 41 00                   1537  MSG_AR                          DC.B    'A',0
0000222E= 28 00                   1538  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002230= 29 00                   1539  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00002232= 2B 00                   1540  MSG_PLUS                        DC.B    '+',0
00002234= 2D 00                   1541  MSG_MINUS                       DC.B    '-',0
00002236= 23 00                   1542  MSG_POUND                       DC.B    '#',0 
00002238= 24 00                   1543  MSG_HEX                         DC.B    '$',0 
0000223A= 2C 20 00                1544  MSG_COMMA                       DC.B    ', ',0 
0000223D= 20 00                   1545  MSG_SPACE                       DC.B    ' ',0
0000223F= 09 00                   1546  MSG_TAB                         DC.B    TAB,0
00002241                          1547  
00002241                          1548  * Size Messages
00002241= 2E 42 09 09 09 00       1549  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00002247= 2E 57 09 09 09 00       1550  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
0000224D= 2E 4C 09 09 09 00       1551  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00002253                          1552  
00002253                          1553  * Variables
00002253  =00000100               1554  STARTING_ADDRESS                EQU     $100
00002253  =00000150               1555  ENDING_ADDRESS                  EQU     $150
00002253  =00000200               1556  CURRENT_INSTR                   EQU     $200
00002253  =00000250               1557  REG_VAR                         EQU     $250 * Hold bits 11-9
00002253  =00000300               1558  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00002253  =00000350               1559  EA_MODE                         EQU     $350 * Hold bits 5-3
00002253  =00000400               1560  EA_REG                          EQU     $400 * Hold bits 2-0
00002253                          1561  
00002253                          1562              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           14D0
ADDQ_BYTE           1566
ADDQ_LONG           1586
ADDQ_WORD           1576
ADD_SUB_BYTE        140C
ADD_SUB_HELP        138A
ADD_SUB_LONG        1428
ADD_SUB_OPERAND     143E
ADD_SUB_SIZE        13E8
ADD_SUB_WORD        141A
AN                  1
AND_BYTE            1750
AND_LONG            1770
AND_WORD            1760
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           20B8
CASE_ADD            135E
CASE_ADDA           14A4
CASE_ADDQ           150C
CASE_AND            1706
CASE_AR             1C6A
CASE_ARI            1C82
CASE_ARIPOST        1CB2
CASE_ARIPRE         1CEE
CASE_ASDMEM         188C
CASE_ASDREG         1954
CASE_BCC            1A8C
CASE_BEQ            1ABE
CASE_BGT            1AD2
CASE_BLE            1AC8
CASE_BRA            1A68
CASE_DATA           1B02
CASE_DR             1C52
CASE_EPICFAIL       1B04
CASE_IMMEDIATE      1D3C
CASE_JSR            1AEC
CASE_LEA            1674
CASE_LEFTMEM        18B2
CASE_LEFTREG        197A
CASE_LONG           1D7C
CASE_LSDASD         184C
CASE_LSDMEM         1882
CASE_LSDREG         194A
CASE_MOVE           11FA
CASE_MOVEM          12A0
CASE_MOVEQ          1306
CASE_NOP            11E0
CASE_NOT            17F0
CASE_OR             1798
CASE_OTHER          1D2A
CASE_RIGHTMEM       18BC
CASE_RIGHTREG       1984
CASE_RODMEM         1896
CASE_RODREG         195E
CASE_RTS            1AEC
CASE_SHIFTMEM       186A
CASE_SHIFTREG       1930
CASE_SUB            15E4
CASE_SUBA           165E
CASE_WORD           1D60
CHECKEAEXIT         1C22
CHECKEAMLOOP        1BF4
CHECKEAXN_IFVALID   1BF2
CHECKGET_EAXN       1B5A
CHECKMEMSOURE       18F0
CHECKSHIFT_XN       191A
CHECK_LENGTH        1132
CHECK_ODD           11C8
CHECK_ORDER         109A
CHECK_XN            1B8A
CONCAT              117A
CONVERT             1144
CR                  D
CURRENT_INSTR       200
DELETEME            1F58
DELETEMEAGAIN       1F94
DESTEA              1B10
DESTXN              1B3A
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          1478
DONE                2104
EASHIFT_VALID       190E
EAXN_INVALID        1B9C
EAXN_VALID          1B82
EA_MODE             350
EA_REG              400
EA_TO_STRING        1C26
EA_TO_STRING_EXIT   1D9C
ENDING              2082
ENDING_ADDRESS      150
END_CHECKGET        1BA0
ERROR               1F4C
ERROR_MSG           20DA
FINDTYPEEA          1B24
FINDTYPEXN          1B4E
FINISHED            10B4
FINISHMOVE          1F42
FINISH_ADD          1436
FINISH_ADDA         14E0
FINISH_ADDQ         1596
FINISH_AND          1780
FINISH_SUB          1624
FINISH_SUBA         162A
GETDIRECTION        1BDA
GETDISPLACEMENT     1BA2
GETMEMSOURCE        18D8
GETROTATION         1BD0
GETROTATIONLOCATION  1BEA
GETROTATIONSIZE     1BE2
GET_EA              1B06
GET_XN              1B30
INPUT1              100C
INPUT2              1052
INSERTA             126C
INVALID             1192
INVALIDEA           1C06
INVALID_INSTR       20F6
INV_INSTR           178A
ISNUMBER            115A
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       1306
MOVEM_REG2MEM       12D6
MOVE_BYTE           1F28
MOVE_LONG           1F3C
MOVE_WORD           1F32
MSG_ADD             215D
MSG_ADDA            2162
MSG_ADDQ            2168
MSG_AND             2187
MSG_AR              222C
MSG_ASD             2199
MSG_B               2241
MSG_BCC             21A1
MSG_BCS             21A9
MSG_BEQ             21B1
MSG_BGE             21C1
MSG_BGT             21C9
MSG_BHI             21D1
MSG_BLE             21D9
MSG_BLS             21E1
MSG_BLT             21E9
MSG_BMI             21F1
MSG_BNE             21B9
MSG_BPL             21F9
MSG_BRA             221E
MSG_BVC             2201
MSG_BVS             2209
MSG_COMMA           223A
MSG_DIVU            2179
MSG_DR              222A
MSG_HEX             2238
MSG_JSR             2211
MSG_L               224D
MSG_LB              222E
MSG_LEA             217F
MSG_LEFT            2228
MSG_LSD             2195
MSG_MINUS           2234
MSG_MOVE            2142
MSG_MOVEA           2148
MSG_MOVEM           2156
MSG_MOVEQ           214F
MSG_MULS            2173
MSG_NOP             213D
MSG_NOT             2190
MSG_OR              218C
MSG_PLUS            2232
MSG_POUND           2236
MSG_RB              2230
MSG_RIGHT           2226
MSG_ROD             219D
MSG_RTS             2219
MSG_SPACE           223D
MSG_SUB             216E
MSG_TAB             223F
MSG_W               2247
NEW_LINE            2136
NOTNUMBER           1162
OPCODE_DECODE       11DC
OPMODE_VAR          300
OR_SIZE             17D8
OTHER               7
OTHEREA             1C1E
PRINTADD            13D0
PRINTADDRESS        1BB2
PRINTASHEX          1EBA
PRINTBCC            1ADC
PRINTENTER          1EFE
PRINTHEXNUM         1DB2
PRINTLONGZERO       1E12
PRINTMOVE           1272
PRINTMOVESIZE       1F0E
PRINTNULL           1EEC
PRINTNUM            1DA2
PRINTRANGE          1ED6
PRINTREGEA          19C6
PRINTREGSIZE        1994
PRINTSHIFTMEM       189C
PRINTSHIFTREG       1964
PRINTSHORTLONGNUM   1DC6
PRINTSHORTZERO      1DD2
PRINTSUB            15FE
PRINTZERO           1ECA
PRINT_8             15D8
PRINT_ADDQ_DATA     15B4
PRINT_ADDR          11D0
PRINT_MEMDIR        18C2
PRINT_MOVEQ         1328
PRINT_REGDIR        198E
REG2MEMXNCHECK      12F0
REG_BYTE            19AC
REG_IMMEDIATE       19DC
REG_LONG            19C0
REG_REGISTER        1A22
REG_VAR             250
REG_WORD            19B6
RESET_INPUT         112A
RESTART             10D4
RETURN              1190
ROD_MEM             3
ROD_REG             3
SOURCEEA            1B1C
SOURCEXN            1B46
START               1000
STARTING            204B
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11B0
THREE_TAB           2139
VALIDEA             1C0E
VALIDEA_ADDSUB_DESTOPERAND  1FAD
VALIDEA_ALL         1F98
VALIDEA_ANDORNOT    1FBB
VALIDEA_ANDOR_DESTOPERAND  1FC1
VALIDEA_JSR         1FCB
VALIDEA_LEA         1FB8
VALIDEA_MOVEM_MEMTOREG  1FA9
VALIDEA_MOVEM_REGTOMEM  1FA5
VALIDEA_MOVEQ       1F9F
VALIDEA_MULSDIVU    1FB2
VALIDEA_SHIFT       1FC6
VALIDXN_ALL         1FCE
VALIDXN_SHORTLONG   1FD2
WELCOME             1FD5
XNIMMEDIATE         4
