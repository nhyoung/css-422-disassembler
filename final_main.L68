00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/8/2020 12:53:57 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00002139             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 000021AF             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 00001132             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 00001144             28                  JSR     CONVERT
0000103E  4EB9 000011B0             29                  JSR     TEST_RANGE
00001044  4EB9 000011C8             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 000021E6             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 00001132             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 00001144             47                  JSR     CONVERT
00001086  4EB9 000011B0             48                  JSR     TEST_RANGE
0000108C  4EB9 000011C8             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0088                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4                            58  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010A4                            59                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A4                            60                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010A4  4EB9 000011E4             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010AA  4EB9 00002062             62                  JSR     PRINTENTER          ; prints a new line
000010B0  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010B2  6FF0                      64                  BLE     DISASSEMBLE         ; if not, loop
000010B4                            65  
000010B4  4BF9 00002266             66  FINISHED        LEA     DONE,A5
000010BA  4EB9 00002050             67                  JSR     PRINTNULL
000010C0  103C 0005                 68                  MOVE.B  #5,D0
000010C4  4E4F                      69                  TRAP    #15
000010C6                            70                  
000010C6  B23C 000D                 71                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010CA  6700 0008                 72                  BEQ     RESTART             ; it's Enter, restart
000010CE                            73                  
000010CE  103C 0009                 74                  MOVE.B  #9,D0
000010D2  4E4F                      75                  TRAP    #15
000010D4                            76                  
000010D4  103C 000B                 77  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010D8  323C FF00                 78                  MOVE.W  #$FF00, D1          Clear Screen
000010DC  4E4F                      79                  TRAP    #15                 Call Trap
000010DE                            80                  
000010DE  103C 000C                 81                  MOVE.B  #12,D0              Keyboard echo
000010E2  123C 0001                 82                  MOVE.B  #1,D1               Visible
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  207C 00000000             85                  MOVE.L  #$0000000, A0       ; Reset A1
000010EE  227C 00000000             86                  MOVE.L  #$0000000, A1       ; Reset A1
000010F4  247C 00000000             87                  MOVE.L  #$0000000, A2       ; Reset A2
000010FA  267C 00000000             88                  MOVE.L  #$0000000, A3       ; Reset A3
00001100  287C 00000000             89                  MOVE.L  #$0000000, A4       ; Reset A4
00001106  2A7C 00000000             90                  MOVE.L  #$0000000, A5       ; Reset A5
0000110C  2C7C 00000000             91                  MOVE.L  #$0000000, A6       ; Reset A6
00001112  2E7C 01000000             92                  MOVEA.L #$01000000,A7       ; Reset A7
00001118  4281                      93                  CLR.L   D1                  ; Reset D1
0000111A  4281                      94                  CLR.L   D1                  ; Reset D1
0000111C  4282                      95                  CLR.L   D2                  ; Reset D2
0000111E  4283                      96                  CLR.L   D3                  ; Reset D3
00001120  4284                      97                  CLR.L   D4                  ; Reset D4
00001122  4285                      98                  CLR.L   D5                  ; Reset D5
00001124  4286                      99                  CLR.L   D6                  ; Reset D6
00001126  6000 FED8                100                  BRA     START               ; branch to start of program
0000112A                           101  
0000112A                           102  *--------------------SUBROUTINES------------------    
0000112A                           103  
0000112A  143C 0001                104  RESET_INPUT     MOVE.B  #1,D2
0000112E  6000 0062                105                  BRA     INVALID            
00001132                           106                  
00001132  7800                     107  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001134  B204                     108                  CMP.B   D4,D1               ; D1 stores length
00001136  6700 005A                109                  BEQ     INVALID             ; input is null
0000113A  0C41 0008                110                  CMPI    #$8,D1              ; check if input is longer than a longword
0000113E  6600 0052                111                  BNE     INVALID             ; input is longer than a longword
00001142  4E75                     112                  RTS
00001144                           113                              
00001144  4283                     114  CONVERT         CLR.L   D3
00001146  4284                     115                  CLR.L   D4
00001148  1619                     116                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000114A  B63C 0039                117                  CMP.B   #57,D3
0000114E  6E00 0012                118                  BGT     NOTNUMBER
00001152                           119                  
00001152  B63C 002F                120                  CMP.B   #47,D3
00001156  6E00 0002                121                  BGT     ISNUMBER
0000115A                           122                  
0000115A  0603 00D0                123  ISNUMBER        ADD.B   #-48,D3             ; current char is number
0000115E  6000 001A                124                  BRA     CONCAT
00001162                           125              
00001162  B63C 0041                126  NOTNUMBER       CMP.B   #65,D3
00001166  6D00 002A                127                  BLT     INVALID
0000116A  B63C 0046                128                  CMP.B   #70,D3
0000116E  6E00 0022                129                  BGT     INVALID  
00001172  0603 00C9                130                  ADD.B   #-55,D3             ; is letter             
00001176  6000 0002                131                  BRA     CONCAT
0000117A                           132              
0000117A  BC3C 0000                133  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000117E  6D00 0010                134                  BLT     RETURN
00001182  1806                     135                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001184  E50C                     136                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001186  E9AB                     137                  LSL.L   D4,D3               ; moves current char to correct position  
00001188  DA83                     138                  ADD.L   D3,D5               ; D5 stores converted input so far
0000118A  0606 00FF                139                  ADD.B   #-1,D6  
0000118E  60B4                     140                  BRA     CONVERT             ; continue loop for remaining chars
00001190                           141                  
00001190  4E75                     142  RETURN          RTS
00001192                           143                  
00001192  227C 00000000            144  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001198  43F9 0000221C            145                  LEA     BAD_INPUT,A1        ; output invalid message
0000119E  103C 000E                146                  MOVE.B  #14,D0
000011A2  4E4F                     147                  TRAP    #15
000011A4  B47C 0001                148                  CMP     #1,D2
000011A8  6700 FE62                149                  BEQ     INPUT1
000011AC  6000 FEA4                150                  BRA     INPUT2
000011B0                           151  
000011B0  4284                     152  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011B2  223C 00001000            153                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011B8  BA81                     154                  CMP.L      D1,D5            ; Compare minimum address with input
000011BA  6DD6                     155                  BLT        INVALID          ; input is too low. 
000011BC  223C 00FFFFFE            156                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011C2  BA81                     157                  CMP.L      D1,D5            ; compare maximum address with input
000011C4  6ECC                     158                  BGT        INVALID          ; input too large
000011C6  4E75                     159                  RTS                         ; input is within range
000011C8                           160             
000011C8  0805 0000                161  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011CC  66C4                     162                  BNE        INVALID
000011CE  4E75                     163                  RTS
000011D0                           164  
000011D0  48E7 4800                165  PRINT_ADDR      MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
000011D4  220E                     166                  MOVE.L  A6,D1                   ; loads current address in D1
000011D6  7801                     167                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011D8  4EB9 00001F2A            168                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011DE  4CDF 0012                169                  MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
000011E2  4E75                     170                  RTS
000011E4                           171  
000011E4                           172  
000011E4                           173  * Checks every single possible opcode we could have. Jump table
000011E4                           174  * Inputs: (A2) which is a pointer to intruction word to be translated
000011E4                           175  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011E4                           176  
000011E4  3C4A                     177  OPCODE_DECODE   MOVE.W  A2,A6
000011E6  301A                     178                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011E8                           179                  
000011E8                           180  
000011E8                           181  *---------------NOP opcode----------------------                
000011E8  B07C 4E71                182  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011EC  6600 0014                183                  BNE     CASE_MOVE               ; checks the next case if not equal
000011F0                           184                  
000011F0  4EB8 11D0                185                  JSR     PRINT_ADDR
000011F4  4BF9 0000229F            186                  LEA     MSG_NOP,A5              ; loads string pointer into A5
000011FA  4EB9 00002050            187                  JSR     PRINTNULL               ; prints NOP                
00001200  4E75                     188                  RTS                             ; returns from the subroutine
00001202                           189  
00001202                           190  *---------------MOVE opcode----------------------              
00001202                           191                  * if first two bits are 00, next two are not 00
00001202  3200                     192  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001204  C27C C000                193                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001208  6600 009E                194                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
0000120C  B07C 0FFF                195                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001210  6F00 0096                196                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001214                           197                  
00001214                           198                  ; Check source
00001214  4BF9 000020FC            199                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000121A  4DF9 00002132            200                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001220  3E3C 0000                201                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001224  4EB9 00001C1C            202                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000122A  B27C 0001                203                  CMP.W   #1,D1                    ; checks if invalid
0000122E  6700 0994                204                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001232  3802                     205                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
00001234  3A03                     206                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001236                           207                  
00001236                           208                  ; Check destination
00001236  4BF9 000020FC            209                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000123C  4DF9 00002136            210                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001242  3E3C 0001                211                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001246  4EB9 00001C1C            212                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000124C  B27C 0001                213                  CMP.W   #1,D1                    ; checks if invalid
00001250  6700 0972                214                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001254  3C02                     215                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001256  3E03                     216                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001258                           217                  
00001258                           218                  ; Checking if it is MOVEA
00001258  3200                     219                  MOVE.W  D0,D1                    ; stores d0 in d1
0000125A  C27C 01C0                220                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
0000125E  B27C 0040                221                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
00001262  6700 0010                222                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001266                           223                  
00001266  4EB8 11D0                224                  JSR     PRINT_ADDR               ; print address
0000126A  4BF9 000022A4            225                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001270  6000 0008                226                  BRA     PRINTMOVE                ; Branches to print move
00001274                           227                  
00001274  4BF9 000022AA            228  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
0000127A                           229   
0000127A  4EB9 00002050            230  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001280  4EB9 00002072            231                  JSR     PRINTMOVESIZE            ; prints out the size  
00001286  3404                     232                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001288  3605                     233                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000128A  4EB9 00001D8A            234                  JSR     EA_TO_STRING             ; outputs it into a string
00001290                           235                  
00001290                           236                  ; prints a comma to seperate
00001290  4BF9 0000239C            237                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001296  4EB9 00002050            238                  JSR     PRINTNULL                ; prints out MOVE
0000129C                           239                  
0000129C                           240                  ; print destination
0000129C  3406                     241                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000129E  3607                     242                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
000012A0  4EB9 00001D8A            243                  JSR     EA_TO_STRING             ; outputs it into a string
000012A6  4E75                     244                  RTS                              ; exits subroutine                 
000012A8                           245                
000012A8                           246  *---------------MOVEM opcode----------------------                
000012A8  3200                     247  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012AA  C27C FB80                248                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012AE  B27C 4880                249                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012B2  6600 00F4                250                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012B6                           251                  
000012B6                           252                  ; Check D
000012B6  3200                     253                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012B8  C27C 0400                254                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012BC  3E01                     255                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012BE  B27C 0400                256                  CMP.W   #$0400,D1                       ; checks if value is 1
000012C2  6700 0074                257                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012C6                           258  
000012C6                           259  MOVEM_REG2MEM   ; loads EA and XN
000012C6  3E3C 0000                260                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000012CA  4BF9 00002109            261                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
000012D0  4DF9 00002136            262                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000012D6  4EB9 00001C1C            263                  JSR     CHECKGET_EAXN
000012DC  B27C 0001                264                  CMP.W   #1,D1                           ; checks if D1 invalid
000012E0  6700 08E2                265                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000012E4  4EB8 11D0                266                  JSR     PRINT_ADDR                      ; prints the address
000012E8  4BF9 000022B8            267                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000012EE  4EB9 00002050            268                  JSR     PRINTNULL                       ; prints MOVEM
000012F4                           269                  
000012F4                           270                  ; finds and prints size
000012F4  3200                     271                  MOVE.W  D0,D1                           ; copies D0
000012F6  C27C 0040                272                  AND.W   #$0040,D1                       ; gets the size bit
000012FA  6600 0012                273                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000012FE                           274  
000012FE  4BF9 000023AB            275  REG2MEMWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001304  4EB9 00002050            276                  JSR     PRINTNULL                       ; prints MOVEM
0000130A  6000 000E                277                  BRA     PRINTREG2MEM                    ; prints the registers           
0000130E                           278                  
0000130E  4BF9 000023B1            279  REG2MEMLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001314  4EB9 00002050            280                  JSR     PRINTNULL                       ; prints MOVEM 
0000131A                           281             
0000131A  383C 0001                282  PRINTREG2MEM    MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
0000131E  4EB9 00001CB4            283                  JSR     PRINTREGISTERS                  ; prints registers
00001324  4BF9 0000239C            284                  LEA     MSG_COMMA,A5                    ; loads comma
0000132A  4EB9 00002050            285                  JSR     PRINTNULL                       ; prints comma
00001330  4EB9 00001D8A            286                  JSR     EA_TO_STRING                    ; prints EA
00001336  4E75                     287                  RTS
00001338                           288  
00001338                           289  MOVEM_MEM2REG  ; loads EA and XN
00001338  3E3C 0000                290                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000133C  4BF9 0000210D            291                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
00001342  4DF9 00002136            292                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001348  4EB9 00001C1C            293                  JSR     CHECKGET_EAXN
0000134E  B27C 0001                294                  CMP.W   #1,D1                           ; checks if D1 invalid
00001352  6700 0870                295                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001356  4EB8 11D0                296                  JSR     PRINT_ADDR                      ; prints the address
0000135A  4BF9 000022B8            297                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001360  4EB9 00002050            298                  JSR     PRINTNULL                       ; prints MOVEM
00001366                           299                  
00001366                           300                  ; finds and prints size
00001366  3200                     301                  MOVE.W  D0,D1                           ; copies D0
00001368  C27C 0040                302                  AND.W   #$0040,D1                       ; gets the size bit
0000136C  6600 0010                303                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001370                           304  
00001370  4BF9 000023AB            305  MEM2REGWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001376  4EB9 00002050            306                  JSR     PRINTNULL                       ; prints MOVEM
0000137C  609C                     307                  BRA     PRINTREG2MEM                    ; prints the registers           
0000137E                           308                  
0000137E  4BF9 000023B1            309  MEM2REGLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001384  4EB9 00002050            310                  JSR     PRINTNULL                       ; prints MOVEM 
0000138A                           311             
0000138A  4EB9 00001D8A            312  PRINTMEM2REG    JSR     EA_TO_STRING                    ; prints EA
00001390  4BF9 0000239C            313                  LEA     MSG_COMMA,A5                    ; loads comma
00001396  4EB9 00002050            314                  JSR     PRINTNULL                       ; prints comma
0000139C  383C FFFF                315                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
000013A0  4EB9 00001CB4            316                  JSR     PRINTREGISTERS                  ; prints registers
000013A6  4E75                     317                  RTS
000013A8                           318                          
000013A8                           319  
000013A8                           320  *---------------MOVEQ opcode----------------------
000013A8  3200                     321  CASE_MOVEQ      MOVE.W  D0,D1
000013AA  C27C F100                322                  AND.W   #$F100,D1
000013AE  B27C 7000                323                  CMP.W   #$7000,D1
000013B2  6600 004C                324                  BNE     CASE_ADD
000013B6                           325                  
000013B6                           326                  ;loads Register
000013B6  323C 0001                327                  MOVE.W  #1,D1                           ; copies instruction word to D1
000013BA  4EB9 00001BF2            328                  JSR     GET_XN                          ; gets XN and puts in D1
000013C0  3401                     329                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000013C2                           330                  
000013C2                           331                  ;loads DATA
000013C2  3200                     332                  MOVE.W  D0,D1
000013C4  C27C 00FF                333                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000013C8  3601                     334                  MOVE.W  D1,D3                          ;copy data into D3
000013CA                           335                                                        ;must convert bits to hex
000013CA                           336                                  
000013CA  4EB8 11D0                337  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
000013CE                           338  
000013CE  4BF9 000022B1            339                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000013D4  4EB9 00002050            340                  JSR     PRINTNULL  
000013DA                           341                  
000013DA  4BF9 000023B1            342                  LEA     MSG_L,A5                        ;PRINT SIZE L
000013E0  4EB9 00002050            343                  JSR     PRINTNULL
000013E6                           344      
000013E6  4BF9 0000229B            345                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000013EC  4EB9 00002050            346                  JSR     PRINTNULL
000013F2                           347                  
000013F2  4BF9 00002398            348                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000013F8  4EB9 00002050            349                  JSR     PRINTNULL
000013FE  4E75                     350                  RTS
00001400                           351                  
00001400                           352  *---------------ADD opcode----------------------                
00001400                           353  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
00001400  3200                     354  CASE_ADD        MOVE.W  D0,D1
00001402  C27C F000                355                  AND.W   #$F000,D1
00001406  B27C D000                356                  CMP.W   #$D000,D1
0000140A  6600 01A2                357                  BNE     CASE_ADDQ
0000140E                           358                  
0000140E  4EB8 11D0                359                  JSR     PRINT_ADDR              ; print address
00001412                           360                  
00001412  4EB9 0000142C            361                  JSR     ADD_SUB_HELP
00001418                           362                  
00001418                           363                  ; bits 7-8 determine if it is ADDA or ADD
00001418  3200                     364                  MOVE.W  D0,D1
0000141A  E149                     365                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000141C  E049                     366                  LSR.W   #8,D1
0000141E  EC49                     367                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001420  B27C 0003                368                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001424  6700 0120                369                  BEQ     CASE_ADDA
00001428                           370                  
00001428  6000 0048                371                  BRA     PRINTADD                ; Branches to print add
0000142C                           372                  
0000142C                           373                  ; Check bits 0-5 
0000142C  4BF9 000020FC            374  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001432  4DF9 00002132            375                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001438  3E3C 0000                376                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000143C  4EB9 00001C1C            377                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001442  B27C 0001                378                  CMP.W       #1,D1                    ; checks if invalid
00001446  6700 077C                379                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000144A  3802                     380                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
0000144C  3A03                     381                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000144E                           382                  
0000144E                           383                  ; Check 6-11
0000144E  4BF9 000020FC            384                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001454  4DF9 00002136            385                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000145A  3E3C 0001                386                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000145E  4EB9 00001C1C            387                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001464  B27C 0001                388                  CMP.W       #1,D1                    ; checks if invalid
00001468  6700 075A                389                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000146C  3C02                     390                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
0000146E  3E03                     391                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001470                           392    
00001470  4E75                     393                  RTS                
00001472                           394                    
00001472  4BF9 000022BF            395  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001478  4EB9 00002050            396                  JSR         PRINTNULL               ; print ADD
0000147E  3200                     397                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001480  4EB9 0000148A            398                  JSR         ADD_SUB_SIZE
00001486  6000 0050                399                  BRA         FINISH_ADD
0000148A                           400                    
0000148A  3200                     401  ADD_SUB_SIZE    MOVE.W      D0,D1
0000148C  E149                     402                  LSL.W       #8,D1
0000148E  E049                     403                  LSR.W       #8,D1
00001490  EC49                     404                  LSR.W       #6,D1                   ; gets bits 6-7
00001492                           405                    
00001492  B27C 0000                406                  CMP.W       #0,D1
00001496  6700 0016                407                  BEQ         ADD_SUB_BYTE
0000149A  B27C 0001                408                  CMP.W       #1,D1                   ; if 1, it is a word
0000149E  6700 001C                409                  BEQ         ADD_SUB_WORD
000014A2  B27C 0002                410                  CMP.W       #2,D1                   ; if 2, it is a long
000014A6  6700 0022                411                  BEQ         ADD_SUB_LONG
000014AA  6000 0254                412                  BRA         CASE_SUBA                    ; error
000014AE                           413                    
000014AE  4BF9 000023A5            414  ADD_SUB_BYTE    LEA         MSG_B,A5
000014B4  4EB9 00002050            415                  JSR         PRINTNULL
000014BA  4E75                     416                  RTS
000014BC                           417                    
000014BC  4BF9 000023AB            418  ADD_SUB_WORD    LEA         MSG_W,A5
000014C2  4EB9 00002050            419                  JSR         PRINTNULL
000014C8  4E75                     420                  RTS
000014CA                           421    
000014CA  4BF9 000023B1            422  ADD_SUB_LONG    LEA         MSG_L,A5
000014D0  4EB9 00002050            423                  JSR         PRINTNULL
000014D6  4E75                     424                  RTS
000014D8                           425        
000014D8  4EB9 000014E0            426  FINISH_ADD      JSR         ADD_SUB_OPERAND
000014DE  4E75                     427                  RTS
000014E0                           428    
000014E0  EF49                     429  ADD_SUB_OPERAND LSL.W       #7,D1
000014E2  EE49                     430                  LSR.W       #7,D1
000014E4  E049                     431                  LSR.W       #8,D1
000014E6  B27C 0001                432                  CMP.W       #1,D1
000014EA  6600 002E                433                  BNE         Dn_PLUS_EA          
000014EE                           434                    
000014EE                           435                  ; print Data Register
000014EE  4BF9 0000238C            436                  LEA         MSG_DR,A5
000014F4  4EB9 00002050            437                  JSR         PRINTNULL
000014FA  3207                     438                  MOVE.W      D7,D1
000014FC  4EB9 00001F06            439                  JSR         PRINTNUM                
00001502                           440                  
00001502                           441                  ; prints a comma to seperate
00001502  4BF9 0000239C            442                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001508  4EB9 00002050            443                  JSR         PRINTNULL                ; prints out MOVE
0000150E                           444                 
0000150E                           445                  ; below is EA+Dn->Dn  
0000150E  3404                     446                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001510  3605                     447                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001512  4EB9 00001D8A            448                  JSR         EA_TO_STRING             ; outputs it into a string
00001518  4E75                     449                  RTS                                 ; exits subroutine 
0000151A                           450  
0000151A                           451  Dn_PLUS_EA      ; below is Dn+EA->EA  
0000151A  3404                     452                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000151C  3605                     453                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000151E  4EB9 00001D8A            454                  JSR         EA_TO_STRING             ; outputs it into a string   
00001524                           455                  
00001524                           456                  ; prints a comma to seperate
00001524  4BF9 0000239C            457                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000152A  4EB9 00002050            458                  JSR         PRINTNULL                ; prints out MOVE
00001530                           459                  
00001530                           460                  ; below is Dn+EA->EA
00001530  4BF9 0000238C            461                  LEA         MSG_DR,A5                ; print data register
00001536  4EB9 00002050            462                  JSR         PRINTNULL
0000153C  3207                     463                  MOVE.W      D7,D1
0000153E  4EB9 00001F06            464                  JSR         PRINTNUM             
00001544  4E75                     465                  RTS                                  ; exits subroutine          
00001546                           466                        
00001546                           467  *---------------ADDA opcode----------------------
00001546                           468  CASE_ADDA       ; gets bit 8 (size bit)
00001546  3200                     469                  MOVE.W      D0,D1
00001548  EF49                     470                  LSL.W       #7,D1
0000154A  EE49                     471                  LSR.W       #7,D1
0000154C  E049                     472                  LSR         #8,D1                   
0000154E                           473                  
0000154E  4BF9 000022C4            474                  LEA         MSG_ADDA,A5             ; print ADDA
00001554  4EB9 00002050            475                  JSR         PRINTNULL
0000155A                           476                   
0000155A  B27C 0001                477                  CMP.W       #1,D1
0000155E  6700 0012                478                  BEQ         ADDA_LONG
00001562                           479                    
00001562  4BF9 000023AB            480                  LEA         MSG_W,A5
00001568  4EB9 00002050            481                  JSR         PRINTNULL
0000156E  6000 0012                482                  BRA         FINISH_ADDA   
00001572                           483                    
00001572  4BF9 000023B1            484  ADDA_LONG       LEA         MSG_L,A5
00001578  4EB9 00002050            485                  JSR         PRINTNULL
0000157E  6000 0002                486                  BRA         FINISH_ADDA
00001582                           487                    
00001582  3404                     488  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001584  3605                     489                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001586  4EB9 00001D8A            490                  JSR         EA_TO_STRING             ; outputs it into a string
0000158C                           491                    
0000158C                           492                  ; prints a comma to seperate
0000158C  4BF9 0000239C            493                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001592  4EB9 00002050            494                  JSR         PRINTNULL                ; prints out MOVE
00001598                           495            
00001598  4BF9 0000238E            496                  LEA         MSG_AR,A5                ; print address register
0000159E  4EB9 00002050            497                  JSR         PRINTNULL
000015A4  3207                     498                  MOVE.W      D7,D1
000015A6  4EB9 00001F06            499                  JSR         PRINTNUM             
000015AC  4E75                     500                  RTS                              ; exits subroutine
000015AE                           501                  
000015AE                           502  *---------------ADDQ opcode----------------------                  
000015AE  3200                     503  CASE_ADDQ       MOVE.W      D0,D1
000015B0  C27C F000                504                  AND.W       #$F000,D1       
000015B4  B27C 5000                505                  CMP.W       #$5000,D1
000015B8  6600 00CC                506                  BNE         CASE_SUB
000015BC                           507                                                   
000015BC  4EB8 11D0                508                  JSR         PRINT_ADDR              ; print address  
000015C0  4BF9 000022CA            509                  LEA         MSG_ADDQ,A5             ; print ADDQ
000015C6  4EB9 00002050            510                  JSR         PRINTNULL
000015CC                           511                  
000015CC                           512                  ; get bits 6-7 (size bits)
000015CC  3200                     513                  MOVE.W      D0,D1
000015CE  E149                     514                  LSL.W       #8,D1
000015D0  E049                     515                  LSR.W       #8,D1
000015D2  EC49                     516                  LSR.W       #6,D1
000015D4  3401                     517                  MOVE.W      D1,D2
000015D6                           518                  
000015D6                           519                  ; Check bits 0-5 
000015D6  4BF9 000020FC            520                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000015DC  4DF9 00002132            521                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000015E2  3E3C 0000                522                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000015E6  4EB9 00001C1C            523                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000015EC  B27C 0001                524                  CMP.W       #1,D1                    ; checks if invalid
000015F0  6700 05D2                525                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000015F4  3802                     526                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000015F6  3A03                     527                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000015F8                           528                  
000015F8  B47C 0001                529                  CMP.W       #1,D2
000015FC  6700 001A                530                  BEQ         ADDQ_WORD
00001600  B47C 0002                531                  CMP.W       #2,D2
00001604  6700 0022                532                  BEQ         ADDQ_LONG
00001608                           533                    
00001608  4BF9 000023A5            534  ADDQ_BYTE       LEA         MSG_B,A5
0000160E  4EB9 00002050            535                  JSR         PRINTNULL
00001614  6000 0022                536                  BRA         FINISH_ADDQ  
00001618                           537   
00001618  4BF9 000023AB            538  ADDQ_WORD       LEA         MSG_W,A5
0000161E  4EB9 00002050            539                  JSR         PRINTNULL
00001624  6000 0012                540                  BRA         FINISH_ADDQ                 
00001628                           541    
00001628  4BF9 000023B1            542  ADDQ_LONG       LEA         MSG_L,A5
0000162E  4EB9 00002050            543                  JSR         PRINTNULL
00001634  6000 0002                544                  BRA         FINISH_ADDQ                  
00001638                           545                    
00001638  4EB9 00001656            546  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000163E                           547   
0000163E                           548                  ; prints a comma to seperate
0000163E  4BF9 0000239C            549                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001644  4EB9 00002050            550                  JSR         PRINTNULL                ; prints out MOVE
0000164A                           551                    
0000164A                           552                  ; prints destination
0000164A  3404                     553                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000164C  3605                     554                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000164E  4EB9 00001D8A            555                  JSR         EA_TO_STRING             ; outputs it into a string
00001654                           556                 
00001654  4E75                     557                  RTS
00001656                           558   
00001656  4BF9 00002398            559  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
0000165C  4EB9 00002050            560                  JSR         PRINTNULL
00001662                           561                  ; gets bits 9-11 (data bits)
00001662  E949                     562                  LSL.W       #4,D1
00001664  E849                     563                  LSR.W       #4,D1                               ; get rid of left 4 bits
00001666  E049                     564                  LSR.W       #8,D1
00001668  E249                     565                  LSR.W       #1,D1                               ; get rid of right 9 bits
0000166A                           566                  
0000166A  B27C 0000                567                  CMP.W       #0,D1
0000166E  6700 000A                568                  BEQ         PRINT_8
00001672  4EB9 00001F06            569                  JSR         PRINTNUM
00001678  4E75                     570                  RTS 
0000167A                           571  
0000167A  123C 0008                572  PRINT_8         MOVE.B      #8,D1
0000167E  4EB9 00001F06            573                  JSR         PRINTNUM
00001684  4E75                     574                  RTS   
00001686                           575         
00001686                           576  *---------------SUB opcode---------------------- 
00001686  3200                     577  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
00001688  C27C F000                578                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000168C  B27C 9000                579                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001690  6600 0084                580                  BNE         CASE_LEA
00001694                           581                 
00001694  4EB8 142C                582                  JSR         ADD_SUB_HELP
00001698  4EB8 11D0                583                  JSR         PRINT_ADDR                          ; print address               
0000169C                           584                  
0000169C  6000 0002                585                  BRA         PRINTSUB                            ; Branches to print move
000016A0                           586  
000016A0  4BF9 000022D0            587  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
000016A6  4EB9 00002050            588                  JSR         PRINTNULL
000016AC  3200                     589                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000016AE  4EB8 148A                590                  JSR         ADD_SUB_SIZE
000016B2  3200                     591                  MOVE.W      D0,D1
000016B4  E149                     592                  LSL.W       #8,D1
000016B6  E049                     593                  LSR.W       #8,D1
000016B8  EC49                     594                  LSR.W       #6,D1
000016BA  B27C 0003                595                  CMP.W       #3,D1
000016BE  6600 0006                596                  BNE         FINISH_SUB
000016C2  6000 0008                597                  BRA         FINISH_SUBA                         ; same as ADDA
000016C6                           598                  
000016C6  4EB8 14E0                599  FINISH_SUB      JSR     ADD_SUB_OPERAND
000016CA  4E75                     600                  RTS
000016CC                           601                    
000016CC  3404                     602  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016CE  3605                     603                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016D0  4EB9 00001D8A            604                  JSR         EA_TO_STRING             ; outputs it into a string
000016D6                           605                
000016D6                           606                  ; prints a comma to seperate
000016D6  4BF9 0000239C            607                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016DC  4EB9 00002050            608                  JSR         PRINTNULL                ; prints out MOVE
000016E2                           609          
000016E2  4BF9 0000238E            610                  LEA         MSG_AR,A5                ; print address register
000016E8  4EB9 00002050            611                  JSR         PRINTNULL
000016EE  3200                     612                  MOVE.W      D0,D1
000016F0  E949                     613                  LSL.W       #4,D1
000016F2  E849                     614                  LSR.W       #4,D1
000016F4  E049                     615                  LSR.W       #8,D1
000016F6  E249                     616                  LSR.W       #1,D1
000016F8  4EB9 00001F06            617                  JSR         PRINTNUM             
000016FE  4E75                     618                  RTS                              ; exits subroutine
00001700                           619  
00001700                           620  
00001700                           621  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
00001700  3200                     622  CASE_SUBA       MOVE.W      D0,D1
00001702  EF49                     623                  LSL.W       #7,D1
00001704  EE49                     624                  LSR.W       #7,D1
00001706  E049                     625                  LSR.W       #8,D1
00001708  B23C 0000                626                  CMP.B       #0,D1
0000170C  6700 FDAE                627                  BEQ         ADD_SUB_WORD
00001710  6000 FDB8                628                  BRA         ADD_SUB_LONG
00001714  4E75                     629                  RTS         
00001716                           630                   
00001716  3200                     631  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001718  C27C F000                632                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000171C  B27C 4000                633                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001720  6600 0086                634                  BNE.W   CASE_AND                             ; If its not, check AND
00001724  3200                     635                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001726  C27C 01C0                636                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
0000172A  B27C 01C0                637                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000172E  6600 0078                638                  BNE.W   CASE_AND                             ; If its not, check AND
00001732                           639                  
00001732                           640                  ; Check source
00001732  4BF9 0000211C            641                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001738  4DF9 00002136            642                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000173E  3E3C 0000                643                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001742  4EB9 00001C1C            644                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001748  3802                     645                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000174A  3A03                     646                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000174C                           647                  
0000174C                           648                  ; Check destination
0000174C  4BF9 0000211C            649                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001752  4DF9 00002136            650                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001758  3E3C 0001                651                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000175C  4EB9 00001C1C            652                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001762  3C02                     653                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001764  3E03                     654                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001766                           655  
00001766  4BF9 000022E1            656                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000176C  4EB9 00002050            657                  JSR     PRINTNULL                            ; prints LEA
00001772                           658                  
00001772                           659                  ; print source
00001772  3404                     660                  MOVE.W  D4,D2
00001774  3605                     661                  MOVE.W  D5,D3
00001776  4EB9 00001D8A            662                  JSR     EA_TO_STRING                         ; Prints out the EA
0000177C                           663                  
0000177C                           664                  ; comma
0000177C  4BF9 0000239C            665                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001782  4EB9 00002050            666                  JSR     PRINTNULL                       
00001788                           667                   
00001788                           668                  ; register
00001788  4BF9 0000238E            669                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
0000178E  4EB9 00002050            670                  JSR     PRINTNULL 
00001794  3401                     671                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
00001796  323C 0001                672                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
0000179A  4EB9 00001BF2            673                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000017A0  4EB9 00001F06            674                  JSR     PRINTNUM                             ; Prints the number in D1
000017A6  4E75                     675                  RTS
000017A8                           676  
000017A8                           677  *---------------AND opcode----------------------
000017A8  3200                     678  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017AA  C27C F000                679                  AND.W       #$F000,D1       
000017AE  B27C C000                680                  CMP.W       #$C000,D1
000017B2  6600 0092                681                  BNE         CASE_OR
000017B6                           682                  
000017B6  3200                     683                  MOVE.W      D0,D1
000017B8  E149                     684                  LSL.W       #8,D1
000017BA  E049                     685                  LSR.W       #8,D1
000017BC  EC49                     686                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000017BE  3C01                     687                  MOVE.W      D1,D6
000017C0  BC7C 0003                688                  CMP.W       #3,D6
000017C4  6700 0066                689                  BEQ         INV_INSTR
000017C8                           690                  
000017C8  4EB8 11D0                691                  JSR         PRINT_ADDR                      ; print address
000017CC  4BF9 000022E9            692                  LEA         MSG_AND,A5                      ; print AND
000017D2  4EB9 00002050            693                  JSR         PRINTNULL
000017D8                           694                  
000017D8  3206                     695                  MOVE.W      D6,D1
000017DA  B27C 0000                696                  CMP.W       #0,D1
000017DE  6700 0012                697                  BEQ         AND_BYTE
000017E2  B27C 0001                698                  CMP.W       #1,D1                   ; if 1, it is a word
000017E6  6700 001A                699                  BEQ         AND_WORD
000017EA  B27C 0002                700                  CMP.W       #2,D1                   ; if 2, it is a long
000017EE  6700 0022                701                  BEQ         AND_LONG
000017F2                           702                  
000017F2  4BF9 000023A5            703  AND_BYTE        LEA         MSG_B,A5
000017F8  4EB9 00002050            704                  JSR         PRINTNULL
000017FE  6000 0022                705                  BRA         FINISH_AND
00001802                           706                                    
00001802  4BF9 000023AB            707  AND_WORD        LEA         MSG_W,A5
00001808  4EB9 00002050            708                  JSR         PRINTNULL
0000180E  6000 0012                709                  BRA         FINISH_AND
00001812                           710    
00001812  4BF9 000023B1            711  AND_LONG        LEA         MSG_L,A5
00001818  4EB9 00002050            712                  JSR         PRINTNULL
0000181E  6000 0002                713                  BRA         FINISH_AND
00001822                           714        
00001822  4EB8 142C                715  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001826  4EB8 14E0                716                  JSR         ADD_SUB_OPERAND
0000182A  4E75                     717                  RTS
0000182C                           718                  
0000182C  4BF9 0000225A            719  INV_INSTR       LEA         INVALID_INSTR,A5
00001832  4EB9 00002050            720                  JSR         PRINTNULL
00001838  2200                     721                  MOVE.L      D0,D1
0000183A  383C 0000                722                  MOVE.W      #0,D4
0000183E  4EB9 00001F2A            723                  JSR         PRINTSHORTLONGNUM
00001844  4E75                     724                  RTS               
00001846                           725                  
00001846                           726  *---------------OR opcode----------------------            
00001846  3200                     727  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001848  C27C F000                728                  AND.W       #$F000,D1       
0000184C  B27C 8000                729                  CMP.W       #$8000,D1
00001850  6600 004C                730                  BNE         CASE_NOT
00001854                           731                                                
00001854  3200                     732                  MOVE.W      D0,D1
00001856  E149                     733                  LSL.W       #8,D1
00001858  E049                     734                  LSR.W       #8,D1
0000185A  EC49                     735                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000185C  B27C 0003                736                  CMP.W       #3,D1
00001860  3C01                     737                  MOVE.W      D1,D6
00001862  67C8                     738                  BEQ         INV_INSTR
00001864                           739                  
00001864  4EB8 11D0                740                  JSR         PRINT_ADDR                      ; print address
00001868                           741                  
00001868  4BF9 000022EE            742                  LEA         MSG_OR,A5
0000186E  4EB9 00002050            743                  JSR         PRINTNULL                       ; print "OR"
00001874                           744                  
00001874  3206                     745                  MOVE.W      D6,D1
00001876  4EB9 00001886            746                  JSR         OR_SIZE                         ; print ".B",".W",".L"
0000187C  4EB8 142C                747                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001880  4EB8 14E0                748                  JSR         ADD_SUB_OPERAND                 ; print 
00001884  4E75                     749                  RTS
00001886                           750  
00001886  B27C 0000                751  OR_SIZE         CMP.W       #0,D1
0000188A  6700 FC22                752                  BEQ         ADD_SUB_BYTE
0000188E  B27C 0001                753                  CMP.W       #1,D1                   ; if 1, it is a word
00001892  6700 FC28                754                  BEQ         ADD_SUB_WORD
00001896  B27C 0002                755                  CMP.W       #2,D1                   ; if 2, it is a long
0000189A  6700 FC2E                756                  BEQ         ADD_SUB_LONG
0000189E                           757                  ; no need for rts, since ADD_SUB_ already has                
0000189E                           758  
0000189E                           759  *---------------NOT opcode----------------------
0000189E  3200                     760  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018A0  C27C FF00                761                  AND.W       #$FF00,D1       
000018A4  B27C 4600                762                  CMP.W       #$4600,D1
000018A8  6600 0050                763                  BNE         CASE_LSDASDROD
000018AC                           764                 
000018AC                           765                  ; get bits 6-7 (size)
000018AC  3200                     766                  MOVE.W      D0,D1
000018AE  E149                     767                  LSL.W       #8,D1
000018B0  E049                     768                  LSR.W       #8,D1
000018B2  EC49                     769                  LSR.W       #6,D1 
000018B4  3C01                     770                  MOVE.W      D1,D6                         
000018B6  BC7C 0003                771                  CMP.W       #3,D6
000018BA  6700 FF70                772                  BEQ         INV_INSTR
000018BE                           773                  
000018BE  4EB8 11D0                774                  JSR         PRINT_ADDR
000018C2                           775                  
000018C2  4BF9 000022F2            776                  LEA         MSG_NOT,A5
000018C8  4EB9 00002050            777                  JSR         PRINTNULL                       ; print "NOT"
000018CE                           778                                 
000018CE  3206                     779                  MOVE.W      D6,D1
000018D0                           780  
000018D0  4EB8 1886                781                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000018D4                           782                  
000018D4                           783                  ; get bits 0-5 
000018D4  4BF9 000020FC            784                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000018DA  4DF9 00002132            785                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000018E0  3E3C 0000                786                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000018E4  4EB9 00001C1C            787                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000018EA  B27C 0001                788                  CMP.W       #1,D1                    ; checks if invalid
000018EE  6700 02D4                789                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000018F2  4EB9 00001D8A            790                  JSR         EA_TO_STRING             ; outputs it into a string
000018F8                           791    
000018F8  4E75                     792                  RTS
000018FA                           793  
000018FA  3200                     794  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
000018FC  C27C F000                795                  AND.W       #$F000, D1                       ; gets first 4 bits
00001900  B27C E000                796                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001904  6600 0218                797                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001908  3400                     798                  MOVE.W      D0,D2                            ; copies D0 to D2
0000190A  4EB9 00001CA4            799                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001910  B47C 0003                800                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001914  6600 00CC                801                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001918                           802                  
00001918  3400                     803  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000191A  4EB9 00001C92            804                  JSR         GETROTATION                      ; gets rotation value of D2
00001920  B47C 0000                805                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001924  6700 0014                806                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001928  B47C 0003                807                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
0000192C  6700 0016                808                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001930                           809                  
00001930  4BF9 000022F7            810  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001936  6000 0012                811                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000193A                           812  
0000193A  4BF9 000022FB            813  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001940  6000 0008                814                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001944                           815  
00001944  4BF9 000022FF            816  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000194A                           817                  
0000194A  4EB8 11D0                818  PRINTSHIFTMEM   JSR         PRINT_ADDR                       ; prints address
0000194E  4EB9 00002050            819                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001954  3400                     820                  MOVE.W      D0,D2                            ; copies D0 to D2
00001956  4EB9 00001C9C            821                  JSR         GETDIRECTION                     ; gets direction
0000195C  B47C 0000                822                  CMP.W       #0,D2                            ; checking if its right
00001960  6700 000C                823                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001964                           824  
00001964  4BF9 0000238A            825  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000196A  6000 0008                826                  BRA         PRINT_MEMDIR                     ; branches for printing
0000196E                           827          
0000196E  4BF9 00002388            828  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001974                           829  
00001974  4EB9 00002050            830  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000197A  4BF9 000023AB            831                  LEA         MSG_W,A5                         ; loads .W into A5
00001980  4EB9 00002050            832                  JSR         PRINTNULL                        ; Prints .W
00001986  6000 0002                833                  BRA         GETMEMSOURCE                     ; checks the source 
0000198A                           834                  
0000198A                           835  ; get source addressing mode       
0000198A                           836  GETMEMSOURCE                                                 
0000198A  323C 0000                837                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000198E  4EB9 00001BC8            838                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001994  3801                     839                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001996  323C 0000                840                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
0000199A  4EB9 00001BF2            841                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000019A0  3A01                     842                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000019A2                           843  
000019A2  4BF9 0000212A            844  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000019A8  3204                     845                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000019AA  4EB9 00001D56            846                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000019B0  B27C 0002                847                  CMP.W       #2,D1                            ; checks if it is Xn
000019B4  6700 0016                848                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000019B8  B27C 0001                849                  CMP.W       #1,D1                            ; Checks if it is invalid
000019BC  6700 0206                850                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000019C0                           851  
000019C0  3404                     852  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000019C2  3605                     853                  MOVE.W      D5,D3                            ; moves EA to D3
000019C4  4EB9 00001D8A            854                  JSR         EA_TO_STRING                     ; prints out the EA
000019CA  4E75                     855                  RTS                
000019CC                           856                  
000019CC                           857                  
000019CC  4BF9 00002136            858  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000019D2  3205                     859                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000019D4  4EB9 00001D56            860                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000019DA  4A41                     861                  TST.W       D1                               ; checks if it is valid
000019DC  67E2                     862                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000019DE  6000 01E4                863                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000019E2                           864  
000019E2                           865  
000019E2  3602                     866  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000019E4  3200                     867                  MOVE.W      D0,D1                            ; copies D0 to D1
000019E6  C27C 0018                868                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000019EA  E649                     869                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000019EC  B27C 0000                870                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000019F0  6700 0014                871                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000019F4  B27C 0003                872                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000019F8  6700 0016                873                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000019FC                           874                  
000019FC  4BF9 000022F7            875  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001A02  6000 0012                876                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A06                           877  
00001A06  4BF9 000022FB            878  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001A0C  6000 0008                879                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A10                           880  
00001A10  4BF9 000022FF            881  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001A16                           882                  
00001A16  4EB8 11D0                883  PRINTSHIFTREG   JSR         PRINT_ADDR                       ; prints address
00001A1A  4EB9 00002050            884                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001A20  3400                     885                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A22  4EB9 00001C9C            886                  JSR         GETDIRECTION                     ; gets direction
00001A28  B47C 0000                887                  CMP.W       #0,D2                            ; checking if its right
00001A2C  6700 000C                888                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001A30                           889  
00001A30  4BF9 0000238A            890  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001A36  6000 000C                891                  BRA         PRINT_REGDIR                     ; branches for printing
00001A3A                           892          
00001A3A  4BF9 00002388            893  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001A40  6000 0002                894                  BRA         PRINT_REGDIR                     ; branches for printing
00001A44                           895                  
00001A44  4EB9 00002050            896  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001A4A                           897  
00001A4A  3400                     898  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001A4C  4EB9 00001CA4            899                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A52  B47C 0001                900                  CMP.W       #1,D2                            ; Checks if it is word size
00001A56  6700 0014                901                  BEQ         REG_WORD                         ; Prints .W
00001A5A  B47C 0002                902                  CMP.W       #2,D2                            ; Checks if it is long size
00001A5E  6700 0016                903                  BEQ         REG_LONG                         ; Prints .L
00001A62                           904  
00001A62  4BF9 000023A5            905  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001A68  6000 0012                906                  BRA         PRINTREGEA      
00001A6C                           907  
00001A6C  4BF9 000023AB            908  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001A72  6000 0008                909                  BRA         PRINTREGEA      
00001A76                           910                             
00001A76  4BF9 000023B1            911  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001A7C                           912  
00001A7C  4EB9 00002050            913  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001A82  3400                     914                  MOVE.W      D0,D2                            ; copies D0 to D1
00001A84  4EB9 00001CAC            915                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001A8A  B27C 0001                916                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001A8E  6700 0048                917                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001A92                           918                                  
00001A92  3400                     919  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001A94  4EB9 00001CA4            920                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A9A  3202                     921                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001A9C  4BF9 00002398            922                  LEA         MSG_POUND, A5                    ; loads # into A5
00001AA2  4EB9 00002050            923                  JSR         PRINTNULL                        ; prints #
00001AA8  4EB9 00001F06            924                  JSR         PRINTNUM                         ; prints shift count
00001AAE  4BF9 0000239C            925                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001AB4  4EB9 00002050            926                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001ABA  4BF9 0000238C            927                  LEA         MSG_DR, A5                       ; loads D into A5
00001AC0  4EB9 00002050            928                  JSR         PRINTNULL                        ; prints out D 
00001AC6  323C 0000                929                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001ACA  4EB9 00001BF2            930                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001AD0  4EB9 00001F06            931                  JSR         PRINTNUM                         ; prints data register number in D1          
00001AD6  4E75                     932                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001AD8                           933                  
00001AD8  3400                     934  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001ADA  4EB9 00001CA4            935                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AE0  3202                     936                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AE2  4BF9 0000238C            937                  LEA         MSG_DR, A5                       ; loads D into A5
00001AE8  4EB9 00002050            938                  JSR         PRINTNULL                        ; prints D
00001AEE  4EB9 00001F06            939                  JSR         PRINTNUM                         ; prints register number
00001AF4  4BF9 0000239C            940                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001AFA  4EB9 00002050            941                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001B00  4BF9 0000238C            942                  LEA         MSG_DR, A5                       ; loads D into A5
00001B06  4EB9 00002050            943                  JSR         PRINTNULL                        ; prints out D 
00001B0C  323C 0000                944                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001B10  4EB9 00001BF2            945                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001B16  4EB9 00001F06            946                  JSR         PRINTNUM                         ; prints data register number in D1          
00001B1C  4E75                     947                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001B1E                           948               
00001B1E  3200                     949  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001B20  C27C FF00                950                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001B24  B27C 6000                951                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001B28  6600 001C                952                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001B2C                           953                  
00001B2C  4EB8 11D0                954                  JSR     PRINT_ADDR
00001B30  4BF9 00002380            955                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001B36  4EB9 00002050            956                  JSR     PRINTNULL                            ; prints BRA
00001B3C                           957  
00001B3C  3400                     958                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001B3E  4EB9 00001C64            959                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001B44  4E75                     960                  RTS
00001B46                           961                  
00001B46                           962  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001B46                           963  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001B46  3200                     964  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B48  C27C F000                965                  AND.W   #$F000,D1                            ; get top 4 bits
00001B4C  B27C 6000                966                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001B50  6600 0058                967                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001B54  3200                     968                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B56  C27C 0F00                969                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001B5A  E049                     970                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001B5C                           971                  
00001B5C  B27C 000E                972                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001B60  6700 002A                973                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001B64                           974                  
00001B64  B27C 000F                975                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001B68  6700 0018                976                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001B6C                           977                      
00001B6C  B27C 0007                978                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001B70  6700 0006                979                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001B74  6000 004E                980                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001B78                           981     
00001B78  4BF9 00002313            982  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001B7E  6000 0016                983                  BRA     PRINTBCC
00001B82                           984  
00001B82  4BF9 0000233B            985  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001B88  6000 000C                986                  BRA     PRINTBCC
00001B8C                           987                  
00001B8C  4BF9 0000232B            988  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001B92  6000 0002                989                  BRA     PRINTBCC
00001B96                           990  
00001B96  4EB8 11D0                991  PRINTBCC        JSR     PRINT_ADDR                           ; prints address
00001B9A  4EB9 00002050            992                  JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001BA0  3400                     993                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001BA2  4EB9 00001C64            994                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001BA8  4E75                     995                  RTS              
00001BAA                           996                  
00001BAA                           997  
00001BAA                           998  CASE_JSR       
00001BAA                           999  
00001BAA  B07C 4E75               1000  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001BAE  6600 0014               1001                  BNE     CASE_DATA           ; checks the next case if not equal
00001BB2  4EB8 11D0               1002                  JSR     PRINT_ADDR          ; prints address
00001BB6  4BF9 0000237B           1003                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001BBC  4EB9 00002050           1004                  JSR     PRINTNULL           ; prints RTS                
00001BC2  4E75                    1005                  RTS                         ; returns from the subroutine
00001BC4                          1006  
00001BC4                          1007                  
00001BC4                          1008  
00001BC4                          1009  CASE_DATA             
00001BC4  4E75                    1010                      RTS               
00001BC6                          1011  
00001BC6  4E75                    1012  CASE_EPICFAIL       RTS
00001BC8                          1013  
00001BC8                          1014  
00001BC8                          1015  * Finds the EA type
00001BC8                          1016  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001BC8                          1017  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001BC8  48E7 3000               1018  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001BCC  4A41                    1019                      TST.W     D1                    ; compares D1 to 0
00001BCE  6700 000E               1020                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001BD2                          1021                      
00001BD2  343C 01C0               1022  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001BD6  363C 0006               1023                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001BDA  6000 000A               1024                      BRA       FINDTYPEEA            
00001BDE                          1025  
00001BDE  343C 0038               1026  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001BE2  363C 0003               1027                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001BE6                          1028  
00001BE6                          1029  
00001BE6  3200                    1030  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001BE8  C242                    1031                      AND.W     D2,D1                 ; applies bitmask to D1
00001BEA  E669                    1032                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001BEC  4CDF 000C               1033                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001BF0  4E75                    1034                      RTS                             ; returns from subroutine    
00001BF2                          1035                      
00001BF2                          1036  * Finds Xn type
00001BF2                          1037  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001BF2                          1038  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001BF2  48E7 3000               1039  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001BF6  4A41                    1040                      TST.W     D1                    ; compares D1 to 0
00001BF8  6700 000E               1041                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001BFC                          1042  
00001BFC  343C 0E00               1043  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001C00  363C 0009               1044                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001C04  6000 000A               1045                      BRA       FINDTYPEXN            ; finds the type of Xn
00001C08                          1046  
00001C08  343C 0007               1047  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001C0C  363C 0000               1048                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001C10                          1049                      
00001C10  3200                    1050  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001C12  C242                    1051                      AND.W     D2,D1                 ; applies bitmask to D1
00001C14  E669                    1052                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C16  4CDF 000C               1053                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C1A  4E75                    1054                      RTS                             ; returns from subroutine 
00001C1C                          1055                      
00001C1C                          1056  * Checks and gets the EA and Xn
00001C1C                          1057  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001C1C                          1058  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001C1C  3207                    1059  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001C1E  4EB8 1BC8               1060                  JSR     GET_EA                  ; Gets EA
00001C22  3401                    1061                  MOVE.W  D1,D2                   ; Stores EA in D2
00001C24  3207                    1062                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001C26  4EB8 1BF2               1063                  JSR     GET_XN                  ; Gets Xn
00001C2A  3601                    1064                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001C2C  3202                    1065                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001C2E                          1066                  
00001C2E  4EB9 00001D56           1067                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001C34  B27C 0002               1068                  CMP.W   #2,D1                   ; checks if it is Xn
00001C38  6700 0012               1069                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001C3C  B27C 0001               1070                  CMP.W   #1,D1                   ; Checks if it is invalid
00001C40  6700 001C               1071                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001C44                          1072                  
00001C44                          1073                  
00001C44  323C 0000               1074  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001C48  6000 0018               1075                  BRA     END_CHECKGET
00001C4C                          1076        
00001C4C                          1077  ; need XN
00001C4C  2A4E                    1078  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001C4E  3203                    1079                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001C50  4EB9 00001D56           1080                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001C56  4A41                    1081                  TST.W   D1                      ; checks if it is valid
00001C58  67EA                    1082                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001C5A  6000 0002               1083                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001C5E                          1084   
00001C5E  323C 0001               1085  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001C62                          1086  
00001C62  4E75                    1087  END_CHECKGET    RTS          
00001C64                          1088                                            
00001C64                          1089                                            
00001C64                          1090  * Gets the displacement and pritns it 
00001C64                          1091  * Inputs: D2 = instruction word, A2 = address of next word
00001C64                          1092  * Outputs: prints out displacement
00001C64  48E7 4004               1093  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001C68  3A4A                    1094                      MOVE.W    A2,A5                 ; copies A2 to A5
00001C6A  C47C 00FF               1095                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001C6E  6600 0004               1096                      BNE       PRINTADDRESS          ; prints address if not 0
00001C72  341A                    1097                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001C74                          1098                      
00001C74  D44D                    1099  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001C76  3202                    1100                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001C78  183C 0000               1101                      MOVE.B    #0,D4                 ; marks address as word  length
00001C7C  4BF9 0000239A           1102                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001C82  4EB9 00002050           1103                      JSR       PRINTNULL             ; prints null
00001C88  4EB9 00001F2A           1104                      JSR       PRINTSHORTLONGNUM     ; prints address
00001C8E                          1105                      
00001C8E  4CDF 2002               1106                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001C92                          1107                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001C92                          1108  
00001C92                          1109  * Gets the rotation value for ASd and LSd
00001C92                          1110  * Input: D2 = instruction word copy (of D0)                                    
00001C92                          1111  * Output: rotation  value in D2             
00001C92  C47C 0E00               1112  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001C96  E04A                    1113                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001C98  E24A                    1114                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001C9A  4E75                    1115                      RTS                             ; return from subroutine
00001C9C                          1116  
00001C9C                          1117  * Gets the direction value for ASd and LSd
00001C9C                          1118  * Input: D2 = instruction word copy (of D0)                                    
00001C9C                          1119  * Output: direction value in D2             
00001C9C  C47C 0100               1120  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001CA0  E04A                    1121                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CA2  4E75                    1122                      RTS                             ; return from subroutine
00001CA4                          1123  
00001CA4                          1124  * Gets the rotation size value for ASd and LSd
00001CA4                          1125  * Input: D2 = instruction word copy (of D0)                                    
00001CA4                          1126  * Output: rotation size value in D2             
00001CA4  C47C 00C0               1127  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001CA8  EC4A                    1128                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CAA  4E75                    1129                      RTS                             ; return from subroutine
00001CAC                          1130  
00001CAC                          1131  * Gets the rotation location  value for ASd and LSd
00001CAC                          1132  * Input: D2 = instruction word copy (of D0)                                    
00001CAC                          1133  * Output: rotation location value in D2             
00001CAC  C47C 0020               1134  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001CB0  EA4A                    1135                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CB2  4E75                    1136                      RTS                             ; return from subroutine
00001CB4                          1137  
00001CB4                          1138  * Prints out registers for MOVEM
00001CB4                          1139  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001CB4                          1140  * Output: printed out registers
00001CB4                          1141  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001CB4  48E7 0706               1142  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001CB8  3A3C 0000               1143                      MOVE.W     #0,D5                ; sets counter to 0
00001CBC  3E1A                    1144                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001CBE  B83C 0001               1145                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001CC2  6600 0010               1146                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001CC6                          1147  
00001CC6  3C3C 0000               1148  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001CCA  4BF9 0000238C           1149                      LEA        MSG_DR,A5            ; loads D to A5
00001CD0  6000 000C               1150                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001CD4                          1151                      
00001CD4  3C3C 0007               1152  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001CD8  4BF9 0000238E           1153                      LEA        MSG_AR,A5            ; loads A to A5
00001CDE                          1154                      
00001CDE  E34F                    1155  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001CE0  6500 0018               1156                      BCS        PRINTREG             ; if pushes out a 1
00001CE4  DC44                    1157                      ADD.W      D4,D6                ; decrements or increments
00001CE6  5245                    1158                      ADD.W      #1,D5                ; increments D5
00001CE8  BA7C 0008               1159                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001CEC  66F0                    1160                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001CEE  B83C 0001               1161                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001CF2  6600 0052               1162                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001CF6  6000 0042               1163                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001CFA                          1164                      
00001CFA  4EB9 00002050           1165  PRINTREG            JSR        PRINTNULL
00001D00  3206                    1166                      MOVE.W     D6,D1
00001D02  4EB9 00001F06           1167                      JSR        PRINTNUM 
00001D08                          1168    
00001D08  BE7C 0000               1169  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001D0C  6600 0006               1170                      BNE        PRINTMORE            ; continue if there is more
00001D10  6000 0040               1171                      BRA        DONEPRINTINGREG      ; exit case
00001D14                          1172  
00001D14  2C4D                    1173  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001D16  4BF9 0000239F           1174                      LEA        MSG_SLASH,A5         ; leads / into A5
00001D1C  4EB9 00002050           1175                      JSR        PRINTNULL            ; prints the slash
00001D22  2A4E                    1176                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001D24  DC44                    1177                      ADD.W      D4,D6                ; decrements or increments
00001D26  5245                    1178                      ADD.W      #1,D5                ; increments D5
00001D28  BA7C 0008               1179                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D2C  66B0                    1180                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D2E  B83C 0001               1181                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D32  6600 0012               1182                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D36  6000 0002               1183                      BRA        REGTOMEM2            ; loops
00001D3A                          1184  
00001D3A  3C3C 0000               1185  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001D3E  4BF9 0000238E           1186                      LEA        MSG_AR,A5            ; loads A to A5
00001D44  6098                    1187                      BRA        PRINTREGISTERLOOP    ; loops
00001D46                          1188  
00001D46  3C3C 0007               1189  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001D4A  4BF9 0000238C           1190                      LEA        MSG_DR,A5            ; loads D to A5
00001D50  608C                    1191                      BRA        PRINTREGISTERLOOP    ; loops
00001D52                          1192  
00001D52  4CDF 60E0               1193  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001D56                          1194  
00001D56                          1195                          
00001D56                          1196  * Checks if EA or Xn is valid
00001D56                          1197  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001D56                          1198  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001D56  2F02                    1199  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001D58                          1200  
00001D58  141D                    1201  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001D5A  B43C 00FF               1202                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001D5E  6700 000A               1203                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001D62  B202                    1204                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001D64  6700 000C               1205                     BEQ        VALIDEA               ; branches to valid EA
00001D68  60EE                    1206                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001D6A                          1207                     
00001D6A  323C 0001               1208  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001D6E  6000 0016               1209                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001D72                          1210                    
00001D72  B43C 0007               1211  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001D76  6700 000A               1212                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001D7A  323C 0000               1213                     MOVE.W     #$0,D1                ; marks that it is valid
00001D7E  6000 0006               1214                     BRA        CHECKEAEXIT           ; exits the subroutine
00001D82                          1215  
00001D82  323C 0002               1216  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001D86                          1217  
00001D86  241F                    1218  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001D88  4E75                    1219                     RTS                              ; returns from subroutine
00001D8A                          1220  
00001D8A                          1221  * Converts EA and Xn into a string                                
00001D8A                          1222  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001D8A                          1223  * Outputs: Prints out EA and Xn into a string
00001D8A  48E7 C004               1224  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001D8E  B47C 0001               1225                     CMP.W    #An,D2                  ; checks if it is An
00001D92  6700 003A               1226                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001D96                          1227                     
00001D96  B47C 0002               1228                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001D9A  6700 004A               1229                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001D9E                          1230                     
00001D9E  B47C 0003               1231                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001DA2  6700 0072               1232                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001DA6                          1233                     
00001DA6  B47C 0004               1234                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001DAA  6700 00A6               1235                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001DAE                          1236                     
00001DAE  B47C 0007               1237                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001DB2  6700 00DA               1238                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001DB6                          1239                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001DB6                          1240  
00001DB6                          1241  * data register, Dn
00001DB6  4BF9 0000238C           1242  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001DBC  4EB9 00002050           1243                     JSR      PRINTNULL               ; Prints D
00001DC2  3203                    1244                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DC4  4EB9 00001F06           1245                     JSR      PRINTNUM                ; Prints the Xn
00001DCA  6000 0134               1246                     BRA      EA_TO_STRING_EXIT       ; exits           
00001DCE                          1247  
00001DCE                          1248  
00001DCE                          1249  * address register
00001DCE  4BF9 0000238E           1250  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001DD4  4EB9 00002050           1251                     JSR      PRINTNULL               ; Prints A
00001DDA  3203                    1252                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DDC  4EB9 00001F06           1253                     JSR      PRINTNUM                ; Prints the Xn
00001DE2  6000 011C               1254                     BRA      EA_TO_STRING_EXIT       ; exits
00001DE6                          1255  
00001DE6                          1256  * address register indirect
00001DE6  4BF9 00002390           1257  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001DEC  4EB9 00002050           1258                     JSR      PRINTNULL               ; Prints (
00001DF2  4BF9 0000238E           1259                     LEA      MSG_AR,A5               ; Loads A into A5
00001DF8  4EB9 00002050           1260                     JSR      PRINTNULL               ; Prints A
00001DFE  3203                    1261                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E00  4EB9 00001F06           1262                     JSR      PRINTNUM                ; Prints the Xn
00001E06  4BF9 00002392           1263                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E0C  4EB9 00002050           1264                     JSR      PRINTNULL               ; Prints )
00001E12  6000 00EC               1265                     BRA      EA_TO_STRING_EXIT       ; exits
00001E16                          1266  
00001E16                          1267  * address register indirect post increment
00001E16  4BF9 00002390           1268  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001E1C  4EB9 00002050           1269                     JSR      PRINTNULL               ; Prints (
00001E22  4BF9 0000238E           1270                     LEA      MSG_AR,A5               ; Loads A into A5
00001E28  4EB9 00002050           1271                     JSR      PRINTNULL               ; Prints A
00001E2E  3203                    1272                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E30  4EB9 00001F06           1273                     JSR      PRINTNUM                ; Prints the Xn
00001E36  4BF9 00002392           1274                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E3C  4EB9 00002050           1275                     JSR      PRINTNULL               ; Prints )
00001E42  4BF9 00002394           1276                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001E48  4EB9 00002050           1277                     JSR      PRINTNULL               ; Prints +
00001E4E  6000 00B0               1278                     BRA      EA_TO_STRING_EXIT       ; exits
00001E52                          1279  
00001E52                          1280  
00001E52                          1281  * address register indirect pre increment
00001E52  4BF9 00002396           1282  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001E58  4EB9 00002050           1283                     JSR      PRINTNULL               ; Prints -
00001E5E  4BF9 00002390           1284                     LEA      MSG_LB,A5               ; Loads ( into A5
00001E64  4EB9 00002050           1285                     JSR      PRINTNULL               ; Prints (
00001E6A  4BF9 0000238E           1286                     LEA      MSG_AR,A5               ; Loads A into A5
00001E70  4EB9 00002050           1287                     JSR      PRINTNULL               ; Prints A
00001E76  3203                    1288                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E78  4EB9 00001F06           1289                     JSR      PRINTNUM                ; Prints the Xn
00001E7E  4BF9 00002392           1290                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E84  4EB9 00002050           1291                     JSR      PRINTNULL               ; Prints )
00001E8A  6000 0074               1292                     BRA      EA_TO_STRING_EXIT       ; exits
00001E8E                          1293  
00001E8E                          1294  * other (long, short, immediate) with Xn yes
00001E8E  301A                    1295  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001E90  B67C 0000               1296                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001E94  6700 002E               1297                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001E98                          1298                     
00001E98  B67C 0001               1299                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001E9C  6700 0042               1300                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001EA0                          1301  
00001EA0                          1302  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001EA0                          1303  * immediate
00001EA0  4BF9 00002398           1304  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001EA6  4EB9 00002050           1305                     JSR      PRINTNULL               ; Prints #  
00001EAC  4BF9 0000239A           1306                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EB2  4EB9 00002050           1307                     JSR      PRINTNULL               ; Prints $
00001EB8  3200                    1308                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001EBA  4EB9 00001F16           1309                     JSR      PRINTHEXNUM 
00001EC0  6000 003E               1310                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001EC4                          1311                     
00001EC4                          1312  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001EC4                          1313  
00001EC4                          1314  * word address
00001EC4                          1315  CASE_WORD          
00001EC4  4BF9 0000239A           1316                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001ECA  4EB9 00002050           1317                     JSR      PRINTNULL               ; Prints $
00001ED0  3200                    1318                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001ED2  383C 0000               1319                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001ED6  4EB9 00001F2A           1320                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001EDC  6000 0022               1321                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001EE0                          1322  
00001EE0                          1323  * long address 
00001EE0                          1324  CASE_LONG          
00001EE0  4BF9 0000239A           1325                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EE6  4EB9 00002050           1326                     JSR      PRINTNULL               ; Prints $
00001EEC  3200                    1327                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001EEE  383C 0001               1328                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001EF2  4EB9 00001F2A           1329                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001EF8  321A                    1330                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001EFA  4EB9 00001F06           1331                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001F00                          1332  
00001F00                          1333  
00001F00                          1334  * exits subroutine
00001F00  4CDF 2003               1335  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001F04  4E75                    1336                      RTS                              ; returns from subroutine
00001F06                          1337  
00001F06                          1338  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001F06                          1339  
00001F06                          1340  * Prints out the content of D1 as a decimal number
00001F06                          1341  * Input: number in D1 to be printed
00001F06                          1342  * Output: contents of D1 printed
00001F06  48E7 C000               1343  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F0A  103C 0003               1344                   MOVE.B      #3,D0               ; prints D1
00001F0E  4E4F                    1345                   TRAP        #15                 ; is trap task 3
00001F10                          1346              
00001F10  4CDF 0003               1347                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F14  4E75                    1348                   RTS                             ; returns from subroutine
00001F16                          1349                   
00001F16                          1350  * Prints out the content of D1 as a hex number
00001F16                          1351  * Input: number in D1 to be printed
00001F16                          1352  * Output: contents of D1 printed
00001F16  48E7 C000               1353  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F1A  143C 0010               1354                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001F1E  103C 000F               1355                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001F22  4E4F                    1356                   TRAP        #15                 ; is trap task 15
00001F24  4CDF 0003               1357                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F28  4E75                    1358                   RTS                             ; returns from subroutine
00001F2A                          1359                   
00001F2A                          1360  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001F2A                          1361  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001F2A                          1362  * Output: contents of D1 printed
00001F2A  48E7 E000               1363  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001F2E  B83C 0001               1364                            CMP.B       #1,D4               ; checks size of number
00001F32  6700 0042               1365                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001F36                          1366  
00001F36  3401                    1367  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001F38  C47C F000               1368                            AND.W       #$F000,D2           ; gets the first digit
00001F3C  B47C 0000               1369                            CMP.W       #0, D2              ; checks if it is 0
00001F40  6600 00DC               1370                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F44  4EB9 0000202E           1371                            JSR         PRINTZERO           ; prints a zero
00001F4A                          1372                            
00001F4A  3401                    1373                            MOVE.W      D1,D2               ; copies number to D2
00001F4C  C47C 0F00               1374                            AND.W       #$0F00,D2           ; gets the second digit
00001F50  B47C 0000               1375                            CMP.W       #0, D2              ; checks if it is 0
00001F54  6600 00C8               1376                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F58  4EB9 0000202E           1377                            JSR         PRINTZERO           ; prints a zero
00001F5E                          1378                            
00001F5E  3401                    1379                            MOVE.W      D1,D2               ; copies number to D2
00001F60  C47C 00F0               1380                            AND.W       #$00F0,D2           ; gets the third digit
00001F64  B47C 0000               1381                            CMP.W       #0, D2              ; checks if it is 0
00001F68  6600 00B4               1382                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F6C  4EB9 0000202E           1383                            JSR         PRINTZERO           ; prints a zero
00001F72  6000 00AA               1384                            BRA         PRINTASHEX          ; prints last digit
00001F76                          1385                            
00001F76  2401                    1386  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001F78  C4BC F0000000           1387                            AND.L       #$F0000000,D2       ; gets the first digit
00001F7E  B4BC 00000000           1388                            CMP.L       #0, D2              ; checks if it is 0
00001F84  6600 0098               1389                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F88  4EB9 0000202E           1390                            JSR         PRINTZERO           ; prints a zero
00001F8E                          1391                            
00001F8E  2401                    1392                            MOVE.L      D1,D2               ; copies number to D2
00001F90  C4BC 0F000000           1393                            AND.L       #$0F000000,D2       ; gets the second digit
00001F96  B4BC 00000000           1394                            CMP.L       #0, D2              ; checks if it is 0
00001F9C  6600 0080               1395                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FA0  4EB9 0000202E           1396                            JSR         PRINTZERO           ; prints a zero
00001FA6                          1397                            
00001FA6  2401                    1398                            MOVE.L      D1,D2               ; copies number to D2
00001FA8  C4BC 00F00000           1399                            AND.L       #$00F00000,D2       ; gets the third digit
00001FAE  B4BC 00000000           1400                            CMP.L       #0, D2              ; checks if it is 0
00001FB4  6600 0068               1401                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FB8  4EB9 0000202E           1402                            JSR         PRINTZERO           ; prints a zero
00001FBE                          1403                            
00001FBE  2401                    1404                            MOVE.L      D1,D2               ; copies number to D2
00001FC0  C4BC 000F0000           1405                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001FC6  B4BC 00000000           1406                            CMP.L       #0, D2              ; checks if it is 0
00001FCC  6600 0050               1407                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FD0  4EB9 0000202E           1408                            JSR         PRINTZERO           ; prints a zero
00001FD6                          1409                            
00001FD6  2401                    1410                            MOVE.L      D1,D2               ; copies number to D2
00001FD8  C4BC 0000F000           1411                            AND.L       #$0000F000,D2       ; gets the fith digit
00001FDE  B4BC 00000000           1412                            CMP.L       #0, D2              ; checks if it is 0
00001FE4  6600 0038               1413                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FE8  4EB9 0000202E           1414                            JSR         PRINTZERO           ; prints a zero
00001FEE                          1415                            
00001FEE  2401                    1416                            MOVE.L      D1,D2               ; copies number to D2
00001FF0  C4BC 00000F00           1417                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001FF6  B4BC 00000000           1418                            CMP.L       #0, D2              ; checks if it is 0
00001FFC  6600 0020               1419                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002000  4EB9 0000202E           1420                            JSR         PRINTZERO           ; prints a zero
00002006                          1421                            
00002006  2401                    1422                            MOVE.L      D1,D2               ; copies number to D2
00002008  C4BC 000000F0           1423                            AND.L       #$000000F0,D2       ; gets the seventh digit
0000200E  B4BC 00000000           1424                            CMP.L       #0, D2              ; checks if it is 0
00002014  6600 0008               1425                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002018  4EB9 0000202E           1426                            JSR         PRINTZERO           ; prints a zero
0000201E                          1427  
0000201E  143C 0010               1428  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002022  103C 000F               1429                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002026  4E4F                    1430                            TRAP        #15                 ; is trap task 15
00002028  4CDF 0007               1431                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
0000202C  4E75                    1432                            RTS                             ; returns from subroutine    
0000202E                          1433  * Prints a zero
0000202E                          1434  * Input: nothing
0000202E                          1435  * Output: 0 printed out to the console
0000202E  2F01                    1436  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002030  7200                    1437                            MOVE.L      #0,D1               ; moves 0 to D1
00002032  4EB8 1F06               1438                            JSR         PRINTNUM            ; prints the number
00002036  221F                    1439                            MOVE.L      (SP)+,D1            ; restores D1
00002038  4E75                    1440                            RTS                             ; returns from subroutine
0000203A                          1441              
0000203A                          1442  * Prints contents of things between a range
0000203A                          1443  * input: A5, A6 (the range)
0000203A                          1444  * output: prints memory contents from A5 to A6 as strings   
0000203A  48E7 C040               1445  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
0000203E  224D                    1446                  MOVEA.L     A5, A1           ; loads A5 into A1
00002040  9DCD                    1447                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00002042  320E                    1448                  MOVE.W      A6, D1           ; move n into D1
00002044  103C 0001               1449                  MOVE.B      #1, D0           ; display n characters of string at A1
00002048  4E4F                    1450                  TRAP        #15              ; is trap task 1
0000204A  4CDF 0203               1451                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
0000204E  4E75                    1452                  RTS                          ; returns
00002050                          1453      
00002050                          1454  * Prints null terminated string
00002050                          1455  * input: string pointed to by A5
00002050                          1456  * output: prints out the null terminated string
00002050  48E7 8040               1457  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002054  224D                    1458                  MOVE.L      A5,A1           ; loads A5 into A1
00002056  103C 000E               1459                  MOVE.B      #14,D0          ; prints null terminated string
0000205A  4E4F                    1460                  TRAP        #15             ; is trap task 10
0000205C  4CDF 0201               1461                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00002060  4E75                    1462                  RTS                         ; returns from subroutine
00002062                          1463                  
00002062  2F0D                    1464  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002064  4BF9 00002298           1465                  LEA         NEW_LINE,A5     ; Prints null
0000206A  4EB8 2050               1466                  JSR         PRINTNULL       ; prints the new line
0000206E  2A5F                    1467                  MOVE.L      (SP)+,A5        ; returns A5
00002070  4E75                    1468                  RTS
00002072                          1469  
00002072                          1470  * Prints the size of the MOVE or MOVEA operation  
00002072                          1471  * input: D0
00002072                          1472  * output: prints out the size of a MOVE or MOVEA operation        
00002072  48E7 8004               1473  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00002076  3200                    1474                  MOVE.W  D0,D1               ; stores d0 in d1
00002078  C07C 3000               1475                  AND.W   #$3000,D0           ; gets the size
0000207C  B07C 2000               1476                  CMP.W   #$2000,D0           ; checks if is long
00002080  6700 001E               1477                  BEQ     MOVE_LONG
00002084  B07C 3000               1478                  CMP.W   #$3000,D0           ; checks if is word
00002088  6700 000C               1479                  BEQ     MOVE_WORD      
0000208C                          1480                  
0000208C  4BF9 000023A5           1481  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00002092  6000 0012               1482                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002096                          1483  
00002096  4BF9 000023AB           1484  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
0000209C  6000 0008               1485                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020A0                          1486  
000020A0  4BF9 000023B1           1487  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000020A6                          1488                  
000020A6  4EB8 2050               1489  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000020AA  4CDF 2001               1490                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000020AE  4E75                    1491                  RTS
000020B0                          1492  
000020B0  43F9 0000223E           1493  ERROR           LEA     ERROR_MSG,A1
000020B6  103C 000E               1494                  MOVE.B  #14,D0
000020BA  4E4F                    1495                  TRAP    #15 
000020BC                          1496         
000020BC                          1497  * DELETE THIS: Test                
000020BC  2661                    1498  DELETEME        MOVEA.L  -(A1),A3
000020BE  6700 0038               1499                  BEQ      DELETEMEAGAIN  
000020C2  6F00 0034               1500                  BLE      DELETEMEAGAIN
000020C6  6E00 0030               1501                  BGT      DELETEMEAGAIN
000020CA                          1502  
000020CA  E40A                    1503                  LSR.B      #2,D2
000020CC  E2E2                    1504                  LSR.W      -(A2)
000020CE  E2DA                    1505                  LSR.W      (A2)+
000020D0  E4AA                    1506                  LSR.L      D2,D2 
000020D2  E50A                    1507                  LSL.B      #2,D2
000020D4  E3E2                    1508                  LSL.W      -(A2)
000020D6  E3DA                    1509                  LSL.W      (A2)+
000020D8  E5AA                    1510                  LSL.L      D2,D2
000020DA  E51A                    1511                  ROL.B      #2,D2
000020DC  E7E2                    1512                  ROL.W      -(A2)
000020DE  E7DA                    1513                  ROL.W      (A2)+
000020E0  E5BA                    1514                  ROL.L      D2,D2
000020E2  E41A                    1515                  ROR.B      #2,D2
000020E4  E6E2                    1516                  ROR.W      -(A2)
000020E6  E6DA                    1517                  ROR.W      (A2)+
000020E8  E4BA                    1518                  ROR.L      D2,D2
000020EA                          1519                  
000020EA  504D                    1520                  ADDQ.W      #8,A5
000020EC  D6C2                    1521                  ADDA.W      D2,A3
000020EE  9BCB                    1522                  SUB.L       A3,A5        
000020F0  8A43                    1523                  OR.W        D3,D5
000020F2  4642                    1524                  NOT.W       D2
000020F4                          1525                  
000020F4  C5FC 0010               1526                  MULS.W    #$0010,D2
000020F8                          1527                  
000020F8                          1528  DELETEMEAGAIN                 
000020F8                          1529            
000020F8  FFFF FFFF               1530      SIMHALT             ; halt simulator
000020FC                          1531  
000020FC                          1532  * Put variables and constants here
000020FC                          1533  
000020FC  =0000000D               1534  CR                              EQU     $0D
000020FC  =0000000A               1535  LF                              EQU     $0A 
000020FC  =00000009               1536  TAB                             EQU     $09  
000020FC                          1537  
000020FC                          1538  * Addressing Modes
000020FC  =00000000               1539  Dn                              EQU     0
000020FC  =00000001               1540  An                              EQU     1
000020FC  =00000002               1541  AnIndirect                      EQU     2
000020FC  =00000003               1542  AnPost                          EQU     3
000020FC  =00000004               1543  AnPre                           EQU     4
000020FC  =00000007               1544  Other                           EQU     7           ; short, long, immediate
000020FC                          1545  
000020FC                          1546  * Xn
000020FC  =00000000               1547  ABSShort                        EQU     0
000020FC  =00000001               1548  ABSLong                         EQU     1
000020FC  =00000004               1549  XnImmediate                     EQU     4
000020FC                          1550  
000020FC                          1551  * Valid Addressing Modes
000020FC= 00 01 02 03 04 07 FF    1552  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00002103                          1553  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00002103= 00 02 03 04 07 FF       1554  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002109= 02 04 07 FF             1555  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
0000210D= 02 03 07 FF             1556  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00002111= 02 03 04 07 FF          1557  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002116= 00 02 03 04 07 FF       1558  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000211C= 01 07 FF                1559  VALIDEA_LEA                     DC.B    An,Other,-1
0000211F= 00 02 03 04 07 FF       1560  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002125= 02 03 04 07 FF          1561  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000212A= 02 03 04 07 FF          1562  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
0000212F= 02 07 FF                1563  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00002132                          1564  
00002132                          1565  * Valid Xn
00002132= 00 01 04 FF             1566  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00002136                          1567  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00002136= 00 01 FF                1568  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00002139                          1569  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00002139                          1570  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00002139                          1571  
00002139                          1572  * posible memory ASd/LSd rotation values
00002139  =00000000               1573  ASd_MEM                         EQU     0   
00002139  =00000001               1574  LSd_MEM                         EQU     1 
00002139  =00000003               1575  ROd_MEM                         EQU     3
00002139                          1576   
00002139  =00000000               1577  ASd_REG                         EQU     0   
00002139  =00000001               1578  LSd_REG                         EQU     1 
00002139  =00000003               1579  ROd_REG                         EQU     3
00002139                          1580  
00002139                          1581  * Messages
00002139= 57 65 6C 63 6F 6D ...   1582  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00002160= 46 6F 72 6D 61 74 ...   1583                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
000021AF= 50 6C 65 61 73 65 ...   1584  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
000021E6= 50 6C 65 61 73 65 ...   1585  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
0000221C= 49 6E 76 61 6C 69 ...   1586  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
0000223E= 45 72 72 6F 72 20 ...   1587  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
0000225A= 31 30 30 30 09 44 ...   1588  INVALID_INSTR                   DC.B    '1000',TAB,'DATA',TAB,'$',0
00002266= 46 69 6E 69 73 68 ...   1589  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
00002298= 0D 0A 00                1590  NEW_LINE                        DC.B    CR,LF,0
0000229B= 09 09 09 00             1591  THREE_TAB                       DC.B    TAB,TAB,TAB,0
0000229F                          1592  
0000229F                          1593  * Opcode Messages
0000229F= 09 4E 4F 50 00          1594  MSG_NOP                         DC.B    TAB,'NOP',0
000022A4= 09 4D 4F 56 45 00       1595  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000022AA= 09 4D 4F 56 45 41 00    1596  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000022B1= 09 4D 4F 56 45 51 00    1597  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000022B8= 09 4D 4F 56 45 4D 00    1598  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000022BF= 09 41 44 44 00          1599  MSG_ADD                         DC.B    TAB,'ADD',0
000022C4= 09 41 44 44 41 00       1600  MSG_ADDA                        DC.B    TAB,'ADDA',0
000022CA= 09 41 44 44 51 00       1601  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
000022D0= 09 53 55 42 00          1602  MSG_SUB                         DC.B    TAB,'SUB',0
000022D5= 09 4D 55 4C 53 00       1603  MSG_MULS                        DC.B    TAB,'MULS',0
000022DB= 09 44 49 56 55 00       1604  MSG_DIVU                        DC.B    TAB,'DIVU',0
000022E1= 09 4C 45 41 09 09 ...   1605  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
000022E9= 09 41 4E 44 00          1606  MSG_AND                         DC.B    TAB,'AND',0
000022EE= 09 4F 52 00             1607  MSG_OR                          DC.B    TAB,'OR',0
000022F2= 09 4E 4F 54 00          1608  MSG_NOT                         DC.B    TAB,'NOT',0
000022F7= 09 4C 53 00             1609  MSG_LSd                         DC.B    TAB,'LS',0
000022FB= 09 41 53 00             1610  MSG_ASd                         DC.B    TAB,'AS',0
000022FF= 09 52 4F 00             1611  MSG_ROd                         DC.B    TAB,'RO',0
00002303= 09 42 43 43 09 09 ...   1612  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
0000230B= 09 42 43 53 09 09 ...   1613  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00002313= 09 42 45 51 09 09 ...   1614  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
0000231B= 09 42 4E 45 09 09 ...   1615  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00002323= 09 42 47 45 09 09 ...   1616  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
0000232B= 09 42 47 54 09 09 ...   1617  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00002333= 09 42 48 49 09 09 ...   1618  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
0000233B= 09 42 4C 45 09 09 ...   1619  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00002343= 09 42 4C 53 09 09 ...   1620  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
0000234B= 09 42 4C 54 09 09 ...   1621  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00002353= 09 42 4D 49 09 09 ...   1622  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
0000235B= 09 42 50 4C 09 09 ...   1623  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00002363= 09 42 56 43 09 09 ...   1624  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
0000236B= 09 42 56 53 09 09 ...   1625  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00002373= 09 4A 53 52 09 09 ...   1626  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
0000237B= 09 52 54 53 00          1627  MSG_RTS                         DC.B    TAB,'RTS',0
00002380= 09 42 52 41 09 09 ...   1628  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00002388                          1629  
00002388                          1630  * Direction for LSd and ASd
00002388= 52 00                   1631  MSG_RIGHT                       DC.B    'R',0
0000238A= 4C 00                   1632  MSG_LEFT                        DC.B    'L',0
0000238C                          1633  
0000238C                          1634  * Effective Addresses Messages
0000238C= 44 00                   1635  MSG_DR                          DC.B    'D',0
0000238E= 41 00                   1636  MSG_AR                          DC.B    'A',0
00002390= 28 00                   1637  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002392= 29 00                   1638  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00002394= 2B 00                   1639  MSG_PLUS                        DC.B    '+',0
00002396= 2D 00                   1640  MSG_MINUS                       DC.B    '-',0
00002398= 23 00                   1641  MSG_POUND                       DC.B    '#',0 
0000239A= 24 00                   1642  MSG_HEX                         DC.B    '$',0 
0000239C= 2C 20 00                1643  MSG_COMMA                       DC.B    ', ',0
0000239F= 2F 00                   1644  MSG_SLASH                       DC.B    '/',0  
000023A1= 20 00                   1645  MSG_SPACE                       DC.B    ' ',0
000023A3= 09 00                   1646  MSG_TAB                         DC.B    TAB,0
000023A5                          1647  
000023A5                          1648  * Size Messages
000023A5= 2E 42 09 09 09 00       1649  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
000023AB= 2E 57 09 09 09 00       1650  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
000023B1= 2E 4C 09 09 09 00       1651  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
000023B7                          1652  
000023B7                          1653  * Variables
000023B7  =00000100               1654  STARTING_ADDRESS                EQU     $100
000023B7  =00000150               1655  ENDING_ADDRESS                  EQU     $150
000023B7  =00000200               1656  CURRENT_INSTR                   EQU     $200
000023B7  =00000250               1657  REG_VAR                         EQU     $250 * Hold bits 11-9
000023B7  =00000300               1658  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000023B7  =00000350               1659  EA_MODE                         EQU     $350 * Hold bits 5-3
000023B7  =00000400               1660  EA_REG                          EQU     $400 * Hold bits 2-0
000023B7                          1661  
000023B7                          1662              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1572
ADDQ_BYTE           1608
ADDQ_LONG           1628
ADDQ_WORD           1618
ADD_SUB_BYTE        14AE
ADD_SUB_HELP        142C
ADD_SUB_LONG        14CA
ADD_SUB_OPERAND     14E0
ADD_SUB_SIZE        148A
ADD_SUB_WORD        14BC
AN                  1
AND_BYTE            17F2
AND_LONG            1812
AND_WORD            1802
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           221C
CASE_ADD            1400
CASE_ADDA           1546
CASE_ADDQ           15AE
CASE_AND            17A8
CASE_AR             1DCE
CASE_ARI            1DE6
CASE_ARIPOST        1E16
CASE_ARIPRE         1E52
CASE_ASDMEM         193A
CASE_ASDREG         1A06
CASE_BCC            1B46
CASE_BEQ            1B78
CASE_BGT            1B8C
CASE_BLE            1B82
CASE_BRA            1B1E
CASE_DATA           1BC4
CASE_DR             1DB6
CASE_EPICFAIL       1BC6
CASE_IMMEDIATE      1EA0
CASE_JSR            1BAA
CASE_LEA            1716
CASE_LEFTMEM        1964
CASE_LEFTREG        1A30
CASE_LONG           1EE0
CASE_LSDASDROD      18FA
CASE_LSDMEM         1930
CASE_LSDREG         19FC
CASE_MOVE           1202
CASE_MOVEM          12A8
CASE_MOVEQ          13A8
CASE_NOP            11E8
CASE_NOT            189E
CASE_OR             1846
CASE_OTHER          1E8E
CASE_RIGHTMEM       196E
CASE_RIGHTREG       1A3A
CASE_RODMEM         1944
CASE_RODREG         1A10
CASE_RTS            1BAA
CASE_SHIFTMEM       1918
CASE_SHIFTREG       19E2
CASE_SUB            1686
CASE_SUBA           1700
CASE_WORD           1EC4
CHECKEAEXIT         1D86
CHECKEAMLOOP        1D58
CHECKEAXN_IFVALID   1D56
CHECKGET_EAXN       1C1C
CHECKMEMSOURE       19A2
CHECKMOREBITS       1D08
CHECKSHIFT_XN       19CC
CHECK_LENGTH        1132
CHECK_ODD           11C8
CHECK_ORDER         109A
CHECK_XN            1C4C
CONCAT              117A
CONVERT             1144
CR                  D
CURRENT_INSTR       200
DELETEME            20BC
DELETEMEAGAIN       20F8
DESTEA              1BD2
DESTXN              1BFC
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          151A
DONE                2266
DONEPRINTINGREG     1D52
EASHIFT_VALID       19C0
EAXN_INVALID        1C5E
EAXN_VALID          1C44
EA_MODE             350
EA_REG              400
EA_TO_STRING        1D8A
EA_TO_STRING_EXIT   1F00
ENDING              21E6
ENDING_ADDRESS      150
END_CHECKGET        1C62
ERROR               20B0
ERROR_MSG           223E
FINDTYPEEA          1BE6
FINDTYPEXN          1C10
FINISHED            10B4
FINISHMOVE          20A6
FINISH_ADD          14D8
FINISH_ADDA         1582
FINISH_ADDQ         1638
FINISH_AND          1822
FINISH_SUB          16C6
FINISH_SUBA         16CC
GETDIRECTION        1C9C
GETDISPLACEMENT     1C64
GETMEMSOURCE        198A
GETROTATION         1C92
GETROTATIONLOCATION  1CAC
GETROTATIONSIZE     1CA4
GET_EA              1BC8
GET_XN              1BF2
INPUT1              100C
INPUT2              1052
INSERTA             1274
INVALID             1192
INVALIDEA           1D6A
INVALID_INSTR       225A
INV_INSTR           182C
ISNUMBER            115A
LF                  A
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         137E
MEM2REGWORD         1370
MEMTOREG1           1CD4
MEMTOREG2           1D46
MOVEM_MEM2REG       1338
MOVEM_REG2MEM       12C6
MOVE_BYTE           208C
MOVE_LONG           20A0
MOVE_WORD           2096
MSG_ADD             22BF
MSG_ADDA            22C4
MSG_ADDQ            22CA
MSG_AND             22E9
MSG_AR              238E
MSG_ASD             22FB
MSG_B               23A5
MSG_BCC             2303
MSG_BCS             230B
MSG_BEQ             2313
MSG_BGE             2323
MSG_BGT             232B
MSG_BHI             2333
MSG_BLE             233B
MSG_BLS             2343
MSG_BLT             234B
MSG_BMI             2353
MSG_BNE             231B
MSG_BPL             235B
MSG_BRA             2380
MSG_BVC             2363
MSG_BVS             236B
MSG_COMMA           239C
MSG_DIVU            22DB
MSG_DR              238C
MSG_HEX             239A
MSG_JSR             2373
MSG_L               23B1
MSG_LB              2390
MSG_LEA             22E1
MSG_LEFT            238A
MSG_LSD             22F7
MSG_MINUS           2396
MSG_MOVE            22A4
MSG_MOVEA           22AA
MSG_MOVEM           22B8
MSG_MOVEQ           22B1
MSG_MULS            22D5
MSG_NOP             229F
MSG_NOT             22F2
MSG_OR              22EE
MSG_PLUS            2394
MSG_POUND           2398
MSG_RB              2392
MSG_RIGHT           2388
MSG_ROD             22FF
MSG_RTS             237B
MSG_SLASH           239F
MSG_SPACE           23A1
MSG_SUB             22D0
MSG_TAB             23A3
MSG_W               23AB
NEW_LINE            2298
NOTNUMBER           1162
OPCODE_DECODE       11E4
OPMODE_VAR          300
OR_SIZE             1886
OTHER               7
OTHEREA             1D82
PRINTADD            1472
PRINTADDRESS        1C74
PRINTASHEX          201E
PRINTBCC            1B96
PRINTENTER          2062
PRINTHEXNUM         1F16
PRINTLONGZERO       1F76
PRINTMEM2REG        138A
PRINTMORE           1D14
PRINTMOVE           127A
PRINTMOVESIZE       2072
PRINTNULL           2050
PRINTNUM            1F06
PRINTRANGE          203A
PRINTREG            1CFA
PRINTREG2MEM        131A
PRINTREGEA          1A7C
PRINTREGISTERLOOP   1CDE
PRINTREGISTERS      1CB4
PRINTREGSIZE        1A4A
PRINTSHIFTMEM       194A
PRINTSHIFTREG       1A16
PRINTSHORTLONGNUM   1F2A
PRINTSHORTZERO      1F36
PRINTSUB            16A0
PRINTZERO           202E
PRINT_8             167A
PRINT_ADDQ_DATA     1656
PRINT_ADDR          11D0
PRINT_MEMDIR        1974
PRINT_MOVEQ         13CA
PRINT_REGDIR        1A44
REG2MEMLONG         130E
REG2MEMWORD         12FE
REGTOMEM1           1CC6
REGTOMEM2           1D3A
REG_BYTE            1A62
REG_IMMEDIATE       1A92
REG_LONG            1A76
REG_REGISTER        1AD8
REG_VAR             250
REG_WORD            1A6C
RESET_INPUT         112A
RESTART             10D4
RETURN              1190
ROD_MEM             3
ROD_REG             3
SOURCEEA            1BDE
SOURCEXN            1C08
START               1000
STARTING            21AF
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11B0
THREE_TAB           229B
VALIDEA             1D72
VALIDEA_ADDSUB_DESTOPERAND  2111
VALIDEA_ALL         20FC
VALIDEA_ANDORNOT    211F
VALIDEA_ANDOR_DESTOPERAND  2125
VALIDEA_JSR         212F
VALIDEA_LEA         211C
VALIDEA_MOVEM_MEMTOREG  210D
VALIDEA_MOVEM_REGTOMEM  2109
VALIDEA_MOVEQ       2103
VALIDEA_MULSDIVU    2116
VALIDEA_SHIFT       212A
VALIDXN_ALL         2132
VALIDXN_SHORTLONG   2136
WELCOME             2139
XNIMMEDIATE         4
