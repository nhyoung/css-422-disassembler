00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/6/2020 4:28:37 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001B59             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001BCF             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001C06             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 00001958             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001A90             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6E00 0052                 78                  BGT     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 00001C3C            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C  33C0 00000200            138                  MOVE.W  D0,CURRENT_INSTR
00001172                           139                  
00001172  B07C 4E71                140  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001176  6600 0010                141                  BNE     CASE_MOVE               ; checks the next case if not equal
0000117A  4BF9 00001C81            142                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001180  4EB9 00001A7E            143                  JSR     PRINTNULL               ; prints NOP                
00001186  4E75                     144                  RTS                             ; returns from the subroutine
00001188                           145                  
00001188                           146                  * if first two bits are 00, next two are not 00
00001188  3200                     147  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
0000118A  C27C C000                148                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000118E  6600 009A                149                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001192  B07C 0FFF                150                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001196  6F00 0092                151                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
0000119A                           152                  
0000119A                           153                  ; Check source
0000119A  4BF9 00001B1C            154                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011A0  4DF9 00001B52            155                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A6  3E3C 0000                156                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011AA  4EB9 000016FC            157                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011B0  B27C 0001                158                  CMP.W   #1,D1                    ; checks if invalid
000011B4  6700 04EE                159                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B8  3802                     160                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011BA  3A03                     161                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011BC                           162                  
000011BC                           163                  ; Check destination
000011BC  4BF9 00001B1C            164                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011C2  4DF9 00001B56            165                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C8  3E3C 0001                166                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011CC  4EB9 000016FC            167                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011D2  B27C 0001                168                  CMP.W   #1,D1                    ; checks if invalid
000011D6  6700 04CC                169                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011DA  3C02                     170                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011DC  3E03                     171                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011DE                           172                  
000011DE                           173                  ; Checking if it is MOVEA
000011DE  3200                     174                  MOVE.W  D0,D1                    ; stores d0 in d1
000011E0  C27C 01C0                175                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011E4  B27C 0040                176                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E8  6700 000C                177                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011EC                           178   
000011EC  4BF9 00001C86            179                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011F2  6000 0008                180                  BRA     PRINTMOVE                ; Branches to print move
000011F6                           181                  
000011F6  4BF9 00001C8C            182  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011FC                           183   
000011FC  4EB9 00001A7E            184  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001202  4EB9 00001AA0            185                  JSR     PRINTMOVESIZE            ; prints out the size  
00001208  3404                     186                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000120A  3605                     187                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000120C  4EB9 000017B8            188                  JSR     EA_TO_STRING             ; outputs it into a string
00001212                           189                  
00001212                           190                  ; prints a comma to seperate
00001212  4BF9 00001D7E            191                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001218  4EB9 00001A7E            192                  JSR     PRINTNULL                ; prints out MOVE
0000121E                           193                  
0000121E                           194                  ; print destination
0000121E  3406                     195                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001220  3607                     196                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001222  4EB9 000017B8            197                  JSR     EA_TO_STRING             ; outputs it into a string
00001228  4E75                     198                  RTS                              ; exits subroutine                 
0000122A                           199                
0000122A                           200                  
0000122A  3200                     201  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000122C  C27C FB80                202                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001230  B27C 4880                203                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001234  6600 005A                204                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001238                           205                  
00001238                           206                  ; loads EA and XN
00001238  323C 0000                207                  MOVE.W  #0,D1                           ; copies instruction word to D1
0000123C  4EB9 000016A8            208                  JSR     GET_EA                          ; gets EA and puts in D1
00001242  3401                     209                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
00001244  323C 0000                210                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001248  4EB9 000016D2            211                  JSR     GET_XN                          ; gets XN and puts in D1
0000124E  3601                     212                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
00001250                           213                  
00001250                           214                  ; Check D
00001250  3200                     215                  MOVE.W  D0,D1                           ; copies instruction word to D1
00001252  C27C 0400                216                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001256  3E01                     217                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001258  B27C 0400                218                  CMP.W   #$0400,D1                       ; checks if value is 1
0000125C  6700 0032                219                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
00001260                           220  
00001260  4BF9 00001B29            221  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001266  3202                     222                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001268  4EB9 00001784            223                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
0000126E  B27C 0001                224                  CMP.W   #1,D1                           ; checks if D1 invalid
00001272  6700 0430                225                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001276  B27C 0002                226                  CMP.W   #2,D1                           ; checks if we need to check Xn
0000127A                           227                  
0000127A  4BF9 00001B29            228  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001280  3203                     229                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
00001282  4EB9 00001784            230                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001288  B27C 0001                231                  CMP.W   #1,D1                           ; checks if D1 invalid
0000128C  6700 0416                232                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001290                           233  
00001290                           234                  
00001290                           235  
00001290                           236  MOVEM_MEM2REG    
00001290                           237                          
00001290                           238  
00001290                           239  
00001290  3200                     240  CASE_MOVEQ      MOVE.W  D0,D1
00001292  C27C F100                241                  AND.W   #$F100,D1
00001296  B27C 7000                242                  CMP.W   #$7000,D1
0000129A  6600 0046                243                  BNE     CASE_ADD
0000129E                           244                  
0000129E                           245                  ;loads Register
0000129E  323C 0001                246                  MOVE.W  #1,D1                           ; copies instruction word to D1
000012A2  4EB9 000016D2            247                  JSR     GET_XN                          ; gets XN and puts in D1
000012A8  3401                     248                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012AA                           249                  
000012AA                           250                  ;loads DATA
000012AA  3200                     251                  MOVE.W  D0,D1
000012AC  C27C 00FF                252                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012B0  3601                     253                  MOVE.W  D1,D3                          ;copy data into D3
000012B2                           254                                                          ;must convert bits to hex
000012B2                           255                  
000012B2                           256                  
000012B2  4BF9 00001C93            257  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B8  4EB9 00001A7E            258                  JSR     PRINTNULL  
000012BE                           259                  
000012BE  4BF9 00001D91            260                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012C4  4EB9 00001A7E            261                  JSR     PRINTNULL
000012CA                           262      
000012CA  4BF9 00001C7D            263                  LEA     THREE_TAB,A5                ;PRINT THREE TABS
000012D0  4EB9 00001A7E            264                  JSR     PRINTNULL
000012D6                           265                  
000012D6  4BF9 00001D7A            266                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012DC  4EB9 00001A7E            267                  JSR     PRINTNULL
000012E2                           268  
000012E2                           269  
000012E2  3200                     270  CASE_ADD        MOVE.W  D0,D1
000012E4  C27C F000                271                  AND.W   #$F000,D1
000012E8  B27C D000                272                  CMP.W   #$D000,D1
000012EC  6600 006E                273                  BNE     CASE_ADDQ
000012F0                           274                   
000012F0  3200                     275                  MOVE.W  D0,D1
000012F2  E149                     276                  LSL.W   #8,D1                   ; get rid of left 8 bits
000012F4  E049                     277                  LSR.W   #8,D1
000012F6  EC49                     278                  LSR.W   #6,D1                   ; get rid of right 6 bits
000012F8  B27C 0003                279                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000012FC  6700 005E                280                  BEQ     CASE_ADDA
00001300                           281                  
00001300                           282                  ; Check bits 0-6 
00001300  4BF9 00001B1C            283                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001306  4DF9 00001B52            284                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000130C  3E3C 0001                285                  MOVE.W  #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001310  4EB9 000016FC            286                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001316  B27C 0001                287                  CMP.W   #1,D1                    ; checks if invalid
0000131A  6700 0388                288                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000131E  3802                     289                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
00001320  3A03                     290                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001322                           291                  
00001322                           292                  ; Check destination
00001322  4BF9 00001B1C            293                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001328  4DF9 00001B56            294                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000132E  3E3C 0001                295                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001332  4EB9 000016FC            296                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001338  B27C 0001                297                  CMP.W   #1,D1                    ; checks if invalid
0000133C  6700 0366                298                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001340  3C02                     299                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001342  3E03                     300                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001344                           301                  
00001344                           302                  ; Checking if it is MOVEA
00001344  3200                     303                  MOVE.W  D0,D1                    ; stores d0 in d1
00001346  C27C 01C0                304                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
0000134A  B27C 0040                305                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000134E  6700 FEA6                306                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001352                           307   
00001352  4BF9 00001C86            308                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001358  6000 FEA2                309                  BRA     PRINTMOVE                ; Branches to print move
0000135C                           310   
0000135C                           311  
0000135C                           312  CASE_ADDA 
0000135C                           313  *
0000135C                           314  *CASE_ADDA       LEA         MSG_ADDA,A1
0000135C                           315  *                MOVE.B      #14,D0
0000135C                           316  *                TRAP        #15                 ; print "ADDA"
0000135C                           317  *                MOVE.W      OPMODE_VAR,D3
0000135C                           318  *                JSR         ADDA_SIZE
0000135C                           319  *                JSR         ADDR_MODE_JUMP_TABLE
0000135C                           320  *                    
0000135C                           321  *            
0000135C                           322  *ADDA_SIZE       CMP.W       #%111,D3
0000135C                           323  *                BEQ         PRINT_WORD 
0000135C                           324  *                BRA         PRINT_LONG          
0000135C                           325                  
0000135C                           326  
0000135C                           327  CASE_ADDQ       
0000135C                           328  
0000135C                           329  CASE_SUB
0000135C                           330  
0000135C  3200                     331  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000135E  C27C F000                332                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001362  B27C 4000                333                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001366  6600 0086                334                  BNE.W   CASE_AND                             ; If its not, check AND
0000136A  3200                     335                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000136C  C27C 01C0                336                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001370  B27C 01C0                337                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001374  6600 0078                338                  BNE.W   CASE_AND                             ; If its not, check AND
00001378                           339                  
00001378                           340                  ; Check source
00001378  4BF9 00001B3C            341                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000137E  4DF9 00001B56            342                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001384  3E3C 0000                343                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001388  4EB9 000016FC            344                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000138E  3802                     345                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001390  3A03                     346                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001392                           347                  
00001392                           348                  ; Check destination
00001392  4BF9 00001B3C            349                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001398  4DF9 00001B56            350                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000139E  3E3C 0001                351                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000013A2  4EB9 000016FC            352                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000013A8  3C02                     353                  MOVE.W  D2,D6                                ; Saves D2 in D4
000013AA  3E03                     354                  MOVE.W  D3,D7                                ; Saves D2 in D4
000013AC                           355  
000013AC  4BF9 00001CC3            356                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000013B2  4EB9 00001A7E            357                  JSR     PRINTNULL                            ; prints LEA
000013B8                           358                  
000013B8                           359                  ; print source
000013B8  3404                     360                  MOVE.W  D4,D2
000013BA  3605                     361                  MOVE.W  D5,D3
000013BC  4EB9 000017B8            362                  JSR     EA_TO_STRING                         ; Prints out the EA
000013C2                           363                  
000013C2                           364                  ; comma
000013C2  4BF9 00001D7E            365                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000013C8  4EB9 00001A7E            366                  JSR     PRINTNULL                       
000013CE                           367                   
000013CE                           368                  ; register
000013CE  4BF9 00001D70            369                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000013D4  4EB9 00001A7E            370                  JSR     PRINTNULL 
000013DA  3401                     371                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000013DC  323C 0001                372                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000013E0  4EB9 000016D2            373                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000013E6  4EB9 00001934            374                  JSR     PRINTNUM                             ; Prints the number in D1
000013EC  4E75                     375                  RTS
000013EE                           376  
000013EE                           377  **---------------AND opcode----------------------
000013EE                           378  CASE_AND
000013EE                           379  *CASE_AND        LEA         MSG_AND,A1
000013EE                           380  *                MOVE.B      #14,D0
000013EE                           381  *                TRAP        #15 
000013EE                           382  *                JSR         GET_VARS
000013EE                           383  *                JSR         AND_SIZE                        ; .B, .W, or .L  
000013EE                           384  *                MOVE.W      CURRENT_INSTR, D5                         
000013EE                           385  *                LSL.W       #7, D5                        
000013EE                           386  *                LSR.W       #8, D5                   
000013EE                           387  *                LSR.W       #7, D5                     
000013EE                           388  *                CMP.B       #00, D5                         ; check if destination is a Dn?
000013EE                           389  *                BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
000013EE                           390  *                CMP.B       #$01,D5                         ; Is the destination not a Dn?
000013EE                           391  *                BEQ         DEST_EA                         ; branch to DEST_EA            
000013EE                           392  *                RTS
000013EE                           393     
000013EE                           394  *AND_SIZE        CMP.B       #%00,OPMODE_VAR       
000013EE                           395  *                BEQ         PRINT_BYTE
000013EE                           396  *                CMP.B       #$01, OPMODE_VAR
000013EE                           397  *                BEQ         PRINT_WORD
000013EE                           398  *                CMP.B       #$02, OPMODE_VAR
000013EE                           399  *                BEQ         PRINT_LONG    
000013EE                           400  *    
000013EE                           401  *DEST_DN         MOVE.W      CURRENT_INSTR, D5               
000013EE                           402  *                LSL.W       #6,D5
000013EE                           403  *                LSL.W       #4,D5
000013EE                           404  *                LSR.W       #6,D5
000013EE                           405  *                LSR.W       #4,D5
000013EE                           406  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000013EE                           407  *                  
000013EE                           408  *                MOVE.W      CURRENT_INSTR, D6               
000013EE                           409  *                LSL.W       #6,D5
000013EE                           410  *                LSL.W       #4,D5
000013EE                           411  *                LSL.W       #3,D6
000013EE                           412  *                LSR.W       #6,D6
000013EE                           413  *                LSR.W       #4,D6
000013EE                           414  *                LSR.W       #3,D6                           ; d6 stores EA register
000013EE                           415  *                JSR         FIND_EA
000013EE                           416  *
000013EE                           417  *                
000013EE                           418  *                MOVE.W      CURRENT_INSTR, D5               
000013EE                           419  *                LSL.W       #4, D5                         
000013EE                           420  *                LSR.W       #8, D5                          ; shift bits to get register
000013EE                           421  *                LSR.W       #5, D5                          ; D5 contains register
000013EE                           422  *                LEA         MSG_COMMA, A1                   
000013EE                           423  *                MOVE.B      #14,D0
000013EE                           424  *                TRAP        #15                             ; print comma
000013EE                           425  *                LEA         MSG_DR, A1                      ; print D
000013EE                           426  *                MOVE.B      #14,D0
000013EE                           427  *                TRAP        #15
000013EE                           428  *                MOVEA.L     D5,A1
000013EE                           429  *                MOVE.B      #14,D0
000013EE                           430  *                TRAP        #15                              
000013EE                           431  *                RTS        
000013EE                           432  *
000013EE                           433  *FIND_EA        CMP.W       #%010,D5
000013EE                           434  *                BEQ         CASE_ARI
000013EE                           435  *                CMP.W       #%011,D5
000013EE                           436  *                BEQ         CASE_ARIPOST
000013EE                           437  *                CMP.W       #%100,D5
000013EE                           438  *                BEQ         CASE_ARIPRE
000013EE                           439  *                CMP.W       #%111,D5
000013EE                           440  *                BEQ         CASE_OTHER
000013EE                           441  *                BRA         ERROR    
000013EE                           442  *                                     
000013EE                           443  *DEST_EA         MOVE.W      CURRENT_INSTR, D5               
000013EE                           444  *                LSL.W       #4, D5                         
000013EE                           445  *                LSR.W       #8, D5                          ; shift bits to get register
000013EE                           446  *                LSR.W       #5, D5                          ; D5 contains register
000013EE                           447  *
000013EE                           448  *                LEA         MSG_DR, A1                   
000013EE                           449  *                MOVE.B      #14,D0
000013EE                           450  *                TRAP        #15                             ; print D
000013EE                           451  *                MOVEA.L     D5,A1  
000013EE                           452  *                MOVE.B      #14,D0                          ; print register
000013EE                           453  *                TRAP        #15
000013EE                           454  *                
000013EE                           455  *                LEA         MSG_COMMA, A1                   
000013EE                           456  *                MOVE.B      #14,D0
000013EE                           457  *                TRAP        #15                             ; print comma
000013EE                           458  *                
000013EE                           459  *                MOVE.W      CURRENT_INSTR, D5               
000013EE                           460  *                LSL.W       #6,D5
000013EE                           461  *                LSL.W       #4,D5
000013EE                           462  *                LSR.W       #6,D5
000013EE                           463  *                LSR.W       #4,D5
000013EE                           464  *                LSR.W       #3,D5                           ; d5 stores EA mode                
000013EE                           465  *                  
000013EE                           466  *                MOVE.W      CURRENT_INSTR, D6               
000013EE                           467  *                LSL.W       #6,D6
000013EE                           468  *                LSL.W       #4,D6
000013EE                           469  *                LSL.W       #3,D6
000013EE                           470  *                LSR.W       #6,D6
000013EE                           471  *                LSR.W       #4,D6
000013EE                           472  *                LSR.W       #3,D6                           ; d6 stores EA register
000013EE                           473  *                JSR         FIND_EA                          
000013EE                           474  *                RTS                                     Return full instruction   
000013EE                           475              
000013EE                           476  CASE_OR
000013EE                           477  
000013EE                           478  CASE_NOT
000013EE                           479  
000013EE  3200                     480  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
000013F0  C27C F000                481                  AND.W       #$F000, D1                       ; gets first 4 bits
000013F4  B27C E000                482                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000013F8  6600 0210                483                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000013FC  3400                     484                  MOVE.W      D0,D2                            ; copies D0 to D2
000013FE  4EB9 00001774            485                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001404  B47C 0003                486                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001408  6600 00C8                487                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
0000140C                           488                  
0000140C  3400                     489  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000140E  4EB9 00001762            490                  JSR         GETROTATION                      ; gets rotation value of D2
00001414  B47C 0000                491                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001418  6700 0014                492                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
0000141C  B47C 0003                493                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001420  6700 0016                494                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001424                           495                  
00001424  4BF9 00001CD9            496  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
0000142A  6000 0012                497                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000142E                           498  
0000142E  4BF9 00001CDD            499  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001434  6000 0008                500                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001438                           501  
00001438  4BF9 00001CE1            502  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000143E                           503                  
0000143E  4EB9 00001A7E            504  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
00001444  3400                     505                  MOVE.W      D0,D2                            ; copies D0 to D2
00001446  4EB9 0000176C            506                  JSR         GETDIRECTION                     ; gets direction
0000144C  B47C 0000                507                  CMP.W       #0,D2                            ; checking if its right
00001450  6700 000C                508                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001454                           509  
00001454  4BF9 00001D6C            510  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000145A  6000 0008                511                  BRA         PRINT_MEMDIR                     ; branches for printing
0000145E                           512          
0000145E  4BF9 00001D6A            513  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001464                           514  
00001464  4EB9 00001A7E            515  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000146A  4BF9 00001D8B            516                  LEA         MSG_W,A5                         ; loads .W into A5
00001470  4EB9 00001A7E            517                  JSR         PRINTNULL                        ; Prints .W
00001476  6000 0002                518                  BRA         GETMEMSOURCE                     ; checks the source 
0000147A                           519                  
0000147A                           520  ; get source addressing mode       
0000147A                           521  GETMEMSOURCE                                                 
0000147A  323C 0000                522                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000147E  4EB9 000016A8            523                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001484  3801                     524                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001486  323C 0000                525                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
0000148A  4EB9 000016D2            526                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001490  3A01                     527                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001492                           528  
00001492  4BF9 00001B4A            529  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001498  3204                     530                  MOVE.W      D4,D1                            ; marks down that we are checking EA
0000149A  4EB9 00001784            531                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000014A0  B27C 0002                532                  CMP.W       #2,D1                            ; checks if it is Xn
000014A4  6700 0016                533                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000014A8  B27C 0001                534                  CMP.W       #1,D1                            ; Checks if it is invalid
000014AC  6700 01F6                535                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000014B0                           536  
000014B0  3404                     537  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000014B2  3605                     538                  MOVE.W      D5,D3                            ; moves EA to D3
000014B4  4EB9 000017B8            539                  JSR         EA_TO_STRING                     ; prints out the EA
000014BA  4E75                     540                  RTS                
000014BC                           541                  
000014BC                           542                  
000014BC  4BF9 00001B56            543  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000014C2  3205                     544                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000014C4  4EB9 00001784            545                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000014CA  4A41                     546                  TST.W       D1                               ; checks if it is valid
000014CC  67E2                     547                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000014CE  6000 01D4                548                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000014D2                           549  
000014D2                           550  
000014D2  3602                     551  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000014D4  3200                     552                  MOVE.W      D0,D1                            ; copies D0 to D1
000014D6  C27C 0018                553                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000014DA  E649                     554                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000014DC  B27C 0000                555                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000014E0  6700 0014                556                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000014E4  B27C 0003                557                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000014E8  6700 0016                558                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000014EC                           559                  
000014EC  4BF9 00001CD9            560  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
000014F2  6000 0012                561                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000014F6                           562  
000014F6  4BF9 00001CDD            563  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
000014FC  6000 0008                564                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001500                           565  
00001500  4BF9 00001CE1            566  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001506                           567                  
00001506  4EB9 00001A7E            568  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
0000150C  3400                     569                  MOVE.W      D0,D2                            ; copies D0 to D2
0000150E  4EB9 0000176C            570                  JSR         GETDIRECTION                     ; gets direction
00001514  B47C 0000                571                  CMP.W       #0,D2                            ; checking if its right
00001518  6700 000C                572                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
0000151C                           573  
0000151C  4BF9 00001D6C            574  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001522  6000 000C                575                  BRA         PRINT_REGDIR                     ; branches for printing
00001526                           576          
00001526  4BF9 00001D6A            577  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
0000152C  6000 0002                578                  BRA         PRINT_REGDIR                     ; branches for printing
00001530                           579                  
00001530  4EB9 00001A7E            580  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001536                           581  
00001536  3400                     582  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001538  4EB9 00001774            583                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000153E  B47C 0001                584                  CMP.W       #1,D2                            ; Checks if it is word size
00001542  6700 0014                585                  BEQ         REG_WORD                         ; Prints .W
00001546  B47C 0002                586                  CMP.W       #2,D2                            ; Checks if it is long size
0000154A  6700 0016                587                  BEQ         REG_LONG                         ; Prints .L
0000154E                           588  
0000154E  4BF9 00001D85            589  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001554  6000 0012                590                  BRA         PRINTREGEA      
00001558                           591  
00001558  4BF9 00001D8B            592  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
0000155E  6000 0008                593                  BRA         PRINTREGEA      
00001562                           594                             
00001562  4BF9 00001D91            595  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001568                           596  
00001568  4EB9 00001A7E            597  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
0000156E  3400                     598                  MOVE.W      D0,D2                            ; copies D0 to D1
00001570  4EB9 0000177C            599                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001576  B27C 0001                600                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
0000157A  6700 0048                601                  BEQ         REG_REGISTER                     ; goes to ASd case if so
0000157E                           602                                  
0000157E  3400                     603  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001580  4EB9 00001774            604                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001586  3202                     605                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001588  4BF9 00001D7A            606                  LEA         MSG_POUND, A5                    ; loads # into A5
0000158E  4EB9 00001A7E            607                  JSR         PRINTNULL                        ; prints #
00001594  4EB9 00001934            608                  JSR         PRINTNUM                         ; prints shift count
0000159A  4BF9 00001D7E            609                  LEA         MSG_COMMA, A5                    ; loads , into A5
000015A0  4EB9 00001A7E            610                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000015A6  4BF9 00001D6E            611                  LEA         MSG_DR, A5                       ; loads D into A5
000015AC  4EB9 00001A7E            612                  JSR         PRINTNULL                        ; prints out D 
000015B2  323C 0000                613                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000015B6  4EB9 000016D2            614                  JSR         GET_XN                           ; gets the data register number, stores in D1
000015BC  4EB9 00001934            615                  JSR         PRINTNUM                         ; prints data register number in D1          
000015C2  4E75                     616                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000015C4                           617                  
000015C4  3400                     618  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
000015C6  4EB9 00001774            619                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000015CC  3202                     620                  MOVE.W      D2, D1                           ; moves rotation size to D1
000015CE  4BF9 00001D6E            621                  LEA         MSG_DR, A5                       ; loads D into A5
000015D4  4EB9 00001A7E            622                  JSR         PRINTNULL                        ; prints D
000015DA  4EB9 00001934            623                  JSR         PRINTNUM                         ; prints register number
000015E0  4BF9 00001D7E            624                  LEA         MSG_COMMA, A5                    ; loads , into A5
000015E6  4EB9 00001A7E            625                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000015EC  4BF9 00001D6E            626                  LEA         MSG_DR, A5                       ; loads D into A5
000015F2  4EB9 00001A7E            627                  JSR         PRINTNULL                        ; prints out D 
000015F8  323C 0000                628                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000015FC  4EB9 000016D2            629                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001602  4EB9 00001934            630                  JSR         PRINTNUM                         ; prints data register number in D1          
00001608  4E75                     631                  RTS                                          ; ends subroutine to go onto the next instruction opcode
0000160A                           632               
0000160A  3200                     633  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000160C  C27C FF00                634                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001610  B27C 6000                635                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001614  6600 0018                636                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001618                           637                  
00001618  4BF9 00001D62            638                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
0000161E  4EB9 00001A7E            639                  JSR     PRINTNULL                            ; prints BRA
00001624                           640  
00001624  3400                     641                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001626  4EB9 00001744            642                  JSR     GETDISPLACEMENT                      ; finds the displacement
0000162C  4E75                     643                  RTS
0000162E                           644                  
0000162E                           645  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
0000162E                           646  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
0000162E  3200                     647  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001630  C27C F000                648                  AND.W   #$F000,D1                            ; get top 4 bits
00001634  B27C 6000                649                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001638  6600 0054                650                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
0000163C  3200                     651                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
0000163E  C27C 0F00                652                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001642  E049                     653                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001644                           654                  
00001644  B27C 000E                655                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001648  6700 002A                656                  BEQ     CASE_BGT                             ; branches to BGT if it is
0000164C                           657                  
0000164C  B27C 000F                658                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001650  6700 0018                659                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001654                           660                      
00001654  B27C 0007                661                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001658  6700 0006                662                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
0000165C  6000 0046                663                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001660                           664     
00001660  4BF9 00001CF5            665  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001666  6000 0016                666                  BRA     PRINTBCC
0000166A                           667  
0000166A  4BF9 00001D1D            668  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001670  6000 000C                669                  BRA     PRINTBCC
00001674                           670                  
00001674  4BF9 00001D0D            671  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
0000167A  6000 0002                672                  BRA     PRINTBCC
0000167E                           673  
0000167E  4EB9 00001A7E            674  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001684  3400                     675                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001686  4EB9 00001744            676                  JSR     GETDISPLACEMENT                      ; finds the displacement
0000168C  4E75                     677                  RTS              
0000168E                           678                  
0000168E                           679  
0000168E                           680  CASE_JSR       
0000168E                           681  
0000168E  B07C 4E75                682  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001692  6600 FAF4                683                  BNE     CASE_MOVE           ; checks the next case if not equal
00001696  4BF9 00001D5D            684                  LEA     MSG_RTS,A5          ; loads string pointer into A5
0000169C  4EB9 00001A7E            685                  JSR     PRINTNULL           ; prints RTS                
000016A2  4E75                     686                  RTS                         ; returns from the subroutine
000016A4                           687  
000016A4                           688                  
000016A4                           689  
000016A4                           690  CASE_DATA           
000016A4  4E75                     691                      RTS               
000016A6                           692  
000016A6  4E75                     693  CASE_EPICFAIL       RTS
000016A8                           694  
000016A8                           695  
000016A8                           696  * Finds the EA type
000016A8                           697  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
000016A8                           698  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000016A8  48E7 3000                699  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000016AC  4A41                     700                      TST.W     D1                    ; compares D1 to 0
000016AE  6700 000E                701                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
000016B2                           702                      
000016B2  343C 01C0                703  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
000016B6  363C 0006                704                      MOVE.W    #6,D3                 ; stores the shift amount to D3
000016BA  6000 000A                705                      BRA       FINDTYPEEA            
000016BE                           706  
000016BE  343C 0038                707  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
000016C2  363C 0003                708                      MOVE.W    #3,D3                 ; stores the shift amount to D3
000016C6                           709  
000016C6                           710  
000016C6  3200                     711  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
000016C8  C242                     712                      AND.W     D2,D1                 ; applies bitmask to D1
000016CA  E669                     713                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000016CC  4CDF 000C                714                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000016D0  4E75                     715                      RTS                             ; returns from subroutine    
000016D2                           716                      
000016D2                           717  * Finds Xn type
000016D2                           718  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
000016D2                           719  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000016D2  48E7 3000                720  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000016D6  4A41                     721                      TST.W     D1                    ; compares D1 to 0
000016D8  6700 000E                722                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
000016DC                           723  
000016DC  343C 0E00                724  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
000016E0  363C 0009                725                      MOVE.W    #9,D3                 ; stores the shift amount to D3
000016E4  6000 000A                726                      BRA       FINDTYPEXN            ; finds the type of Xn
000016E8                           727  
000016E8  343C 0007                728  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
000016EC  363C 0000                729                      MOVE.W    #0,D3                 ; stores the shift amount to D3
000016F0                           730                      
000016F0  3200                     731  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
000016F2  C242                     732                      AND.W     D2,D1                 ; applies bitmask to D1
000016F4  E669                     733                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000016F6  4CDF 000C                734                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000016FA  4E75                     735                      RTS                             ; returns from subroutine 
000016FC                           736                      
000016FC                           737  * Checks and gets the EA and Xn
000016FC                           738  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
000016FC                           739  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
000016FC  3207                     740  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
000016FE  4EB8 16A8                741                  JSR     GET_EA                  ; Gets EA
00001702  3401                     742                  MOVE.W  D1,D2                   ; Stores EA in D2
00001704  3207                     743                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001706  4EB8 16D2                744                  JSR     GET_XN                  ; Gets Xn
0000170A  3601                     745                  MOVE.W  D1,D3                   ; Stores Xn in D3
0000170C  3202                     746                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
0000170E                           747                  
0000170E  4EB9 00001784            748                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001714  B27C 0002                749                  CMP.W   #2,D1                   ; checks if it is Xn
00001718  6700 0012                750                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
0000171C  B27C 0001                751                  CMP.W   #1,D1                   ; Checks if it is invalid
00001720  6700 001C                752                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001724                           753                  
00001724                           754                  
00001724  323C 0000                755  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001728  6000 0018                756                  BRA     END_CHECKGET
0000172C                           757        
0000172C                           758  ; need XN
0000172C  2A4E                     759  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
0000172E  3203                     760                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001730  4EB9 00001784            761                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001736  4A41                     762                  TST.W   D1                      ; checks if it is valid
00001738  67EA                     763                  BEQ     EAXN_VALID              ; go to EA_VALID to print
0000173A  6000 0002                764                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
0000173E                           765   
0000173E  323C 0001                766  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001742                           767  
00001742  4E75                     768  END_CHECKGET    RTS          
00001744                           769                                            
00001744                           770                                            
00001744                           771  * Gets the displacement and pritns it 
00001744                           772  * Inputs: D2 = instruction word, A2 = address of next word
00001744                           773  * Outputs: prints out displacement
00001744  48E7 4004                774  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001748  3A4A                     775                      MOVE.W    A2,A5                 ; copies A2 to A5
0000174A  C47C 00FF                776                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
0000174E  6600 0004                777                      BNE       PRINTADDRESS          ; prints address if not 0
00001752  341A                     778                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001754                           779                      
00001754  D44D                     780  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001756  3202                     781                      MOVE.W    D2,D1                 ; moves address to D1 to print it
00001758  4EB9 00001934            782                      JSR       PRINTNUM              ; prints address
0000175E                           783                      
0000175E  4CDF 2002                784                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001762                           785                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001762                           786  
00001762                           787  * Gets the rotation value for ASd and LSd
00001762                           788  * Input: D2 = instruction word copy (of D0)                                    
00001762                           789  * Output: rotation  value in D2             
00001762  C47C 0E00                790  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001766  E04A                     791                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001768  E24A                     792                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
0000176A  4E75                     793                      RTS                             ; return from subroutine
0000176C                           794  
0000176C                           795  * Gets the direction value for ASd and LSd
0000176C                           796  * Input: D2 = instruction word copy (of D0)                                    
0000176C                           797  * Output: direction value in D2             
0000176C  C47C 0100                798  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001770  E04A                     799                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001772  4E75                     800                      RTS                             ; return from subroutine
00001774                           801  
00001774                           802  * Gets the rotation size value for ASd and LSd
00001774                           803  * Input: D2 = instruction word copy (of D0)                                    
00001774                           804  * Output: rotation size value in D2             
00001774  C47C 00C0                805  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001778  EC4A                     806                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
0000177A  4E75                     807                      RTS                             ; return from subroutine
0000177C                           808  
0000177C                           809  * Gets the rotation location  value for ASd and LSd
0000177C                           810  * Input: D2 = instruction word copy (of D0)                                    
0000177C                           811  * Output: rotation location value in D2             
0000177C  C47C 0020                812  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001780  EA4A                     813                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001782  4E75                     814                      RTS                             ; return from subroutine
00001784                           815  
00001784                           816                          
00001784                           817  * Checks if EA or Xn is valid
00001784                           818  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001784                           819  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001784  2F02                     820  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001786                           821  
00001786  141D                     822  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001788  B43C 00FF                823                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
0000178C  6700 000A                824                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001790  B202                     825                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001792  6700 000C                826                     BEQ        VALIDEA               ; branches to valid EA
00001796  60EE                     827                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001798                           828                     
00001798  323C 0001                829  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
0000179C  6000 0016                830                     BRA        CHECKEAEXIT           ; exists the subroutine        
000017A0                           831                    
000017A0  B43C 0007                832  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
000017A4  6700 000A                833                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
000017A8  323C 0000                834                     MOVE.W     #$0,D1                ; marks that it is valid
000017AC  6000 0006                835                     BRA        CHECKEAEXIT           ; exits the subroutine
000017B0                           836  
000017B0  323C 0002                837  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
000017B4                           838  
000017B4  241F                     839  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
000017B6  4E75                     840                     RTS                              ; returns from subroutine
000017B8                           841  
000017B8                           842  * Converts EA and Xn into a string                                
000017B8                           843  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
000017B8                           844  * Outputs: Prints out EA and Xn into a string
000017B8  48E7 C004                845  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
000017BC  B47C 0001                846                     CMP.W    #An,D2                  ; checks if it is An
000017C0  6700 003A                847                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
000017C4                           848                     
000017C4  B47C 0002                849                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
000017C8  6700 004A                850                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
000017CC                           851                     
000017CC  B47C 0003                852                     CMP.W    #AnPost,D2              ; checks if it is (An)+
000017D0  6700 0072                853                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
000017D4                           854                     
000017D4  B47C 0004                855                     CMP.W    #AnPre,D2               ; checks if it is -(An)
000017D8  6700 00A6                856                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
000017DC                           857                     
000017DC  B47C 0007                858                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
000017E0  6700 00DA                859                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
000017E4                           860                     ; otherwise assumes D2 = #Dn which means its a data register                   
000017E4                           861  
000017E4                           862  * data register, Dn
000017E4  4BF9 00001D6E            863  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
000017EA  4EB9 00001A7E            864                     JSR      PRINTNULL               ; Prints D
000017F0  3203                     865                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000017F2  4EB9 00001934            866                     JSR      PRINTNUM                ; Prints the Xn
000017F8  6000 0134                867                     BRA      EA_TO_STRING_EXIT       ; exits           
000017FC                           868  
000017FC                           869  
000017FC                           870  * address register
000017FC  4BF9 00001D70            871  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001802  4EB9 00001A7E            872                     JSR      PRINTNULL               ; Prints A
00001808  3203                     873                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000180A  4EB9 00001934            874                     JSR      PRINTNUM                ; Prints the Xn
00001810  6000 011C                875                     BRA      EA_TO_STRING_EXIT       ; exits
00001814                           876  
00001814                           877  * address register indirect
00001814  4BF9 00001D72            878  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
0000181A  4EB9 00001A7E            879                     JSR      PRINTNULL               ; Prints (
00001820  4BF9 00001D70            880                     LEA      MSG_AR,A5               ; Loads A into A5
00001826  4EB9 00001A7E            881                     JSR      PRINTNULL               ; Prints A
0000182C  3203                     882                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000182E  4EB9 00001934            883                     JSR      PRINTNUM                ; Prints the Xn
00001834  4BF9 00001D74            884                     LEA      MSG_RB,A5               ; Loads ) into A5
0000183A  4EB9 00001A7E            885                     JSR      PRINTNULL               ; Prints )
00001840  6000 00EC                886                     BRA      EA_TO_STRING_EXIT       ; exits
00001844                           887  
00001844                           888  * address register indirect post increment
00001844  4BF9 00001D72            889  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
0000184A  4EB9 00001A7E            890                     JSR      PRINTNULL               ; Prints (
00001850  4BF9 00001D70            891                     LEA      MSG_AR,A5               ; Loads A into A5
00001856  4EB9 00001A7E            892                     JSR      PRINTNULL               ; Prints A
0000185C  3203                     893                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000185E  4EB9 00001934            894                     JSR      PRINTNUM                ; Prints the Xn
00001864  4BF9 00001D74            895                     LEA      MSG_RB,A5               ; Loads ) into A5
0000186A  4EB9 00001A7E            896                     JSR      PRINTNULL               ; Prints )
00001870  4BF9 00001D76            897                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001876  4EB9 00001A7E            898                     JSR      PRINTNULL               ; Prints +
0000187C  6000 00B0                899                     BRA      EA_TO_STRING_EXIT       ; exits
00001880                           900  
00001880                           901  
00001880                           902  * address register indirect pre increment
00001880  4BF9 00001D78            903  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001886  4EB9 00001A7E            904                     JSR      PRINTNULL               ; Prints -
0000188C  4BF9 00001D72            905                     LEA      MSG_LB,A5               ; Loads ( into A5
00001892  4EB9 00001A7E            906                     JSR      PRINTNULL               ; Prints (
00001898  4BF9 00001D70            907                     LEA      MSG_AR,A5               ; Loads A into A5
0000189E  4EB9 00001A7E            908                     JSR      PRINTNULL               ; Prints A
000018A4  3203                     909                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000018A6  4EB9 00001934            910                     JSR      PRINTNUM                ; Prints the Xn
000018AC  4BF9 00001D74            911                     LEA      MSG_RB,A5               ; Loads ) into A5
000018B2  4EB9 00001A7E            912                     JSR      PRINTNULL               ; Prints )
000018B8  6000 0074                913                     BRA      EA_TO_STRING_EXIT       ; exits
000018BC                           914  
000018BC                           915  * other (long, short, immediate) with Xn yes
000018BC  301A                     916  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000018BE  B67C 0000                917                     CMP.W    #ABSShort,D3            ; checks if it is a word
000018C2  6700 002E                918                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000018C6                           919                     
000018C6  B67C 0001                920                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000018CA  6700 0042                921                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000018CE                           922  
000018CE                           923  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
000018CE                           924  * immediate
000018CE  4BF9 00001D7A            925  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000018D4  4EB9 00001A7E            926                     JSR      PRINTNULL               ; Prints #  
000018DA  4BF9 00001D7C            927                     LEA      MSG_HEX,A5              ; Loads $ into A5
000018E0  4EB9 00001A7E            928                     JSR      PRINTNULL               ; Prints $
000018E6  3200                     929                     MOVE.W   D0, D1                  ; moves instruction word into d1
000018E8  4EB9 00001944            930                     JSR      PRINTHEXNUM 
000018EE  6000 003E                931                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
000018F2                           932                     
000018F2                           933  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
000018F2                           934  
000018F2                           935  * word address
000018F2                           936  CASE_WORD          
000018F2  4BF9 00001D7C            937                     LEA      MSG_HEX,A5              ; Loads $ into A5
000018F8  4EB9 00001A7E            938                     JSR      PRINTNULL               ; Prints $
000018FE  3200                     939                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001900  383C 0000                940                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001904  4EB9 00001958            941                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000190A  6000 0022                942                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000190E                           943  
0000190E                           944  * long address 
0000190E                           945  CASE_LONG          
0000190E  4BF9 00001D7C            946                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001914  4EB9 00001A7E            947                     JSR      PRINTNULL               ; Prints $
0000191A  3200                     948                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000191C  383C 0001                949                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001920  4EB9 00001958            950                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001926  321A                     951                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001928  4EB9 00001934            952                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
0000192E                           953  
0000192E                           954  
0000192E                           955  * exits subroutine
0000192E  4CDF 2003                956  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001932  4E75                     957                      RTS                              ; returns from subroutine
00001934                           958  
00001934                           959  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001934                           960  
00001934                           961  * Prints out the content of D1 as a decimal number
00001934                           962  * Input: number in D1 to be printed
00001934                           963  * Output: contents of D1 printed
00001934  48E7 C000                964  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001938  103C 0003                965                   MOVE.B      #3,D0               ; prints D1
0000193C  4E4F                     966                   TRAP        #15                 ; is trap task 3
0000193E                           967              
0000193E  4CDF 0003                968                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001942  4E75                     969                   RTS                             ; returns from subroutine
00001944                           970                   
00001944                           971  * Prints out the content of D1 as a hex number
00001944                           972  * Input: number in D1 to be printed
00001944                           973  * Output: contents of D1 printed
00001944  48E7 C000                974  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001948  143C 0010                975                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
0000194C  103C 000F                976                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001950  4E4F                     977                   TRAP        #15                 ; is trap task 15
00001952  4CDF 0003                978                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001956  4E75                     979                   RTS                             ; returns from subroutine
00001958                           980                   
00001958                           981  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001958                           982  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001958                           983  * Output: contents of D1 printed
00001958  48E7 E000                984  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
0000195C  B83C 0001                985                            CMP.B       #1,D4               ; checks size of number
00001960  6700 0042                986                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001964                           987  
00001964  3401                     988  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001966  C47C F000                989                            AND.W       #$F000,D2           ; gets the first digit
0000196A  B47C 0000                990                            CMP.W       #0, D2              ; checks if it is 0
0000196E  6600 00DC                991                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001972  4EB9 00001A5C            992                            JSR         PRINTZERO           ; prints a zero
00001978                           993                            
00001978  3401                     994                            MOVE.W      D1,D2               ; copies number to D2
0000197A  C47C 0F00                995                            AND.W       #$0F00,D2           ; gets the second digit
0000197E  B47C 0000                996                            CMP.W       #0, D2              ; checks if it is 0
00001982  6600 00C8                997                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001986  4EB9 00001A5C            998                            JSR         PRINTZERO           ; prints a zero
0000198C                           999                            
0000198C  3401                    1000                            MOVE.W      D1,D2               ; copies number to D2
0000198E  C47C 00F0               1001                            AND.W       #$00F0,D2           ; gets the third digit
00001992  B47C 0000               1002                            CMP.W       #0, D2              ; checks if it is 0
00001996  6600 00B4               1003                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000199A  4EB9 00001A5C           1004                            JSR         PRINTZERO           ; prints a zero
000019A0  6000 00AA               1005                            BRA         PRINTASHEX          ; prints last digit
000019A4                          1006                            
000019A4  2401                    1007  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
000019A6  C4BC F0000000           1008                            AND.L       #$F0000000,D2       ; gets the first digit
000019AC  B4BC 00000000           1009                            CMP.L       #0, D2              ; checks if it is 0
000019B2  6600 0098               1010                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019B6  4EB9 00001A5C           1011                            JSR         PRINTZERO           ; prints a zero
000019BC                          1012                            
000019BC  2401                    1013                            MOVE.L      D1,D2               ; copies number to D2
000019BE  C4BC 0F000000           1014                            AND.L       #$0F000000,D2       ; gets the second digit
000019C4  B4BC 00000000           1015                            CMP.L       #0, D2              ; checks if it is 0
000019CA  6600 0080               1016                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019CE  4EB9 00001A5C           1017                            JSR         PRINTZERO           ; prints a zero
000019D4                          1018                            
000019D4  2401                    1019                            MOVE.L      D1,D2               ; copies number to D2
000019D6  C4BC 00F00000           1020                            AND.L       #$00F00000,D2       ; gets the third digit
000019DC  B4BC 00000000           1021                            CMP.L       #0, D2              ; checks if it is 0
000019E2  6600 0068               1022                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019E6  4EB9 00001A5C           1023                            JSR         PRINTZERO           ; prints a zero
000019EC                          1024                            
000019EC  2401                    1025                            MOVE.L      D1,D2               ; copies number to D2
000019EE  C4BC 000F0000           1026                            AND.L       #$000F0000,D2       ; gets the fourth digit
000019F4  B4BC 00000000           1027                            CMP.L       #0, D2              ; checks if it is 0
000019FA  6600 0050               1028                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000019FE  4EB9 00001A5C           1029                            JSR         PRINTZERO           ; prints a zero
00001A04                          1030                            
00001A04  2401                    1031                            MOVE.L      D1,D2               ; copies number to D2
00001A06  C4BC 0000F000           1032                            AND.L       #$0000F000,D2       ; gets the fith digit
00001A0C  B4BC 00000000           1033                            CMP.L       #0, D2              ; checks if it is 0
00001A12  6600 0038               1034                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A16  4EB9 00001A5C           1035                            JSR         PRINTZERO           ; prints a zero
00001A1C                          1036                            
00001A1C  2401                    1037                            MOVE.L      D1,D2               ; copies number to D2
00001A1E  C4BC 00000F00           1038                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001A24  B4BC 00000000           1039                            CMP.L       #0, D2              ; checks if it is 0
00001A2A  6600 0020               1040                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A2E  4EB9 00001A5C           1041                            JSR         PRINTZERO           ; prints a zero
00001A34                          1042                            
00001A34  2401                    1043                            MOVE.L      D1,D2               ; copies number to D2
00001A36  C4BC 000000F0           1044                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001A3C  B4BC 00000000           1045                            CMP.L       #0, D2              ; checks if it is 0
00001A42  6600 0008               1046                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A46  4EB9 00001A5C           1047                            JSR         PRINTZERO           ; prints a zero
00001A4C                          1048  
00001A4C  143C 0010               1049  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001A50  103C 000F               1050                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001A54  4E4F                    1051                            TRAP        #15                 ; is trap task 15
00001A56  4CDF 0007               1052                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001A5A  4E75                    1053                            RTS                             ; returns from subroutine    
00001A5C                          1054  * Prints a zero
00001A5C                          1055  * Input: nothing
00001A5C                          1056  * Output: 0 printed out to the console
00001A5C  2F01                    1057  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001A5E  7200                    1058                            MOVE.L      #0,D1               ; moves 0 to D1
00001A60  4EB8 1934               1059                            JSR         PRINTNUM            ; prints the number
00001A64  221F                    1060                            MOVE.L      (SP)+,D1            ; restores D1
00001A66  4E75                    1061                            RTS                             ; returns from subroutine
00001A68                          1062              
00001A68                          1063  * Prints contents of things between a range
00001A68                          1064  * input: A5, A6 (the range)
00001A68                          1065  * output: prints memory contents from A5 to A6 as strings   
00001A68  48E7 C040               1066  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001A6C  224D                    1067                  MOVEA.L     A5, A1           ; loads A5 into A1
00001A6E  9DCD                    1068                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001A70  320E                    1069                  MOVE.W      A6, D1           ; move n into D1
00001A72  103C 0001               1070                  MOVE.B      #1, D0           ; display n characters of string at A1
00001A76  4E4F                    1071                  TRAP        #15              ; is trap task 1
00001A78  4CDF 0203               1072                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001A7C  4E75                    1073                  RTS                          ; returns
00001A7E                          1074      
00001A7E                          1075  * Prints null terminated string
00001A7E                          1076  * input: string pointed to by A5
00001A7E                          1077  * output: prints out the null terminated string
00001A7E  48E7 8040               1078  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001A82  224D                    1079                  MOVE.L      A5,A1           ; loads A5 into A1
00001A84  103C 000E               1080                  MOVE.B      #14,D0          ; prints null terminated string
00001A88  4E4F                    1081                  TRAP        #15             ; is trap task 10
00001A8A  4CDF 0201               1082                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001A8E  4E75                    1083                  RTS                         ; returns from subroutine
00001A90                          1084                  
00001A90  2F0D                    1085  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001A92  4BF9 00001C7A           1086                  LEA         NEW_LINE,A5     ; Prints null
00001A98  4EB8 1A7E               1087                  JSR         PRINTNULL       ; prints the new line
00001A9C  2A5F                    1088                  MOVE.L      (SP)+,A5        ; returns A5
00001A9E  4E75                    1089                  RTS
00001AA0                          1090  
00001AA0                          1091  * Prints the size of the MOVE or MOVEA operation  
00001AA0                          1092  * input: D0
00001AA0                          1093  * output: prints out the size of a MOVE or MOVEA operation        
00001AA0  48E7 8004               1094  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001AA4  3200                    1095                  MOVE.W  D0,D1               ; stores d0 in d1
00001AA6  C07C 3000               1096                  AND.W   #$3000,D0           ; gets the size
00001AAA  B07C 2000               1097                  CMP.W   #$2000,D0           ; checks if is long
00001AAE  6700 001E               1098                  BEQ     MOVE_LONG
00001AB2  B07C 3000               1099                  CMP.W   #$3000,D0           ; checks if is word
00001AB6  6700 000C               1100                  BEQ     MOVE_WORD      
00001ABA                          1101                  
00001ABA  4BF9 00001D85           1102  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001AC0  6000 0012               1103                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001AC4                          1104  
00001AC4  4BF9 00001D8B           1105  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001ACA  6000 0008               1106                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001ACE                          1107  
00001ACE  4BF9 00001D91           1108  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001AD4                          1109                  
00001AD4  4EB8 1A7E               1110  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001AD8  4CDF 2001               1111                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001ADC  4E75                    1112                  RTS
00001ADE                          1113  
00001ADE  43F9 00001C5E           1114  ERROR           LEA     ERROR_MSG,A1
00001AE4  103C 000E               1115                  MOVE.B  #14,D0
00001AE8  4E4F                    1116                  TRAP    #15 
00001AEA                          1117         
00001AEA                          1118  * DELETE THIS: Test                
00001AEA  2661                    1119  DELETEME        MOVEA.L  -(A1),A3
00001AEC  6700 002A               1120                  BEQ      DELETEMEAGAIN  
00001AF0  6F00 0026               1121                  BLE      DELETEMEAGAIN
00001AF4  6E00 0022               1122                  BGT      DELETEMEAGAIN
00001AF8                          1123  
00001AF8  E40A                    1124                  LSR.B      #2,D2
00001AFA  E2E2                    1125                  LSR.W      -(A2)
00001AFC  E2DA                    1126                  LSR.W      (A2)+
00001AFE  E4AA                    1127                  LSR.L      D2,D2 
00001B00  E50A                    1128                  LSL.B      #2,D2
00001B02  E3E2                    1129                  LSL.W      -(A2)
00001B04  E3DA                    1130                  LSL.W      (A2)+
00001B06  E5AA                    1131                  LSL.L      D2,D2
00001B08  E51A                    1132                  ROL.B      #2,D2
00001B0A  E7E2                    1133                  ROL.W      -(A2)
00001B0C  E7DA                    1134                  ROL.W      (A2)+
00001B0E  E5BA                    1135                  ROL.L      D2,D2
00001B10  E41A                    1136                  ROR.B      #2,D2
00001B12  E6E2                    1137                  ROR.W      -(A2)
00001B14  E6DA                    1138                  ROR.W      (A2)+
00001B16  E4BA                    1139                  ROR.L      D2,D2
00001B18                          1140                         
00001B18                          1141                  
00001B18                          1142  DELETEMEAGAIN                 
00001B18                          1143            
00001B18  FFFF FFFF               1144      SIMHALT             ; halt simulator
00001B1C                          1145  
00001B1C                          1146  * Put variables and constants here
00001B1C                          1147  
00001B1C  =0000000D               1148  CR                              EQU     $0D
00001B1C  =0000000A               1149  LF                              EQU     $0A 
00001B1C  =00000009               1150  TAB                             EQU     $09  
00001B1C                          1151  
00001B1C                          1152  * Addressing Modes
00001B1C  =00000000               1153  Dn                              EQU     0
00001B1C  =00000001               1154  An                              EQU     1
00001B1C  =00000002               1155  AnIndirect                      EQU     2
00001B1C  =00000003               1156  AnPost                          EQU     3
00001B1C  =00000004               1157  AnPre                           EQU     4
00001B1C  =00000007               1158  Other                           EQU     7           ; short, long, immediate
00001B1C                          1159  
00001B1C                          1160  * Xn
00001B1C  =00000000               1161  ABSShort                        EQU     0
00001B1C  =00000001               1162  ABSLong                         EQU     1
00001B1C  =00000004               1163  XnImmediate                     EQU     4
00001B1C                          1164  
00001B1C                          1165  * Valid Addressing Modes
00001B1C= 00 01 02 03 04 07 FF    1166  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001B23                          1167  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001B23= 00 02 03 04 07 FF       1168  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001B29= 02 04 07 FF             1169  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001B2D= 02 03 07 FF             1170  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001B31= 02 03 04 07 FF          1171  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001B36= 00 02 03 04 07 FF       1172  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001B3C= 01 07 FF                1173  VALIDEA_LEA                     DC.B    An,Other,-1
00001B3F= 00 02 03 04 07 FF       1174  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001B45= 02 03 04 07 FF          1175  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001B4A= 02 03 04 07 FF          1176  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001B4F= 02 07 FF                1177  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001B52                          1178  
00001B52                          1179  * Valid Xn
00001B52= 00 01 04 FF             1180  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001B56                          1181  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001B56= 00 01 FF                1182  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001B59                          1183  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001B59                          1184  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001B59                          1185  
00001B59                          1186  * posible memory ASd/LSd rotation values
00001B59  =00000000               1187  ASd_MEM                         EQU     0   
00001B59  =00000001               1188  LSd_MEM                         EQU     1 
00001B59  =00000003               1189  ROd_MEM                         EQU     3
00001B59                          1190   
00001B59  =00000000               1191  ASd_REG                         EQU     0   
00001B59  =00000001               1192  LSd_REG                         EQU     1 
00001B59  =00000003               1193  ROd_REG                         EQU     3
00001B59                          1194  
00001B59                          1195  * Starting messages
00001B59= 57 65 6C 63 6F 6D ...   1196  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001B80= 46 6F 72 6D 61 74 ...   1197                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001BCF= 50 6C 65 61 73 65 ...   1198  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001C06= 50 6C 65 61 73 65 ...   1199  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001C3C= 49 6E 76 61 6C 69 ...   1200  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001C5E= 45 72 72 6F 72 20 ...   1201  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001C7A= 0D 0A 00                1202  NEW_LINE                        DC.B    CR,LF,0
00001C7D= 09 09 09 00             1203  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001C81                          1204  
00001C81                          1205  * Opcode Messages
00001C81= 09 4E 4F 50 00          1206  MSG_NOP                         DC.B    TAB,'NOP',0
00001C86= 09 4D 4F 56 45 00       1207  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001C8C= 09 4D 4F 56 45 41 00    1208  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001C93= 09 4D 4F 56 45 51 00    1209  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001C9A= 09 4D 4F 56 45 4D 00    1210  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001CA1= 09 41 44 44 00          1211  MSG_ADD                         DC.B    TAB,'ADD',0
00001CA6= 09 41 44 44 41 00       1212  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001CAC= 09 41 44 44 51 00       1213  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001CB2= 09 53 55 42 00          1214  MSG_SUB                         DC.B    TAB,'SUB',0
00001CB7= 09 4D 55 4C 53 00       1215  MSG_MULS                        DC.B    TAB,'MULS',0
00001CBD= 09 44 49 56 55 00       1216  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001CC3= 09 4C 45 41 09 09 ...   1217  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001CCB= 09 41 4E 44 00          1218  MSG_AND                         DC.B    TAB,'AND',0
00001CD0= 09 4F 52 00             1219  MSG_OR                          DC.B    TAB,'OR',0
00001CD4= 09 4E 4F 54 00          1220  MSG_NOT                         DC.B    TAB,'NOT',0
00001CD9= 09 4C 53 00             1221  MSG_LSd                         DC.B    TAB,'LS',0
00001CDD= 09 41 53 00             1222  MSG_ASd                         DC.B    TAB,'AS',0
00001CE1= 09 52 4F 00             1223  MSG_ROd                         DC.B    TAB,'RO',0
00001CE5= 09 42 43 43 09 09 ...   1224  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001CED= 09 42 43 53 09 09 ...   1225  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001CF5= 09 42 45 51 09 09 ...   1226  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001CFD= 09 42 4E 45 09 09 ...   1227  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001D05= 09 42 47 45 09 09 ...   1228  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001D0D= 09 42 47 54 09 09 ...   1229  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001D15= 09 42 48 49 09 09 ...   1230  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001D1D= 09 42 4C 45 09 09 ...   1231  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001D25= 09 42 4C 53 09 09 ...   1232  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001D2D= 09 42 4C 54 09 09 ...   1233  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001D35= 09 42 4D 49 09 09 ...   1234  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001D3D= 09 42 50 4C 09 09 ...   1235  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001D45= 09 42 56 43 09 09 ...   1236  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001D4D= 09 42 56 53 09 09 ...   1237  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001D55= 09 4A 53 52 09 09 ...   1238  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001D5D= 09 52 54 53 00          1239  MSG_RTS                         DC.B    TAB,'RTS',0
00001D62= 09 42 52 41 09 09 ...   1240  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001D6A                          1241  
00001D6A                          1242  * Direction for LSd and ASd
00001D6A= 52 00                   1243  MSG_RIGHT                       DC.B    'R',0
00001D6C= 4C 00                   1244  MSG_LEFT                        DC.B    'L',0
00001D6E                          1245  
00001D6E                          1246  * Effective Addresses Messages
00001D6E= 44 00                   1247  MSG_DR                          DC.B    'D',0
00001D70= 41 00                   1248  MSG_AR                          DC.B    'A',0
00001D72= 28 00                   1249  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001D74= 29 00                   1250  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001D76= 2B 00                   1251  MSG_PLUS                        DC.B    '+',0
00001D78= 2D 00                   1252  MSG_MINUS                       DC.B    '-',0
00001D7A= 23 00                   1253  MSG_POUND                       DC.B    '#',0 
00001D7C= 24 00                   1254  MSG_HEX                         DC.B    '$',0 
00001D7E= 2C 20 00                1255  MSG_COMMA                       DC.B    ', ',0 
00001D81= 20 00                   1256  MSG_SPACE                       DC.B    ' ',0
00001D83= 09 00                   1257  MSG_TAB                         DC.B    TAB,0
00001D85                          1258  
00001D85                          1259  * Size Messages
00001D85= 2E 42 09 09 09 00       1260  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001D8B= 2E 57 09 09 09 00       1261  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001D91= 2E 4C 09 09 09 00       1262  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001D97                          1263  
00001D97                          1264  * Variables
00001D97  =00000100               1265  STARTING_ADDRESS                EQU     $100
00001D97  =00000150               1266  ENDING_ADDRESS                  EQU     $150
00001D97  =00000200               1267  CURRENT_INSTR                   EQU     $200
00001D97  =00000250               1268  REG_VAR                         EQU     $250 * Hold bits 11-9
00001D97  =00000300               1269  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001D97  =00000350               1270  EA_MODE                         EQU     $350 * Hold bits 5-3
00001D97  =00000400               1271  EA_REG                          EQU     $400 * Hold bits 2-0
00001D97                          1272  
00001D97                          1273              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1C3C
CASE_ADD            12E2
CASE_ADDA           135C
CASE_ADDQ           135C
CASE_AND            13EE
CASE_AR             17FC
CASE_ARI            1814
CASE_ARIPOST        1844
CASE_ARIPRE         1880
CASE_ASDMEM         142E
CASE_ASDREG         14F6
CASE_BCC            162E
CASE_BEQ            1660
CASE_BGT            1674
CASE_BLE            166A
CASE_BRA            160A
CASE_DATA           16A4
CASE_DR             17E4
CASE_EPICFAIL       16A6
CASE_IMMEDIATE      18CE
CASE_JSR            168E
CASE_LEA            135C
CASE_LEFTMEM        1454
CASE_LEFTREG        151C
CASE_LONG           190E
CASE_LSDASD         13EE
CASE_LSDMEM         1424
CASE_LSDREG         14EC
CASE_MOVE           1188
CASE_MOVEM          122A
CASE_MOVEQ          1290
CASE_NOP            1172
CASE_NOT            13EE
CASE_OR             13EE
CASE_OTHER          18BC
CASE_RIGHTMEM       145E
CASE_RIGHTREG       1526
CASE_RODMEM         1438
CASE_RODREG         1500
CASE_RTS            168E
CASE_SHIFTMEM       140C
CASE_SHIFTREG       14D2
CASE_SUB            135C
CASE_WORD           18F2
CHECKEAEXIT         17B4
CHECKEAMLOOP        1786
CHECKEAXN_IFVALID   1784
CHECKGET_EAXN       16FC
CHECKMEMSOURE       1492
CHECKSHIFT_XN       14BC
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            172C
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1AEA
DELETEMEAGAIN       1B18
DESTEA              16B2
DESTXN              16DC
DISASSEMBLE         10A4
DN                  0
EASHIFT_VALID       14B0
EAXN_INVALID        173E
EAXN_VALID          1724
EA_MODE             350
EA_REG              400
EA_TO_STRING        17B8
EA_TO_STRING_EXIT   192E
ENDING              1C06
ENDING_ADDRESS      150
END_CHECKGET        1742
ERROR               1ADE
ERROR_MSG           1C5E
FINDTYPEEA          16C6
FINDTYPEXN          16F0
FINISHMOVE          1AD4
GETDIRECTION        176C
GETDISPLACEMENT     1744
GETMEMSOURCE        147A
GETROTATION         1762
GETROTATIONLOCATION  177C
GETROTATIONSIZE     1774
GET_EA              16A8
GET_XN              16D2
INPUT1              100C
INPUT2              1052
INSERTA             11F6
INVALID             112C
INVALIDEA           1798
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       1290
MOVEM_REG2MEM       1260
MOVE_BYTE           1ABA
MOVE_LONG           1ACE
MOVE_WORD           1AC4
MSG_ADD             1CA1
MSG_ADDA            1CA6
MSG_ADDQ            1CAC
MSG_AND             1CCB
MSG_AR              1D70
MSG_ASD             1CDD
MSG_B               1D85
MSG_BCC             1CE5
MSG_BCS             1CED
MSG_BEQ             1CF5
MSG_BGE             1D05
MSG_BGT             1D0D
MSG_BHI             1D15
MSG_BLE             1D1D
MSG_BLS             1D25
MSG_BLT             1D2D
MSG_BMI             1D35
MSG_BNE             1CFD
MSG_BPL             1D3D
MSG_BRA             1D62
MSG_BVC             1D45
MSG_BVS             1D4D
MSG_COMMA           1D7E
MSG_DIVU            1CBD
MSG_DR              1D6E
MSG_HEX             1D7C
MSG_JSR             1D55
MSG_L               1D91
MSG_LB              1D72
MSG_LEA             1CC3
MSG_LEFT            1D6C
MSG_LSD             1CD9
MSG_MINUS           1D78
MSG_MOVE            1C86
MSG_MOVEA           1C8C
MSG_MOVEM           1C9A
MSG_MOVEQ           1C93
MSG_MULS            1CB7
MSG_NOP             1C81
MSG_NOT             1CD4
MSG_OR              1CD0
MSG_PLUS            1D76
MSG_POUND           1D7A
MSG_RB              1D74
MSG_RIGHT           1D6A
MSG_ROD             1CE1
MSG_RTS             1D5D
MSG_SPACE           1D81
MSG_SUB             1CB2
MSG_TAB             1D83
MSG_W               1D8B
NEW_LINE            1C7A
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OTHER               7
OTHEREA             17B0
PRINTADDRESS        1754
PRINTASHEX          1A4C
PRINTBCC            167E
PRINTENTER          1A90
PRINTHEXNUM         1944
PRINTLONGZERO       19A4
PRINTMOVE           11FC
PRINTMOVESIZE       1AA0
PRINTNULL           1A7E
PRINTNUM            1934
PRINTRANGE          1A68
PRINTREGEA          1568
PRINTREGSIZE        1536
PRINTSHIFTMEM       143E
PRINTSHIFTREG       1506
PRINTSHORTLONGNUM   1958
PRINTSHORTZERO      1964
PRINTZERO           1A5C
PRINT_MEMDIR        1464
PRINT_MOVEQ         12B2
PRINT_REGDIR        1530
REG2MEMXNCHECK      127A
REG_BYTE            154E
REG_IMMEDIATE       157E
REG_LONG            1562
REG_REGISTER        15C4
REG_VAR             250
REG_WORD            1558
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            16BE
SOURCEXN            16E8
START               1000
STARTING            1BCF
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           1C7D
VALIDEA             17A0
VALIDEA_ADDSUB_DESTOPERAND  1B31
VALIDEA_ALL         1B1C
VALIDEA_ANDORNOT    1B3F
VALIDEA_ANDOR_DESTOPERAND  1B45
VALIDEA_JSR         1B4F
VALIDEA_LEA         1B3C
VALIDEA_MOVEM_MEMTOREG  1B2D
VALIDEA_MOVEM_REGTOMEM  1B29
VALIDEA_MOVEQ       1B23
VALIDEA_MULSDIVU    1B36
VALIDEA_SHIFT       1B4A
VALIDXN_ALL         1B52
VALIDXN_SHORTLONG   1B56
WELCOME             1B59
XNIMMEDIATE         4
