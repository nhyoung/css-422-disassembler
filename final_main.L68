00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/8/2020 3:35:10 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 0000213D             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 000021CD             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 00001132             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 00001144             28                  JSR     CONVERT
0000103E  4EB9 000011B0             29                  JSR     TEST_RANGE
00001044  4EB9 000011C8             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00002204             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 00001132             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 00001144             47                  JSR     CONVERT
00001086  4EB9 000011B0             48                  JSR     TEST_RANGE
0000108C  4EB9 000011C8             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0088                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4                            58  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010A4                            59                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A4                            60                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010A4  4EB9 000011DC             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010AA  4EB9 00002066             62                  JSR     PRINTENTER          ; prints a new line
000010B0  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010B2  6FF0                      64                  BLE     DISASSEMBLE         ; if not, loop
000010B4                            65  
000010B4  4BF9 00002287             66  FINISHED        LEA     DONE,A5
000010BA  4EB9 00002054             67                  JSR     PRINTNULL
000010C0  103C 0005                 68                  MOVE.B  #5,D0
000010C4  4E4F                      69                  TRAP    #15
000010C6                            70                  
000010C6  B23C 000D                 71                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010CA  6700 0008                 72                  BEQ     RESTART             ; it's Enter, restart
000010CE                            73                  
000010CE  103C 0009                 74                  MOVE.B  #9,D0
000010D2  4E4F                      75                  TRAP    #15
000010D4                            76                  
000010D4  103C 000B                 77  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010D8  323C FF00                 78                  MOVE.W  #$FF00, D1          Clear Screen
000010DC  4E4F                      79                  TRAP    #15                 Call Trap
000010DE                            80                  
000010DE  103C 000C                 81                  MOVE.B  #12,D0              Keyboard echo
000010E2  123C 0001                 82                  MOVE.B  #1,D1               Visible
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  207C 00000000             85                  MOVE.L  #$0000000, A0       ; Reset A1
000010EE  227C 00000000             86                  MOVE.L  #$0000000, A1       ; Reset A1
000010F4  247C 00000000             87                  MOVE.L  #$0000000, A2       ; Reset A2
000010FA  267C 00000000             88                  MOVE.L  #$0000000, A3       ; Reset A3
00001100  287C 00000000             89                  MOVE.L  #$0000000, A4       ; Reset A4
00001106  2A7C 00000000             90                  MOVE.L  #$0000000, A5       ; Reset A5
0000110C  2C7C 00000000             91                  MOVE.L  #$0000000, A6       ; Reset A6
00001112  2E7C 01000000             92                  MOVEA.L #$01000000,A7       ; Reset A7
00001118  4281                      93                  CLR.L   D1                  ; Reset D1
0000111A  4281                      94                  CLR.L   D1                  ; Reset D1
0000111C  4282                      95                  CLR.L   D2                  ; Reset D2
0000111E  4283                      96                  CLR.L   D3                  ; Reset D3
00001120  4284                      97                  CLR.L   D4                  ; Reset D4
00001122  4285                      98                  CLR.L   D5                  ; Reset D5
00001124  4286                      99                  CLR.L   D6                  ; Reset D6
00001126  6000 FED8                100                  BRA     START               ; branch to start of program
0000112A                           101  
0000112A                           102  *--------------------SUBROUTINES------------------    
0000112A                           103  
0000112A  143C 0001                104  RESET_INPUT     MOVE.B  #1,D2
0000112E  6000 0062                105                  BRA     INVALID            
00001132                           106                  
00001132  7800                     107  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001134  B204                     108                  CMP.B   D4,D1               ; D1 stores length
00001136  6700 005A                109                  BEQ     INVALID             ; input is null
0000113A  0C41 0008                110                  CMPI    #$8,D1              ; check if input is longer than a longword
0000113E  6600 0052                111                  BNE     INVALID             ; input is longer than a longword
00001142  4E75                     112                  RTS
00001144                           113                              
00001144  4283                     114  CONVERT         CLR.L   D3
00001146  4284                     115                  CLR.L   D4
00001148  1619                     116                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000114A  B63C 0039                117                  CMP.B   #57,D3
0000114E  6E00 0012                118                  BGT     NOTNUMBER
00001152                           119                  
00001152  B63C 002F                120                  CMP.B   #47,D3
00001156  6E00 0002                121                  BGT     ISNUMBER
0000115A                           122                  
0000115A  0603 00D0                123  ISNUMBER        ADD.B   #-48,D3             ; current char is number
0000115E  6000 001A                124                  BRA     CONCAT
00001162                           125              
00001162  B63C 0041                126  NOTNUMBER       CMP.B   #65,D3
00001166  6D00 002A                127                  BLT     INVALID
0000116A  B63C 0046                128                  CMP.B   #70,D3
0000116E  6E00 0022                129                  BGT     INVALID  
00001172  0603 00C9                130                  ADD.B   #-55,D3             ; is letter             
00001176  6000 0002                131                  BRA     CONCAT
0000117A                           132              
0000117A  BC3C 0000                133  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000117E  6D00 0010                134                  BLT     RETURN
00001182  1806                     135                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001184  E50C                     136                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001186  E9AB                     137                  LSL.L   D4,D3               ; moves current char to correct position  
00001188  DA83                     138                  ADD.L   D3,D5               ; D5 stores converted input so far
0000118A  0606 00FF                139                  ADD.B   #-1,D6  
0000118E  60B4                     140                  BRA     CONVERT             ; continue loop for remaining chars
00001190                           141                  
00001190  4E75                     142  RETURN          RTS
00001192                           143                  
00001192  227C 00000000            144  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001198  43F9 0000223A            145                  LEA     BAD_INPUT,A1        ; output invalid message
0000119E  103C 000E                146                  MOVE.B  #14,D0
000011A2  4E4F                     147                  TRAP    #15
000011A4  B47C 0001                148                  CMP     #1,D2
000011A8  6700 FE62                149                  BEQ     INPUT1
000011AC  6000 FEA4                150                  BRA     INPUT2
000011B0                           151  
000011B0  4284                     152  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011B2  223C 00001000            153                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011B8  BA81                     154                  CMP.L      D1,D5            ; Compare minimum address with input
000011BA  6DD6                     155                  BLT        INVALID          ; input is too low. 
000011BC  223C 00FFFFFE            156                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011C2  BA81                     157                  CMP.L      D1,D5            ; compare maximum address with input
000011C4  6ECC                     158                  BGT        INVALID          ; input too large
000011C6  4E75                     159                  RTS                         ; input is within range
000011C8                           160             
000011C8  0805 0000                161  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011CC  66C4                     162                  BNE        INVALID
000011CE  4E75                     163                  RTS
000011D0                           164  
000011D0                           165  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
000011D0                           166  *                MOVE.L  A6,D1                   ; loads current address in D1
000011D0                           167  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011D0                           168  *                JSR     PRINTSHORTLONGNUM       ; prints out address
000011D0                           169  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
000011D0                           170  *                RTS
000011D0  220E                     171                  MOVE.L  A6,D1                   ; loads current address in D1
000011D2  7801                     172                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011D4  4EB9 00001F2E            173                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011DA  4E75                     174                  RTS
000011DC                           175  
000011DC                           176  
000011DC                           177  
000011DC                           178  * Checks every single possible opcode we could have. Jump table
000011DC                           179  * Inputs: (A2) which is a pointer to intruction word to be translated
000011DC                           180  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011DC                           181  
000011DC  3C4A                     182  OPCODE_DECODE   MOVE.W  A2,A6
000011DE  301A                     183                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011E0                           184                  
000011E0                           185  
000011E0                           186  *---------------NOP opcode----------------------                
000011E0  B07C 4E71                187  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011E4  6600 0014                188                  BNE     CASE_MOVE               ; checks the next case if not equal
000011E8                           189                  
000011E8  4EB8 11D0                190                  JSR     PRINT_ADDR
000011EC  4BF9 000022C0            191                  LEA     MSG_NOP,A5              ; loads string pointer into A5
000011F2  4EB9 00002054            192                  JSR     PRINTNULL               ; prints NOP                
000011F8  4E75                     193                  RTS                             ; returns from the subroutine
000011FA                           194  
000011FA                           195  *---------------MOVE opcode----------------------              
000011FA                           196                  * if first two bits are 00, next two are not 00
000011FA  3200                     197  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
000011FC  C27C C000                198                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001200  6600 009E                199                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001204  B07C 0FFF                200                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001208  6F00 0096                201                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
0000120C                           202                  
0000120C                           203                  ; Check source
0000120C  4BF9 00002100            204                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001212  4DF9 00002136            205                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001218  3E3C 0000                206                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000121C  4EB9 00001C20            207                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001222  B27C 0001                208                  CMP.W   #1,D1                    ; checks if invalid
00001226  6700 09A0                209                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000122A  3802                     210                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000122C  3A03                     211                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000122E                           212                  
0000122E                           213                  ; Check destination
0000122E  4BF9 00002100            214                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001234  4DF9 0000213A            215                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000123A  3E3C 0001                216                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000123E  4EB9 00001C20            217                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001244  B27C 0001                218                  CMP.W   #1,D1                    ; checks if invalid
00001248  6700 097E                219                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000124C  3C02                     220                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
0000124E  3E03                     221                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001250                           222                  
00001250                           223                  ; Checking if it is MOVEA
00001250  3200                     224                  MOVE.W  D0,D1                    ; stores d0 in d1
00001252  C27C 01C0                225                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
00001256  B27C 0040                226                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000125A  6700 0010                227                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
0000125E                           228                  
0000125E  4EB8 11D0                229                  JSR     PRINT_ADDR               ; print address
00001262  4BF9 000022C5            230                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001268  6000 0008                231                  BRA     PRINTMOVE                ; Branches to print move
0000126C                           232                  
0000126C  4BF9 000022CB            233  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001272                           234   
00001272  4EB9 00002054            235  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001278  4EB9 00002076            236                  JSR     PRINTMOVESIZE            ; prints out the size  
0000127E  3404                     237                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001280  3605                     238                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001282  4EB9 00001D8E            239                  JSR     EA_TO_STRING             ; outputs it into a string
00001288                           240                  
00001288                           241                  ; prints a comma to seperate
00001288  4BF9 000023BD            242                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000128E  4EB9 00002054            243                  JSR     PRINTNULL                ; prints out MOVE
00001294                           244                  
00001294                           245                  ; print destination
00001294  3406                     246                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001296  3607                     247                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001298  4EB9 00001D8E            248                  JSR     EA_TO_STRING             ; outputs it into a string
0000129E  4E75                     249                  RTS                              ; exits subroutine                 
000012A0                           250                
000012A0                           251  *---------------MOVEM opcode----------------------                
000012A0  3200                     252  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012A2  C27C FB80                253                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012A6  B27C 4880                254                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012AA  6600 00F4                255                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012AE                           256                  
000012AE                           257                  ; Check D
000012AE  3200                     258                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012B0  C27C 0400                259                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012B4  3E01                     260                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012B6  B27C 0400                261                  CMP.W   #$0400,D1                       ; checks if value is 1
000012BA  6700 0074                262                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012BE                           263  
000012BE                           264  MOVEM_REG2MEM   ; loads EA and XN
000012BE  3E3C 0000                265                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000012C2  4BF9 0000210D            266                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
000012C8  4DF9 0000213A            267                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000012CE  4EB9 00001C20            268                  JSR     CHECKGET_EAXN
000012D4  B27C 0001                269                  CMP.W   #1,D1                           ; checks if D1 invalid
000012D8  6700 08EE                270                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000012DC  4EB8 11D0                271                  JSR     PRINT_ADDR                      ; prints the address
000012E0  4BF9 000022D9            272                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000012E6  4EB9 00002054            273                  JSR     PRINTNULL                       ; prints MOVEM
000012EC                           274                  
000012EC                           275                  ; finds and prints size
000012EC  3200                     276                  MOVE.W  D0,D1                           ; copies D0
000012EE  C27C 0040                277                  AND.W   #$0040,D1                       ; gets the size bit
000012F2  6600 0012                278                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000012F6                           279  
000012F6  4BF9 000023CC            280  REG2MEMWORD     LEA     MSG_W,A5                        ; loads MOVEM
000012FC  4EB9 00002054            281                  JSR     PRINTNULL                       ; prints MOVEM
00001302  6000 000E                282                  BRA     PRINTREG2MEM                    ; prints the registers           
00001306                           283                  
00001306  4BF9 000023D2            284  REG2MEMLONG     LEA     MSG_L,A5                        ; loads MOVEM
0000130C  4EB9 00002054            285                  JSR     PRINTNULL                       ; prints MOVEM 
00001312                           286             
00001312  383C 0001                287  PRINTREG2MEM    MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
00001316  4EB9 00001CB8            288                  JSR     PRINTREGISTERS                  ; prints registers
0000131C  4BF9 000023BD            289                  LEA     MSG_COMMA,A5                    ; loads comma
00001322  4EB9 00002054            290                  JSR     PRINTNULL                       ; prints comma
00001328  4EB9 00001D8E            291                  JSR     EA_TO_STRING                    ; prints EA
0000132E  4E75                     292                  RTS
00001330                           293  
00001330                           294  MOVEM_MEM2REG  ; loads EA and XN
00001330  3E3C 0000                295                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001334  4BF9 00002111            296                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
0000133A  4DF9 0000213A            297                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001340  4EB9 00001C20            298                  JSR     CHECKGET_EAXN
00001346  B27C 0001                299                  CMP.W   #1,D1                           ; checks if D1 invalid
0000134A  6700 087C                300                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000134E  4EB8 11D0                301                  JSR     PRINT_ADDR                      ; prints the address
00001352  4BF9 000022D9            302                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001358  4EB9 00002054            303                  JSR     PRINTNULL                       ; prints MOVEM
0000135E                           304                  
0000135E                           305                  ; finds and prints size
0000135E  3200                     306                  MOVE.W  D0,D1                           ; copies D0
00001360  C27C 0040                307                  AND.W   #$0040,D1                       ; gets the size bit
00001364  6600 0010                308                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001368                           309  
00001368  4BF9 000023CC            310  MEM2REGWORD     LEA     MSG_W,A5                        ; loads MOVEM
0000136E  4EB9 00002054            311                  JSR     PRINTNULL                       ; prints MOVEM
00001374  609C                     312                  BRA     PRINTREG2MEM                    ; prints the registers           
00001376                           313                  
00001376  4BF9 000023D2            314  MEM2REGLONG     LEA     MSG_L,A5                        ; loads MOVEM
0000137C  4EB9 00002054            315                  JSR     PRINTNULL                       ; prints MOVEM 
00001382                           316             
00001382  4EB9 00001D8E            317  PRINTMEM2REG    JSR     EA_TO_STRING                    ; prints EA
00001388  4BF9 000023BD            318                  LEA     MSG_COMMA,A5                    ; loads comma
0000138E  4EB9 00002054            319                  JSR     PRINTNULL                       ; prints comma
00001394  383C FFFF                320                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001398  4EB9 00001CB8            321                  JSR     PRINTREGISTERS                  ; prints registers
0000139E  4E75                     322                  RTS
000013A0                           323                          
000013A0                           324  
000013A0                           325  *---------------MOVEQ opcode----------------------
000013A0  3200                     326  CASE_MOVEQ      MOVE.W  D0,D1
000013A2  C27C F100                327                  AND.W   #$F100,D1
000013A6  B27C 7000                328                  CMP.W   #$7000,D1
000013AA  6600 004C                329                  BNE     CASE_ADD
000013AE                           330                  
000013AE                           331                  ;loads Register
000013AE  323C 0001                332                  MOVE.W  #1,D1                           ; copies instruction word to D1
000013B2  4EB9 00001BF6            333                  JSR     GET_XN                          ; gets XN and puts in D1
000013B8  3401                     334                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000013BA                           335                  
000013BA                           336                  ;loads DATA
000013BA  3200                     337                  MOVE.W  D0,D1
000013BC  C27C 00FF                338                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000013C0  3601                     339                  MOVE.W  D1,D3                          ;copy data into D3
000013C2                           340                                                        ;must convert bits to hex
000013C2                           341                                  
000013C2  4EB8 11D0                342  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
000013C6                           343  
000013C6  4BF9 000022D2            344                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000013CC  4EB9 00002054            345                  JSR     PRINTNULL  
000013D2                           346                  
000013D2  4BF9 000023D2            347                  LEA     MSG_L,A5                        ;PRINT SIZE L
000013D8  4EB9 00002054            348                  JSR     PRINTNULL
000013DE                           349      
000013DE  4BF9 000022BC            350                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000013E4  4EB9 00002054            351                  JSR     PRINTNULL
000013EA                           352                  
000013EA  4BF9 000023B9            353                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000013F0  4EB9 00002054            354                  JSR     PRINTNULL
000013F6  4E75                     355                  RTS
000013F8                           356                  
000013F8                           357  *---------------ADD opcode----------------------                
000013F8                           358  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000013F8  3200                     359  CASE_ADD        MOVE.W  D0,D1
000013FA  C27C F000                360                  AND.W   #$F000,D1
000013FE  B27C D000                361                  CMP.W   #$D000,D1
00001402  6600 01A2                362                  BNE     CASE_ADDQ
00001406                           363   
00001406  4EB8 11D0                364                  JSR     PRINT_ADDR              ; print address
0000140A                           365                  
0000140A  4EB9 00001424            366                  JSR     ADD_SUB_HELP
00001410                           367                  
00001410                           368                  ; bits 7-8 determine if it is ADDA or ADD
00001410  3200                     369                  MOVE.W  D0,D1
00001412  E149                     370                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001414  E049                     371                  LSR.W   #8,D1
00001416  EC49                     372                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001418  B27C 0003                373                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
0000141C  6700 0120                374                  BEQ     CASE_ADDA
00001420                           375                  
00001420  6000 0048                376                  BRA     PRINTADD                ; Branches to print add
00001424                           377                  
00001424                           378                  ; Check bits 0-5 
00001424  4BF9 00002100            379  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000142A  4DF9 00002136            380                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001430  3E3C 0000                381                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001434  4EB9 00001C20            382                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000143A  B27C 0001                383                  CMP.W       #1,D1                    ; checks if invalid
0000143E  6700 0788                384                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001442  3802                     385                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001444  3A03                     386                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001446                           387                  
00001446                           388                  ; Check 6-11
00001446  4BF9 00002100            389                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000144C  4DF9 0000213A            390                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001452  3E3C 0001                391                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001456  4EB9 00001C20            392                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000145C  B27C 0001                393                  CMP.W       #1,D1                    ; checks if invalid
00001460  6700 0766                394                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001464  3C02                     395                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001466  3E03                     396                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001468                           397    
00001468  4E75                     398                  RTS                
0000146A                           399                    
0000146A  4BF9 000022E0            400  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001470  4EB9 00002054            401                  JSR         PRINTNULL               ; print ADD
00001476  3200                     402                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001478  4EB9 00001482            403                  JSR         ADD_SUB_SIZE
0000147E  6000 0050                404                  BRA         FINISH_ADD
00001482                           405                    
00001482  3200                     406  ADD_SUB_SIZE    MOVE.W      D0,D1
00001484  E149                     407                  LSL.W       #8,D1
00001486  E049                     408                  LSR.W       #8,D1
00001488  EC49                     409                  LSR.W       #6,D1                   ; gets bits 6-7
0000148A                           410                    
0000148A  B27C 0000                411                  CMP.W       #0,D1
0000148E  6700 0016                412                  BEQ         ADD_SUB_BYTE
00001492  B27C 0001                413                  CMP.W       #1,D1                   ; if 1, it is a word
00001496  6700 001C                414                  BEQ         ADD_SUB_WORD
0000149A  B27C 0002                415                  CMP.W       #2,D1                   ; if 2, it is a long
0000149E  6700 0022                416                  BEQ         ADD_SUB_LONG
000014A2  6000 0254                417                  BRA         CASE_SUBA                    ; error
000014A6                           418                    
000014A6  4BF9 000023C6            419  ADD_SUB_BYTE    LEA         MSG_B,A5
000014AC  4EB9 00002054            420                  JSR         PRINTNULL
000014B2  4E75                     421                  RTS
000014B4                           422                    
000014B4  4BF9 000023CC            423  ADD_SUB_WORD    LEA         MSG_W,A5
000014BA  4EB9 00002054            424                  JSR         PRINTNULL
000014C0  4E75                     425                  RTS
000014C2                           426    
000014C2  4BF9 000023D2            427  ADD_SUB_LONG    LEA         MSG_L,A5
000014C8  4EB9 00002054            428                  JSR         PRINTNULL
000014CE  4E75                     429                  RTS
000014D0                           430        
000014D0  4EB9 000014D8            431  FINISH_ADD      JSR         ADD_SUB_OPERAND
000014D6  4E75                     432                  RTS
000014D8                           433    
000014D8  EF49                     434  ADD_SUB_OPERAND LSL.W       #7,D1
000014DA  EE49                     435                  LSR.W       #7,D1
000014DC  E049                     436                  LSR.W       #8,D1
000014DE  B27C 0001                437                  CMP.W       #1,D1
000014E2  6600 002E                438                  BNE         Dn_PLUS_EA          
000014E6                           439                    
000014E6                           440                  ; print Data Register
000014E6  4BF9 000023AD            441                  LEA         MSG_DR,A5
000014EC  4EB9 00002054            442                  JSR         PRINTNULL
000014F2  3207                     443                  MOVE.W      D7,D1
000014F4  4EB9 00001F0A            444                  JSR         PRINTNUM                
000014FA                           445                  
000014FA                           446                  ; prints a comma to seperate
000014FA  4BF9 000023BD            447                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001500  4EB9 00002054            448                  JSR         PRINTNULL                ; prints out MOVE
00001506                           449                 
00001506                           450                  ; below is EA+Dn->Dn  
00001506  3404                     451                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001508  3605                     452                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000150A  4EB9 00001D8E            453                  JSR         EA_TO_STRING             ; outputs it into a string
00001510  4E75                     454                  RTS                                 ; exits subroutine 
00001512                           455  
00001512                           456  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001512  3404                     457                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001514  3605                     458                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001516  4EB9 00001D8E            459                  JSR         EA_TO_STRING             ; outputs it into a string   
0000151C                           460                  
0000151C                           461                  ; prints a comma to seperate
0000151C  4BF9 000023BD            462                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001522  4EB9 00002054            463                  JSR         PRINTNULL                ; prints out MOVE
00001528                           464                  
00001528                           465                  ; below is Dn+EA->EA
00001528  4BF9 000023AD            466                  LEA         MSG_DR,A5                ; print data register
0000152E  4EB9 00002054            467                  JSR         PRINTNULL
00001534  3207                     468                  MOVE.W      D7,D1
00001536  4EB9 00001F0A            469                  JSR         PRINTNUM             
0000153C  4E75                     470                  RTS                                  ; exits subroutine          
0000153E                           471                        
0000153E                           472  *---------------ADDA opcode----------------------
0000153E                           473  CASE_ADDA       ; gets bit 8 (size bit)
0000153E  3200                     474                  MOVE.W      D0,D1
00001540  EF49                     475                  LSL.W       #7,D1
00001542  EE49                     476                  LSR.W       #7,D1
00001544  E049                     477                  LSR         #8,D1                   
00001546                           478                  
00001546  4BF9 000022E5            479                  LEA         MSG_ADDA,A5             ; print ADDA
0000154C  4EB9 00002054            480                  JSR         PRINTNULL
00001552                           481                   
00001552  B27C 0001                482                  CMP.W       #1,D1
00001556  6700 0012                483                  BEQ         ADDA_LONG
0000155A                           484                    
0000155A  4BF9 000023CC            485                  LEA         MSG_W,A5
00001560  4EB9 00002054            486                  JSR         PRINTNULL
00001566  6000 0012                487                  BRA         FINISH_ADDA   
0000156A                           488                    
0000156A  4BF9 000023D2            489  ADDA_LONG       LEA         MSG_L,A5
00001570  4EB9 00002054            490                  JSR         PRINTNULL
00001576  6000 0002                491                  BRA         FINISH_ADDA
0000157A                           492                    
0000157A  3404                     493  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000157C  3605                     494                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000157E  4EB9 00001D8E            495                  JSR         EA_TO_STRING             ; outputs it into a string
00001584                           496                    
00001584                           497                  ; prints a comma to seperate
00001584  4BF9 000023BD            498                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000158A  4EB9 00002054            499                  JSR         PRINTNULL                ; prints out MOVE
00001590                           500            
00001590  4BF9 000023AF            501                  LEA         MSG_AR,A5                ; print address register
00001596  4EB9 00002054            502                  JSR         PRINTNULL
0000159C  3207                     503                  MOVE.W      D7,D1
0000159E  4EB9 00001F0A            504                  JSR         PRINTNUM             
000015A4  4E75                     505                  RTS                              ; exits subroutine
000015A6                           506                  
000015A6                           507  *---------------ADDQ opcode----------------------                  
000015A6  3200                     508  CASE_ADDQ       MOVE.W      D0,D1
000015A8  C27C F000                509                  AND.W       #$F000,D1       
000015AC  B27C 5000                510                  CMP.W       #$5000,D1
000015B0  6600 00CC                511                  BNE         CASE_SUB
000015B4                           512                                                   
000015B4  4EB8 11D0                513                  JSR         PRINT_ADDR              ; print address  
000015B8  4BF9 000022EB            514                  LEA         MSG_ADDQ,A5             ; print ADDQ
000015BE  4EB9 00002054            515                  JSR         PRINTNULL
000015C4                           516                  
000015C4                           517                  ; get bits 6-7 (size bits)
000015C4  3200                     518                  MOVE.W      D0,D1
000015C6  E149                     519                  LSL.W       #8,D1
000015C8  E049                     520                  LSR.W       #8,D1
000015CA  EC49                     521                  LSR.W       #6,D1
000015CC  3401                     522                  MOVE.W      D1,D2
000015CE                           523                  
000015CE                           524                  ; Check bits 0-5 
000015CE  4BF9 00002100            525                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000015D4  4DF9 00002136            526                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000015DA  3E3C 0000                527                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000015DE  4EB9 00001C20            528                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000015E4  B27C 0001                529                  CMP.W       #1,D1                    ; checks if invalid
000015E8  6700 05DE                530                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000015EC  3802                     531                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000015EE  3A03                     532                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000015F0                           533                  
000015F0  B47C 0001                534                  CMP.W       #1,D2
000015F4  6700 001A                535                  BEQ         ADDQ_WORD
000015F8  B47C 0002                536                  CMP.W       #2,D2
000015FC  6700 0022                537                  BEQ         ADDQ_LONG
00001600                           538                    
00001600  4BF9 000023C6            539  ADDQ_BYTE       LEA         MSG_B,A5
00001606  4EB9 00002054            540                  JSR         PRINTNULL
0000160C  6000 0022                541                  BRA         FINISH_ADDQ  
00001610                           542   
00001610  4BF9 000023CC            543  ADDQ_WORD       LEA         MSG_W,A5
00001616  4EB9 00002054            544                  JSR         PRINTNULL
0000161C  6000 0012                545                  BRA         FINISH_ADDQ                 
00001620                           546    
00001620  4BF9 000023D2            547  ADDQ_LONG       LEA         MSG_L,A5
00001626  4EB9 00002054            548                  JSR         PRINTNULL
0000162C  6000 0002                549                  BRA         FINISH_ADDQ                  
00001630                           550                    
00001630  4EB9 0000164E            551  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001636                           552   
00001636                           553                  ; prints a comma to seperate
00001636  4BF9 000023BD            554                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000163C  4EB9 00002054            555                  JSR         PRINTNULL                ; prints out MOVE
00001642                           556                    
00001642                           557                  ; prints destination
00001642  3404                     558                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001644  3605                     559                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001646  4EB9 00001D8E            560                  JSR         EA_TO_STRING             ; outputs it into a string
0000164C                           561                 
0000164C  4E75                     562                  RTS
0000164E                           563   
0000164E  4BF9 000023B9            564  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
00001654  4EB9 00002054            565                  JSR         PRINTNULL
0000165A                           566                  ; gets bits 9-11 (data bits)
0000165A  E949                     567                  LSL.W       #4,D1
0000165C  E849                     568                  LSR.W       #4,D1                               ; get rid of left 4 bits
0000165E  E049                     569                  LSR.W       #8,D1
00001660  E249                     570                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001662                           571                  
00001662  B27C 0000                572                  CMP.W       #0,D1
00001666  6700 000A                573                  BEQ         PRINT_8
0000166A  4EB9 00001F0A            574                  JSR         PRINTNUM
00001670  4E75                     575                  RTS 
00001672                           576  
00001672  123C 0008                577  PRINT_8         MOVE.B      #8,D1
00001676  4EB9 00001F0A            578                  JSR         PRINTNUM
0000167C  4E75                     579                  RTS   
0000167E                           580         
0000167E                           581  *---------------SUB opcode---------------------- 
0000167E  3200                     582  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
00001680  C27C F000                583                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001684  B27C 9000                584                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001688  6600 0084                585                  BNE         CASE_LEA
0000168C                           586                 
0000168C  4EB8 1424                587                  JSR         ADD_SUB_HELP
00001690  4EB8 11D0                588                  JSR         PRINT_ADDR                          ; print address               
00001694                           589                  
00001694  6000 0002                590                  BRA         PRINTSUB                            ; Branches to print move
00001698                           591  
00001698  4BF9 000022F1            592  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
0000169E  4EB9 00002054            593                  JSR         PRINTNULL
000016A4  3200                     594                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000016A6  4EB8 1482                595                  JSR         ADD_SUB_SIZE
000016AA  3200                     596                  MOVE.W      D0,D1
000016AC  E149                     597                  LSL.W       #8,D1
000016AE  E049                     598                  LSR.W       #8,D1
000016B0  EC49                     599                  LSR.W       #6,D1
000016B2  B27C 0003                600                  CMP.W       #3,D1
000016B6  6600 0006                601                  BNE         FINISH_SUB
000016BA  6000 0008                602                  BRA         FINISH_SUBA                         ; same as ADDA
000016BE                           603                  
000016BE  4EB8 14D8                604  FINISH_SUB      JSR     ADD_SUB_OPERAND
000016C2  4E75                     605                  RTS
000016C4                           606                    
000016C4  3404                     607  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016C6  3605                     608                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016C8  4EB9 00001D8E            609                  JSR         EA_TO_STRING             ; outputs it into a string
000016CE                           610                
000016CE                           611                  ; prints a comma to seperate
000016CE  4BF9 000023BD            612                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016D4  4EB9 00002054            613                  JSR         PRINTNULL                ; prints out MOVE
000016DA                           614          
000016DA  4BF9 000023AF            615                  LEA         MSG_AR,A5                ; print address register
000016E0  4EB9 00002054            616                  JSR         PRINTNULL
000016E6  3200                     617                  MOVE.W      D0,D1
000016E8  E949                     618                  LSL.W       #4,D1
000016EA  E849                     619                  LSR.W       #4,D1
000016EC  E049                     620                  LSR.W       #8,D1
000016EE  E249                     621                  LSR.W       #1,D1
000016F0  4EB9 00001F0A            622                  JSR         PRINTNUM             
000016F6  4E75                     623                  RTS                              ; exits subroutine
000016F8                           624  
000016F8                           625  
000016F8                           626  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
000016F8  3200                     627  CASE_SUBA       MOVE.W      D0,D1
000016FA  EF49                     628                  LSL.W       #7,D1
000016FC  EE49                     629                  LSR.W       #7,D1
000016FE  E049                     630                  LSR.W       #8,D1
00001700  B23C 0000                631                  CMP.B       #0,D1
00001704  6700 FDAE                632                  BEQ         ADD_SUB_WORD
00001708  6000 FDB8                633                  BRA         ADD_SUB_LONG
0000170C  4E75                     634                  RTS         
0000170E                           635                   
0000170E  3200                     636  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001710  C27C F000                637                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001714  B27C 4000                638                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001718  6600 0086                639                  BNE.W   CASE_AND                             ; If its not, check AND
0000171C  3200                     640                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000171E  C27C 01C0                641                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001722  B27C 01C0                642                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001726  6600 0078                643                  BNE.W   CASE_AND                             ; If its not, check AND
0000172A                           644                  
0000172A                           645                  ; Check source
0000172A  4BF9 00002120            646                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001730  4DF9 0000213A            647                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001736  3E3C 0000                648                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
0000173A  4EB9 00001C20            649                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001740  3802                     650                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001742  3A03                     651                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001744                           652                  
00001744                           653                  ; Check destination
00001744  4BF9 00002120            654                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000174A  4DF9 0000213A            655                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001750  3E3C 0001                656                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
00001754  4EB9 00001C20            657                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000175A  3C02                     658                  MOVE.W  D2,D6                                ; Saves D2 in D4
0000175C  3E03                     659                  MOVE.W  D3,D7                                ; Saves D2 in D4
0000175E                           660  
0000175E  4BF9 00002302            661                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
00001764  4EB9 00002054            662                  JSR     PRINTNULL                            ; prints LEA
0000176A                           663                  
0000176A                           664                  ; print source
0000176A  3404                     665                  MOVE.W  D4,D2
0000176C  3605                     666                  MOVE.W  D5,D3
0000176E  4EB9 00001D8E            667                  JSR     EA_TO_STRING                         ; Prints out the EA
00001774                           668                  
00001774                           669                  ; comma
00001774  4BF9 000023BD            670                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
0000177A  4EB9 00002054            671                  JSR     PRINTNULL                       
00001780                           672                   
00001780                           673                  ; register
00001780  4BF9 000023AF            674                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001786  4EB9 00002054            675                  JSR     PRINTNULL 
0000178C  3401                     676                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
0000178E  323C 0001                677                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
00001792  4EB9 00001BF6            678                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001798  4EB9 00001F0A            679                  JSR     PRINTNUM                             ; Prints the number in D1
0000179E  4E75                     680                  RTS
000017A0                           681  
000017A0                           682  *---------------AND opcode----------------------
000017A0  3200                     683  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017A2  C27C F000                684                  AND.W       #$F000,D1       
000017A6  B27C C000                685                  CMP.W       #$C000,D1
000017AA  6600 009E                686                  BNE         CASE_OR
000017AE                           687                  
000017AE  3200                     688                  MOVE.W      D0,D1
000017B0  E149                     689                  LSL.W       #8,D1
000017B2  E049                     690                  LSR.W       #8,D1
000017B4  EC49                     691                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000017B6  3C01                     692                  MOVE.W      D1,D6
000017B8  BC7C 0003                693                  CMP.W       #3,D6
000017BC  6700 0066                694                  BEQ         INV_INSTR
000017C0                           695                  
000017C0  4EB8 11D0                696                  JSR         PRINT_ADDR                      ; print address
000017C4  4BF9 0000230A            697                  LEA         MSG_AND,A5                      ; print AND
000017CA  4EB9 00002054            698                  JSR         PRINTNULL
000017D0                           699                  
000017D0  3206                     700                  MOVE.W      D6,D1
000017D2  B27C 0000                701                  CMP.W       #0,D1
000017D6  6700 0012                702                  BEQ         AND_BYTE
000017DA  B27C 0001                703                  CMP.W       #1,D1                   ; if 1, it is a word
000017DE  6700 001A                704                  BEQ         AND_WORD
000017E2  B27C 0002                705                  CMP.W       #2,D1                   ; if 2, it is a long
000017E6  6700 0022                706                  BEQ         AND_LONG
000017EA                           707                  
000017EA  4BF9 000023C6            708  AND_BYTE        LEA         MSG_B,A5
000017F0  4EB9 00002054            709                  JSR         PRINTNULL
000017F6  6000 0022                710                  BRA         FINISH_AND
000017FA                           711                                    
000017FA  4BF9 000023CC            712  AND_WORD        LEA         MSG_W,A5
00001800  4EB9 00002054            713                  JSR         PRINTNULL
00001806  6000 0012                714                  BRA         FINISH_AND
0000180A                           715    
0000180A  4BF9 000023D2            716  AND_LONG        LEA         MSG_L,A5
00001810  4EB9 00002054            717                  JSR         PRINTNULL
00001816  6000 0002                718                  BRA         FINISH_AND
0000181A                           719        
0000181A  4EB8 1424                720  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
0000181E  4EB8 14D8                721                  JSR         ADD_SUB_OPERAND
00001822  4E75                     722                  RTS
00001824                           723                  
00001824  4BF9 00002278            724  INV_INSTR       LEA         INVALID_INSTR,A5
0000182A  4EB9 00002054            725                  JSR         PRINTNULL
00001830  2200                     726                  MOVE.L      D0,D1
00001832  383C 0000                727                  MOVE.W      #0,D4
00001836  4EB9 00001F2E            728                  JSR         PRINTSHORTLONGNUM
0000183C  4BF9 000022B9            729                  LEA         NEW_LINE,A5
00001842  4EB9 00002054            730                  JSR         PRINTNULL
00001848  4E75                     731                  RTS               
0000184A                           732                  
0000184A                           733  *---------------OR opcode----------------------            
0000184A  3200                     734  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
0000184C  C27C F000                735                  AND.W       #$F000,D1       
00001850  B27C 8000                736                  CMP.W       #$8000,D1
00001854  6600 004C                737                  BNE         CASE_NOT
00001858                           738                                                
00001858  3200                     739                  MOVE.W      D0,D1
0000185A  E149                     740                  LSL.W       #8,D1
0000185C  E049                     741                  LSR.W       #8,D1
0000185E  EC49                     742                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001860  B27C 0003                743                  CMP.W       #3,D1
00001864  3C01                     744                  MOVE.W      D1,D6
00001866  67BC                     745                  BEQ         INV_INSTR
00001868                           746                  
00001868  4EB8 11D0                747                  JSR         PRINT_ADDR                      ; print address
0000186C                           748                  
0000186C  4BF9 0000230F            749                  LEA         MSG_OR,A5
00001872  4EB9 00002054            750                  JSR         PRINTNULL                       ; print "OR"
00001878                           751                  
00001878  3206                     752                  MOVE.W      D6,D1
0000187A  4EB9 0000188A            753                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001880  4EB8 1424                754                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001884  4EB8 14D8                755                  JSR         ADD_SUB_OPERAND                 ; print 
00001888  4E75                     756                  RTS
0000188A                           757  
0000188A  B27C 0000                758  OR_SIZE         CMP.W       #0,D1
0000188E  6700 FC16                759                  BEQ         ADD_SUB_BYTE
00001892  B27C 0001                760                  CMP.W       #1,D1                   ; if 1, it is a word
00001896  6700 FC1C                761                  BEQ         ADD_SUB_WORD
0000189A  B27C 0002                762                  CMP.W       #2,D1                   ; if 2, it is a long
0000189E  6700 FC22                763                  BEQ         ADD_SUB_LONG
000018A2                           764                  ; no need for rts, since ADD_SUB_ already has                
000018A2                           765  
000018A2                           766  *---------------NOT opcode----------------------
000018A2  3200                     767  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018A4  C27C FF00                768                  AND.W       #$FF00,D1       
000018A8  B27C 4600                769                  CMP.W       #$4600,D1
000018AC  6600 0050                770                  BNE         CASE_LSDASDROD
000018B0                           771                 
000018B0                           772                  ; get bits 6-7 (size)
000018B0  3200                     773                  MOVE.W      D0,D1
000018B2  E149                     774                  LSL.W       #8,D1
000018B4  E049                     775                  LSR.W       #8,D1
000018B6  EC49                     776                  LSR.W       #6,D1 
000018B8  3C01                     777                  MOVE.W      D1,D6                         
000018BA  BC7C 0003                778                  CMP.W       #3,D6
000018BE  6700 FF64                779                  BEQ         INV_INSTR
000018C2                           780                  
000018C2  4EB8 11D0                781                  JSR         PRINT_ADDR
000018C6                           782                  
000018C6  4BF9 00002313            783                  LEA         MSG_NOT,A5
000018CC  4EB9 00002054            784                  JSR         PRINTNULL                       ; print "NOT"
000018D2                           785                                 
000018D2  3206                     786                  MOVE.W      D6,D1
000018D4                           787  
000018D4  4EB8 188A                788                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000018D8                           789                  
000018D8                           790                  ; get bits 0-5 
000018D8  4BF9 00002100            791                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000018DE  4DF9 00002136            792                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000018E4  3E3C 0000                793                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000018E8  4EB9 00001C20            794                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000018EE  B27C 0001                795                  CMP.W       #1,D1                    ; checks if invalid
000018F2  6700 02D4                796                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000018F6  4EB9 00001D8E            797                  JSR         EA_TO_STRING             ; outputs it into a string
000018FC                           798    
000018FC  4E75                     799                  RTS
000018FE                           800  
000018FE  3200                     801  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001900  C27C F000                802                  AND.W       #$F000, D1                       ; gets first 4 bits
00001904  B27C E000                803                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001908  6600 0218                804                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
0000190C  3400                     805                  MOVE.W      D0,D2                            ; copies D0 to D2
0000190E  4EB9 00001CA8            806                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001914  B47C 0003                807                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001918  6600 00CC                808                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
0000191C                           809                  
0000191C  3400                     810  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000191E  4EB9 00001C96            811                  JSR         GETROTATION                      ; gets rotation value of D2
00001924  B47C 0000                812                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001928  6700 0014                813                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
0000192C  B47C 0003                814                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001930  6700 0016                815                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001934                           816                  
00001934  4BF9 00002318            817  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
0000193A  6000 0012                818                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000193E                           819  
0000193E  4BF9 0000231C            820  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001944  6000 0008                821                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001948                           822  
00001948  4BF9 00002320            823  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000194E                           824                  
0000194E  4EB8 11D0                825  PRINTSHIFTMEM   JSR         PRINT_ADDR                       ; prints address
00001952  4EB9 00002054            826                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001958  3400                     827                  MOVE.W      D0,D2                            ; copies D0 to D2
0000195A  4EB9 00001CA0            828                  JSR         GETDIRECTION                     ; gets direction
00001960  B47C 0000                829                  CMP.W       #0,D2                            ; checking if its right
00001964  6700 000C                830                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001968                           831  
00001968  4BF9 000023AB            832  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000196E  6000 0008                833                  BRA         PRINT_MEMDIR                     ; branches for printing
00001972                           834          
00001972  4BF9 000023A9            835  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001978                           836  
00001978  4EB9 00002054            837  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000197E  4BF9 000023CC            838                  LEA         MSG_W,A5                         ; loads .W into A5
00001984  4EB9 00002054            839                  JSR         PRINTNULL                        ; Prints .W
0000198A  6000 0002                840                  BRA         GETMEMSOURCE                     ; checks the source 
0000198E                           841                  
0000198E                           842  ; get source addressing mode       
0000198E                           843  GETMEMSOURCE                                                 
0000198E  323C 0000                844                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001992  4EB9 00001BCC            845                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001998  3801                     846                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
0000199A  323C 0000                847                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
0000199E  4EB9 00001BF6            848                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000019A4  3A01                     849                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000019A6                           850  
000019A6  4BF9 0000212E            851  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000019AC  3204                     852                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000019AE  4EB9 00001D5A            853                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000019B4  B27C 0002                854                  CMP.W       #2,D1                            ; checks if it is Xn
000019B8  6700 0016                855                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000019BC  B27C 0001                856                  CMP.W       #1,D1                            ; Checks if it is invalid
000019C0  6700 0206                857                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000019C4                           858  
000019C4  3404                     859  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000019C6  3605                     860                  MOVE.W      D5,D3                            ; moves EA to D3
000019C8  4EB9 00001D8E            861                  JSR         EA_TO_STRING                     ; prints out the EA
000019CE  4E75                     862                  RTS                
000019D0                           863                  
000019D0                           864                  
000019D0  4BF9 0000213A            865  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000019D6  3205                     866                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000019D8  4EB9 00001D5A            867                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000019DE  4A41                     868                  TST.W       D1                               ; checks if it is valid
000019E0  67E2                     869                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000019E2  6000 01E4                870                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000019E6                           871  
000019E6                           872  
000019E6  3602                     873  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000019E8  3200                     874                  MOVE.W      D0,D1                            ; copies D0 to D1
000019EA  C27C 0018                875                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000019EE  E649                     876                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000019F0  B27C 0000                877                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000019F4  6700 0014                878                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000019F8  B27C 0003                879                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000019FC  6700 0016                880                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001A00                           881                  
00001A00  4BF9 00002318            882  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001A06  6000 0012                883                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A0A                           884  
00001A0A  4BF9 0000231C            885  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001A10  6000 0008                886                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A14                           887  
00001A14  4BF9 00002320            888  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001A1A                           889                  
00001A1A  4EB8 11D0                890  PRINTSHIFTREG   JSR         PRINT_ADDR                       ; prints address
00001A1E  4EB9 00002054            891                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001A24  3400                     892                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A26  4EB9 00001CA0            893                  JSR         GETDIRECTION                     ; gets direction
00001A2C  B47C 0000                894                  CMP.W       #0,D2                            ; checking if its right
00001A30  6700 000C                895                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001A34                           896  
00001A34  4BF9 000023AB            897  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001A3A  6000 000C                898                  BRA         PRINT_REGDIR                     ; branches for printing
00001A3E                           899          
00001A3E  4BF9 000023A9            900  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001A44  6000 0002                901                  BRA         PRINT_REGDIR                     ; branches for printing
00001A48                           902                  
00001A48  4EB9 00002054            903  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001A4E                           904  
00001A4E  3400                     905  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001A50  4EB9 00001CA8            906                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A56  B47C 0001                907                  CMP.W       #1,D2                            ; Checks if it is word size
00001A5A  6700 0014                908                  BEQ         REG_WORD                         ; Prints .W
00001A5E  B47C 0002                909                  CMP.W       #2,D2                            ; Checks if it is long size
00001A62  6700 0016                910                  BEQ         REG_LONG                         ; Prints .L
00001A66                           911  
00001A66  4BF9 000023C6            912  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001A6C  6000 0012                913                  BRA         PRINTREGEA      
00001A70                           914  
00001A70  4BF9 000023CC            915  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001A76  6000 0008                916                  BRA         PRINTREGEA      
00001A7A                           917                             
00001A7A  4BF9 000023D2            918  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001A80                           919  
00001A80  4EB9 00002054            920  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001A86  3400                     921                  MOVE.W      D0,D2                            ; copies D0 to D1
00001A88  4EB9 00001CB0            922                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001A8E  B27C 0001                923                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001A92  6700 0048                924                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001A96                           925                                  
00001A96  3400                     926  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001A98  4EB9 00001CA8            927                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A9E  3202                     928                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AA0  4BF9 000023B9            929                  LEA         MSG_POUND, A5                    ; loads # into A5
00001AA6  4EB9 00002054            930                  JSR         PRINTNULL                        ; prints #
00001AAC  4EB9 00001F0A            931                  JSR         PRINTNUM                         ; prints shift count
00001AB2  4BF9 000023BD            932                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001AB8  4EB9 00002054            933                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001ABE  4BF9 000023AD            934                  LEA         MSG_DR, A5                       ; loads D into A5
00001AC4  4EB9 00002054            935                  JSR         PRINTNULL                        ; prints out D 
00001ACA  323C 0000                936                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001ACE  4EB9 00001BF6            937                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001AD4  4EB9 00001F0A            938                  JSR         PRINTNUM                         ; prints data register number in D1          
00001ADA  4E75                     939                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001ADC                           940                  
00001ADC  3400                     941  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001ADE  4EB9 00001CA8            942                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AE4  3202                     943                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AE6  4BF9 000023AD            944                  LEA         MSG_DR, A5                       ; loads D into A5
00001AEC  4EB9 00002054            945                  JSR         PRINTNULL                        ; prints D
00001AF2  4EB9 00001F0A            946                  JSR         PRINTNUM                         ; prints register number
00001AF8  4BF9 000023BD            947                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001AFE  4EB9 00002054            948                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001B04  4BF9 000023AD            949                  LEA         MSG_DR, A5                       ; loads D into A5
00001B0A  4EB9 00002054            950                  JSR         PRINTNULL                        ; prints out D 
00001B10  323C 0000                951                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001B14  4EB9 00001BF6            952                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001B1A  4EB9 00001F0A            953                  JSR         PRINTNUM                         ; prints data register number in D1          
00001B20  4E75                     954                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001B22                           955               
00001B22  3200                     956  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001B24  C27C FF00                957                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001B28  B27C 6000                958                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001B2C  6600 001C                959                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001B30                           960                  
00001B30  4EB8 11D0                961                  JSR     PRINT_ADDR
00001B34  4BF9 000023A1            962                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001B3A  4EB9 00002054            963                  JSR     PRINTNULL                            ; prints BRA
00001B40                           964  
00001B40  3400                     965                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001B42  4EB9 00001C68            966                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001B48  4E75                     967                  RTS
00001B4A                           968                  
00001B4A                           969  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001B4A                           970  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001B4A  3200                     971  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B4C  C27C F000                972                  AND.W   #$F000,D1                            ; get top 4 bits
00001B50  B27C 6000                973                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001B54  6600 0058                974                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001B58  3200                     975                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B5A  C27C 0F00                976                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001B5E  E049                     977                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001B60                           978                  
00001B60  B27C 000E                979                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001B64  6700 002A                980                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001B68                           981                  
00001B68  B27C 000F                982                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001B6C  6700 0018                983                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001B70                           984                      
00001B70  B27C 0007                985                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001B74  6700 0006                986                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001B78  6000 004E                987                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001B7C                           988     
00001B7C  4BF9 00002334            989  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001B82  6000 0016                990                  BRA     PRINTBCC
00001B86                           991  
00001B86  4BF9 0000235C            992  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001B8C  6000 000C                993                  BRA     PRINTBCC
00001B90                           994                  
00001B90  4BF9 0000234C            995  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001B96  6000 0002                996                  BRA     PRINTBCC
00001B9A                           997  
00001B9A  4EB8 11D0                998  PRINTBCC        JSR     PRINT_ADDR                           ; prints address
00001B9E  4EB9 00002054            999                  JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001BA4  3400                    1000                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001BA6  4EB9 00001C68           1001                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001BAC  4E75                    1002                  RTS              
00001BAE                          1003                  
00001BAE                          1004  
00001BAE                          1005  CASE_JSR       
00001BAE                          1006  
00001BAE  B07C 4E75               1007  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001BB2  6600 0014               1008                  BNE     CASE_DATA           ; checks the next case if not equal
00001BB6  4EB8 11D0               1009                  JSR     PRINT_ADDR          ; prints address
00001BBA  4BF9 0000239C           1010                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001BC0  4EB9 00002054           1011                  JSR     PRINTNULL           ; prints RTS                
00001BC6  4E75                    1012                  RTS                         ; returns from the subroutine
00001BC8                          1013  
00001BC8                          1014                  
00001BC8                          1015  
00001BC8                          1016  CASE_DATA           ; JSR INV_INSTR  
00001BC8  4E75                    1017                      RTS               
00001BCA                          1018  
00001BCA  4E75                    1019  CASE_EPICFAIL       RTS
00001BCC                          1020  
00001BCC                          1021  
00001BCC                          1022  * Finds the EA type
00001BCC                          1023  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001BCC                          1024  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001BCC  48E7 3000               1025  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001BD0  4A41                    1026                      TST.W     D1                    ; compares D1 to 0
00001BD2  6700 000E               1027                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001BD6                          1028                      
00001BD6  343C 01C0               1029  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001BDA  363C 0006               1030                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001BDE  6000 000A               1031                      BRA       FINDTYPEEA            
00001BE2                          1032  
00001BE2  343C 0038               1033  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001BE6  363C 0003               1034                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001BEA                          1035  
00001BEA                          1036  
00001BEA  3200                    1037  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001BEC  C242                    1038                      AND.W     D2,D1                 ; applies bitmask to D1
00001BEE  E669                    1039                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001BF0  4CDF 000C               1040                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001BF4  4E75                    1041                      RTS                             ; returns from subroutine    
00001BF6                          1042                      
00001BF6                          1043  * Finds Xn type
00001BF6                          1044  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001BF6                          1045  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001BF6  48E7 3000               1046  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001BFA  4A41                    1047                      TST.W     D1                    ; compares D1 to 0
00001BFC  6700 000E               1048                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001C00                          1049  
00001C00  343C 0E00               1050  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001C04  363C 0009               1051                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001C08  6000 000A               1052                      BRA       FINDTYPEXN            ; finds the type of Xn
00001C0C                          1053  
00001C0C  343C 0007               1054  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001C10  363C 0000               1055                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001C14                          1056                      
00001C14  3200                    1057  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001C16  C242                    1058                      AND.W     D2,D1                 ; applies bitmask to D1
00001C18  E669                    1059                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C1A  4CDF 000C               1060                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C1E  4E75                    1061                      RTS                             ; returns from subroutine 
00001C20                          1062                      
00001C20                          1063  * Checks and gets the EA and Xn
00001C20                          1064  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001C20                          1065  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001C20  3207                    1066  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001C22  4EB8 1BCC               1067                  JSR     GET_EA                  ; Gets EA
00001C26  3401                    1068                  MOVE.W  D1,D2                   ; Stores EA in D2
00001C28  3207                    1069                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001C2A  4EB8 1BF6               1070                  JSR     GET_XN                  ; Gets Xn
00001C2E  3601                    1071                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001C30  3202                    1072                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001C32                          1073                  
00001C32  4EB9 00001D5A           1074                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001C38  B27C 0002               1075                  CMP.W   #2,D1                   ; checks if it is Xn
00001C3C  6700 0012               1076                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001C40  B27C 0001               1077                  CMP.W   #1,D1                   ; Checks if it is invalid
00001C44  6700 001C               1078                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001C48                          1079                  
00001C48                          1080                  
00001C48  323C 0000               1081  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001C4C  6000 0018               1082                  BRA     END_CHECKGET
00001C50                          1083        
00001C50                          1084  ; need XN
00001C50  2A4E                    1085  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001C52  3203                    1086                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001C54  4EB9 00001D5A           1087                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001C5A  4A41                    1088                  TST.W   D1                      ; checks if it is valid
00001C5C  67EA                    1089                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001C5E  6000 0002               1090                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001C62                          1091   
00001C62  323C 0001               1092  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001C66                          1093  
00001C66  4E75                    1094  END_CHECKGET    RTS          
00001C68                          1095                                            
00001C68                          1096                                            
00001C68                          1097  * Gets the displacement and pritns it 
00001C68                          1098  * Inputs: D2 = instruction word, A2 = address of next word
00001C68                          1099  * Outputs: prints out displacement
00001C68  48E7 4004               1100  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001C6C  3A4A                    1101                      MOVE.W    A2,A5                 ; copies A2 to A5
00001C6E  C47C 00FF               1102                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001C72  6600 0004               1103                      BNE       PRINTADDRESS          ; prints address if not 0
00001C76  341A                    1104                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001C78                          1105                      
00001C78  D44D                    1106  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001C7A  3202                    1107                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001C7C  183C 0000               1108                      MOVE.B    #0,D4                 ; marks address as word  length
00001C80  4BF9 000023BB           1109                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001C86  4EB9 00002054           1110                      JSR       PRINTNULL             ; prints null
00001C8C  4EB9 00001F2E           1111                      JSR       PRINTSHORTLONGNUM     ; prints address
00001C92                          1112                      
00001C92  4CDF 2002               1113                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001C96                          1114                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001C96                          1115  
00001C96                          1116  * Gets the rotation value for ASd and LSd
00001C96                          1117  * Input: D2 = instruction word copy (of D0)                                    
00001C96                          1118  * Output: rotation  value in D2             
00001C96  C47C 0E00               1119  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001C9A  E04A                    1120                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001C9C  E24A                    1121                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001C9E  4E75                    1122                      RTS                             ; return from subroutine
00001CA0                          1123  
00001CA0                          1124  * Gets the direction value for ASd and LSd
00001CA0                          1125  * Input: D2 = instruction word copy (of D0)                                    
00001CA0                          1126  * Output: direction value in D2             
00001CA0  C47C 0100               1127  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001CA4  E04A                    1128                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CA6  4E75                    1129                      RTS                             ; return from subroutine
00001CA8                          1130  
00001CA8                          1131  * Gets the rotation size value for ASd and LSd
00001CA8                          1132  * Input: D2 = instruction word copy (of D0)                                    
00001CA8                          1133  * Output: rotation size value in D2             
00001CA8  C47C 00C0               1134  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001CAC  EC4A                    1135                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CAE  4E75                    1136                      RTS                             ; return from subroutine
00001CB0                          1137  
00001CB0                          1138  * Gets the rotation location  value for ASd and LSd
00001CB0                          1139  * Input: D2 = instruction word copy (of D0)                                    
00001CB0                          1140  * Output: rotation location value in D2             
00001CB0  C47C 0020               1141  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001CB4  EA4A                    1142                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CB6  4E75                    1143                      RTS                             ; return from subroutine
00001CB8                          1144  
00001CB8                          1145  * Prints out registers for MOVEM
00001CB8                          1146  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001CB8                          1147  * Output: printed out registers
00001CB8                          1148  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001CB8  48E7 0706               1149  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001CBC  3A3C 0000               1150                      MOVE.W     #0,D5                ; sets counter to 0
00001CC0  3E1A                    1151                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001CC2  B83C 0001               1152                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001CC6  6600 0010               1153                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001CCA                          1154  
00001CCA  3C3C 0000               1155  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001CCE  4BF9 000023AD           1156                      LEA        MSG_DR,A5            ; loads D to A5
00001CD4  6000 000C               1157                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001CD8                          1158                      
00001CD8  3C3C 0007               1159  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001CDC  4BF9 000023AF           1160                      LEA        MSG_AR,A5            ; loads A to A5
00001CE2                          1161                      
00001CE2  E34F                    1162  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001CE4  6500 0018               1163                      BCS        PRINTREG             ; if pushes out a 1
00001CE8  DC44                    1164                      ADD.W      D4,D6                ; decrements or increments
00001CEA  5245                    1165                      ADD.W      #1,D5                ; increments D5
00001CEC  BA7C 0008               1166                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001CF0  66F0                    1167                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001CF2  B83C 0001               1168                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001CF6  6600 0052               1169                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001CFA  6000 0042               1170                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001CFE                          1171                      
00001CFE  4EB9 00002054           1172  PRINTREG            JSR        PRINTNULL
00001D04  3206                    1173                      MOVE.W     D6,D1
00001D06  4EB9 00001F0A           1174                      JSR        PRINTNUM 
00001D0C                          1175    
00001D0C  BE7C 0000               1176  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001D10  6600 0006               1177                      BNE        PRINTMORE            ; continue if there is more
00001D14  6000 0040               1178                      BRA        DONEPRINTINGREG      ; exit case
00001D18                          1179  
00001D18  2C4D                    1180  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001D1A  4BF9 000023C0           1181                      LEA        MSG_SLASH,A5         ; leads / into A5
00001D20  4EB9 00002054           1182                      JSR        PRINTNULL            ; prints the slash
00001D26  2A4E                    1183                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001D28  DC44                    1184                      ADD.W      D4,D6                ; decrements or increments
00001D2A  5245                    1185                      ADD.W      #1,D5                ; increments D5
00001D2C  BA7C 0008               1186                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D30  66B0                    1187                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D32  B83C 0001               1188                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D36  6600 0012               1189                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D3A  6000 0002               1190                      BRA        REGTOMEM2            ; loops
00001D3E                          1191  
00001D3E  3C3C 0000               1192  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001D42  4BF9 000023AF           1193                      LEA        MSG_AR,A5            ; loads A to A5
00001D48  6098                    1194                      BRA        PRINTREGISTERLOOP    ; loops
00001D4A                          1195  
00001D4A  3C3C 0007               1196  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001D4E  4BF9 000023AD           1197                      LEA        MSG_DR,A5            ; loads D to A5
00001D54  608C                    1198                      BRA        PRINTREGISTERLOOP    ; loops
00001D56                          1199  
00001D56  4CDF 60E0               1200  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001D5A                          1201  
00001D5A                          1202                          
00001D5A                          1203  * Checks if EA or Xn is valid
00001D5A                          1204  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001D5A                          1205  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001D5A  2F02                    1206  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001D5C                          1207  
00001D5C  141D                    1208  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001D5E  B43C 00FF               1209                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001D62  6700 000A               1210                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001D66  B202                    1211                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001D68  6700 000C               1212                     BEQ        VALIDEA               ; branches to valid EA
00001D6C  60EE                    1213                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001D6E                          1214                     
00001D6E  323C 0001               1215  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001D72  6000 0016               1216                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001D76                          1217                    
00001D76  B43C 0007               1218  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001D7A  6700 000A               1219                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001D7E  323C 0000               1220                     MOVE.W     #$0,D1                ; marks that it is valid
00001D82  6000 0006               1221                     BRA        CHECKEAEXIT           ; exits the subroutine
00001D86                          1222  
00001D86  323C 0002               1223  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001D8A                          1224  
00001D8A  241F                    1225  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001D8C  4E75                    1226                     RTS                              ; returns from subroutine
00001D8E                          1227  
00001D8E                          1228  * Converts EA and Xn into a string                                
00001D8E                          1229  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001D8E                          1230  * Outputs: Prints out EA and Xn into a string
00001D8E  48E7 C004               1231  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001D92  B47C 0001               1232                     CMP.W    #An,D2                  ; checks if it is An
00001D96  6700 003A               1233                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001D9A                          1234                     
00001D9A  B47C 0002               1235                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001D9E  6700 004A               1236                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001DA2                          1237                     
00001DA2  B47C 0003               1238                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001DA6  6700 0072               1239                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001DAA                          1240                     
00001DAA  B47C 0004               1241                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001DAE  6700 00A6               1242                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001DB2                          1243                     
00001DB2  B47C 0007               1244                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001DB6  6700 00DA               1245                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001DBA                          1246                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001DBA                          1247  
00001DBA                          1248  * data register, Dn
00001DBA  4BF9 000023AD           1249  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001DC0  4EB9 00002054           1250                     JSR      PRINTNULL               ; Prints D
00001DC6  3203                    1251                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DC8  4EB9 00001F0A           1252                     JSR      PRINTNUM                ; Prints the Xn
00001DCE  6000 0134               1253                     BRA      EA_TO_STRING_EXIT       ; exits           
00001DD2                          1254  
00001DD2                          1255  
00001DD2                          1256  * address register
00001DD2  4BF9 000023AF           1257  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001DD8  4EB9 00002054           1258                     JSR      PRINTNULL               ; Prints A
00001DDE  3203                    1259                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DE0  4EB9 00001F0A           1260                     JSR      PRINTNUM                ; Prints the Xn
00001DE6  6000 011C               1261                     BRA      EA_TO_STRING_EXIT       ; exits
00001DEA                          1262  
00001DEA                          1263  * address register indirect
00001DEA  4BF9 000023B1           1264  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001DF0  4EB9 00002054           1265                     JSR      PRINTNULL               ; Prints (
00001DF6  4BF9 000023AF           1266                     LEA      MSG_AR,A5               ; Loads A into A5
00001DFC  4EB9 00002054           1267                     JSR      PRINTNULL               ; Prints A
00001E02  3203                    1268                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E04  4EB9 00001F0A           1269                     JSR      PRINTNUM                ; Prints the Xn
00001E0A  4BF9 000023B3           1270                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E10  4EB9 00002054           1271                     JSR      PRINTNULL               ; Prints )
00001E16  6000 00EC               1272                     BRA      EA_TO_STRING_EXIT       ; exits
00001E1A                          1273  
00001E1A                          1274  * address register indirect post increment
00001E1A  4BF9 000023B1           1275  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001E20  4EB9 00002054           1276                     JSR      PRINTNULL               ; Prints (
00001E26  4BF9 000023AF           1277                     LEA      MSG_AR,A5               ; Loads A into A5
00001E2C  4EB9 00002054           1278                     JSR      PRINTNULL               ; Prints A
00001E32  3203                    1279                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E34  4EB9 00001F0A           1280                     JSR      PRINTNUM                ; Prints the Xn
00001E3A  4BF9 000023B3           1281                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E40  4EB9 00002054           1282                     JSR      PRINTNULL               ; Prints )
00001E46  4BF9 000023B5           1283                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001E4C  4EB9 00002054           1284                     JSR      PRINTNULL               ; Prints +
00001E52  6000 00B0               1285                     BRA      EA_TO_STRING_EXIT       ; exits
00001E56                          1286  
00001E56                          1287  
00001E56                          1288  * address register indirect pre increment
00001E56  4BF9 000023B7           1289  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001E5C  4EB9 00002054           1290                     JSR      PRINTNULL               ; Prints -
00001E62  4BF9 000023B1           1291                     LEA      MSG_LB,A5               ; Loads ( into A5
00001E68  4EB9 00002054           1292                     JSR      PRINTNULL               ; Prints (
00001E6E  4BF9 000023AF           1293                     LEA      MSG_AR,A5               ; Loads A into A5
00001E74  4EB9 00002054           1294                     JSR      PRINTNULL               ; Prints A
00001E7A  3203                    1295                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E7C  4EB9 00001F0A           1296                     JSR      PRINTNUM                ; Prints the Xn
00001E82  4BF9 000023B3           1297                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E88  4EB9 00002054           1298                     JSR      PRINTNULL               ; Prints )
00001E8E  6000 0074               1299                     BRA      EA_TO_STRING_EXIT       ; exits
00001E92                          1300  
00001E92                          1301  * other (long, short, immediate) with Xn yes
00001E92  301A                    1302  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001E94  B67C 0000               1303                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001E98  6700 002E               1304                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001E9C                          1305                     
00001E9C  B67C 0001               1306                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001EA0  6700 0042               1307                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001EA4                          1308  
00001EA4                          1309  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001EA4                          1310  * immediate
00001EA4  4BF9 000023B9           1311  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001EAA  4EB9 00002054           1312                     JSR      PRINTNULL               ; Prints #  
00001EB0  4BF9 000023BB           1313                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EB6  4EB9 00002054           1314                     JSR      PRINTNULL               ; Prints $
00001EBC  3200                    1315                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001EBE  4EB9 00001F1A           1316                     JSR      PRINTHEXNUM 
00001EC4  6000 003E               1317                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001EC8                          1318                     
00001EC8                          1319  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001EC8                          1320  
00001EC8                          1321  * word address
00001EC8                          1322  CASE_WORD          
00001EC8  4BF9 000023BB           1323                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001ECE  4EB9 00002054           1324                     JSR      PRINTNULL               ; Prints $
00001ED4  3200                    1325                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001ED6  383C 0000               1326                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001EDA  4EB9 00001F2E           1327                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001EE0  6000 0022               1328                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001EE4                          1329  
00001EE4                          1330  * long address 
00001EE4                          1331  CASE_LONG          
00001EE4  4BF9 000023BB           1332                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EEA  4EB9 00002054           1333                     JSR      PRINTNULL               ; Prints $
00001EF0  3200                    1334                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001EF2  383C 0001               1335                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001EF6  4EB9 00001F2E           1336                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001EFC  321A                    1337                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001EFE  4EB9 00001F0A           1338                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001F04                          1339  
00001F04                          1340  
00001F04                          1341  * exits subroutine
00001F04  4CDF 2003               1342  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001F08  4E75                    1343                      RTS                              ; returns from subroutine
00001F0A                          1344  
00001F0A                          1345  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001F0A                          1346  
00001F0A                          1347  * Prints out the content of D1 as a decimal number
00001F0A                          1348  * Input: number in D1 to be printed
00001F0A                          1349  * Output: contents of D1 printed
00001F0A  48E7 C000               1350  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F0E  103C 0003               1351                   MOVE.B      #3,D0               ; prints D1
00001F12  4E4F                    1352                   TRAP        #15                 ; is trap task 3
00001F14                          1353              
00001F14  4CDF 0003               1354                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F18  4E75                    1355                   RTS                             ; returns from subroutine
00001F1A                          1356                   
00001F1A                          1357  * Prints out the content of D1 as a hex number
00001F1A                          1358  * Input: number in D1 to be printed
00001F1A                          1359  * Output: contents of D1 printed
00001F1A  48E7 C000               1360  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F1E  143C 0010               1361                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001F22  103C 000F               1362                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001F26  4E4F                    1363                   TRAP        #15                 ; is trap task 15
00001F28  4CDF 0003               1364                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F2C  4E75                    1365                   RTS                             ; returns from subroutine
00001F2E                          1366                   
00001F2E                          1367  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001F2E                          1368  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001F2E                          1369  * Output: contents of D1 printed
00001F2E  48E7 E000               1370  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001F32  B83C 0001               1371                            CMP.B       #1,D4               ; checks size of number
00001F36  6700 0042               1372                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001F3A                          1373  
00001F3A  3401                    1374  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001F3C  C47C F000               1375                            AND.W       #$F000,D2           ; gets the first digit
00001F40  B47C 0000               1376                            CMP.W       #0, D2              ; checks if it is 0
00001F44  6600 00DC               1377                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F48  4EB9 00002032           1378                            JSR         PRINTZERO           ; prints a zero
00001F4E                          1379                            
00001F4E  3401                    1380                            MOVE.W      D1,D2               ; copies number to D2
00001F50  C47C 0F00               1381                            AND.W       #$0F00,D2           ; gets the second digit
00001F54  B47C 0000               1382                            CMP.W       #0, D2              ; checks if it is 0
00001F58  6600 00C8               1383                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F5C  4EB9 00002032           1384                            JSR         PRINTZERO           ; prints a zero
00001F62                          1385                            
00001F62  3401                    1386                            MOVE.W      D1,D2               ; copies number to D2
00001F64  C47C 00F0               1387                            AND.W       #$00F0,D2           ; gets the third digit
00001F68  B47C 0000               1388                            CMP.W       #0, D2              ; checks if it is 0
00001F6C  6600 00B4               1389                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F70  4EB9 00002032           1390                            JSR         PRINTZERO           ; prints a zero
00001F76  6000 00AA               1391                            BRA         PRINTASHEX          ; prints last digit
00001F7A                          1392                            
00001F7A  2401                    1393  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001F7C  C4BC F0000000           1394                            AND.L       #$F0000000,D2       ; gets the first digit
00001F82  B4BC 00000000           1395                            CMP.L       #0, D2              ; checks if it is 0
00001F88  6600 0098               1396                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F8C  4EB9 00002032           1397                            JSR         PRINTZERO           ; prints a zero
00001F92                          1398                            
00001F92  2401                    1399                            MOVE.L      D1,D2               ; copies number to D2
00001F94  C4BC 0F000000           1400                            AND.L       #$0F000000,D2       ; gets the second digit
00001F9A  B4BC 00000000           1401                            CMP.L       #0, D2              ; checks if it is 0
00001FA0  6600 0080               1402                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FA4  4EB9 00002032           1403                            JSR         PRINTZERO           ; prints a zero
00001FAA                          1404                            
00001FAA  2401                    1405                            MOVE.L      D1,D2               ; copies number to D2
00001FAC  C4BC 00F00000           1406                            AND.L       #$00F00000,D2       ; gets the third digit
00001FB2  B4BC 00000000           1407                            CMP.L       #0, D2              ; checks if it is 0
00001FB8  6600 0068               1408                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FBC  4EB9 00002032           1409                            JSR         PRINTZERO           ; prints a zero
00001FC2                          1410                            
00001FC2  2401                    1411                            MOVE.L      D1,D2               ; copies number to D2
00001FC4  C4BC 000F0000           1412                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001FCA  B4BC 00000000           1413                            CMP.L       #0, D2              ; checks if it is 0
00001FD0  6600 0050               1414                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FD4  4EB9 00002032           1415                            JSR         PRINTZERO           ; prints a zero
00001FDA                          1416                            
00001FDA  2401                    1417                            MOVE.L      D1,D2               ; copies number to D2
00001FDC  C4BC 0000F000           1418                            AND.L       #$0000F000,D2       ; gets the fith digit
00001FE2  B4BC 00000000           1419                            CMP.L       #0, D2              ; checks if it is 0
00001FE8  6600 0038               1420                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FEC  4EB9 00002032           1421                            JSR         PRINTZERO           ; prints a zero
00001FF2                          1422                            
00001FF2  2401                    1423                            MOVE.L      D1,D2               ; copies number to D2
00001FF4  C4BC 00000F00           1424                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001FFA  B4BC 00000000           1425                            CMP.L       #0, D2              ; checks if it is 0
00002000  6600 0020               1426                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002004  4EB9 00002032           1427                            JSR         PRINTZERO           ; prints a zero
0000200A                          1428                            
0000200A  2401                    1429                            MOVE.L      D1,D2               ; copies number to D2
0000200C  C4BC 000000F0           1430                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002012  B4BC 00000000           1431                            CMP.L       #0, D2              ; checks if it is 0
00002018  6600 0008               1432                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000201C  4EB9 00002032           1433                            JSR         PRINTZERO           ; prints a zero
00002022                          1434  
00002022  143C 0010               1435  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002026  103C 000F               1436                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000202A  4E4F                    1437                            TRAP        #15                 ; is trap task 15
0000202C  4CDF 0007               1438                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002030  4E75                    1439                            RTS                             ; returns from subroutine    
00002032                          1440  * Prints a zero
00002032                          1441  * Input: nothing
00002032                          1442  * Output: 0 printed out to the console
00002032  2F01                    1443  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002034  7200                    1444                            MOVE.L      #0,D1               ; moves 0 to D1
00002036  4EB8 1F0A               1445                            JSR         PRINTNUM            ; prints the number
0000203A  221F                    1446                            MOVE.L      (SP)+,D1            ; restores D1
0000203C  4E75                    1447                            RTS                             ; returns from subroutine
0000203E                          1448              
0000203E                          1449  * Prints contents of things between a range
0000203E                          1450  * input: A5, A6 (the range)
0000203E                          1451  * output: prints memory contents from A5 to A6 as strings   
0000203E  48E7 C040               1452  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00002042  224D                    1453                  MOVEA.L     A5, A1           ; loads A5 into A1
00002044  9DCD                    1454                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00002046  320E                    1455                  MOVE.W      A6, D1           ; move n into D1
00002048  103C 0001               1456                  MOVE.B      #1, D0           ; display n characters of string at A1
0000204C  4E4F                    1457                  TRAP        #15              ; is trap task 1
0000204E  4CDF 0203               1458                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00002052  4E75                    1459                  RTS                          ; returns
00002054                          1460      
00002054                          1461  * Prints null terminated string
00002054                          1462  * input: string pointed to by A5
00002054                          1463  * output: prints out the null terminated string
00002054  48E7 8040               1464  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002058  224D                    1465                  MOVE.L      A5,A1           ; loads A5 into A1
0000205A  103C 000E               1466                  MOVE.B      #14,D0          ; prints null terminated string
0000205E  4E4F                    1467                  TRAP        #15             ; is trap task 10
00002060  4CDF 0201               1468                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00002064  4E75                    1469                  RTS                         ; returns from subroutine
00002066                          1470                  
00002066  2F0D                    1471  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002068  4BF9 000022B9           1472                  LEA         NEW_LINE,A5     ; Prints null
0000206E  4EB8 2054               1473                  JSR         PRINTNULL       ; prints the new line
00002072  2A5F                    1474                  MOVE.L      (SP)+,A5        ; returns A5
00002074  4E75                    1475                  RTS
00002076                          1476  
00002076                          1477  * Prints the size of the MOVE or MOVEA operation  
00002076                          1478  * input: D0
00002076                          1479  * output: prints out the size of a MOVE or MOVEA operation        
00002076  48E7 8004               1480  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
0000207A  3200                    1481                  MOVE.W  D0,D1               ; stores d0 in d1
0000207C  C07C 3000               1482                  AND.W   #$3000,D0           ; gets the size
00002080  B07C 2000               1483                  CMP.W   #$2000,D0           ; checks if is long
00002084  6700 001E               1484                  BEQ     MOVE_LONG
00002088  B07C 3000               1485                  CMP.W   #$3000,D0           ; checks if is word
0000208C  6700 000C               1486                  BEQ     MOVE_WORD      
00002090                          1487                  
00002090  4BF9 000023C6           1488  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00002096  6000 0012               1489                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000209A                          1490  
0000209A  4BF9 000023CC           1491  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000020A0  6000 0008               1492                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020A4                          1493  
000020A4  4BF9 000023D2           1494  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000020AA                          1495                  
000020AA  4EB8 2054               1496  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000020AE  4CDF 2001               1497                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000020B2  4E75                    1498                  RTS
000020B4                          1499  
000020B4  43F9 0000225C           1500  ERROR           LEA     ERROR_MSG,A1
000020BA  103C 000E               1501                  MOVE.B  #14,D0
000020BE  4E4F                    1502                  TRAP    #15 
000020C0                          1503         
000020C0                          1504  * DELETE THIS: Test                
000020C0  2661                    1505  DELETEME        MOVEA.L  -(A1),A3
000020C2  6700 0038               1506                  BEQ      DELETEMEAGAIN  
000020C6  6F00 0034               1507                  BLE      DELETEMEAGAIN
000020CA  6E00 0030               1508                  BGT      DELETEMEAGAIN
000020CE                          1509  
000020CE  E40A                    1510                  LSR.B      #2,D2
000020D0  E2E2                    1511                  LSR.W      -(A2)
000020D2  E2DA                    1512                  LSR.W      (A2)+
000020D4  E4AA                    1513                  LSR.L      D2,D2 
000020D6  E50A                    1514                  LSL.B      #2,D2
000020D8  E3E2                    1515                  LSL.W      -(A2)
000020DA  E3DA                    1516                  LSL.W      (A2)+
000020DC  E5AA                    1517                  LSL.L      D2,D2
000020DE  E51A                    1518                  ROL.B      #2,D2
000020E0  E7E2                    1519                  ROL.W      -(A2)
000020E2  E7DA                    1520                  ROL.W      (A2)+
000020E4  E5BA                    1521                  ROL.L      D2,D2
000020E6  E41A                    1522                  ROR.B      #2,D2
000020E8  E6E2                    1523                  ROR.W      -(A2)
000020EA  E6DA                    1524                  ROR.W      (A2)+
000020EC  E4BA                    1525                  ROR.L      D2,D2
000020EE                          1526                  
000020EE  504D                    1527                  ADDQ.W      #8,A5
000020F0  D6C2                    1528                  ADDA.W      D2,A3
000020F2  9BCB                    1529                  SUB.L       A3,A5        
000020F4  8A43                    1530                  OR.W        D3,D5
000020F6  4642                    1531                  NOT.W       D2
000020F8                          1532                  
000020F8  C5FC 0010               1533                  MULS.W    #$0010,D2
000020FC                          1534                  
000020FC                          1535  DELETEMEAGAIN                 
000020FC                          1536            
000020FC  FFFF FFFF               1537      SIMHALT             ; halt simulator
00002100                          1538  
00002100                          1539  * Put variables and constants here
00002100                          1540  
00002100  =0000000D               1541  CR                              EQU     $0D
00002100  =0000000A               1542  LF                              EQU     $0A 
00002100  =00000009               1543  TAB                             EQU     $09  
00002100                          1544  
00002100                          1545  * Addressing Modes
00002100  =00000000               1546  Dn                              EQU     0
00002100  =00000001               1547  An                              EQU     1
00002100  =00000002               1548  AnIndirect                      EQU     2
00002100  =00000003               1549  AnPost                          EQU     3
00002100  =00000004               1550  AnPre                           EQU     4
00002100  =00000007               1551  Other                           EQU     7           ; short, long, immediate
00002100                          1552  
00002100                          1553  * Xn
00002100  =00000000               1554  ABSShort                        EQU     0
00002100  =00000001               1555  ABSLong                         EQU     1
00002100  =00000004               1556  XnImmediate                     EQU     4
00002100                          1557  
00002100                          1558  * Valid Addressing Modes
00002100= 00 01 02 03 04 07 FF    1559  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00002107                          1560  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00002107= 00 02 03 04 07 FF       1561  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000210D= 02 04 07 FF             1562  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002111= 02 03 07 FF             1563  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00002115= 02 03 04 07 FF          1564  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000211A= 00 02 03 04 07 FF       1565  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002120= 01 07 FF                1566  VALIDEA_LEA                     DC.B    An,Other,-1
00002123= 00 02 03 04 07 FF       1567  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002129= 02 03 04 07 FF          1568  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000212E= 02 03 04 07 FF          1569  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00002133= 02 07 FF                1570  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00002136                          1571  
00002136                          1572  * Valid Xn
00002136= 00 01 04 FF             1573  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
0000213A                          1574  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
0000213A= 00 01 FF                1575  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
0000213D                          1576  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
0000213D                          1577  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
0000213D                          1578  
0000213D                          1579  * posible memory ASd/LSd rotation values
0000213D  =00000000               1580  ASd_MEM                         EQU     0   
0000213D  =00000001               1581  LSd_MEM                         EQU     1 
0000213D  =00000003               1582  ROd_MEM                         EQU     3
0000213D                          1583   
0000213D  =00000000               1584  ASd_REG                         EQU     0   
0000213D  =00000001               1585  LSd_REG                         EQU     1 
0000213D  =00000003               1586  ROd_REG                         EQU     3
0000213D                          1587  
0000213D                          1588  * Messages
0000213D= 57 65 6C 63 6F 6D ...   1589  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00002164= 46 6F 72 6D 61 74 ...   1590                                  DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only. Letters must be capital case.',CR,LF,0
000021CD= 50 6C 65 61 73 65 ...   1591  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002204= 50 6C 65 61 73 65 ...   1592  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
0000223A= 49 6E 76 61 6C 69 ...   1593  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
0000225C= 45 72 72 6F 72 20 ...   1594  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00002278= 31 30 30 30 09 09 ...   1595  INVALID_INSTR                   DC.B    '1000',TAB,TAB,'DATA',TAB,TAB,TAB,'$',0
00002287= 46 69 6E 69 73 68 ...   1596  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
000022B9= 0D 0A 00                1597  NEW_LINE                        DC.B    CR,LF,0
000022BC= 09 09 09 00             1598  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000022C0                          1599  
000022C0                          1600  * Opcode Messages
000022C0= 09 4E 4F 50 00          1601  MSG_NOP                         DC.B    TAB,'NOP',0
000022C5= 09 4D 4F 56 45 00       1602  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000022CB= 09 4D 4F 56 45 41 00    1603  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000022D2= 09 4D 4F 56 45 51 00    1604  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000022D9= 09 4D 4F 56 45 4D 00    1605  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000022E0= 09 41 44 44 00          1606  MSG_ADD                         DC.B    TAB,'ADD',0
000022E5= 09 41 44 44 41 00       1607  MSG_ADDA                        DC.B    TAB,'ADDA',0
000022EB= 09 41 44 44 51 00       1608  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
000022F1= 09 53 55 42 00          1609  MSG_SUB                         DC.B    TAB,'SUB',0
000022F6= 09 4D 55 4C 53 00       1610  MSG_MULS                        DC.B    TAB,'MULS',0
000022FC= 09 44 49 56 55 00       1611  MSG_DIVU                        DC.B    TAB,'DIVU',0
00002302= 09 4C 45 41 09 09 ...   1612  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
0000230A= 09 41 4E 44 00          1613  MSG_AND                         DC.B    TAB,'AND',0
0000230F= 09 4F 52 00             1614  MSG_OR                          DC.B    TAB,'OR',0
00002313= 09 4E 4F 54 00          1615  MSG_NOT                         DC.B    TAB,'NOT',0
00002318= 09 4C 53 00             1616  MSG_LSd                         DC.B    TAB,'LS',0
0000231C= 09 41 53 00             1617  MSG_ASd                         DC.B    TAB,'AS',0
00002320= 09 52 4F 00             1618  MSG_ROd                         DC.B    TAB,'RO',0
00002324= 09 42 43 43 09 09 ...   1619  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
0000232C= 09 42 43 53 09 09 ...   1620  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00002334= 09 42 45 51 09 09 ...   1621  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
0000233C= 09 42 4E 45 09 09 ...   1622  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00002344= 09 42 47 45 09 09 ...   1623  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
0000234C= 09 42 47 54 09 09 ...   1624  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00002354= 09 42 48 49 09 09 ...   1625  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
0000235C= 09 42 4C 45 09 09 ...   1626  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00002364= 09 42 4C 53 09 09 ...   1627  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
0000236C= 09 42 4C 54 09 09 ...   1628  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00002374= 09 42 4D 49 09 09 ...   1629  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
0000237C= 09 42 50 4C 09 09 ...   1630  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00002384= 09 42 56 43 09 09 ...   1631  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
0000238C= 09 42 56 53 09 09 ...   1632  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00002394= 09 4A 53 52 09 09 ...   1633  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
0000239C= 09 52 54 53 00          1634  MSG_RTS                         DC.B    TAB,'RTS',0
000023A1= 09 42 52 41 09 09 ...   1635  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
000023A9                          1636  
000023A9                          1637  * Direction for LSd and ASd
000023A9= 52 00                   1638  MSG_RIGHT                       DC.B    'R',0
000023AB= 4C 00                   1639  MSG_LEFT                        DC.B    'L',0
000023AD                          1640  
000023AD                          1641  * Effective Addresses Messages
000023AD= 44 00                   1642  MSG_DR                          DC.B    'D',0
000023AF= 41 00                   1643  MSG_AR                          DC.B    'A',0
000023B1= 28 00                   1644  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000023B3= 29 00                   1645  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000023B5= 2B 00                   1646  MSG_PLUS                        DC.B    '+',0
000023B7= 2D 00                   1647  MSG_MINUS                       DC.B    '-',0
000023B9= 23 00                   1648  MSG_POUND                       DC.B    '#',0 
000023BB= 24 00                   1649  MSG_HEX                         DC.B    '$',0 
000023BD= 2C 20 00                1650  MSG_COMMA                       DC.B    ', ',0
000023C0= 2F 00                   1651  MSG_SLASH                       DC.B    '/',0  
000023C2= 20 00                   1652  MSG_SPACE                       DC.B    ' ',0
000023C4= 09 00                   1653  MSG_TAB                         DC.B    TAB,0
000023C6                          1654  
000023C6                          1655  * Size Messages
000023C6= 2E 42 09 09 09 00       1656  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
000023CC= 2E 57 09 09 09 00       1657  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
000023D2= 2E 4C 09 09 09 00       1658  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
000023D8                          1659  
000023D8                          1660  * Variables
000023D8  =00000100               1661  STARTING_ADDRESS                EQU     $100
000023D8  =00000150               1662  ENDING_ADDRESS                  EQU     $150
000023D8  =00000200               1663  CURRENT_INSTR                   EQU     $200
000023D8  =00000250               1664  REG_VAR                         EQU     $250 * Hold bits 11-9
000023D8  =00000300               1665  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000023D8  =00000350               1666  EA_MODE                         EQU     $350 * Hold bits 5-3
000023D8  =00000400               1667  EA_REG                          EQU     $400 * Hold bits 2-0
000023D8                          1668  
000023D8                          1669              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           156A
ADDQ_BYTE           1600
ADDQ_LONG           1620
ADDQ_WORD           1610
ADD_SUB_BYTE        14A6
ADD_SUB_HELP        1424
ADD_SUB_LONG        14C2
ADD_SUB_OPERAND     14D8
ADD_SUB_SIZE        1482
ADD_SUB_WORD        14B4
AN                  1
AND_BYTE            17EA
AND_LONG            180A
AND_WORD            17FA
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           223A
CASE_ADD            13F8
CASE_ADDA           153E
CASE_ADDQ           15A6
CASE_AND            17A0
CASE_AR             1DD2
CASE_ARI            1DEA
CASE_ARIPOST        1E1A
CASE_ARIPRE         1E56
CASE_ASDMEM         193E
CASE_ASDREG         1A0A
CASE_BCC            1B4A
CASE_BEQ            1B7C
CASE_BGT            1B90
CASE_BLE            1B86
CASE_BRA            1B22
CASE_DATA           1BC8
CASE_DR             1DBA
CASE_EPICFAIL       1BCA
CASE_IMMEDIATE      1EA4
CASE_JSR            1BAE
CASE_LEA            170E
CASE_LEFTMEM        1968
CASE_LEFTREG        1A34
CASE_LONG           1EE4
CASE_LSDASDROD      18FE
CASE_LSDMEM         1934
CASE_LSDREG         1A00
CASE_MOVE           11FA
CASE_MOVEM          12A0
CASE_MOVEQ          13A0
CASE_NOP            11E0
CASE_NOT            18A2
CASE_OR             184A
CASE_OTHER          1E92
CASE_RIGHTMEM       1972
CASE_RIGHTREG       1A3E
CASE_RODMEM         1948
CASE_RODREG         1A14
CASE_RTS            1BAE
CASE_SHIFTMEM       191C
CASE_SHIFTREG       19E6
CASE_SUB            167E
CASE_SUBA           16F8
CASE_WORD           1EC8
CHECKEAEXIT         1D8A
CHECKEAMLOOP        1D5C
CHECKEAXN_IFVALID   1D5A
CHECKGET_EAXN       1C20
CHECKMEMSOURE       19A6
CHECKMOREBITS       1D0C
CHECKSHIFT_XN       19D0
CHECK_LENGTH        1132
CHECK_ODD           11C8
CHECK_ORDER         109A
CHECK_XN            1C50
CONCAT              117A
CONVERT             1144
CR                  D
CURRENT_INSTR       200
DELETEME            20C0
DELETEMEAGAIN       20FC
DESTEA              1BD6
DESTXN              1C00
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          1512
DONE                2287
DONEPRINTINGREG     1D56
EASHIFT_VALID       19C4
EAXN_INVALID        1C62
EAXN_VALID          1C48
EA_MODE             350
EA_REG              400
EA_TO_STRING        1D8E
EA_TO_STRING_EXIT   1F04
ENDING              2204
ENDING_ADDRESS      150
END_CHECKGET        1C66
ERROR               20B4
ERROR_MSG           225C
FINDTYPEEA          1BEA
FINDTYPEXN          1C14
FINISHED            10B4
FINISHMOVE          20AA
FINISH_ADD          14D0
FINISH_ADDA         157A
FINISH_ADDQ         1630
FINISH_AND          181A
FINISH_SUB          16BE
FINISH_SUBA         16C4
GETDIRECTION        1CA0
GETDISPLACEMENT     1C68
GETMEMSOURCE        198E
GETROTATION         1C96
GETROTATIONLOCATION  1CB0
GETROTATIONSIZE     1CA8
GET_EA              1BCC
GET_XN              1BF6
INPUT1              100C
INPUT2              1052
INSERTA             126C
INVALID             1192
INVALIDEA           1D6E
INVALID_INSTR       2278
INV_INSTR           1824
ISNUMBER            115A
LF                  A
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         1376
MEM2REGWORD         1368
MEMTOREG1           1CD8
MEMTOREG2           1D4A
MOVEM_MEM2REG       1330
MOVEM_REG2MEM       12BE
MOVE_BYTE           2090
MOVE_LONG           20A4
MOVE_WORD           209A
MSG_ADD             22E0
MSG_ADDA            22E5
MSG_ADDQ            22EB
MSG_AND             230A
MSG_AR              23AF
MSG_ASD             231C
MSG_B               23C6
MSG_BCC             2324
MSG_BCS             232C
MSG_BEQ             2334
MSG_BGE             2344
MSG_BGT             234C
MSG_BHI             2354
MSG_BLE             235C
MSG_BLS             2364
MSG_BLT             236C
MSG_BMI             2374
MSG_BNE             233C
MSG_BPL             237C
MSG_BRA             23A1
MSG_BVC             2384
MSG_BVS             238C
MSG_COMMA           23BD
MSG_DIVU            22FC
MSG_DR              23AD
MSG_HEX             23BB
MSG_JSR             2394
MSG_L               23D2
MSG_LB              23B1
MSG_LEA             2302
MSG_LEFT            23AB
MSG_LSD             2318
MSG_MINUS           23B7
MSG_MOVE            22C5
MSG_MOVEA           22CB
MSG_MOVEM           22D9
MSG_MOVEQ           22D2
MSG_MULS            22F6
MSG_NOP             22C0
MSG_NOT             2313
MSG_OR              230F
MSG_PLUS            23B5
MSG_POUND           23B9
MSG_RB              23B3
MSG_RIGHT           23A9
MSG_ROD             2320
MSG_RTS             239C
MSG_SLASH           23C0
MSG_SPACE           23C2
MSG_SUB             22F1
MSG_TAB             23C4
MSG_W               23CC
NEW_LINE            22B9
NOTNUMBER           1162
OPCODE_DECODE       11DC
OPMODE_VAR          300
OR_SIZE             188A
OTHER               7
OTHEREA             1D86
PRINTADD            146A
PRINTADDRESS        1C78
PRINTASHEX          2022
PRINTBCC            1B9A
PRINTENTER          2066
PRINTHEXNUM         1F1A
PRINTLONGZERO       1F7A
PRINTMEM2REG        1382
PRINTMORE           1D18
PRINTMOVE           1272
PRINTMOVESIZE       2076
PRINTNULL           2054
PRINTNUM            1F0A
PRINTRANGE          203E
PRINTREG            1CFE
PRINTREG2MEM        1312
PRINTREGEA          1A80
PRINTREGISTERLOOP   1CE2
PRINTREGISTERS      1CB8
PRINTREGSIZE        1A4E
PRINTSHIFTMEM       194E
PRINTSHIFTREG       1A1A
PRINTSHORTLONGNUM   1F2E
PRINTSHORTZERO      1F3A
PRINTSUB            1698
PRINTZERO           2032
PRINT_8             1672
PRINT_ADDQ_DATA     164E
PRINT_ADDR          11D0
PRINT_MEMDIR        1978
PRINT_MOVEQ         13C2
PRINT_REGDIR        1A48
REG2MEMLONG         1306
REG2MEMWORD         12F6
REGTOMEM1           1CCA
REGTOMEM2           1D3E
REG_BYTE            1A66
REG_IMMEDIATE       1A96
REG_LONG            1A7A
REG_REGISTER        1ADC
REG_VAR             250
REG_WORD            1A70
RESET_INPUT         112A
RESTART             10D4
RETURN              1190
ROD_MEM             3
ROD_REG             3
SOURCEEA            1BE2
SOURCEXN            1C0C
START               1000
STARTING            21CD
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11B0
THREE_TAB           22BC
VALIDEA             1D76
VALIDEA_ADDSUB_DESTOPERAND  2115
VALIDEA_ALL         2100
VALIDEA_ANDORNOT    2123
VALIDEA_ANDOR_DESTOPERAND  2129
VALIDEA_JSR         2133
VALIDEA_LEA         2120
VALIDEA_MOVEM_MEMTOREG  2111
VALIDEA_MOVEM_REGTOMEM  210D
VALIDEA_MOVEQ       2107
VALIDEA_MULSDIVU    211A
VALIDEA_SHIFT       212E
VALIDXN_ALL         2136
VALIDXN_SHORTLONG   213A
WELCOME             213D
XNIMMEDIATE         4
