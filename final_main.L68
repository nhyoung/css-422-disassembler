00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/7/2020 7:08:18 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001F2B             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001FA1             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001FD8             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 00001D20             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001E58             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6600 0052                 78                  BNE     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 0000200E            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C                           138  
0000116C                           139  
0000116C                           140  *---------------NOP opcode----------------------                
0000116C  B07C 4E71                141  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001170  6600 0010                142                  BNE     CASE_MOVE               ; checks the next case if not equal
00001174  4BF9 00002065            143                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117A  4EB9 00001E46            144                  JSR     PRINTNULL               ; prints NOP                
00001180  4E75                     145                  RTS                             ; returns from the subroutine
00001182                           146  
00001182                           147  *---------------MOVE opcode----------------------              
00001182                           148                  * if first two bits are 00, next two are not 00
00001182  3200                     149  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001184  C27C C000                150                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001188  6600 009A                151                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
0000118C  B07C 0FFF                152                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001190  6F00 0092                153                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001194                           154                  
00001194                           155                  ; Check source
00001194  4BF9 00001EEE            156                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119A  4DF9 00001F24            157                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A0  3E3C 0000                158                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A4  4EB9 00001AB4            159                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AA  B27C 0001                160                  CMP.W   #1,D1                    ; checks if invalid
000011AE  6700 08AC                161                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B2  3802                     162                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B4  3A03                     163                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011B6                           164                  
000011B6                           165                  ; Check destination
000011B6  4BF9 00001EEE            166                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011BC  4DF9 00001F28            167                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C2  3E3C 0001                168                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011C6  4EB9 00001AB4            169                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011CC  B27C 0001                170                  CMP.W   #1,D1                    ; checks if invalid
000011D0  6700 088A                171                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D4  3C02                     172                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011D6  3E03                     173                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011D8                           174                  
000011D8                           175                  ; Checking if it is MOVEA
000011D8  3200                     176                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DA  C27C 01C0                177                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011DE  B27C 0040                178                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E2  6700 000C                179                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011E6                           180   
000011E6  4BF9 0000206A            181                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011EC  6000 0008                182                  BRA     PRINTMOVE                ; Branches to print move
000011F0                           183                  
000011F0  4BF9 00002070            184  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011F6                           185   
000011F6  4EB9 00001E46            186  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
000011FC  4EB9 00001E68            187                  JSR     PRINTMOVESIZE            ; prints out the size  
00001202  3404                     188                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001204  3605                     189                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001206  4EB9 00001B80            190                  JSR     EA_TO_STRING             ; outputs it into a string
0000120C                           191                  
0000120C                           192                  ; prints a comma to seperate
0000120C  4BF9 00002162            193                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001212  4EB9 00001E46            194                  JSR     PRINTNULL                ; prints out MOVE
00001218                           195                  
00001218                           196                  ; print destination
00001218  3406                     197                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121A  3607                     198                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000121C  4EB9 00001B80            199                  JSR     EA_TO_STRING             ; outputs it into a string
00001222  4E75                     200                  RTS                              ; exits subroutine                 
00001224                           201                
00001224                           202  *---------------MOVEM opcode----------------------                
00001224  3200                     203  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001226  C27C FB80                204                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122A  B27C 4880                205                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000122E  6600 005A                206                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001232                           207                  
00001232                           208                  ; loads EA and XN
00001232  323C 0000                209                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001236  4EB9 00001A60            210                  JSR     GET_EA                          ; gets EA and puts in D1
0000123C  3401                     211                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
0000123E  323C 0000                212                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001242  4EB9 00001A8A            213                  JSR     GET_XN                          ; gets XN and puts in D1
00001248  3601                     214                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
0000124A                           215                  
0000124A                           216                  ; Check D
0000124A  3200                     217                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000124C  C27C 0400                218                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001250  3E01                     219                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001252  B27C 0400                220                  CMP.W   #$0400,D1                       ; checks if value is 1
00001256  6700 0032                221                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000125A                           222  
0000125A  4BF9 00001EFB            223  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001260  3202                     224                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001262  4EB9 00001B4C            225                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001268  B27C 0001                226                  CMP.W   #1,D1                           ; checks if D1 invalid
0000126C  6700 07EE                227                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001270  B27C 0002                228                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001274                           229                  
00001274  4BF9 00001EFB            230  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127A  3203                     231                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
0000127C  4EB9 00001B4C            232                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001282  B27C 0001                233                  CMP.W   #1,D1                           ; checks if D1 invalid
00001286  6700 07D4                234                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128A                           235  
0000128A                           236                  
0000128A                           237  
0000128A                           238  MOVEM_MEM2REG    
0000128A                           239                          
0000128A                           240  
0000128A                           241  *---------------MOVEQ opcode----------------------
0000128A  3200                     242  CASE_MOVEQ      MOVE.W  D0,D1
0000128C  C27C F100                243                  AND.W   #$F100,D1
00001290  B27C 7000                244                  CMP.W   #$7000,D1
00001294  6600 0048                245                  BNE     CASE_ADD
00001298                           246                  
00001298                           247                  ;loads Register
00001298  323C 0001                248                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000129C  4EB9 00001A8A            249                  JSR     GET_XN                          ; gets XN and puts in D1
000012A2  3401                     250                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012A4                           251                  
000012A4                           252                  ;loads DATA
000012A4  3200                     253                  MOVE.W  D0,D1
000012A6  C27C 00FF                254                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012AA  3601                     255                  MOVE.W  D1,D3                          ;copy data into D3
000012AC                           256                                                        ;must convert bits to hex
000012AC                           257                                  
000012AC  4BF9 00002077            258  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B2  4EB9 00001E46            259                  JSR     PRINTNULL  
000012B8                           260                  
000012B8  4BF9 00002175            261                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012BE  4EB9 00001E46            262                  JSR     PRINTNULL
000012C4                           263      
000012C4  4BF9 00002061            264                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000012CA  4EB9 00001E46            265                  JSR     PRINTNULL
000012D0                           266                  
000012D0  4BF9 0000215E            267                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012D6  4EB9 00001E46            268                  JSR     PRINTNULL
000012DC  4E75                     269                  RTS
000012DE                           270                  
000012DE                           271  *---------------ADD opcode----------------------                
000012DE                           272  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000012DE  3200                     273  CASE_ADD        MOVE.W  D0,D1
000012E0  C27C F000                274                  AND.W   #$F000,D1
000012E4  B27C D000                275                  CMP.W   #$D000,D1
000012E8  6600 019E                276                  BNE     CASE_ADDQ
000012EC                           277                  
000012EC  4EB9 0000130C            278                  JSR     ADD_SUB_HELP
000012F2                           279                  
000012F2                           280                  ; bits 7-8 determine if it is ADDA or ADD
000012F2  3200                     281                  MOVE.W  D0,D1
000012F4  E149                     282                  LSL.W   #8,D1                   ; get rid of left 8 bits
000012F6  E049                     283                  LSR.W   #8,D1
000012F8  EC49                     284                  LSR.W   #6,D1                   ; get rid of right 6 bits
000012FA  B27C 0003                285                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000012FE  6700 0120                286                  BEQ     CASE_ADDA
00001302                           287                  
00001302  4BF9 00002085            288                  LEA     MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001308  6000 0048                289                  BRA     PRINTADD                ; Branches to print move
0000130C                           290                  
0000130C                           291                  ; Check bits 0-5 
0000130C  4BF9 00001EEE            292  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001312  4DF9 00001F24            293                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001318  3E3C 0000                294                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000131C  4EB9 00001AB4            295                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001322  B27C 0001                296                  CMP.W       #1,D1                    ; checks if invalid
00001326  6700 0734                297                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000132A  3802                     298                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
0000132C  3A03                     299                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000132E                           300                  
0000132E                           301                  ; Check 6-11
0000132E  4BF9 00001EEE            302                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001334  4DF9 00001F28            303                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000133A  3E3C 0001                304                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000133E  4EB9 00001AB4            305                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001344  B27C 0001                306                  CMP.W       #1,D1                    ; checks if invalid
00001348  6700 0712                307                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000134C  3C02                     308                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
0000134E  3E03                     309                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001350                           310    
00001350  4E75                     311                  RTS                
00001352                           312                    
00001352  4EB9 00001E46            313  PRINTADD        JSR         PRINTNULL
00001358  3200                     314                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000135A  4EB9 00001364            315                  JSR         ADD_SUB_SIZE
00001360  6000 0050                316                  BRA         FINISH_ADD
00001364                           317                    
00001364  3200                     318  ADD_SUB_SIZE    MOVE.W      D0,D1
00001366  E149                     319                  LSL.W       #8,D1
00001368  E049                     320                  LSR.W       #8,D1
0000136A  EC49                     321                  LSR.W       #6,D1                   ; gets bits 6-7
0000136C                           322                    
0000136C  B27C 0000                323                  CMP.W       #0,D1
00001370  6700 0016                324                  BEQ         ADD_SUB_BYTE
00001374  B27C 0001                325                  CMP.W       #1,D1                   ; if 1, it is a word
00001378  6700 001C                326                  BEQ         ADD_SUB_WORD
0000137C  B27C 0002                327                  CMP.W       #2,D1                   ; if 2, it is a long
00001380  6700 0022                328                  BEQ         ADD_SUB_LONG
00001384  6000 024C                329                  BRA         CASE_SUBA                    ; error
00001388                           330                    
00001388  4BF9 00002169            331  ADD_SUB_BYTE    LEA         MSG_B,A5
0000138E  4EB9 00001E46            332                  JSR         PRINTNULL
00001394  4E75                     333                  RTS
00001396                           334                    
00001396  4BF9 0000216F            335  ADD_SUB_WORD    LEA         MSG_W,A5
0000139C  4EB9 00001E46            336                  JSR         PRINTNULL
000013A2  4E75                     337                  RTS
000013A4                           338    
000013A4  4BF9 00002175            339  ADD_SUB_LONG    LEA         MSG_L,A5
000013AA  4EB9 00001E46            340                  JSR         PRINTNULL
000013B0  4E75                     341                  RTS
000013B2                           342        
000013B2  4EB9 000013BA            343  FINISH_ADD      JSR         ADD_SUB_OPERAND
000013B8  4E75                     344                  RTS
000013BA                           345    
000013BA  EF49                     346  ADD_SUB_OPERAND LSL.W       #7,D1
000013BC  EE49                     347                  LSR.W       #7,D1
000013BE  E049                     348                  LSR.W       #8,D1
000013C0  B27C 0001                349                  CMP.W       #1,D1
000013C4  6600 002E                350                  BNE         Dn_PLUS_EA          
000013C8                           351                    
000013C8                           352                  ; print Data Register
000013C8  4BF9 00002152            353                  LEA         MSG_DR,A5
000013CE  4EB9 00001E46            354                  JSR         PRINTNULL
000013D4  3207                     355                  MOVE.W      D7,D1
000013D6  4EB9 00001CFC            356                  JSR         PRINTNUM                
000013DC                           357                  
000013DC                           358                  ; prints a comma to seperate
000013DC  4BF9 00002162            359                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000013E2  4EB9 00001E46            360                  JSR         PRINTNULL                ; prints out MOVE
000013E8                           361                 
000013E8                           362                  ; below is EA+Dn->Dn  
000013E8  3404                     363                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000013EA  3605                     364                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000013EC  4EB9 00001B80            365                  JSR         EA_TO_STRING             ; outputs it into a string
000013F2  4E75                     366                  RTS                                 ; exits subroutine 
000013F4                           367  
000013F4                           368  Dn_PLUS_EA      ; below is Dn+EA->EA  
000013F4  3404                     369                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000013F6  3605                     370                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000013F8  4EB9 00001B80            371                  JSR         EA_TO_STRING             ; outputs it into a string   
000013FE                           372                  
000013FE                           373                  ; prints a comma to seperate
000013FE  4BF9 00002162            374                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001404  4EB9 00001E46            375                  JSR         PRINTNULL                ; prints out MOVE
0000140A                           376                  
0000140A                           377                  ; below is Dn+EA->EA
0000140A  4BF9 00002152            378                  LEA         MSG_DR,A5                ; print data register
00001410  4EB9 00001E46            379                  JSR         PRINTNULL
00001416  3207                     380                  MOVE.W      D7,D1
00001418  4EB9 00001CFC            381                  JSR         PRINTNUM             
0000141E  4E75                     382                  RTS                                  ; exits subroutine          
00001420                           383                        
00001420                           384  *---------------ADDA opcode----------------------
00001420  3200                     385  CASE_ADDA       MOVE.W      D0,D1
00001422  EF49                     386                  LSL.W       #7,D1
00001424  EE49                     387                  LSR.W       #7,D1
00001426  E049                     388                  LSR         #8,D1                               ; gets bit 8 (size bit)
00001428                           389                  
00001428  4BF9 0000208A            390                  LEA         MSG_ADDA,A5
0000142E  4EB9 00001E46            391                  JSR         PRINTNULL
00001434                           392                   
00001434  B27C 0001                393                  CMP.W       #1,D1
00001438  6700 0012                394                  BEQ         ADDA_LONG
0000143C                           395                    
0000143C  4BF9 0000216F            396                  LEA         MSG_W,A5
00001442  4EB9 00001E46            397                  JSR         PRINTNULL
00001448  6000 0012                398                  BRA         FINISH_ADDA   
0000144C                           399                    
0000144C  4BF9 00002175            400  ADDA_LONG       LEA         MSG_L,A5
00001452  4EB9 00001E46            401                  JSR         PRINTNULL
00001458  6000 0002                402                  BRA         FINISH_ADDA
0000145C                           403                    
0000145C  3404                     404  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000145E  3605                     405                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001460  4EB9 00001B80            406                  JSR         EA_TO_STRING             ; outputs it into a string
00001466                           407                    
00001466                           408                  ; prints a comma to seperate
00001466  4BF9 00002162            409                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000146C  4EB9 00001E46            410                  JSR         PRINTNULL                ; prints out MOVE
00001472                           411            
00001472  4BF9 00002154            412                  LEA         MSG_AR,A5                ; print address register
00001478  4EB9 00001E46            413                  JSR         PRINTNULL
0000147E  3207                     414                  MOVE.W      D7,D1
00001480  4EB9 00001CFC            415                  JSR         PRINTNUM             
00001486  4E75                     416                  RTS                              ; exits subroutine
00001488                           417                  
00001488                           418  *---------------ADDQ opcode----------------------                  
00001488  3200                     419  CASE_ADDQ       MOVE.W      D0,D1
0000148A  C27C F000                420                  AND.W       #$F000,D1       
0000148E  B27C 5000                421                  CMP.W       #$5000,D1
00001492  6600 00C8                422                  BNE         CASE_SUB
00001496                           423                   
00001496                           424                  ; Check bits 0-5 
00001496  4BF9 00001EEE            425                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000149C  4DF9 00001F24            426                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000014A2  3E3C 0000                427                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000014A6  4EB9 00001AB4            428                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000014AC  B27C 0001                429                  CMP.W       #1,D1                    ; checks if invalid
000014B0  6700 05AA                430                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000014B4  3802                     431                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000014B6  3A03                     432                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000014B8                           433                    
000014B8                           434                  ; get bits 6-7 (size bits)
000014B8  3200                     435                  MOVE.W      D0,D1
000014BA  E149                     436                  LSL.W       #8,D1
000014BC  E049                     437                  LSR.W       #8,D1
000014BE  EC49                     438                  LSR.W       #6,D1
000014C0  3401                     439                  MOVE.W      D1,D2
000014C2                           440    
000014C2                           441                  ; gets bits 9-11 (data bits)
000014C2  E949                     442                  LSL.W       #4,D1
000014C4  E849                     443                  LSR.W       #4,D1                               ; get rid of left 4 bits
000014C6  E049                     444                  LSR.W       #8,D1
000014C8  E249                     445                  LSR.W       #1,D1                               ; get rid of right 9 bits
000014CA                           446                    
000014CA  4BF9 00002090            447                  LEA         MSG_ADDQ,A5
000014D0  4EB9 00001E46            448                  JSR         PRINTNULL
000014D6                           449                    
000014D6  B47C 0001                450                  CMP.W       #1,D2
000014DA  6700 001A                451                  BEQ         ADDQ_WORD
000014DE  B47C 0002                452                  CMP.W       #2,D2
000014E2  6700 0022                453                  BEQ         ADDQ_LONG
000014E6                           454                    
000014E6  4BF9 00002169            455  ADDQ_BYTE       LEA         MSG_B,A5
000014EC  4EB9 00001E46            456                  JSR         PRINTNULL
000014F2  6000 0022                457                  BRA         FINISH_ADDQ  
000014F6                           458   
000014F6  4BF9 0000216F            459  ADDQ_WORD       LEA         MSG_W,A5
000014FC  4EB9 00001E46            460                  JSR         PRINTNULL
00001502  6000 0012                461                  BRA         FINISH_ADDQ                 
00001506                           462    
00001506  4BF9 00002175            463  ADDQ_LONG       LEA         MSG_L,A5
0000150C  4EB9 00001E46            464                  JSR         PRINTNULL
00001512  6000 0002                465                  BRA         FINISH_ADDQ                  
00001516                           466                    
00001516  4EB9 00001534            467  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000151C                           468   
0000151C                           469                  ; prints a comma to seperate
0000151C  4BF9 00002162            470                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001522  4EB9 00001E46            471                  JSR         PRINTNULL                ; prints out MOVE
00001528                           472                    
00001528                           473                  ; prints destination
00001528  3404                     474                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000152A  3605                     475                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000152C  4EB9 00001B80            476                  JSR         EA_TO_STRING             ; outputs it into a string
00001532                           477                 
00001532  4E75                     478                  RTS
00001534                           479   
00001534  4BF9 0000215E            480  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
0000153A  4EB9 00001E46            481                  JSR         PRINTNULL
00001540  B27C 0000                482                  CMP.W       #0,D1
00001544  6700 000A                483                  BEQ         PRINT_8
00001548  4EB9 00001CFC            484                  JSR         PRINTNUM
0000154E  4E75                     485                  RTS 
00001550                           486  
00001550  123C 0008                487  PRINT_8         MOVE.B      #8,D1
00001554  4EB9 00001CFC            488                  JSR         PRINTNUM
0000155A  4E75                     489                  RTS   
0000155C                           490         
0000155C                           491  *---------------SUB opcode---------------------- 
0000155C  3200                     492  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000155E  C27C F000                493                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001562  B27C 9000                494                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001566  6600 0080                495                  BNE         CASE_LEA
0000156A                           496                 
0000156A  4EB8 130C                497                  JSR         ADD_SUB_HELP
0000156E                           498                                 
0000156E  4BF9 00002096            499                  LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
00001574  6000 0002                500                  BRA         PRINTSUB                            ; Branches to print move
00001578                           501  
00001578  4EB9 00001E46            502  PRINTSUB        JSR         PRINTNULL
0000157E  3200                     503                  MOVE.W      D0,D1                               ; bits 6-7 contain size
00001580  4EB8 1364                504                  JSR         ADD_SUB_SIZE
00001584  3200                     505                  MOVE.W      D0,D1
00001586  E149                     506                  LSL.W       #8,D1
00001588  E049                     507                  LSR.W       #8,D1
0000158A  EC49                     508                  LSR.W       #6,D1
0000158C  B27C 0003                509                  CMP.W       #3,D1
00001590  6600 0006                510                  BNE         FINISH_SUB
00001594  6000 0008                511                  BRA         FINISH_SUBA                         ; same as ADDA
00001598                           512                  
00001598  4EB8 13BA                513  FINISH_SUB      JSR     ADD_SUB_OPERAND
0000159C  4E75                     514                  RTS
0000159E                           515                    
0000159E  3404                     516  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015A0  3605                     517                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015A2  4EB9 00001B80            518                  JSR         EA_TO_STRING             ; outputs it into a string
000015A8                           519                
000015A8                           520                  ; prints a comma to seperate
000015A8  4BF9 00002162            521                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015AE  4EB9 00001E46            522                  JSR         PRINTNULL                ; prints out MOVE
000015B4                           523          
000015B4  4BF9 00002154            524                  LEA         MSG_AR,A5                ; print address register
000015BA  4EB9 00001E46            525                  JSR         PRINTNULL
000015C0  3200                     526                  MOVE.W      D0,D1
000015C2  E949                     527                  LSL.W       #4,D1
000015C4  E849                     528                  LSR.W       #4,D1
000015C6  E049                     529                  LSR.W       #8,D1
000015C8  E249                     530                  LSR.W       #1,D1
000015CA  4EB9 00001CFC            531                  JSR         PRINTNUM             
000015D0  4E75                     532                  RTS                              ; exits subroutine
000015D2                           533  
000015D2                           534  
000015D2                           535  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
000015D2  3200                     536  CASE_SUBA       MOVE.W      D0,D1
000015D4  EF49                     537                  LSL.W       #7,D1
000015D6  EE49                     538                  LSR.W       #7,D1
000015D8  E049                     539                  LSR.W       #8,D1
000015DA  B23C 0000                540                  CMP.B       #0,D1
000015DE  6700 FDB6                541                  BEQ         ADD_SUB_WORD
000015E2  6000 FDC0                542                  BRA         ADD_SUB_LONG
000015E6  4E75                     543                  RTS         
000015E8                           544                   
000015E8  3200                     545  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000015EA  C27C F000                546                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000015EE  B27C 4000                547                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
000015F2  6600 0086                548                  BNE.W   CASE_AND                             ; If its not, check AND
000015F6  3200                     549                  MOVE.W  D0,D1                                ; Copies instruction word to D1
000015F8  C27C 01C0                550                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
000015FC  B27C 01C0                551                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001600  6600 0078                552                  BNE.W   CASE_AND                             ; If its not, check AND
00001604                           553                  
00001604                           554                  ; Check source
00001604  4BF9 00001F0E            555                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000160A  4DF9 00001F28            556                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001610  3E3C 0000                557                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001614  4EB9 00001AB4            558                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000161A  3802                     559                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000161C  3A03                     560                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000161E                           561                  
0000161E                           562                  ; Check destination
0000161E  4BF9 00001F0E            563                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001624  4DF9 00001F28            564                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000162A  3E3C 0001                565                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000162E  4EB9 00001AB4            566                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001634  3C02                     567                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001636  3E03                     568                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001638                           569  
00001638  4BF9 000020A7            570                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000163E  4EB9 00001E46            571                  JSR     PRINTNULL                            ; prints LEA
00001644                           572                  
00001644                           573                  ; print source
00001644  3404                     574                  MOVE.W  D4,D2
00001646  3605                     575                  MOVE.W  D5,D3
00001648  4EB9 00001B80            576                  JSR     EA_TO_STRING                         ; Prints out the EA
0000164E                           577                  
0000164E                           578                  ; comma
0000164E  4BF9 00002162            579                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001654  4EB9 00001E46            580                  JSR     PRINTNULL                       
0000165A                           581                   
0000165A                           582                  ; register
0000165A  4BF9 00002154            583                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001660  4EB9 00001E46            584                  JSR     PRINTNULL 
00001666  3401                     585                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
00001668  323C 0001                586                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
0000166C  4EB9 00001A8A            587                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001672  4EB9 00001CFC            588                  JSR     PRINTNUM                             ; Prints the number in D1
00001678  4E75                     589                  RTS
0000167A                           590  
0000167A                           591  *---------------AND opcode----------------------
0000167A  3200                     592  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
0000167C  C27C F000                593                  AND.W       #$F000,D1       
00001680  B27C C000                594                  CMP.W       #$C000,D1
00001684  6600 007E                595                  BNE         CASE_OR
00001688                           596                                
00001688  4EB8 130C                597                  JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
0000168C                           598                  
0000168C  3200                     599                  MOVE.W      D0,D1
0000168E  E149                     600                  LSL.W       #8,D1
00001690  E049                     601                  LSR.W       #8,D1
00001692  EC49                     602                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001694  B27C 0003                603                  CMP.W       #3,D1
00001698  6700 005C                604                  BEQ         INV_INSTR
0000169C                           605                  
0000169C  4BF9 000020AF            606                  LEA         MSG_AND,A5
000016A2  4EB9 00001E46            607                  JSR         PRINTNULL
000016A8                           608                  
000016A8  B27C 0000                609                  CMP.W       #0,D1
000016AC  6700 0012                610                  BEQ         AND_BYTE
000016B0  B27C 0001                611                  CMP.W       #1,D1                   ; if 1, it is a word
000016B4  6700 001A                612                  BEQ         AND_WORD
000016B8  B27C 0002                613                  CMP.W       #2,D1                   ; if 2, it is a long
000016BC  6700 0022                614                  BEQ         AND_LONG
000016C0                           615                  
000016C0  4BF9 00002169            616  AND_BYTE        LEA         MSG_B,A5
000016C6  4EB9 00001E46            617                  JSR         PRINTNULL
000016CC  6000 0022                618                  BRA         FINISH_AND
000016D0                           619                                    
000016D0  4BF9 0000216F            620  AND_WORD        LEA         MSG_W,A5
000016D6  4EB9 00001E46            621                  JSR         PRINTNULL
000016DC  6000 0012                622                  BRA         FINISH_AND
000016E0                           623    
000016E0  4BF9 00002175            624  AND_LONG        LEA         MSG_L,A5
000016E6  4EB9 00001E46            625                  JSR         PRINTNULL
000016EC  6000 0002                626                  BRA         FINISH_AND
000016F0                           627        
000016F0  4EB8 13BA                628  FINISH_AND      JSR         ADD_SUB_OPERAND
000016F4  4E75                     629                  RTS
000016F6                           630                  
000016F6  4BF9 0000204C            631  INV_INSTR       LEA         INVALID_INSTR,A5
000016FC  4EB9 00001E46            632                  JSR         PRINTNULL
00001702  4E75                     633                  RTS               
00001704                           634                  
00001704                           635  *---------------OR opcode----------------------            
00001704  3200                     636  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001706  C27C F000                637                  AND.W       #$F000,D1       
0000170A  B27C 8000                638                  CMP.W       #$8000,D1
0000170E  6600 0044                639                  BNE         CASE_NOT
00001712                           640                                
00001712  4EB8 130C                641                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001716                           642                  
00001716  3200                     643                  MOVE.W      D0,D1
00001718  E149                     644                  LSL.W       #8,D1
0000171A  E049                     645                  LSR.W       #8,D1
0000171C  EC49                     646                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000171E  B27C 0003                647                  CMP.W       #3,D1
00001722  67D2                     648                  BEQ         INV_INSTR
00001724                           649                  
00001724  4BF9 000020B4            650                  LEA         MSG_OR,A5
0000172A  4EB9 00001E46            651                  JSR         PRINTNULL                       ; print "OR"
00001730                           652                  
00001730  4EB9 0000173C            653                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001736  4EB8 13BA                654                  JSR         ADD_SUB_OPERAND                 ; print 
0000173A  4E75                     655                  RTS
0000173C                           656  
0000173C  B27C 0000                657  OR_SIZE         CMP.W       #0,D1
00001740  6700 FC46                658                  BEQ         ADD_SUB_BYTE
00001744  B27C 0001                659                  CMP.W       #1,D1                   ; if 1, it is a word
00001748  6700 FC4C                660                  BEQ         ADD_SUB_WORD
0000174C  B27C 0002                661                  CMP.W       #2,D1                   ; if 2, it is a long
00001750  6700 FC52                662                  BEQ         ADD_SUB_LONG
00001754                           663                  ; no need for rts, since ADD_SUB_ already has                
00001754                           664  
00001754                           665  *---------------NOT opcode----------------------
00001754  3200                     666  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001756  C27C FF00                667                  AND.W       #$FF00,D1       
0000175A  B27C 4600                668                  CMP.W       #$4600,D1
0000175E  6600 0046                669                  BNE         CASE_LSDASD
00001762                           670                 
00001762                           671                  ; get bits 6-7 (size)
00001762  3200                     672                  MOVE.W      D0,D1
00001764  E149                     673                  LSL.W       #8,D1
00001766  E049                     674                  LSR.W       #8,D1
00001768  EC49                     675                  LSR.W       #6,D1                          
0000176A  B27C 0003                676                  CMP.W       #3,D1
0000176E  6786                     677                  BEQ         INV_INSTR
00001770                           678                  
00001770  4BF9 000020B8            679                  LEA         MSG_NOT,A5
00001776  4EB9 00001E46            680                  JSR         PRINTNULL                       ; print "NOT"
0000177C                           681                  
0000177C  4EB8 173C                682                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001780                           683                  
00001780                           684                  ; get bits 0-5 
00001780  4BF9 00001EEE            685                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001786  4DF9 00001F24            686                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000178C  3E3C 0000                687                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001790  4EB9 00001AB4            688                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001796  B27C 0001                689                  CMP.W       #1,D1                    ; checks if invalid
0000179A  6700 02C0                690                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000179E  4EB9 00001B80            691                  JSR         EA_TO_STRING             ; outputs it into a string
000017A4                           692    
000017A4  4E75                     693                  RTS
000017A6                           694  
000017A6  3200                     695  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
000017A8  C27C F000                696                  AND.W       #$F000, D1                       ; gets first 4 bits
000017AC  B27C E000                697                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
000017B0  6600 0210                698                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
000017B4  3400                     699                  MOVE.W      D0,D2                            ; copies D0 to D2
000017B6  4EB9 00001B3C            700                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000017BC  B47C 0003                701                  CMP.W       #$3, D2                          ; checks if it is memory or register option
000017C0  6600 00C8                702                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
000017C4                           703                  
000017C4  3400                     704  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
000017C6  4EB9 00001B2A            705                  JSR         GETROTATION                      ; gets rotation value of D2
000017CC  B47C 0000                706                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
000017D0  6700 0014                707                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
000017D4  B47C 0003                708                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
000017D8  6700 0016                709                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
000017DC                           710                  
000017DC  4BF9 000020BD            711  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
000017E2  6000 0012                712                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000017E6                           713  
000017E6  4BF9 000020C1            714  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
000017EC  6000 0008                715                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000017F0                           716  
000017F0  4BF9 000020C5            717  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
000017F6                           718                  
000017F6  4EB9 00001E46            719  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
000017FC  3400                     720                  MOVE.W      D0,D2                            ; copies D0 to D2
000017FE  4EB9 00001B34            721                  JSR         GETDIRECTION                     ; gets direction
00001804  B47C 0000                722                  CMP.W       #0,D2                            ; checking if its right
00001808  6700 000C                723                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
0000180C                           724  
0000180C  4BF9 00002150            725  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001812  6000 0008                726                  BRA         PRINT_MEMDIR                     ; branches for printing
00001816                           727          
00001816  4BF9 0000214E            728  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
0000181C                           729  
0000181C  4EB9 00001E46            730  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001822  4BF9 0000216F            731                  LEA         MSG_W,A5                         ; loads .W into A5
00001828  4EB9 00001E46            732                  JSR         PRINTNULL                        ; Prints .W
0000182E  6000 0002                733                  BRA         GETMEMSOURCE                     ; checks the source 
00001832                           734                  
00001832                           735  ; get source addressing mode       
00001832                           736  GETMEMSOURCE                                                 
00001832  323C 0000                737                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001836  4EB9 00001A60            738                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
0000183C  3801                     739                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
0000183E  323C 0000                740                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001842  4EB9 00001A8A            741                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001848  3A01                     742                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
0000184A                           743  
0000184A  4BF9 00001F1C            744  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001850  3204                     745                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001852  4EB9 00001B4C            746                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001858  B27C 0002                747                  CMP.W       #2,D1                            ; checks if it is Xn
0000185C  6700 0016                748                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001860  B27C 0001                749                  CMP.W       #1,D1                            ; Checks if it is invalid
00001864  6700 01F6                750                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001868                           751  
00001868  3404                     752  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
0000186A  3605                     753                  MOVE.W      D5,D3                            ; moves EA to D3
0000186C  4EB9 00001B80            754                  JSR         EA_TO_STRING                     ; prints out the EA
00001872  4E75                     755                  RTS                
00001874                           756                  
00001874                           757                  
00001874  4BF9 00001F28            758  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
0000187A  3205                     759                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
0000187C  4EB9 00001B4C            760                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001882  4A41                     761                  TST.W       D1                               ; checks if it is valid
00001884  67E2                     762                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001886  6000 01D4                763                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
0000188A                           764  
0000188A                           765  
0000188A  3602                     766  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
0000188C  3200                     767                  MOVE.W      D0,D1                            ; copies D0 to D1
0000188E  C27C 0018                768                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001892  E649                     769                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001894  B27C 0000                770                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001898  6700 0014                771                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
0000189C  B27C 0003                772                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000018A0  6700 0016                773                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
000018A4                           774                  
000018A4  4BF9 000020BD            775  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
000018AA  6000 0012                776                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000018AE                           777  
000018AE  4BF9 000020C1            778  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
000018B4  6000 0008                779                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
000018B8                           780  
000018B8  4BF9 000020C5            781  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
000018BE                           782                  
000018BE  4EB9 00001E46            783  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
000018C4  3400                     784                  MOVE.W      D0,D2                            ; copies D0 to D2
000018C6  4EB9 00001B34            785                  JSR         GETDIRECTION                     ; gets direction
000018CC  B47C 0000                786                  CMP.W       #0,D2                            ; checking if its right
000018D0  6700 000C                787                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
000018D4                           788  
000018D4  4BF9 00002150            789  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
000018DA  6000 000C                790                  BRA         PRINT_REGDIR                     ; branches for printing
000018DE                           791          
000018DE  4BF9 0000214E            792  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
000018E4  6000 0002                793                  BRA         PRINT_REGDIR                     ; branches for printing
000018E8                           794                  
000018E8  4EB9 00001E46            795  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
000018EE                           796  
000018EE  3400                     797  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
000018F0  4EB9 00001B3C            798                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000018F6  B47C 0001                799                  CMP.W       #1,D2                            ; Checks if it is word size
000018FA  6700 0014                800                  BEQ         REG_WORD                         ; Prints .W
000018FE  B47C 0002                801                  CMP.W       #2,D2                            ; Checks if it is long size
00001902  6700 0016                802                  BEQ         REG_LONG                         ; Prints .L
00001906                           803  
00001906  4BF9 00002169            804  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
0000190C  6000 0012                805                  BRA         PRINTREGEA      
00001910                           806  
00001910  4BF9 0000216F            807  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001916  6000 0008                808                  BRA         PRINTREGEA      
0000191A                           809                             
0000191A  4BF9 00002175            810  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001920                           811  
00001920  4EB9 00001E46            812  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001926  3400                     813                  MOVE.W      D0,D2                            ; copies D0 to D1
00001928  4EB9 00001B44            814                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
0000192E  B27C 0001                815                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001932  6700 0048                816                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001936                           817                                  
00001936  3400                     818  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001938  4EB9 00001B3C            819                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000193E  3202                     820                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001940  4BF9 0000215E            821                  LEA         MSG_POUND, A5                    ; loads # into A5
00001946  4EB9 00001E46            822                  JSR         PRINTNULL                        ; prints #
0000194C  4EB9 00001CFC            823                  JSR         PRINTNUM                         ; prints shift count
00001952  4BF9 00002162            824                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001958  4EB9 00001E46            825                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
0000195E  4BF9 00002152            826                  LEA         MSG_DR, A5                       ; loads D into A5
00001964  4EB9 00001E46            827                  JSR         PRINTNULL                        ; prints out D 
0000196A  323C 0000                828                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
0000196E  4EB9 00001A8A            829                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001974  4EB9 00001CFC            830                  JSR         PRINTNUM                         ; prints data register number in D1          
0000197A  4E75                     831                  RTS                                          ; ends subroutine to go onto the next instruction opcode
0000197C                           832                  
0000197C  3400                     833  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
0000197E  4EB9 00001B3C            834                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001984  3202                     835                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001986  4BF9 00002152            836                  LEA         MSG_DR, A5                       ; loads D into A5
0000198C  4EB9 00001E46            837                  JSR         PRINTNULL                        ; prints D
00001992  4EB9 00001CFC            838                  JSR         PRINTNUM                         ; prints register number
00001998  4BF9 00002162            839                  LEA         MSG_COMMA, A5                    ; loads , into A5
0000199E  4EB9 00001E46            840                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000019A4  4BF9 00002152            841                  LEA         MSG_DR, A5                       ; loads D into A5
000019AA  4EB9 00001E46            842                  JSR         PRINTNULL                        ; prints out D 
000019B0  323C 0000                843                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000019B4  4EB9 00001A8A            844                  JSR         GET_XN                           ; gets the data register number, stores in D1
000019BA  4EB9 00001CFC            845                  JSR         PRINTNUM                         ; prints data register number in D1          
000019C0  4E75                     846                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000019C2                           847               
000019C2  3200                     848  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000019C4  C27C FF00                849                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
000019C8  B27C 6000                850                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
000019CC  6600 0018                851                  BNE.W   CASE_BCC                             ; If its not, check BCC
000019D0                           852                  
000019D0  4BF9 00002146            853                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
000019D6  4EB9 00001E46            854                  JSR     PRINTNULL                            ; prints BRA
000019DC                           855  
000019DC  3400                     856                  MOVE.W  D0,D2                                ; Copies instruction word to D1
000019DE  4EB9 00001AFC            857                  JSR     GETDISPLACEMENT                      ; finds the displacement
000019E4  4E75                     858                  RTS
000019E6                           859                  
000019E6                           860  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
000019E6                           861  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
000019E6  3200                     862  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
000019E8  C27C F000                863                  AND.W   #$F000,D1                            ; get top 4 bits
000019EC  B27C 6000                864                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
000019F0  6600 0054                865                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
000019F4  3200                     866                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
000019F6  C27C 0F00                867                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
000019FA  E049                     868                  LSR.W   #8,D1                                ; shifts 8 bits to the right
000019FC                           869                  
000019FC  B27C 000E                870                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001A00  6700 002A                871                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001A04                           872                  
00001A04  B27C 000F                873                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001A08  6700 0018                874                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001A0C                           875                      
00001A0C  B27C 0007                876                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001A10  6700 0006                877                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001A14  6000 0046                878                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001A18                           879     
00001A18  4BF9 000020D9            880  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001A1E  6000 0016                881                  BRA     PRINTBCC
00001A22                           882  
00001A22  4BF9 00002101            883  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001A28  6000 000C                884                  BRA     PRINTBCC
00001A2C                           885                  
00001A2C  4BF9 000020F1            886  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001A32  6000 0002                887                  BRA     PRINTBCC
00001A36                           888  
00001A36  4EB9 00001E46            889  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001A3C  3400                     890                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001A3E  4EB9 00001AFC            891                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001A44  4E75                     892                  RTS              
00001A46                           893                  
00001A46                           894  
00001A46                           895  CASE_JSR       
00001A46                           896  
00001A46  B07C 4E75                897  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001A4A  6600 F736                898                  BNE     CASE_MOVE           ; checks the next case if not equal
00001A4E  4BF9 00002141            899                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001A54  4EB9 00001E46            900                  JSR     PRINTNULL           ; prints RTS                
00001A5A  4E75                     901                  RTS                         ; returns from the subroutine
00001A5C                           902  
00001A5C                           903                  
00001A5C                           904  
00001A5C                           905  CASE_DATA           
00001A5C  4E75                     906                      RTS               
00001A5E                           907  
00001A5E  4E75                     908  CASE_EPICFAIL       RTS
00001A60                           909  
00001A60                           910  
00001A60                           911  * Finds the EA type
00001A60                           912  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001A60                           913  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001A60  48E7 3000                914  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001A64  4A41                     915                      TST.W     D1                    ; compares D1 to 0
00001A66  6700 000E                916                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001A6A                           917                      
00001A6A  343C 01C0                918  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001A6E  363C 0006                919                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001A72  6000 000A                920                      BRA       FINDTYPEEA            
00001A76                           921  
00001A76  343C 0038                922  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001A7A  363C 0003                923                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001A7E                           924  
00001A7E                           925  
00001A7E  3200                     926  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001A80  C242                     927                      AND.W     D2,D1                 ; applies bitmask to D1
00001A82  E669                     928                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001A84  4CDF 000C                929                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001A88  4E75                     930                      RTS                             ; returns from subroutine    
00001A8A                           931                      
00001A8A                           932  * Finds Xn type
00001A8A                           933  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001A8A                           934  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001A8A  48E7 3000                935  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001A8E  4A41                     936                      TST.W     D1                    ; compares D1 to 0
00001A90  6700 000E                937                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001A94                           938  
00001A94  343C 0E00                939  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001A98  363C 0009                940                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001A9C  6000 000A                941                      BRA       FINDTYPEXN            ; finds the type of Xn
00001AA0                           942  
00001AA0  343C 0007                943  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001AA4  363C 0000                944                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001AA8                           945                      
00001AA8  3200                     946  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001AAA  C242                     947                      AND.W     D2,D1                 ; applies bitmask to D1
00001AAC  E669                     948                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001AAE  4CDF 000C                949                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001AB2  4E75                     950                      RTS                             ; returns from subroutine 
00001AB4                           951                      
00001AB4                           952  * Checks and gets the EA and Xn
00001AB4                           953  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001AB4                           954  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001AB4  3207                     955  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001AB6  4EB8 1A60                956                  JSR     GET_EA                  ; Gets EA
00001ABA  3401                     957                  MOVE.W  D1,D2                   ; Stores EA in D2
00001ABC  3207                     958                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001ABE  4EB8 1A8A                959                  JSR     GET_XN                  ; Gets Xn
00001AC2  3601                     960                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001AC4  3202                     961                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001AC6                           962                  
00001AC6  4EB9 00001B4C            963                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001ACC  B27C 0002                964                  CMP.W   #2,D1                   ; checks if it is Xn
00001AD0  6700 0012                965                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001AD4  B27C 0001                966                  CMP.W   #1,D1                   ; Checks if it is invalid
00001AD8  6700 001C                967                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001ADC                           968                  
00001ADC                           969                  
00001ADC  323C 0000                970  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001AE0  6000 0018                971                  BRA     END_CHECKGET
00001AE4                           972        
00001AE4                           973  ; need XN
00001AE4  2A4E                     974  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001AE6  3203                     975                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001AE8  4EB9 00001B4C            976                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001AEE  4A41                     977                  TST.W   D1                      ; checks if it is valid
00001AF0  67EA                     978                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001AF2  6000 0002                979                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001AF6                           980   
00001AF6  323C 0001                981  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001AFA                           982  
00001AFA  4E75                     983  END_CHECKGET    RTS          
00001AFC                           984                                            
00001AFC                           985                                            
00001AFC                           986  * Gets the displacement and pritns it 
00001AFC                           987  * Inputs: D2 = instruction word, A2 = address of next word
00001AFC                           988  * Outputs: prints out displacement
00001AFC  48E7 4004                989  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001B00  3A4A                     990                      MOVE.W    A2,A5                 ; copies A2 to A5
00001B02  C47C 00FF                991                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001B06  6600 0004                992                      BNE       PRINTADDRESS          ; prints address if not 0
00001B0A  341A                     993                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001B0C                           994                      
00001B0C  D44D                     995  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001B0E  3202                     996                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001B10  183C 0000                997                      MOVE.B    #0,D4                 ; marks address as word  length
00001B14  4BF9 00002160            998                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001B1A  4EB9 00001E46            999                      JSR       PRINTNULL             ; prints null
00001B20  4EB9 00001D20           1000                      JSR       PRINTSHORTLONGNUM     ; prints address
00001B26                          1001                      
00001B26  4CDF 2002               1002                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001B2A                          1003                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001B2A                          1004  
00001B2A                          1005  * Gets the rotation value for ASd and LSd
00001B2A                          1006  * Input: D2 = instruction word copy (of D0)                                    
00001B2A                          1007  * Output: rotation  value in D2             
00001B2A  C47C 0E00               1008  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001B2E  E04A                    1009                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001B30  E24A                    1010                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001B32  4E75                    1011                      RTS                             ; return from subroutine
00001B34                          1012  
00001B34                          1013  * Gets the direction value for ASd and LSd
00001B34                          1014  * Input: D2 = instruction word copy (of D0)                                    
00001B34                          1015  * Output: direction value in D2             
00001B34  C47C 0100               1016  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001B38  E04A                    1017                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001B3A  4E75                    1018                      RTS                             ; return from subroutine
00001B3C                          1019  
00001B3C                          1020  * Gets the rotation size value for ASd and LSd
00001B3C                          1021  * Input: D2 = instruction word copy (of D0)                                    
00001B3C                          1022  * Output: rotation size value in D2             
00001B3C  C47C 00C0               1023  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001B40  EC4A                    1024                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001B42  4E75                    1025                      RTS                             ; return from subroutine
00001B44                          1026  
00001B44                          1027  * Gets the rotation location  value for ASd and LSd
00001B44                          1028  * Input: D2 = instruction word copy (of D0)                                    
00001B44                          1029  * Output: rotation location value in D2             
00001B44  C47C 0020               1030  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001B48  EA4A                    1031                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001B4A  4E75                    1032                      RTS                             ; return from subroutine
00001B4C                          1033  
00001B4C                          1034                          
00001B4C                          1035  * Checks if EA or Xn is valid
00001B4C                          1036  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001B4C                          1037  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001B4C  2F02                    1038  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001B4E                          1039  
00001B4E  141D                    1040  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001B50  B43C 00FF               1041                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001B54  6700 000A               1042                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001B58  B202                    1043                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001B5A  6700 000C               1044                     BEQ        VALIDEA               ; branches to valid EA
00001B5E  60EE                    1045                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001B60                          1046                     
00001B60  323C 0001               1047  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001B64  6000 0016               1048                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001B68                          1049                    
00001B68  B43C 0007               1050  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001B6C  6700 000A               1051                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001B70  323C 0000               1052                     MOVE.W     #$0,D1                ; marks that it is valid
00001B74  6000 0006               1053                     BRA        CHECKEAEXIT           ; exits the subroutine
00001B78                          1054  
00001B78  323C 0002               1055  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001B7C                          1056  
00001B7C  241F                    1057  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001B7E  4E75                    1058                     RTS                              ; returns from subroutine
00001B80                          1059  
00001B80                          1060  * Converts EA and Xn into a string                                
00001B80                          1061  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001B80                          1062  * Outputs: Prints out EA and Xn into a string
00001B80  48E7 C004               1063  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001B84  B47C 0001               1064                     CMP.W    #An,D2                  ; checks if it is An
00001B88  6700 003A               1065                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001B8C                          1066                     
00001B8C  B47C 0002               1067                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001B90  6700 004A               1068                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001B94                          1069                     
00001B94  B47C 0003               1070                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001B98  6700 0072               1071                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001B9C                          1072                     
00001B9C  B47C 0004               1073                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001BA0  6700 00A6               1074                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001BA4                          1075                     
00001BA4  B47C 0007               1076                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001BA8  6700 00DA               1077                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001BAC                          1078                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001BAC                          1079  
00001BAC                          1080  * data register, Dn
00001BAC  4BF9 00002152           1081  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001BB2  4EB9 00001E46           1082                     JSR      PRINTNULL               ; Prints D
00001BB8  3203                    1083                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001BBA  4EB9 00001CFC           1084                     JSR      PRINTNUM                ; Prints the Xn
00001BC0  6000 0134               1085                     BRA      EA_TO_STRING_EXIT       ; exits           
00001BC4                          1086  
00001BC4                          1087  
00001BC4                          1088  * address register
00001BC4  4BF9 00002154           1089  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001BCA  4EB9 00001E46           1090                     JSR      PRINTNULL               ; Prints A
00001BD0  3203                    1091                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001BD2  4EB9 00001CFC           1092                     JSR      PRINTNUM                ; Prints the Xn
00001BD8  6000 011C               1093                     BRA      EA_TO_STRING_EXIT       ; exits
00001BDC                          1094  
00001BDC                          1095  * address register indirect
00001BDC  4BF9 00002156           1096  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001BE2  4EB9 00001E46           1097                     JSR      PRINTNULL               ; Prints (
00001BE8  4BF9 00002154           1098                     LEA      MSG_AR,A5               ; Loads A into A5
00001BEE  4EB9 00001E46           1099                     JSR      PRINTNULL               ; Prints A
00001BF4  3203                    1100                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001BF6  4EB9 00001CFC           1101                     JSR      PRINTNUM                ; Prints the Xn
00001BFC  4BF9 00002158           1102                     LEA      MSG_RB,A5               ; Loads ) into A5
00001C02  4EB9 00001E46           1103                     JSR      PRINTNULL               ; Prints )
00001C08  6000 00EC               1104                     BRA      EA_TO_STRING_EXIT       ; exits
00001C0C                          1105  
00001C0C                          1106  * address register indirect post increment
00001C0C  4BF9 00002156           1107  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001C12  4EB9 00001E46           1108                     JSR      PRINTNULL               ; Prints (
00001C18  4BF9 00002154           1109                     LEA      MSG_AR,A5               ; Loads A into A5
00001C1E  4EB9 00001E46           1110                     JSR      PRINTNULL               ; Prints A
00001C24  3203                    1111                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C26  4EB9 00001CFC           1112                     JSR      PRINTNUM                ; Prints the Xn
00001C2C  4BF9 00002158           1113                     LEA      MSG_RB,A5               ; Loads ) into A5
00001C32  4EB9 00001E46           1114                     JSR      PRINTNULL               ; Prints )
00001C38  4BF9 0000215A           1115                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001C3E  4EB9 00001E46           1116                     JSR      PRINTNULL               ; Prints +
00001C44  6000 00B0               1117                     BRA      EA_TO_STRING_EXIT       ; exits
00001C48                          1118  
00001C48                          1119  
00001C48                          1120  * address register indirect pre increment
00001C48  4BF9 0000215C           1121  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001C4E  4EB9 00001E46           1122                     JSR      PRINTNULL               ; Prints -
00001C54  4BF9 00002156           1123                     LEA      MSG_LB,A5               ; Loads ( into A5
00001C5A  4EB9 00001E46           1124                     JSR      PRINTNULL               ; Prints (
00001C60  4BF9 00002154           1125                     LEA      MSG_AR,A5               ; Loads A into A5
00001C66  4EB9 00001E46           1126                     JSR      PRINTNULL               ; Prints A
00001C6C  3203                    1127                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C6E  4EB9 00001CFC           1128                     JSR      PRINTNUM                ; Prints the Xn
00001C74  4BF9 00002158           1129                     LEA      MSG_RB,A5               ; Loads ) into A5
00001C7A  4EB9 00001E46           1130                     JSR      PRINTNULL               ; Prints )
00001C80  6000 0074               1131                     BRA      EA_TO_STRING_EXIT       ; exits
00001C84                          1132  
00001C84                          1133  * other (long, short, immediate) with Xn yes
00001C84  301A                    1134  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001C86  B67C 0000               1135                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001C8A  6700 002E               1136                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001C8E                          1137                     
00001C8E  B67C 0001               1138                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001C92  6700 0042               1139                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001C96                          1140  
00001C96                          1141  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001C96                          1142  * immediate
00001C96  4BF9 0000215E           1143  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001C9C  4EB9 00001E46           1144                     JSR      PRINTNULL               ; Prints #  
00001CA2  4BF9 00002160           1145                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001CA8  4EB9 00001E46           1146                     JSR      PRINTNULL               ; Prints $
00001CAE  3200                    1147                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001CB0  4EB9 00001D0C           1148                     JSR      PRINTHEXNUM 
00001CB6  6000 003E               1149                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001CBA                          1150                     
00001CBA                          1151  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001CBA                          1152  
00001CBA                          1153  * word address
00001CBA                          1154  CASE_WORD          
00001CBA  4BF9 00002160           1155                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001CC0  4EB9 00001E46           1156                     JSR      PRINTNULL               ; Prints $
00001CC6  3200                    1157                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001CC8  383C 0000               1158                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001CCC  4EB9 00001D20           1159                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001CD2  6000 0022               1160                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001CD6                          1161  
00001CD6                          1162  * long address 
00001CD6                          1163  CASE_LONG          
00001CD6  4BF9 00002160           1164                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001CDC  4EB9 00001E46           1165                     JSR      PRINTNULL               ; Prints $
00001CE2  3200                    1166                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001CE4  383C 0001               1167                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001CE8  4EB9 00001D20           1168                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001CEE  321A                    1169                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001CF0  4EB9 00001CFC           1170                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001CF6                          1171  
00001CF6                          1172  
00001CF6                          1173  * exits subroutine
00001CF6  4CDF 2003               1174  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001CFA  4E75                    1175                      RTS                              ; returns from subroutine
00001CFC                          1176  
00001CFC                          1177  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001CFC                          1178  
00001CFC                          1179  * Prints out the content of D1 as a decimal number
00001CFC                          1180  * Input: number in D1 to be printed
00001CFC                          1181  * Output: contents of D1 printed
00001CFC  48E7 C000               1182  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001D00  103C 0003               1183                   MOVE.B      #3,D0               ; prints D1
00001D04  4E4F                    1184                   TRAP        #15                 ; is trap task 3
00001D06                          1185              
00001D06  4CDF 0003               1186                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001D0A  4E75                    1187                   RTS                             ; returns from subroutine
00001D0C                          1188                   
00001D0C                          1189  * Prints out the content of D1 as a hex number
00001D0C                          1190  * Input: number in D1 to be printed
00001D0C                          1191  * Output: contents of D1 printed
00001D0C  48E7 C000               1192  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001D10  143C 0010               1193                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001D14  103C 000F               1194                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001D18  4E4F                    1195                   TRAP        #15                 ; is trap task 15
00001D1A  4CDF 0003               1196                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001D1E  4E75                    1197                   RTS                             ; returns from subroutine
00001D20                          1198                   
00001D20                          1199  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001D20                          1200  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001D20                          1201  * Output: contents of D1 printed
00001D20  48E7 E000               1202  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001D24  B83C 0001               1203                            CMP.B       #1,D4               ; checks size of number
00001D28  6700 0042               1204                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001D2C                          1205  
00001D2C  3401                    1206  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001D2E  C47C F000               1207                            AND.W       #$F000,D2           ; gets the first digit
00001D32  B47C 0000               1208                            CMP.W       #0, D2              ; checks if it is 0
00001D36  6600 00DC               1209                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D3A  4EB9 00001E24           1210                            JSR         PRINTZERO           ; prints a zero
00001D40                          1211                            
00001D40  3401                    1212                            MOVE.W      D1,D2               ; copies number to D2
00001D42  C47C 0F00               1213                            AND.W       #$0F00,D2           ; gets the second digit
00001D46  B47C 0000               1214                            CMP.W       #0, D2              ; checks if it is 0
00001D4A  6600 00C8               1215                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D4E  4EB9 00001E24           1216                            JSR         PRINTZERO           ; prints a zero
00001D54                          1217                            
00001D54  3401                    1218                            MOVE.W      D1,D2               ; copies number to D2
00001D56  C47C 00F0               1219                            AND.W       #$00F0,D2           ; gets the third digit
00001D5A  B47C 0000               1220                            CMP.W       #0, D2              ; checks if it is 0
00001D5E  6600 00B4               1221                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D62  4EB9 00001E24           1222                            JSR         PRINTZERO           ; prints a zero
00001D68  6000 00AA               1223                            BRA         PRINTASHEX          ; prints last digit
00001D6C                          1224                            
00001D6C  2401                    1225  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001D6E  C4BC F0000000           1226                            AND.L       #$F0000000,D2       ; gets the first digit
00001D74  B4BC 00000000           1227                            CMP.L       #0, D2              ; checks if it is 0
00001D7A  6600 0098               1228                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D7E  4EB9 00001E24           1229                            JSR         PRINTZERO           ; prints a zero
00001D84                          1230                            
00001D84  2401                    1231                            MOVE.L      D1,D2               ; copies number to D2
00001D86  C4BC 0F000000           1232                            AND.L       #$0F000000,D2       ; gets the second digit
00001D8C  B4BC 00000000           1233                            CMP.L       #0, D2              ; checks if it is 0
00001D92  6600 0080               1234                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D96  4EB9 00001E24           1235                            JSR         PRINTZERO           ; prints a zero
00001D9C                          1236                            
00001D9C  2401                    1237                            MOVE.L      D1,D2               ; copies number to D2
00001D9E  C4BC 00F00000           1238                            AND.L       #$00F00000,D2       ; gets the third digit
00001DA4  B4BC 00000000           1239                            CMP.L       #0, D2              ; checks if it is 0
00001DAA  6600 0068               1240                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DAE  4EB9 00001E24           1241                            JSR         PRINTZERO           ; prints a zero
00001DB4                          1242                            
00001DB4  2401                    1243                            MOVE.L      D1,D2               ; copies number to D2
00001DB6  C4BC 000F0000           1244                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001DBC  B4BC 00000000           1245                            CMP.L       #0, D2              ; checks if it is 0
00001DC2  6600 0050               1246                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DC6  4EB9 00001E24           1247                            JSR         PRINTZERO           ; prints a zero
00001DCC                          1248                            
00001DCC  2401                    1249                            MOVE.L      D1,D2               ; copies number to D2
00001DCE  C4BC 0000F000           1250                            AND.L       #$0000F000,D2       ; gets the fith digit
00001DD4  B4BC 00000000           1251                            CMP.L       #0, D2              ; checks if it is 0
00001DDA  6600 0038               1252                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DDE  4EB9 00001E24           1253                            JSR         PRINTZERO           ; prints a zero
00001DE4                          1254                            
00001DE4  2401                    1255                            MOVE.L      D1,D2               ; copies number to D2
00001DE6  C4BC 00000F00           1256                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001DEC  B4BC 00000000           1257                            CMP.L       #0, D2              ; checks if it is 0
00001DF2  6600 0020               1258                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DF6  4EB9 00001E24           1259                            JSR         PRINTZERO           ; prints a zero
00001DFC                          1260                            
00001DFC  2401                    1261                            MOVE.L      D1,D2               ; copies number to D2
00001DFE  C4BC 000000F0           1262                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001E04  B4BC 00000000           1263                            CMP.L       #0, D2              ; checks if it is 0
00001E0A  6600 0008               1264                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E0E  4EB9 00001E24           1265                            JSR         PRINTZERO           ; prints a zero
00001E14                          1266  
00001E14  143C 0010               1267  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001E18  103C 000F               1268                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001E1C  4E4F                    1269                            TRAP        #15                 ; is trap task 15
00001E1E  4CDF 0007               1270                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001E22  4E75                    1271                            RTS                             ; returns from subroutine    
00001E24                          1272  * Prints a zero
00001E24                          1273  * Input: nothing
00001E24                          1274  * Output: 0 printed out to the console
00001E24  2F01                    1275  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001E26  7200                    1276                            MOVE.L      #0,D1               ; moves 0 to D1
00001E28  4EB8 1CFC               1277                            JSR         PRINTNUM            ; prints the number
00001E2C  221F                    1278                            MOVE.L      (SP)+,D1            ; restores D1
00001E2E  4E75                    1279                            RTS                             ; returns from subroutine
00001E30                          1280              
00001E30                          1281  * Prints contents of things between a range
00001E30                          1282  * input: A5, A6 (the range)
00001E30                          1283  * output: prints memory contents from A5 to A6 as strings   
00001E30  48E7 C040               1284  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001E34  224D                    1285                  MOVEA.L     A5, A1           ; loads A5 into A1
00001E36  9DCD                    1286                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001E38  320E                    1287                  MOVE.W      A6, D1           ; move n into D1
00001E3A  103C 0001               1288                  MOVE.B      #1, D0           ; display n characters of string at A1
00001E3E  4E4F                    1289                  TRAP        #15              ; is trap task 1
00001E40  4CDF 0203               1290                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001E44  4E75                    1291                  RTS                          ; returns
00001E46                          1292      
00001E46                          1293  * Prints null terminated string
00001E46                          1294  * input: string pointed to by A5
00001E46                          1295  * output: prints out the null terminated string
00001E46  48E7 8040               1296  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001E4A  224D                    1297                  MOVE.L      A5,A1           ; loads A5 into A1
00001E4C  103C 000E               1298                  MOVE.B      #14,D0          ; prints null terminated string
00001E50  4E4F                    1299                  TRAP        #15             ; is trap task 10
00001E52  4CDF 0201               1300                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001E56  4E75                    1301                  RTS                         ; returns from subroutine
00001E58                          1302                  
00001E58  2F0D                    1303  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001E5A  4BF9 0000205E           1304                  LEA         NEW_LINE,A5     ; Prints null
00001E60  4EB8 1E46               1305                  JSR         PRINTNULL       ; prints the new line
00001E64  2A5F                    1306                  MOVE.L      (SP)+,A5        ; returns A5
00001E66  4E75                    1307                  RTS
00001E68                          1308  
00001E68                          1309  * Prints the size of the MOVE or MOVEA operation  
00001E68                          1310  * input: D0
00001E68                          1311  * output: prints out the size of a MOVE or MOVEA operation        
00001E68  48E7 8004               1312  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001E6C  3200                    1313                  MOVE.W  D0,D1               ; stores d0 in d1
00001E6E  C07C 3000               1314                  AND.W   #$3000,D0           ; gets the size
00001E72  B07C 2000               1315                  CMP.W   #$2000,D0           ; checks if is long
00001E76  6700 001E               1316                  BEQ     MOVE_LONG
00001E7A  B07C 3000               1317                  CMP.W   #$3000,D0           ; checks if is word
00001E7E  6700 000C               1318                  BEQ     MOVE_WORD      
00001E82                          1319                  
00001E82  4BF9 00002169           1320  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001E88  6000 0012               1321                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001E8C                          1322  
00001E8C  4BF9 0000216F           1323  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001E92  6000 0008               1324                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001E96                          1325  
00001E96  4BF9 00002175           1326  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001E9C                          1327                  
00001E9C  4EB8 1E46               1328  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001EA0  4CDF 2001               1329                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001EA4  4E75                    1330                  RTS
00001EA6                          1331  
00001EA6  43F9 00002030           1332  ERROR           LEA     ERROR_MSG,A1
00001EAC  103C 000E               1333                  MOVE.B  #14,D0
00001EB0  4E4F                    1334                  TRAP    #15 
00001EB2                          1335         
00001EB2                          1336  * DELETE THIS: Test                
00001EB2  2661                    1337  DELETEME        MOVEA.L  -(A1),A3
00001EB4  6700 0034               1338                  BEQ      DELETEMEAGAIN  
00001EB8  6F00 0030               1339                  BLE      DELETEMEAGAIN
00001EBC  6E00 002C               1340                  BGT      DELETEMEAGAIN
00001EC0                          1341  
00001EC0  E40A                    1342                  LSR.B      #2,D2
00001EC2  E2E2                    1343                  LSR.W      -(A2)
00001EC4  E2DA                    1344                  LSR.W      (A2)+
00001EC6  E4AA                    1345                  LSR.L      D2,D2 
00001EC8  E50A                    1346                  LSL.B      #2,D2
00001ECA  E3E2                    1347                  LSL.W      -(A2)
00001ECC  E3DA                    1348                  LSL.W      (A2)+
00001ECE  E5AA                    1349                  LSL.L      D2,D2
00001ED0  E51A                    1350                  ROL.B      #2,D2
00001ED2  E7E2                    1351                  ROL.W      -(A2)
00001ED4  E7DA                    1352                  ROL.W      (A2)+
00001ED6  E5BA                    1353                  ROL.L      D2,D2
00001ED8  E41A                    1354                  ROR.B      #2,D2
00001EDA  E6E2                    1355                  ROR.W      -(A2)
00001EDC  E6DA                    1356                  ROR.W      (A2)+
00001EDE  E4BA                    1357                  ROR.L      D2,D2
00001EE0                          1358                  
00001EE0  504D                    1359                  ADDQ.W      #8,A5
00001EE2  D6C2                    1360                  ADDA.W      D2,A3
00001EE4  9BCB                    1361                  SUB.L       A3,A5        
00001EE6  8A43                    1362                  OR.W        D3,D5
00001EE8  4642                    1363                  NOT.W       D2
00001EEA                          1364                  
00001EEA                          1365  DELETEMEAGAIN                 
00001EEA                          1366            
00001EEA  FFFF FFFF               1367      SIMHALT             ; halt simulator
00001EEE                          1368  
00001EEE                          1369  * Put variables and constants here
00001EEE                          1370  
00001EEE  =0000000D               1371  CR                              EQU     $0D
00001EEE  =0000000A               1372  LF                              EQU     $0A 
00001EEE  =00000009               1373  TAB                             EQU     $09  
00001EEE                          1374  
00001EEE                          1375  * Addressing Modes
00001EEE  =00000000               1376  Dn                              EQU     0
00001EEE  =00000001               1377  An                              EQU     1
00001EEE  =00000002               1378  AnIndirect                      EQU     2
00001EEE  =00000003               1379  AnPost                          EQU     3
00001EEE  =00000004               1380  AnPre                           EQU     4
00001EEE  =00000007               1381  Other                           EQU     7           ; short, long, immediate
00001EEE                          1382  
00001EEE                          1383  * Xn
00001EEE  =00000000               1384  ABSShort                        EQU     0
00001EEE  =00000001               1385  ABSLong                         EQU     1
00001EEE  =00000004               1386  XnImmediate                     EQU     4
00001EEE                          1387  
00001EEE                          1388  * Valid Addressing Modes
00001EEE= 00 01 02 03 04 07 FF    1389  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001EF5                          1390  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001EF5= 00 02 03 04 07 FF       1391  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001EFB= 02 04 07 FF             1392  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001EFF= 02 03 07 FF             1393  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001F03= 02 03 04 07 FF          1394  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001F08= 00 02 03 04 07 FF       1395  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001F0E= 01 07 FF                1396  VALIDEA_LEA                     DC.B    An,Other,-1
00001F11= 00 02 03 04 07 FF       1397  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001F17= 02 03 04 07 FF          1398  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001F1C= 02 03 04 07 FF          1399  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001F21= 02 07 FF                1400  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001F24                          1401  
00001F24                          1402  * Valid Xn
00001F24= 00 01 04 FF             1403  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001F28                          1404  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001F28= 00 01 FF                1405  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001F2B                          1406  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001F2B                          1407  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001F2B                          1408  
00001F2B                          1409  * posible memory ASd/LSd rotation values
00001F2B  =00000000               1410  ASd_MEM                         EQU     0   
00001F2B  =00000001               1411  LSd_MEM                         EQU     1 
00001F2B  =00000003               1412  ROd_MEM                         EQU     3
00001F2B                          1413   
00001F2B  =00000000               1414  ASd_REG                         EQU     0   
00001F2B  =00000001               1415  LSd_REG                         EQU     1 
00001F2B  =00000003               1416  ROd_REG                         EQU     3
00001F2B                          1417  
00001F2B                          1418  * Starting messages
00001F2B= 57 65 6C 63 6F 6D ...   1419  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001F52= 46 6F 72 6D 61 74 ...   1420                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001FA1= 50 6C 65 61 73 65 ...   1421  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001FD8= 50 6C 65 61 73 65 ...   1422  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
0000200E= 49 6E 76 61 6C 69 ...   1423  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002030= 45 72 72 6F 72 20 ...   1424  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
0000204C= 31 30 30 30 09 44 ...   1425  INVALID_INSTR                   DC.B    '1000',TAB,'DATA',TAB,'$WXYZ',CR,LF,0
0000205E= 0D 0A 00                1426  NEW_LINE                        DC.B    CR,LF,0
00002061= 09 09 09 00             1427  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00002065                          1428  
00002065                          1429  * Opcode Messages
00002065= 09 4E 4F 50 00          1430  MSG_NOP                         DC.B    TAB,'NOP',0
0000206A= 09 4D 4F 56 45 00       1431  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00002070= 09 4D 4F 56 45 41 00    1432  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00002077= 09 4D 4F 56 45 51 00    1433  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
0000207E= 09 4D 4F 56 45 4D 00    1434  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00002085= 09 41 44 44 00          1435  MSG_ADD                         DC.B    TAB,'ADD',0
0000208A= 09 41 44 44 41 00       1436  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002090= 09 41 44 44 51 00       1437  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00002096= 09 53 55 42 00          1438  MSG_SUB                         DC.B    TAB,'SUB',0
0000209B= 09 4D 55 4C 53 00       1439  MSG_MULS                        DC.B    TAB,'MULS',0
000020A1= 09 44 49 56 55 00       1440  MSG_DIVU                        DC.B    TAB,'DIVU',0
000020A7= 09 4C 45 41 09 09 ...   1441  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
000020AF= 09 41 4E 44 00          1442  MSG_AND                         DC.B    TAB,'AND',0
000020B4= 09 4F 52 00             1443  MSG_OR                          DC.B    TAB,'OR',0
000020B8= 09 4E 4F 54 00          1444  MSG_NOT                         DC.B    TAB,'NOT',0
000020BD= 09 4C 53 00             1445  MSG_LSd                         DC.B    TAB,'LS',0
000020C1= 09 41 53 00             1446  MSG_ASd                         DC.B    TAB,'AS',0
000020C5= 09 52 4F 00             1447  MSG_ROd                         DC.B    TAB,'RO',0
000020C9= 09 42 43 43 09 09 ...   1448  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
000020D1= 09 42 43 53 09 09 ...   1449  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
000020D9= 09 42 45 51 09 09 ...   1450  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
000020E1= 09 42 4E 45 09 09 ...   1451  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
000020E9= 09 42 47 45 09 09 ...   1452  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
000020F1= 09 42 47 54 09 09 ...   1453  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
000020F9= 09 42 48 49 09 09 ...   1454  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00002101= 09 42 4C 45 09 09 ...   1455  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00002109= 09 42 4C 53 09 09 ...   1456  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00002111= 09 42 4C 54 09 09 ...   1457  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00002119= 09 42 4D 49 09 09 ...   1458  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00002121= 09 42 50 4C 09 09 ...   1459  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00002129= 09 42 56 43 09 09 ...   1460  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00002131= 09 42 56 53 09 09 ...   1461  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00002139= 09 4A 53 52 09 09 ...   1462  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00002141= 09 52 54 53 00          1463  MSG_RTS                         DC.B    TAB,'RTS',0
00002146= 09 42 52 41 09 09 ...   1464  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
0000214E                          1465  
0000214E                          1466  * Direction for LSd and ASd
0000214E= 52 00                   1467  MSG_RIGHT                       DC.B    'R',0
00002150= 4C 00                   1468  MSG_LEFT                        DC.B    'L',0
00002152                          1469  
00002152                          1470  * Effective Addresses Messages
00002152= 44 00                   1471  MSG_DR                          DC.B    'D',0
00002154= 41 00                   1472  MSG_AR                          DC.B    'A',0
00002156= 28 00                   1473  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002158= 29 00                   1474  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
0000215A= 2B 00                   1475  MSG_PLUS                        DC.B    '+',0
0000215C= 2D 00                   1476  MSG_MINUS                       DC.B    '-',0
0000215E= 23 00                   1477  MSG_POUND                       DC.B    '#',0 
00002160= 24 00                   1478  MSG_HEX                         DC.B    '$',0 
00002162= 2C 20 00                1479  MSG_COMMA                       DC.B    ', ',0 
00002165= 20 00                   1480  MSG_SPACE                       DC.B    ' ',0
00002167= 09 00                   1481  MSG_TAB                         DC.B    TAB,0
00002169                          1482  
00002169                          1483  * Size Messages
00002169= 2E 42 09 09 09 00       1484  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
0000216F= 2E 57 09 09 09 00       1485  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00002175= 2E 4C 09 09 09 00       1486  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
0000217B                          1487  
0000217B                          1488  * Variables
0000217B  =00000100               1489  STARTING_ADDRESS                EQU     $100
0000217B  =00000150               1490  ENDING_ADDRESS                  EQU     $150
0000217B  =00000200               1491  CURRENT_INSTR                   EQU     $200
0000217B  =00000250               1492  REG_VAR                         EQU     $250 * Hold bits 11-9
0000217B  =00000300               1493  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
0000217B  =00000350               1494  EA_MODE                         EQU     $350 * Hold bits 5-3
0000217B  =00000400               1495  EA_REG                          EQU     $400 * Hold bits 2-0
0000217B                          1496  
0000217B                          1497              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           144C
ADDQ_BYTE           14E6
ADDQ_LONG           1506
ADDQ_WORD           14F6
ADD_SUB_BYTE        1388
ADD_SUB_HELP        130C
ADD_SUB_LONG        13A4
ADD_SUB_OPERAND     13BA
ADD_SUB_SIZE        1364
ADD_SUB_WORD        1396
AN                  1
AND_BYTE            16C0
AND_LONG            16E0
AND_WORD            16D0
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           200E
CASE_ADD            12DE
CASE_ADDA           1420
CASE_ADDQ           1488
CASE_AND            167A
CASE_AR             1BC4
CASE_ARI            1BDC
CASE_ARIPOST        1C0C
CASE_ARIPRE         1C48
CASE_ASDMEM         17E6
CASE_ASDREG         18AE
CASE_BCC            19E6
CASE_BEQ            1A18
CASE_BGT            1A2C
CASE_BLE            1A22
CASE_BRA            19C2
CASE_DATA           1A5C
CASE_DR             1BAC
CASE_EPICFAIL       1A5E
CASE_IMMEDIATE      1C96
CASE_JSR            1A46
CASE_LEA            15E8
CASE_LEFTMEM        180C
CASE_LEFTREG        18D4
CASE_LONG           1CD6
CASE_LSDASD         17A6
CASE_LSDMEM         17DC
CASE_LSDREG         18A4
CASE_MOVE           1182
CASE_MOVEM          1224
CASE_MOVEQ          128A
CASE_NOP            116C
CASE_NOT            1754
CASE_OR             1704
CASE_OTHER          1C84
CASE_RIGHTMEM       1816
CASE_RIGHTREG       18DE
CASE_RODMEM         17F0
CASE_RODREG         18B8
CASE_RTS            1A46
CASE_SHIFTMEM       17C4
CASE_SHIFTREG       188A
CASE_SUB            155C
CASE_SUBA           15D2
CASE_WORD           1CBA
CHECKEAEXIT         1B7C
CHECKEAMLOOP        1B4E
CHECKEAXN_IFVALID   1B4C
CHECKGET_EAXN       1AB4
CHECKMEMSOURE       184A
CHECKSHIFT_XN       1874
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            1AE4
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1EB2
DELETEMEAGAIN       1EEA
DESTEA              1A6A
DESTXN              1A94
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          13F4
EASHIFT_VALID       1868
EAXN_INVALID        1AF6
EAXN_VALID          1ADC
EA_MODE             350
EA_REG              400
EA_TO_STRING        1B80
EA_TO_STRING_EXIT   1CF6
ENDING              1FD8
ENDING_ADDRESS      150
END_CHECKGET        1AFA
ERROR               1EA6
ERROR_MSG           2030
FINDTYPEEA          1A7E
FINDTYPEXN          1AA8
FINISHMOVE          1E9C
FINISH_ADD          13B2
FINISH_ADDA         145C
FINISH_ADDQ         1516
FINISH_AND          16F0
FINISH_SUB          1598
FINISH_SUBA         159E
GETDIRECTION        1B34
GETDISPLACEMENT     1AFC
GETMEMSOURCE        1832
GETROTATION         1B2A
GETROTATIONLOCATION  1B44
GETROTATIONSIZE     1B3C
GET_EA              1A60
GET_XN              1A8A
INPUT1              100C
INPUT2              1052
INSERTA             11F0
INVALID             112C
INVALIDEA           1B60
INVALID_INSTR       204C
INV_INSTR           16F6
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128A
MOVEM_REG2MEM       125A
MOVE_BYTE           1E82
MOVE_LONG           1E96
MOVE_WORD           1E8C
MSG_ADD             2085
MSG_ADDA            208A
MSG_ADDQ            2090
MSG_AND             20AF
MSG_AR              2154
MSG_ASD             20C1
MSG_B               2169
MSG_BCC             20C9
MSG_BCS             20D1
MSG_BEQ             20D9
MSG_BGE             20E9
MSG_BGT             20F1
MSG_BHI             20F9
MSG_BLE             2101
MSG_BLS             2109
MSG_BLT             2111
MSG_BMI             2119
MSG_BNE             20E1
MSG_BPL             2121
MSG_BRA             2146
MSG_BVC             2129
MSG_BVS             2131
MSG_COMMA           2162
MSG_DIVU            20A1
MSG_DR              2152
MSG_HEX             2160
MSG_JSR             2139
MSG_L               2175
MSG_LB              2156
MSG_LEA             20A7
MSG_LEFT            2150
MSG_LSD             20BD
MSG_MINUS           215C
MSG_MOVE            206A
MSG_MOVEA           2070
MSG_MOVEM           207E
MSG_MOVEQ           2077
MSG_MULS            209B
MSG_NOP             2065
MSG_NOT             20B8
MSG_OR              20B4
MSG_PLUS            215A
MSG_POUND           215E
MSG_RB              2158
MSG_RIGHT           214E
MSG_ROD             20C5
MSG_RTS             2141
MSG_SPACE           2165
MSG_SUB             2096
MSG_TAB             2167
MSG_W               216F
NEW_LINE            205E
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OR_SIZE             173C
OTHER               7
OTHEREA             1B78
PRINTADD            1352
PRINTADDRESS        1B0C
PRINTASHEX          1E14
PRINTBCC            1A36
PRINTENTER          1E58
PRINTHEXNUM         1D0C
PRINTLONGZERO       1D6C
PRINTMOVE           11F6
PRINTMOVESIZE       1E68
PRINTNULL           1E46
PRINTNUM            1CFC
PRINTRANGE          1E30
PRINTREGEA          1920
PRINTREGSIZE        18EE
PRINTSHIFTMEM       17F6
PRINTSHIFTREG       18BE
PRINTSHORTLONGNUM   1D20
PRINTSHORTZERO      1D2C
PRINTSUB            1578
PRINTZERO           1E24
PRINT_8             1550
PRINT_ADDQ_DATA     1534
PRINT_MEMDIR        181C
PRINT_MOVEQ         12AC
PRINT_REGDIR        18E8
REG2MEMXNCHECK      1274
REG_BYTE            1906
REG_IMMEDIATE       1936
REG_LONG            191A
REG_REGISTER        197C
REG_VAR             250
REG_WORD            1910
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            1A76
SOURCEXN            1AA0
START               1000
STARTING            1FA1
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           2061
VALIDEA             1B68
VALIDEA_ADDSUB_DESTOPERAND  1F03
VALIDEA_ALL         1EEE
VALIDEA_ANDORNOT    1F11
VALIDEA_ANDOR_DESTOPERAND  1F17
VALIDEA_JSR         1F21
VALIDEA_LEA         1F0E
VALIDEA_MOVEM_MEMTOREG  1EFF
VALIDEA_MOVEM_REGTOMEM  1EFB
VALIDEA_MOVEQ       1EF5
VALIDEA_MULSDIVU    1F08
VALIDEA_SHIFT       1F1C
VALIDXN_ALL         1F24
VALIDXN_SHORTLONG   1F28
WELCOME             1F2B
XNIMMEDIATE         4
