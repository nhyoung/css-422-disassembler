00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/7/2020 10:25:42 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001FE1             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00002057             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 00001132             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 00001144             28                  JSR     CONVERT
0000103E  4EB9 000011B0             29                  JSR     TEST_RANGE
00001044  4EB9 000011C8             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 0000208E             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 00001132             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 00001144             47                  JSR     CONVERT
00001086  4EB9 000011B0             48                  JSR     TEST_RANGE
0000108C  4EB9 000011C8             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0088                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4                            58  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010A4                            59                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A4                            60                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010A4  4EB9 000011DC             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010AA  4EB9 00001F0A             62                  JSR     PRINTENTER          ; prints a new line
000010B0  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010B2  6FF0                      64                  BLE     DISASSEMBLE         ; if not, loop
000010B4                            65  
000010B4  4BF9 0000210E             66  FINISHED        LEA     DONE,A5
000010BA  4EB9 00001EF8             67                  JSR     PRINTNULL
000010C0  103C 0005                 68                  MOVE.B  #5,D0
000010C4  4E4F                      69                  TRAP    #15
000010C6                            70                  
000010C6  B23C 000D                 71                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010CA  6700 0008                 72                  BEQ     RESTART             ; it's Enter, restart
000010CE                            73                  
000010CE  103C 0009                 74                  MOVE.B  #9,D0
000010D2  4E4F                      75                  TRAP    #15
000010D4                            76                  
000010D4  103C 000B                 77  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010D8  323C FF00                 78                  MOVE.W  #$FF00, D1          Clear Screen
000010DC  4E4F                      79                  TRAP    #15                 Call Trap
000010DE                            80                  
000010DE  103C 000C                 81                  MOVE.B  #12,D0              Keyboard echo
000010E2  123C 0001                 82                  MOVE.B  #1,D1               Visible
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  207C 00000000             85                  MOVE.L  #$0000000, A0       ; Reset A1
000010EE  227C 00000000             86                  MOVE.L  #$0000000, A1       ; Reset A1
000010F4  247C 00000000             87                  MOVE.L  #$0000000, A2       ; Reset A2
000010FA  267C 00000000             88                  MOVE.L  #$0000000, A3       ; Reset A3
00001100  287C 00000000             89                  MOVE.L  #$0000000, A4       ; Reset A4
00001106  2A7C 00000000             90                  MOVE.L  #$0000000, A5       ; Reset A5
0000110C  2C7C 00000000             91                  MOVE.L  #$0000000, A6       ; Reset A6
00001112  2E7C 01000000             92                  MOVEA.L #$01000000,A7       ; Reset A7
00001118  4281                      93                  CLR.L   D1                  ; Reset D1
0000111A  4281                      94                  CLR.L   D1                  ; Reset D1
0000111C  4282                      95                  CLR.L   D2                  ; Reset D2
0000111E  4283                      96                  CLR.L   D3                  ; Reset D3
00001120  4284                      97                  CLR.L   D4                  ; Reset D4
00001122  4285                      98                  CLR.L   D5                  ; Reset D5
00001124  4286                      99                  CLR.L   D6                  ; Reset D6
00001126  6000 FED8                100                  BRA     START               ; branch to start of program
0000112A                           101  
0000112A                           102  *--------------------SUBROUTINES------------------    
0000112A                           103  
0000112A  143C 0001                104  RESET_INPUT     MOVE.B  #1,D2
0000112E  6000 0062                105                  BRA     INVALID            
00001132                           106                  
00001132  7800                     107  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001134  B204                     108                  CMP.B   D4,D1               ; D1 stores length
00001136  6700 005A                109                  BEQ     INVALID             ; input is null
0000113A  0C41 0008                110                  CMPI    #$8,D1              ; check if input is longer than a longword
0000113E  6600 0052                111                  BNE     INVALID             ; input is longer than a longword
00001142  4E75                     112                  RTS
00001144                           113                              
00001144  4283                     114  CONVERT         CLR.L   D3
00001146  4284                     115                  CLR.L   D4
00001148  1619                     116                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000114A  B63C 0039                117                  CMP.B   #57,D3
0000114E  6E00 0012                118                  BGT     NOTNUMBER
00001152                           119                  
00001152  B63C 002F                120                  CMP.B   #47,D3
00001156  6E00 0002                121                  BGT     ISNUMBER
0000115A                           122                  
0000115A  0603 00D0                123  ISNUMBER        ADD.B   #-48,D3             ; current char is number
0000115E  6000 001A                124                  BRA     CONCAT
00001162                           125              
00001162  B63C 0041                126  NOTNUMBER       CMP.B   #65,D3
00001166  6D00 002A                127                  BLT     INVALID
0000116A  B63C 0046                128                  CMP.B   #70,D3
0000116E  6E00 0022                129                  BGT     INVALID  
00001172  0603 00C9                130                  ADD.B   #-55,D3             ; is letter             
00001176  6000 0002                131                  BRA     CONCAT
0000117A                           132              
0000117A  BC3C 0000                133  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000117E  6D00 0010                134                  BLT     RETURN
00001182  1806                     135                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001184  E50C                     136                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001186  E9AB                     137                  LSL.L   D4,D3               ; moves current char to correct position  
00001188  DA83                     138                  ADD.L   D3,D5               ; D5 stores converted input so far
0000118A  0606 00FF                139                  ADD.B   #-1,D6  
0000118E  60B4                     140                  BRA     CONVERT             ; continue loop for remaining chars
00001190                           141                  
00001190  4E75                     142  RETURN          RTS
00001192                           143                  
00001192  227C 00000000            144  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001198  43F9 000020C4            145                  LEA     BAD_INPUT,A1        ; output invalid message
0000119E  103C 000E                146                  MOVE.B  #14,D0
000011A2  4E4F                     147                  TRAP    #15
000011A4  B47C 0001                148                  CMP     #1,D2
000011A8  6700 FE62                149                  BEQ     INPUT1
000011AC  6000 FEA4                150                  BRA     INPUT2
000011B0                           151  
000011B0  4284                     152  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011B2  223C 00001000            153                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011B8  BA81                     154                  CMP.L      D1,D5            ; Compare minimum address with input
000011BA  6DD6                     155                  BLT        INVALID          ; input is too low. 
000011BC  223C 00FFFFFE            156                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011C2  BA81                     157                  CMP.L      D1,D5            ; compare maximum address with input
000011C4  6ECC                     158                  BGT        INVALID          ; input too large
000011C6  4E75                     159                  RTS                         ; input is within range
000011C8                           160             
000011C8  0805 0000                161  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011CC  66C4                     162                  BNE        INVALID
000011CE  4E75                     163                  RTS
000011D0                           164  
000011D0  220E                     165  PRINT_ADDR      MOVE.L  A6,D1                   ; loads current address in D1
000011D2  7801                     166                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011D4  4EB9 00001DD2            167                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011DA  4E75                     168                  RTS
000011DC                           169  
000011DC                           170  
000011DC                           171  * Checks every single possible opcode we could have. Jump table
000011DC                           172  * Inputs: (A2) which is a pointer to intruction word to be translated
000011DC                           173  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011DC                           174  
000011DC  3C4A                     175  OPCODE_DECODE   MOVE.W  A2,A6
000011DE  301A                     176                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011E0                           177                  
000011E0                           178  
000011E0                           179  *---------------NOP opcode----------------------                
000011E0  B07C 4E71                180  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011E4  6600 0014                181                  BNE     CASE_MOVE               ; checks the next case if not equal
000011E8                           182                  
000011E8  4EB8 11D0                183                  JSR     PRINT_ADDR
000011EC                           184                  
000011EC  4BF9 00002147            185                  LEA     MSG_NOP,A5              ; loads string pointer into A5
000011F2  4EB9 00001EF8            186                  JSR     PRINTNULL               ; prints NOP                
000011F8  4E75                     187                  RTS                             ; returns from the subroutine
000011FA                           188  
000011FA                           189  *---------------MOVE opcode----------------------              
000011FA                           190                  * if first two bits are 00, next two are not 00
000011FA  3200                     191  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
000011FC  C27C C000                192                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001200  6600 009E                193                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001204  B07C 0FFF                194                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001208  6F00 0096                195                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
0000120C                           196                  
0000120C                           197                  ; Check source
0000120C  4BF9 00001FA4            198                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001212  4DF9 00001FDA            199                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001218  3E3C 0000                200                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000121C  4EB9 00001B66            201                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001222  B27C 0001                202                  CMP.W   #1,D1                    ; checks if invalid
00001226  6700 08E6                203                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000122A  3802                     204                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000122C  3A03                     205                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000122E                           206                  
0000122E                           207                  ; Check destination
0000122E  4BF9 00001FA4            208                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001234  4DF9 00001FDE            209                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000123A  3E3C 0001                210                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000123E  4EB9 00001B66            211                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001244  B27C 0001                212                  CMP.W   #1,D1                    ; checks if invalid
00001248  6700 08C4                213                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000124C  3C02                     214                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
0000124E  3E03                     215                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001250                           216                  
00001250                           217                  ; Checking if it is MOVEA
00001250  3200                     218                  MOVE.W  D0,D1                    ; stores d0 in d1
00001252  C27C 01C0                219                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
00001256  B27C 0040                220                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000125A  6700 0010                221                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
0000125E                           222                  
0000125E  4EB8 11D0                223                  JSR     PRINT_ADDR              ; print address
00001262                           224   
00001262  4BF9 0000214C            225                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001268  6000 0008                226                  BRA     PRINTMOVE                ; Branches to print move
0000126C                           227                  
0000126C  4BF9 00002152            228  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001272                           229   
00001272  4EB9 00001EF8            230  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001278  4EB9 00001F1A            231                  JSR     PRINTMOVESIZE            ; prints out the size  
0000127E  3404                     232                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001280  3605                     233                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001282  4EB9 00001C32            234                  JSR     EA_TO_STRING             ; outputs it into a string
00001288                           235                  
00001288                           236                  ; prints a comma to seperate
00001288  4BF9 00002244            237                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000128E  4EB9 00001EF8            238                  JSR     PRINTNULL                ; prints out MOVE
00001294                           239                  
00001294                           240                  ; print destination
00001294  3406                     241                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001296  3607                     242                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001298  4EB9 00001C32            243                  JSR     EA_TO_STRING             ; outputs it into a string
0000129E  4E75                     244                  RTS                              ; exits subroutine                 
000012A0                           245                
000012A0                           246  *---------------MOVEM opcode----------------------                
000012A0  3200                     247  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012A2  C27C FB80                248                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012A6  B27C 4880                249                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012AA  6600 005A                250                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012AE                           251                  
000012AE                           252                  ; loads EA and XN
000012AE  323C 0000                253                  MOVE.W  #0,D1                           ; copies instruction word to D1
000012B2  4EB9 00001B12            254                  JSR     GET_EA                          ; gets EA and puts in D1
000012B8  3401                     255                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
000012BA  323C 0000                256                  MOVE.W  #0,D1                           ; copies instruction word to D1
000012BE  4EB9 00001B3C            257                  JSR     GET_XN                          ; gets XN and puts in D1
000012C4  3601                     258                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
000012C6                           259                  
000012C6                           260                  ; Check D
000012C6  3200                     261                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012C8  C27C 0400                262                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012CC  3E01                     263                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012CE  B27C 0400                264                  CMP.W   #$0400,D1                       ; checks if value is 1
000012D2  6700 0032                265                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012D6                           266  
000012D6  4BF9 00001FB1            267  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
000012DC  3202                     268                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
000012DE  4EB9 00001BFE            269                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
000012E4  B27C 0001                270                  CMP.W   #1,D1                           ; checks if D1 invalid
000012E8  6700 0824                271                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000012EC  B27C 0002                272                  CMP.W   #2,D1                           ; checks if we need to check Xn
000012F0                           273                  
000012F0  4BF9 00001FB1            274  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
000012F6  3203                     275                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
000012F8  4EB9 00001BFE            276                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
000012FE  B27C 0001                277                  CMP.W   #1,D1                           ; checks if D1 invalid
00001302  6700 080A                278                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001306                           279  
00001306                           280                  
00001306                           281  
00001306                           282  MOVEM_MEM2REG    
00001306                           283                          
00001306                           284  
00001306                           285  *---------------MOVEQ opcode----------------------
00001306  3200                     286  CASE_MOVEQ      MOVE.W  D0,D1
00001308  C27C F100                287                  AND.W   #$F100,D1
0000130C  B27C 7000                288                  CMP.W   #$7000,D1
00001310  6600 004C                289                  BNE     CASE_ADD
00001314                           290                  
00001314                           291                  ;loads Register
00001314  323C 0001                292                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001318  4EB9 00001B3C            293                  JSR     GET_XN                          ; gets XN and puts in D1
0000131E  3401                     294                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
00001320                           295                  
00001320                           296                  ;loads DATA
00001320  3200                     297                  MOVE.W  D0,D1
00001322  C27C 00FF                298                  AND.W   #$00FF,D1                       ;bit mask to get DATA
00001326  3601                     299                  MOVE.W  D1,D3                          ;copy data into D3
00001328                           300                                                        ;must convert bits to hex
00001328                           301                                  
00001328  4EB8 11D0                302  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
0000132C                           303  
0000132C  4BF9 00002159            304                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
00001332  4EB9 00001EF8            305                  JSR     PRINTNULL  
00001338                           306                  
00001338  4BF9 00002257            307                  LEA     MSG_L,A5                        ;PRINT SIZE L
0000133E  4EB9 00001EF8            308                  JSR     PRINTNULL
00001344                           309      
00001344  4BF9 00002143            310                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
0000134A  4EB9 00001EF8            311                  JSR     PRINTNULL
00001350                           312                  
00001350  4BF9 00002240            313                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
00001356  4EB9 00001EF8            314                  JSR     PRINTNULL
0000135C  4E75                     315                  RTS
0000135E                           316                  
0000135E                           317  *---------------ADD opcode----------------------                
0000135E                           318  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
0000135E  3200                     319  CASE_ADD        MOVE.W  D0,D1
00001360  C27C F000                320                  AND.W   #$F000,D1
00001364  B27C D000                321                  CMP.W   #$D000,D1
00001368  6600 01A2                322                  BNE     CASE_ADDQ
0000136C                           323                  
0000136C  4EB8 11D0                324                  JSR     PRINT_ADDR              ; print address
00001370                           325                  
00001370  4EB9 0000138A            326                  JSR     ADD_SUB_HELP
00001376                           327                  
00001376                           328                  ; bits 7-8 determine if it is ADDA or ADD
00001376  3200                     329                  MOVE.W  D0,D1
00001378  E149                     330                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000137A  E049                     331                  LSR.W   #8,D1
0000137C  EC49                     332                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000137E  B27C 0003                333                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001382  6700 0120                334                  BEQ     CASE_ADDA
00001386                           335                  
00001386  6000 0048                336                  BRA     PRINTADD                ; Branches to print add
0000138A                           337                  
0000138A                           338                  ; Check bits 0-5 
0000138A  4BF9 00001FA4            339  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001390  4DF9 00001FDA            340                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001396  3E3C 0000                341                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000139A  4EB9 00001B66            342                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000013A0  B27C 0001                343                  CMP.W       #1,D1                    ; checks if invalid
000013A4  6700 0768                344                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000013A8  3802                     345                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000013AA  3A03                     346                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000013AC                           347                  
000013AC                           348                  ; Check 6-11
000013AC  4BF9 00001FA4            349                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000013B2  4DF9 00001FDE            350                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000013B8  3E3C 0001                351                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
000013BC  4EB9 00001B66            352                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000013C2  B27C 0001                353                  CMP.W       #1,D1                    ; checks if invalid
000013C6  6700 0746                354                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000013CA  3C02                     355                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
000013CC  3E03                     356                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
000013CE                           357    
000013CE  4E75                     358                  RTS                
000013D0                           359                    
000013D0  4BF9 00002167            360  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
000013D6  4EB9 00001EF8            361                  JSR         PRINTNULL               ; print ADD
000013DC  3200                     362                  MOVE.W      D0,D1                   ; bits 7-8 contain size
000013DE  4EB9 000013E8            363                  JSR         ADD_SUB_SIZE
000013E4  6000 0050                364                  BRA         FINISH_ADD
000013E8                           365                    
000013E8  3200                     366  ADD_SUB_SIZE    MOVE.W      D0,D1
000013EA  E149                     367                  LSL.W       #8,D1
000013EC  E049                     368                  LSR.W       #8,D1
000013EE  EC49                     369                  LSR.W       #6,D1                   ; gets bits 6-7
000013F0                           370                    
000013F0  B27C 0000                371                  CMP.W       #0,D1
000013F4  6700 0016                372                  BEQ         ADD_SUB_BYTE
000013F8  B27C 0001                373                  CMP.W       #1,D1                   ; if 1, it is a word
000013FC  6700 001C                374                  BEQ         ADD_SUB_WORD
00001400  B27C 0002                375                  CMP.W       #2,D1                   ; if 2, it is a long
00001404  6700 0022                376                  BEQ         ADD_SUB_LONG
00001408  6000 0254                377                  BRA         CASE_SUBA                    ; error
0000140C                           378                    
0000140C  4BF9 0000224B            379  ADD_SUB_BYTE    LEA         MSG_B,A5
00001412  4EB9 00001EF8            380                  JSR         PRINTNULL
00001418  4E75                     381                  RTS
0000141A                           382                    
0000141A  4BF9 00002251            383  ADD_SUB_WORD    LEA         MSG_W,A5
00001420  4EB9 00001EF8            384                  JSR         PRINTNULL
00001426  4E75                     385                  RTS
00001428                           386    
00001428  4BF9 00002257            387  ADD_SUB_LONG    LEA         MSG_L,A5
0000142E  4EB9 00001EF8            388                  JSR         PRINTNULL
00001434  4E75                     389                  RTS
00001436                           390        
00001436  4EB9 0000143E            391  FINISH_ADD      JSR         ADD_SUB_OPERAND
0000143C  4E75                     392                  RTS
0000143E                           393    
0000143E  EF49                     394  ADD_SUB_OPERAND LSL.W       #7,D1
00001440  EE49                     395                  LSR.W       #7,D1
00001442  E049                     396                  LSR.W       #8,D1
00001444  B27C 0001                397                  CMP.W       #1,D1
00001448  6600 002E                398                  BNE         Dn_PLUS_EA          
0000144C                           399                    
0000144C                           400                  ; print Data Register
0000144C  4BF9 00002234            401                  LEA         MSG_DR,A5
00001452  4EB9 00001EF8            402                  JSR         PRINTNULL
00001458  3207                     403                  MOVE.W      D7,D1
0000145A  4EB9 00001DAE            404                  JSR         PRINTNUM                
00001460                           405                  
00001460                           406                  ; prints a comma to seperate
00001460  4BF9 00002244            407                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001466  4EB9 00001EF8            408                  JSR         PRINTNULL                ; prints out MOVE
0000146C                           409                 
0000146C                           410                  ; below is EA+Dn->Dn  
0000146C  3404                     411                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000146E  3605                     412                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001470  4EB9 00001C32            413                  JSR         EA_TO_STRING             ; outputs it into a string
00001476  4E75                     414                  RTS                                 ; exits subroutine 
00001478                           415  
00001478                           416  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001478  3404                     417                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000147A  3605                     418                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000147C  4EB9 00001C32            419                  JSR         EA_TO_STRING             ; outputs it into a string   
00001482                           420                  
00001482                           421                  ; prints a comma to seperate
00001482  4BF9 00002244            422                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001488  4EB9 00001EF8            423                  JSR         PRINTNULL                ; prints out MOVE
0000148E                           424                  
0000148E                           425                  ; below is Dn+EA->EA
0000148E  4BF9 00002234            426                  LEA         MSG_DR,A5                ; print data register
00001494  4EB9 00001EF8            427                  JSR         PRINTNULL
0000149A  3207                     428                  MOVE.W      D7,D1
0000149C  4EB9 00001DAE            429                  JSR         PRINTNUM             
000014A2  4E75                     430                  RTS                                  ; exits subroutine          
000014A4                           431                        
000014A4                           432  *---------------ADDA opcode----------------------
000014A4                           433  CASE_ADDA       ; gets bit 8 (size bit)
000014A4  3200                     434                  MOVE.W      D0,D1
000014A6  EF49                     435                  LSL.W       #7,D1
000014A8  EE49                     436                  LSR.W       #7,D1
000014AA  E049                     437                  LSR         #8,D1                   
000014AC                           438                  
000014AC  4BF9 0000216C            439                  LEA         MSG_ADDA,A5             ; print ADDA
000014B2  4EB9 00001EF8            440                  JSR         PRINTNULL
000014B8                           441                   
000014B8  B27C 0001                442                  CMP.W       #1,D1
000014BC  6700 0012                443                  BEQ         ADDA_LONG
000014C0                           444                    
000014C0  4BF9 00002251            445                  LEA         MSG_W,A5
000014C6  4EB9 00001EF8            446                  JSR         PRINTNULL
000014CC  6000 0012                447                  BRA         FINISH_ADDA   
000014D0                           448                    
000014D0  4BF9 00002257            449  ADDA_LONG       LEA         MSG_L,A5
000014D6  4EB9 00001EF8            450                  JSR         PRINTNULL
000014DC  6000 0002                451                  BRA         FINISH_ADDA
000014E0                           452                    
000014E0  3404                     453  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000014E2  3605                     454                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000014E4  4EB9 00001C32            455                  JSR         EA_TO_STRING             ; outputs it into a string
000014EA                           456                    
000014EA                           457                  ; prints a comma to seperate
000014EA  4BF9 00002244            458                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000014F0  4EB9 00001EF8            459                  JSR         PRINTNULL                ; prints out MOVE
000014F6                           460            
000014F6  4BF9 00002236            461                  LEA         MSG_AR,A5                ; print address register
000014FC  4EB9 00001EF8            462                  JSR         PRINTNULL
00001502  3207                     463                  MOVE.W      D7,D1
00001504  4EB9 00001DAE            464                  JSR         PRINTNUM             
0000150A  4E75                     465                  RTS                              ; exits subroutine
0000150C                           466                  
0000150C                           467  *---------------ADDQ opcode----------------------                  
0000150C  3200                     468  CASE_ADDQ       MOVE.W      D0,D1
0000150E  C27C F000                469                  AND.W       #$F000,D1       
00001512  B27C 5000                470                  CMP.W       #$5000,D1
00001516  6600 00CC                471                  BNE         CASE_SUB
0000151A                           472                                                   
0000151A  4EB8 11D0                473                  JSR         PRINT_ADDR              ; print address  
0000151E  4BF9 00002172            474                  LEA         MSG_ADDQ,A5             ; print ADDQ
00001524  4EB9 00001EF8            475                  JSR         PRINTNULL
0000152A                           476                  
0000152A                           477                  ; get bits 6-7 (size bits)
0000152A  3200                     478                  MOVE.W      D0,D1
0000152C  E149                     479                  LSL.W       #8,D1
0000152E  E049                     480                  LSR.W       #8,D1
00001530  EC49                     481                  LSR.W       #6,D1
00001532  3401                     482                  MOVE.W      D1,D2
00001534                           483                  
00001534                           484                  ; Check bits 0-5 
00001534  4BF9 00001FA4            485                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000153A  4DF9 00001FDA            486                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001540  3E3C 0000                487                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001544  4EB9 00001B66            488                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000154A  B27C 0001                489                  CMP.W       #1,D1                    ; checks if invalid
0000154E  6700 05BE                490                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001552  3802                     491                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001554  3A03                     492                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001556                           493                  
00001556  B47C 0001                494                  CMP.W       #1,D2
0000155A  6700 001A                495                  BEQ         ADDQ_WORD
0000155E  B47C 0002                496                  CMP.W       #2,D2
00001562  6700 0022                497                  BEQ         ADDQ_LONG
00001566                           498                    
00001566  4BF9 0000224B            499  ADDQ_BYTE       LEA         MSG_B,A5
0000156C  4EB9 00001EF8            500                  JSR         PRINTNULL
00001572  6000 0022                501                  BRA         FINISH_ADDQ  
00001576                           502   
00001576  4BF9 00002251            503  ADDQ_WORD       LEA         MSG_W,A5
0000157C  4EB9 00001EF8            504                  JSR         PRINTNULL
00001582  6000 0012                505                  BRA         FINISH_ADDQ                 
00001586                           506    
00001586  4BF9 00002257            507  ADDQ_LONG       LEA         MSG_L,A5
0000158C  4EB9 00001EF8            508                  JSR         PRINTNULL
00001592  6000 0002                509                  BRA         FINISH_ADDQ                  
00001596                           510                    
00001596  4EB9 000015B4            511  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000159C                           512   
0000159C                           513                  ; prints a comma to seperate
0000159C  4BF9 00002244            514                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015A2  4EB9 00001EF8            515                  JSR         PRINTNULL                ; prints out MOVE
000015A8                           516                    
000015A8                           517                  ; prints destination
000015A8  3404                     518                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015AA  3605                     519                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015AC  4EB9 00001C32            520                  JSR         EA_TO_STRING             ; outputs it into a string
000015B2                           521                 
000015B2  4E75                     522                  RTS
000015B4                           523   
000015B4  4BF9 00002240            524  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
000015BA  4EB9 00001EF8            525                  JSR         PRINTNULL
000015C0                           526                  ; gets bits 9-11 (data bits)
000015C0  E949                     527                  LSL.W       #4,D1
000015C2  E849                     528                  LSR.W       #4,D1                               ; get rid of left 4 bits
000015C4  E049                     529                  LSR.W       #8,D1
000015C6  E249                     530                  LSR.W       #1,D1                               ; get rid of right 9 bits
000015C8                           531                  
000015C8  B27C 0000                532                  CMP.W       #0,D1
000015CC  6700 000A                533                  BEQ         PRINT_8
000015D0  4EB9 00001DAE            534                  JSR         PRINTNUM
000015D6  4E75                     535                  RTS 
000015D8                           536  
000015D8  123C 0008                537  PRINT_8         MOVE.B      #8,D1
000015DC  4EB9 00001DAE            538                  JSR         PRINTNUM
000015E2  4E75                     539                  RTS   
000015E4                           540         
000015E4                           541  *---------------SUB opcode---------------------- 
000015E4  3200                     542  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
000015E6  C27C F000                543                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000015EA  B27C 9000                544                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
000015EE  6600 0084                545                  BNE         CASE_LEA
000015F2                           546                 
000015F2  4EB8 138A                547                  JSR         ADD_SUB_HELP
000015F6  4EB8 11D0                548                  JSR         PRINT_ADDR                          ; print address               
000015FA                           549                  
000015FA  6000 0002                550                  BRA         PRINTSUB                            ; Branches to print move
000015FE                           551  
000015FE  4BF9 00002178            552  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
00001604  4EB9 00001EF8            553                  JSR         PRINTNULL
0000160A  3200                     554                  MOVE.W      D0,D1                               ; bits 6-7 contain size
0000160C  4EB8 13E8                555                  JSR         ADD_SUB_SIZE
00001610  3200                     556                  MOVE.W      D0,D1
00001612  E149                     557                  LSL.W       #8,D1
00001614  E049                     558                  LSR.W       #8,D1
00001616  EC49                     559                  LSR.W       #6,D1
00001618  B27C 0003                560                  CMP.W       #3,D1
0000161C  6600 0006                561                  BNE         FINISH_SUB
00001620  6000 0008                562                  BRA         FINISH_SUBA                         ; same as ADDA
00001624                           563                  
00001624  4EB8 143E                564  FINISH_SUB      JSR     ADD_SUB_OPERAND
00001628  4E75                     565                  RTS
0000162A                           566                    
0000162A  3404                     567  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000162C  3605                     568                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000162E  4EB9 00001C32            569                  JSR         EA_TO_STRING             ; outputs it into a string
00001634                           570                
00001634                           571                  ; prints a comma to seperate
00001634  4BF9 00002244            572                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000163A  4EB9 00001EF8            573                  JSR         PRINTNULL                ; prints out MOVE
00001640                           574          
00001640  4BF9 00002236            575                  LEA         MSG_AR,A5                ; print address register
00001646  4EB9 00001EF8            576                  JSR         PRINTNULL
0000164C  3200                     577                  MOVE.W      D0,D1
0000164E  E949                     578                  LSL.W       #4,D1
00001650  E849                     579                  LSR.W       #4,D1
00001652  E049                     580                  LSR.W       #8,D1
00001654  E249                     581                  LSR.W       #1,D1
00001656  4EB9 00001DAE            582                  JSR         PRINTNUM             
0000165C  4E75                     583                  RTS                              ; exits subroutine
0000165E                           584  
0000165E                           585  
0000165E                           586  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000165E  3200                     587  CASE_SUBA       MOVE.W      D0,D1
00001660  EF49                     588                  LSL.W       #7,D1
00001662  EE49                     589                  LSR.W       #7,D1
00001664  E049                     590                  LSR.W       #8,D1
00001666  B23C 0000                591                  CMP.B       #0,D1
0000166A  6700 FDAE                592                  BEQ         ADD_SUB_WORD
0000166E  6000 FDB8                593                  BRA         ADD_SUB_LONG
00001672  4E75                     594                  RTS         
00001674                           595                   
00001674  3200                     596  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001676  C27C F000                597                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000167A  B27C 4000                598                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000167E  6600 0086                599                  BNE.W   CASE_AND                             ; If its not, check AND
00001682  3200                     600                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001684  C27C 01C0                601                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001688  B27C 01C0                602                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000168C  6600 0078                603                  BNE.W   CASE_AND                             ; If its not, check AND
00001690                           604                  
00001690                           605                  ; Check source
00001690  4BF9 00001FC4            606                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001696  4DF9 00001FDE            607                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000169C  3E3C 0000                608                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
000016A0  4EB9 00001B66            609                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000016A6  3802                     610                  MOVE.W  D2,D4                                ; Saves D2 in D4
000016A8  3A03                     611                  MOVE.W  D3,D5                                ; Saves D2 in D4
000016AA                           612                  
000016AA                           613                  ; Check destination
000016AA  4BF9 00001FC4            614                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000016B0  4DF9 00001FDE            615                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000016B6  3E3C 0001                616                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000016BA  4EB9 00001B66            617                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000016C0  3C02                     618                  MOVE.W  D2,D6                                ; Saves D2 in D4
000016C2  3E03                     619                  MOVE.W  D3,D7                                ; Saves D2 in D4
000016C4                           620  
000016C4  4BF9 00002189            621                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000016CA  4EB9 00001EF8            622                  JSR     PRINTNULL                            ; prints LEA
000016D0                           623                  
000016D0                           624                  ; print source
000016D0  3404                     625                  MOVE.W  D4,D2
000016D2  3605                     626                  MOVE.W  D5,D3
000016D4  4EB9 00001C32            627                  JSR     EA_TO_STRING                         ; Prints out the EA
000016DA                           628                  
000016DA                           629                  ; comma
000016DA  4BF9 00002244            630                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000016E0  4EB9 00001EF8            631                  JSR     PRINTNULL                       
000016E6                           632                   
000016E6                           633                  ; register
000016E6  4BF9 00002236            634                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000016EC  4EB9 00001EF8            635                  JSR     PRINTNULL 
000016F2  3401                     636                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000016F4  323C 0001                637                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000016F8  4EB9 00001B3C            638                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000016FE  4EB9 00001DAE            639                  JSR     PRINTNUM                             ; Prints the number in D1
00001704  4E75                     640                  RTS
00001706                           641  
00001706                           642  *---------------AND opcode----------------------
00001706  3200                     643  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001708  C27C F000                644                  AND.W       #$F000,D1       
0000170C  B27C C000                645                  CMP.W       #$C000,D1
00001710  6600 0092                646                  BNE         CASE_OR
00001714                           647                  
00001714  3200                     648                  MOVE.W      D0,D1
00001716  E149                     649                  LSL.W       #8,D1
00001718  E049                     650                  LSR.W       #8,D1
0000171A  EC49                     651                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000171C  3C01                     652                  MOVE.W      D1,D6
0000171E  BC7C 0003                653                  CMP.W       #3,D6
00001722  6700 0066                654                  BEQ         INV_INSTR
00001726                           655                  
00001726  4EB8 11D0                656                  JSR         PRINT_ADDR                      ; print address
0000172A  4BF9 00002191            657                  LEA         MSG_AND,A5                      ; print AND
00001730  4EB9 00001EF8            658                  JSR         PRINTNULL
00001736                           659                  
00001736  3206                     660                  MOVE.W      D6,D1
00001738  B27C 0000                661                  CMP.W       #0,D1
0000173C  6700 0012                662                  BEQ         AND_BYTE
00001740  B27C 0001                663                  CMP.W       #1,D1                   ; if 1, it is a word
00001744  6700 001A                664                  BEQ         AND_WORD
00001748  B27C 0002                665                  CMP.W       #2,D1                   ; if 2, it is a long
0000174C  6700 0022                666                  BEQ         AND_LONG
00001750                           667                  
00001750  4BF9 0000224B            668  AND_BYTE        LEA         MSG_B,A5
00001756  4EB9 00001EF8            669                  JSR         PRINTNULL
0000175C  6000 0022                670                  BRA         FINISH_AND
00001760                           671                                    
00001760  4BF9 00002251            672  AND_WORD        LEA         MSG_W,A5
00001766  4EB9 00001EF8            673                  JSR         PRINTNULL
0000176C  6000 0012                674                  BRA         FINISH_AND
00001770                           675    
00001770  4BF9 00002257            676  AND_LONG        LEA         MSG_L,A5
00001776  4EB9 00001EF8            677                  JSR         PRINTNULL
0000177C  6000 0002                678                  BRA         FINISH_AND
00001780                           679        
00001780  4EB8 138A                680  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001784  4EB8 143E                681                  JSR         ADD_SUB_OPERAND
00001788  4E75                     682                  RTS
0000178A                           683                  
0000178A  4BF9 00002102            684  INV_INSTR       LEA         INVALID_INSTR,A5
00001790  4EB9 00001EF8            685                  JSR         PRINTNULL
00001796  3200                     686                  MOVE.W      D0,D1
00001798  383C 0000                687                  MOVE.W      #0,D4
0000179C  4EB9 00001DD2            688                  JSR         PRINTSHORTLONGNUM
000017A2  4E75                     689                  RTS               
000017A4                           690                  
000017A4                           691  *---------------OR opcode----------------------            
000017A4  3200                     692  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017A6  C27C F000                693                  AND.W       #$F000,D1       
000017AA  B27C 8000                694                  CMP.W       #$8000,D1
000017AE  6600 004C                695                  BNE         CASE_NOT
000017B2                           696                                                
000017B2  3200                     697                  MOVE.W      D0,D1
000017B4  E149                     698                  LSL.W       #8,D1
000017B6  E049                     699                  LSR.W       #8,D1
000017B8  EC49                     700                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000017BA  B27C 0003                701                  CMP.W       #3,D1
000017BE  3C01                     702                  MOVE.W      D1,D6
000017C0  67C8                     703                  BEQ         INV_INSTR
000017C2                           704                  
000017C2  4EB8 11D0                705                  JSR         PRINT_ADDR                      ; print address
000017C6                           706                  
000017C6  4BF9 00002196            707                  LEA         MSG_OR,A5
000017CC  4EB9 00001EF8            708                  JSR         PRINTNULL                       ; print "OR"
000017D2                           709                  
000017D2  3206                     710                  MOVE.W      D6,D1
000017D4  4EB9 000017E4            711                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000017DA  4EB8 138A                712                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
000017DE  4EB8 143E                713                  JSR         ADD_SUB_OPERAND                 ; print 
000017E2  4E75                     714                  RTS
000017E4                           715  
000017E4  B27C 0000                716  OR_SIZE         CMP.W       #0,D1
000017E8  6700 FC22                717                  BEQ         ADD_SUB_BYTE
000017EC  B27C 0001                718                  CMP.W       #1,D1                   ; if 1, it is a word
000017F0  6700 FC28                719                  BEQ         ADD_SUB_WORD
000017F4  B27C 0002                720                  CMP.W       #2,D1                   ; if 2, it is a long
000017F8  6700 FC2E                721                  BEQ         ADD_SUB_LONG
000017FC                           722                  ; no need for rts, since ADD_SUB_ already has                
000017FC                           723  
000017FC                           724  *---------------NOT opcode----------------------
000017FC  3200                     725  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017FE  C27C FF00                726                  AND.W       #$FF00,D1       
00001802  B27C 4600                727                  CMP.W       #$4600,D1
00001806  6600 0050                728                  BNE         CASE_LSDASD
0000180A                           729                 
0000180A                           730                  ; get bits 6-7 (size)
0000180A  3200                     731                  MOVE.W      D0,D1
0000180C  E149                     732                  LSL.W       #8,D1
0000180E  E049                     733                  LSR.W       #8,D1
00001810  EC49                     734                  LSR.W       #6,D1 
00001812  3C01                     735                  MOVE.W      D1,D6                         
00001814  BC7C 0003                736                  CMP.W       #3,D6
00001818  6700 FF70                737                  BEQ         INV_INSTR
0000181C                           738                  
0000181C  4EB8 11D0                739                  JSR         PRINT_ADDR
00001820                           740                  
00001820  4BF9 0000219A            741                  LEA         MSG_NOT,A5
00001826  4EB9 00001EF8            742                  JSR         PRINTNULL                       ; print "NOT"
0000182C                           743                                 
0000182C  3206                     744                  MOVE.W      D6,D1
0000182E                           745  
0000182E  4EB8 17E4                746                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001832                           747                  
00001832                           748                  ; get bits 0-5 
00001832  4BF9 00001FA4            749                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001838  4DF9 00001FDA            750                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000183E  3E3C 0000                751                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001842  4EB9 00001B66            752                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001848  B27C 0001                753                  CMP.W       #1,D1                    ; checks if invalid
0000184C  6700 02C0                754                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001850  4EB9 00001C32            755                  JSR         EA_TO_STRING             ; outputs it into a string
00001856                           756    
00001856  4E75                     757                  RTS
00001858                           758  
00001858  3200                     759  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
0000185A  C27C F000                760                  AND.W       #$F000, D1                       ; gets first 4 bits
0000185E  B27C E000                761                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001862  6600 0210                762                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001866  3400                     763                  MOVE.W      D0,D2                            ; copies D0 to D2
00001868  4EB9 00001BEE            764                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000186E  B47C 0003                765                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001872  6600 00C8                766                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001876                           767                  
00001876  3400                     768  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001878  4EB9 00001BDC            769                  JSR         GETROTATION                      ; gets rotation value of D2
0000187E  B47C 0000                770                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001882  6700 0014                771                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001886  B47C 0003                772                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
0000188A  6700 0016                773                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
0000188E                           774                  
0000188E  4BF9 0000219F            775  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001894  6000 0012                776                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001898                           777  
00001898  4BF9 000021A3            778  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
0000189E  6000 0008                779                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000018A2                           780  
000018A2  4BF9 000021A7            781  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
000018A8                           782                  
000018A8  4EB9 00001EF8            783  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
000018AE  3400                     784                  MOVE.W      D0,D2                            ; copies D0 to D2
000018B0  4EB9 00001BE6            785                  JSR         GETDIRECTION                     ; gets direction
000018B6  B47C 0000                786                  CMP.W       #0,D2                            ; checking if its right
000018BA  6700 000C                787                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
000018BE                           788  
000018BE  4BF9 00002232            789  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
000018C4  6000 0008                790                  BRA         PRINT_MEMDIR                     ; branches for printing
000018C8                           791          
000018C8  4BF9 00002230            792  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
000018CE                           793  
000018CE  4EB9 00001EF8            794  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
000018D4  4BF9 00002251            795                  LEA         MSG_W,A5                         ; loads .W into A5
000018DA  4EB9 00001EF8            796                  JSR         PRINTNULL                        ; Prints .W
000018E0  6000 0002                797                  BRA         GETMEMSOURCE                     ; checks the source 
000018E4                           798                  
000018E4                           799  ; get source addressing mode       
000018E4                           800  GETMEMSOURCE                                                 
000018E4  323C 0000                801                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
000018E8  4EB9 00001B12            802                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
000018EE  3801                     803                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
000018F0  323C 0000                804                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
000018F4  4EB9 00001B3C            805                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000018FA  3A01                     806                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000018FC                           807  
000018FC  4BF9 00001FD2            808  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001902  3204                     809                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001904  4EB9 00001BFE            810                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
0000190A  B27C 0002                811                  CMP.W       #2,D1                            ; checks if it is Xn
0000190E  6700 0016                812                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001912  B27C 0001                813                  CMP.W       #1,D1                            ; Checks if it is invalid
00001916  6700 01F6                814                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
0000191A                           815  
0000191A  3404                     816  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
0000191C  3605                     817                  MOVE.W      D5,D3                            ; moves EA to D3
0000191E  4EB9 00001C32            818                  JSR         EA_TO_STRING                     ; prints out the EA
00001924  4E75                     819                  RTS                
00001926                           820                  
00001926                           821                  
00001926  4BF9 00001FDE            822  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
0000192C  3205                     823                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
0000192E  4EB9 00001BFE            824                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001934  4A41                     825                  TST.W       D1                               ; checks if it is valid
00001936  67E2                     826                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001938  6000 01D4                827                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
0000193C                           828  
0000193C                           829  
0000193C  3602                     830  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
0000193E  3200                     831                  MOVE.W      D0,D1                            ; copies D0 to D1
00001940  C27C 0018                832                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001944  E649                     833                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001946  B27C 0000                834                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
0000194A  6700 0014                835                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
0000194E  B27C 0003                836                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001952  6700 0016                837                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001956                           838                  
00001956  4BF9 0000219F            839  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
0000195C  6000 0012                840                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001960                           841  
00001960  4BF9 000021A3            842  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001966  6000 0008                843                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
0000196A                           844  
0000196A  4BF9 000021A7            845  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001970                           846                  
00001970  4EB9 00001EF8            847  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
00001976  3400                     848                  MOVE.W      D0,D2                            ; copies D0 to D2
00001978  4EB9 00001BE6            849                  JSR         GETDIRECTION                     ; gets direction
0000197E  B47C 0000                850                  CMP.W       #0,D2                            ; checking if its right
00001982  6700 000C                851                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001986                           852  
00001986  4BF9 00002232            853  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000198C  6000 000C                854                  BRA         PRINT_REGDIR                     ; branches for printing
00001990                           855          
00001990  4BF9 00002230            856  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001996  6000 0002                857                  BRA         PRINT_REGDIR                     ; branches for printing
0000199A                           858                  
0000199A  4EB9 00001EF8            859  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
000019A0                           860  
000019A0  3400                     861  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
000019A2  4EB9 00001BEE            862                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000019A8  B47C 0001                863                  CMP.W       #1,D2                            ; Checks if it is word size
000019AC  6700 0014                864                  BEQ         REG_WORD                         ; Prints .W
000019B0  B47C 0002                865                  CMP.W       #2,D2                            ; Checks if it is long size
000019B4  6700 0016                866                  BEQ         REG_LONG                         ; Prints .L
000019B8                           867  
000019B8  4BF9 0000224B            868  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
000019BE  6000 0012                869                  BRA         PRINTREGEA      
000019C2                           870  
000019C2  4BF9 00002251            871  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
000019C8  6000 0008                872                  BRA         PRINTREGEA      
000019CC                           873                             
000019CC  4BF9 00002257            874  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
000019D2                           875  
000019D2  4EB9 00001EF8            876  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
000019D8  3400                     877                  MOVE.W      D0,D2                            ; copies D0 to D1
000019DA  4EB9 00001BF6            878                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
000019E0  B27C 0001                879                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
000019E4  6700 0048                880                  BEQ         REG_REGISTER                     ; goes to ASd case if so
000019E8                           881                                  
000019E8  3400                     882  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
000019EA  4EB9 00001BEE            883                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000019F0  3202                     884                  MOVE.W      D2, D1                           ; moves rotation size to D1
000019F2  4BF9 00002240            885                  LEA         MSG_POUND, A5                    ; loads # into A5
000019F8  4EB9 00001EF8            886                  JSR         PRINTNULL                        ; prints #
000019FE  4EB9 00001DAE            887                  JSR         PRINTNUM                         ; prints shift count
00001A04  4BF9 00002244            888                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001A0A  4EB9 00001EF8            889                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001A10  4BF9 00002234            890                  LEA         MSG_DR, A5                       ; loads D into A5
00001A16  4EB9 00001EF8            891                  JSR         PRINTNULL                        ; prints out D 
00001A1C  323C 0000                892                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001A20  4EB9 00001B3C            893                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001A26  4EB9 00001DAE            894                  JSR         PRINTNUM                         ; prints data register number in D1          
00001A2C  4E75                     895                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001A2E                           896                  
00001A2E  3400                     897  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001A30  4EB9 00001BEE            898                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A36  3202                     899                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001A38  4BF9 00002234            900                  LEA         MSG_DR, A5                       ; loads D into A5
00001A3E  4EB9 00001EF8            901                  JSR         PRINTNULL                        ; prints D
00001A44  4EB9 00001DAE            902                  JSR         PRINTNUM                         ; prints register number
00001A4A  4BF9 00002244            903                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001A50  4EB9 00001EF8            904                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001A56  4BF9 00002234            905                  LEA         MSG_DR, A5                       ; loads D into A5
00001A5C  4EB9 00001EF8            906                  JSR         PRINTNULL                        ; prints out D 
00001A62  323C 0000                907                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001A66  4EB9 00001B3C            908                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001A6C  4EB9 00001DAE            909                  JSR         PRINTNUM                         ; prints data register number in D1          
00001A72  4E75                     910                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001A74                           911               
00001A74  3200                     912  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001A76  C27C FF00                913                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001A7A  B27C 6000                914                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001A7E  6600 0018                915                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001A82                           916                  
00001A82  4BF9 00002228            917                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001A88  4EB9 00001EF8            918                  JSR     PRINTNULL                            ; prints BRA
00001A8E                           919  
00001A8E  3400                     920                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001A90  4EB9 00001BAE            921                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001A96  4E75                     922                  RTS
00001A98                           923                  
00001A98                           924  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001A98                           925  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001A98  3200                     926  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001A9A  C27C F000                927                  AND.W   #$F000,D1                            ; get top 4 bits
00001A9E  B27C 6000                928                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001AA2  6600 0054                929                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001AA6  3200                     930                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001AA8  C27C 0F00                931                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001AAC  E049                     932                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001AAE                           933                  
00001AAE  B27C 000E                934                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001AB2  6700 002A                935                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001AB6                           936                  
00001AB6  B27C 000F                937                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001ABA  6700 0018                938                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001ABE                           939                      
00001ABE  B27C 0007                940                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001AC2  6700 0006                941                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001AC6  6000 0046                942                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001ACA                           943     
00001ACA  4BF9 000021BB            944  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001AD0  6000 0016                945                  BRA     PRINTBCC
00001AD4                           946  
00001AD4  4BF9 000021E3            947  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001ADA  6000 000C                948                  BRA     PRINTBCC
00001ADE                           949                  
00001ADE  4BF9 000021D3            950  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001AE4  6000 0002                951                  BRA     PRINTBCC
00001AE8                           952  
00001AE8  4EB9 00001EF8            953  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001AEE  3400                     954                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001AF0  4EB9 00001BAE            955                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001AF6  4E75                     956                  RTS              
00001AF8                           957                  
00001AF8                           958  
00001AF8                           959  CASE_JSR       
00001AF8                           960  
00001AF8  B07C 4E75                961  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001AFC  6600 F6FC                962                  BNE     CASE_MOVE           ; checks the next case if not equal
00001B00  4BF9 00002223            963                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001B06  4EB9 00001EF8            964                  JSR     PRINTNULL           ; prints RTS                
00001B0C  4E75                     965                  RTS                         ; returns from the subroutine
00001B0E                           966  
00001B0E                           967                  
00001B0E                           968  
00001B0E                           969  CASE_DATA           
00001B0E  4E75                     970                      RTS               
00001B10                           971  
00001B10  4E75                     972  CASE_EPICFAIL       RTS
00001B12                           973  
00001B12                           974  
00001B12                           975  * Finds the EA type
00001B12                           976  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001B12                           977  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001B12  48E7 3000                978  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001B16  4A41                     979                      TST.W     D1                    ; compares D1 to 0
00001B18  6700 000E                980                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001B1C                           981                      
00001B1C  343C 01C0                982  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001B20  363C 0006                983                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001B24  6000 000A                984                      BRA       FINDTYPEEA            
00001B28                           985  
00001B28  343C 0038                986  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001B2C  363C 0003                987                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001B30                           988  
00001B30                           989  
00001B30  3200                     990  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001B32  C242                     991                      AND.W     D2,D1                 ; applies bitmask to D1
00001B34  E669                     992                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001B36  4CDF 000C                993                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001B3A  4E75                     994                      RTS                             ; returns from subroutine    
00001B3C                           995                      
00001B3C                           996  * Finds Xn type
00001B3C                           997  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001B3C                           998  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001B3C  48E7 3000                999  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001B40  4A41                    1000                      TST.W     D1                    ; compares D1 to 0
00001B42  6700 000E               1001                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001B46                          1002  
00001B46  343C 0E00               1003  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001B4A  363C 0009               1004                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001B4E  6000 000A               1005                      BRA       FINDTYPEXN            ; finds the type of Xn
00001B52                          1006  
00001B52  343C 0007               1007  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001B56  363C 0000               1008                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001B5A                          1009                      
00001B5A  3200                    1010  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001B5C  C242                    1011                      AND.W     D2,D1                 ; applies bitmask to D1
00001B5E  E669                    1012                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001B60  4CDF 000C               1013                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001B64  4E75                    1014                      RTS                             ; returns from subroutine 
00001B66                          1015                      
00001B66                          1016  * Checks and gets the EA and Xn
00001B66                          1017  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001B66                          1018  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001B66  3207                    1019  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001B68  4EB8 1B12               1020                  JSR     GET_EA                  ; Gets EA
00001B6C  3401                    1021                  MOVE.W  D1,D2                   ; Stores EA in D2
00001B6E  3207                    1022                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001B70  4EB8 1B3C               1023                  JSR     GET_XN                  ; Gets Xn
00001B74  3601                    1024                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001B76  3202                    1025                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001B78                          1026                  
00001B78  4EB9 00001BFE           1027                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001B7E  B27C 0002               1028                  CMP.W   #2,D1                   ; checks if it is Xn
00001B82  6700 0012               1029                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001B86  B27C 0001               1030                  CMP.W   #1,D1                   ; Checks if it is invalid
00001B8A  6700 001C               1031                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001B8E                          1032                  
00001B8E                          1033                  
00001B8E  323C 0000               1034  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001B92  6000 0018               1035                  BRA     END_CHECKGET
00001B96                          1036        
00001B96                          1037  ; need XN
00001B96  2A4E                    1038  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001B98  3203                    1039                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001B9A  4EB9 00001BFE           1040                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001BA0  4A41                    1041                  TST.W   D1                      ; checks if it is valid
00001BA2  67EA                    1042                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001BA4  6000 0002               1043                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001BA8                          1044   
00001BA8  323C 0001               1045  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001BAC                          1046  
00001BAC  4E75                    1047  END_CHECKGET    RTS          
00001BAE                          1048                                            
00001BAE                          1049                                            
00001BAE                          1050  * Gets the displacement and pritns it 
00001BAE                          1051  * Inputs: D2 = instruction word, A2 = address of next word
00001BAE                          1052  * Outputs: prints out displacement
00001BAE  48E7 4004               1053  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001BB2  3A4A                    1054                      MOVE.W    A2,A5                 ; copies A2 to A5
00001BB4  C47C 00FF               1055                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001BB8  6600 0004               1056                      BNE       PRINTADDRESS          ; prints address if not 0
00001BBC  341A                    1057                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001BBE                          1058                      
00001BBE  D44D                    1059  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001BC0  3202                    1060                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001BC2  183C 0000               1061                      MOVE.B    #0,D4                 ; marks address as word  length
00001BC6  4BF9 00002242           1062                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001BCC  4EB9 00001EF8           1063                      JSR       PRINTNULL             ; prints null
00001BD2  4EB9 00001DD2           1064                      JSR       PRINTSHORTLONGNUM     ; prints address
00001BD8                          1065                      
00001BD8  4CDF 2002               1066                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001BDC                          1067                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001BDC                          1068  
00001BDC                          1069  * Gets the rotation value for ASd and LSd
00001BDC                          1070  * Input: D2 = instruction word copy (of D0)                                    
00001BDC                          1071  * Output: rotation  value in D2             
00001BDC  C47C 0E00               1072  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001BE0  E04A                    1073                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001BE2  E24A                    1074                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001BE4  4E75                    1075                      RTS                             ; return from subroutine
00001BE6                          1076  
00001BE6                          1077  * Gets the direction value for ASd and LSd
00001BE6                          1078  * Input: D2 = instruction word copy (of D0)                                    
00001BE6                          1079  * Output: direction value in D2             
00001BE6  C47C 0100               1080  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001BEA  E04A                    1081                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001BEC  4E75                    1082                      RTS                             ; return from subroutine
00001BEE                          1083  
00001BEE                          1084  * Gets the rotation size value for ASd and LSd
00001BEE                          1085  * Input: D2 = instruction word copy (of D0)                                    
00001BEE                          1086  * Output: rotation size value in D2             
00001BEE  C47C 00C0               1087  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001BF2  EC4A                    1088                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001BF4  4E75                    1089                      RTS                             ; return from subroutine
00001BF6                          1090  
00001BF6                          1091  * Gets the rotation location  value for ASd and LSd
00001BF6                          1092  * Input: D2 = instruction word copy (of D0)                                    
00001BF6                          1093  * Output: rotation location value in D2             
00001BF6  C47C 0020               1094  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001BFA  EA4A                    1095                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001BFC  4E75                    1096                      RTS                             ; return from subroutine
00001BFE                          1097  
00001BFE                          1098                          
00001BFE                          1099  * Checks if EA or Xn is valid
00001BFE                          1100  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001BFE                          1101  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001BFE  2F02                    1102  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001C00                          1103  
00001C00  141D                    1104  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001C02  B43C 00FF               1105                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001C06  6700 000A               1106                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001C0A  B202                    1107                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001C0C  6700 000C               1108                     BEQ        VALIDEA               ; branches to valid EA
00001C10  60EE                    1109                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001C12                          1110                     
00001C12  323C 0001               1111  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001C16  6000 0016               1112                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001C1A                          1113                    
00001C1A  B43C 0007               1114  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001C1E  6700 000A               1115                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001C22  323C 0000               1116                     MOVE.W     #$0,D1                ; marks that it is valid
00001C26  6000 0006               1117                     BRA        CHECKEAEXIT           ; exits the subroutine
00001C2A                          1118  
00001C2A  323C 0002               1119  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001C2E                          1120  
00001C2E  241F                    1121  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001C30  4E75                    1122                     RTS                              ; returns from subroutine
00001C32                          1123  
00001C32                          1124  * Converts EA and Xn into a string                                
00001C32                          1125  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001C32                          1126  * Outputs: Prints out EA and Xn into a string
00001C32  48E7 C004               1127  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001C36  B47C 0001               1128                     CMP.W    #An,D2                  ; checks if it is An
00001C3A  6700 003A               1129                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001C3E                          1130                     
00001C3E  B47C 0002               1131                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001C42  6700 004A               1132                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001C46                          1133                     
00001C46  B47C 0003               1134                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001C4A  6700 0072               1135                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001C4E                          1136                     
00001C4E  B47C 0004               1137                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001C52  6700 00A6               1138                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001C56                          1139                     
00001C56  B47C 0007               1140                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001C5A  6700 00DA               1141                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001C5E                          1142                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001C5E                          1143  
00001C5E                          1144  * data register, Dn
00001C5E  4BF9 00002234           1145  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001C64  4EB9 00001EF8           1146                     JSR      PRINTNULL               ; Prints D
00001C6A  3203                    1147                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C6C  4EB9 00001DAE           1148                     JSR      PRINTNUM                ; Prints the Xn
00001C72  6000 0134               1149                     BRA      EA_TO_STRING_EXIT       ; exits           
00001C76                          1150  
00001C76                          1151  
00001C76                          1152  * address register
00001C76  4BF9 00002236           1153  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001C7C  4EB9 00001EF8           1154                     JSR      PRINTNULL               ; Prints A
00001C82  3203                    1155                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001C84  4EB9 00001DAE           1156                     JSR      PRINTNUM                ; Prints the Xn
00001C8A  6000 011C               1157                     BRA      EA_TO_STRING_EXIT       ; exits
00001C8E                          1158  
00001C8E                          1159  * address register indirect
00001C8E  4BF9 00002238           1160  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001C94  4EB9 00001EF8           1161                     JSR      PRINTNULL               ; Prints (
00001C9A  4BF9 00002236           1162                     LEA      MSG_AR,A5               ; Loads A into A5
00001CA0  4EB9 00001EF8           1163                     JSR      PRINTNULL               ; Prints A
00001CA6  3203                    1164                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001CA8  4EB9 00001DAE           1165                     JSR      PRINTNUM                ; Prints the Xn
00001CAE  4BF9 0000223A           1166                     LEA      MSG_RB,A5               ; Loads ) into A5
00001CB4  4EB9 00001EF8           1167                     JSR      PRINTNULL               ; Prints )
00001CBA  6000 00EC               1168                     BRA      EA_TO_STRING_EXIT       ; exits
00001CBE                          1169  
00001CBE                          1170  * address register indirect post increment
00001CBE  4BF9 00002238           1171  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001CC4  4EB9 00001EF8           1172                     JSR      PRINTNULL               ; Prints (
00001CCA  4BF9 00002236           1173                     LEA      MSG_AR,A5               ; Loads A into A5
00001CD0  4EB9 00001EF8           1174                     JSR      PRINTNULL               ; Prints A
00001CD6  3203                    1175                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001CD8  4EB9 00001DAE           1176                     JSR      PRINTNUM                ; Prints the Xn
00001CDE  4BF9 0000223A           1177                     LEA      MSG_RB,A5               ; Loads ) into A5
00001CE4  4EB9 00001EF8           1178                     JSR      PRINTNULL               ; Prints )
00001CEA  4BF9 0000223C           1179                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001CF0  4EB9 00001EF8           1180                     JSR      PRINTNULL               ; Prints +
00001CF6  6000 00B0               1181                     BRA      EA_TO_STRING_EXIT       ; exits
00001CFA                          1182  
00001CFA                          1183  
00001CFA                          1184  * address register indirect pre increment
00001CFA  4BF9 0000223E           1185  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001D00  4EB9 00001EF8           1186                     JSR      PRINTNULL               ; Prints -
00001D06  4BF9 00002238           1187                     LEA      MSG_LB,A5               ; Loads ( into A5
00001D0C  4EB9 00001EF8           1188                     JSR      PRINTNULL               ; Prints (
00001D12  4BF9 00002236           1189                     LEA      MSG_AR,A5               ; Loads A into A5
00001D18  4EB9 00001EF8           1190                     JSR      PRINTNULL               ; Prints A
00001D1E  3203                    1191                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001D20  4EB9 00001DAE           1192                     JSR      PRINTNUM                ; Prints the Xn
00001D26  4BF9 0000223A           1193                     LEA      MSG_RB,A5               ; Loads ) into A5
00001D2C  4EB9 00001EF8           1194                     JSR      PRINTNULL               ; Prints )
00001D32  6000 0074               1195                     BRA      EA_TO_STRING_EXIT       ; exits
00001D36                          1196  
00001D36                          1197  * other (long, short, immediate) with Xn yes
00001D36  301A                    1198  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001D38  B67C 0000               1199                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001D3C  6700 002E               1200                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001D40                          1201                     
00001D40  B67C 0001               1202                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001D44  6700 0042               1203                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001D48                          1204  
00001D48                          1205  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001D48                          1206  * immediate
00001D48  4BF9 00002240           1207  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001D4E  4EB9 00001EF8           1208                     JSR      PRINTNULL               ; Prints #  
00001D54  4BF9 00002242           1209                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001D5A  4EB9 00001EF8           1210                     JSR      PRINTNULL               ; Prints $
00001D60  3200                    1211                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001D62  4EB9 00001DBE           1212                     JSR      PRINTHEXNUM 
00001D68  6000 003E               1213                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001D6C                          1214                     
00001D6C                          1215  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001D6C                          1216  
00001D6C                          1217  * word address
00001D6C                          1218  CASE_WORD          
00001D6C  4BF9 00002242           1219                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001D72  4EB9 00001EF8           1220                     JSR      PRINTNULL               ; Prints $
00001D78  3200                    1221                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001D7A  383C 0000               1222                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001D7E  4EB9 00001DD2           1223                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001D84  6000 0022               1224                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001D88                          1225  
00001D88                          1226  * long address 
00001D88                          1227  CASE_LONG          
00001D88  4BF9 00002242           1228                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001D8E  4EB9 00001EF8           1229                     JSR      PRINTNULL               ; Prints $
00001D94  3200                    1230                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001D96  383C 0001               1231                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001D9A  4EB9 00001DD2           1232                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001DA0  321A                    1233                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001DA2  4EB9 00001DAE           1234                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001DA8                          1235  
00001DA8                          1236  
00001DA8                          1237  * exits subroutine
00001DA8  4CDF 2003               1238  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001DAC  4E75                    1239                      RTS                              ; returns from subroutine
00001DAE                          1240  
00001DAE                          1241  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001DAE                          1242  
00001DAE                          1243  * Prints out the content of D1 as a decimal number
00001DAE                          1244  * Input: number in D1 to be printed
00001DAE                          1245  * Output: contents of D1 printed
00001DAE  48E7 C000               1246  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001DB2  103C 0003               1247                   MOVE.B      #3,D0               ; prints D1
00001DB6  4E4F                    1248                   TRAP        #15                 ; is trap task 3
00001DB8                          1249              
00001DB8  4CDF 0003               1250                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001DBC  4E75                    1251                   RTS                             ; returns from subroutine
00001DBE                          1252                   
00001DBE                          1253  * Prints out the content of D1 as a hex number
00001DBE                          1254  * Input: number in D1 to be printed
00001DBE                          1255  * Output: contents of D1 printed
00001DBE  48E7 C000               1256  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001DC2  143C 0010               1257                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001DC6  103C 000F               1258                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001DCA  4E4F                    1259                   TRAP        #15                 ; is trap task 15
00001DCC  4CDF 0003               1260                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001DD0  4E75                    1261                   RTS                             ; returns from subroutine
00001DD2                          1262                   
00001DD2                          1263  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001DD2                          1264  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001DD2                          1265  * Output: contents of D1 printed
00001DD2  48E7 E000               1266  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001DD6  B83C 0001               1267                            CMP.B       #1,D4               ; checks size of number
00001DDA  6700 0042               1268                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001DDE                          1269  
00001DDE  3401                    1270  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001DE0  C47C F000               1271                            AND.W       #$F000,D2           ; gets the first digit
00001DE4  B47C 0000               1272                            CMP.W       #0, D2              ; checks if it is 0
00001DE8  6600 00DC               1273                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001DEC  4EB9 00001ED6           1274                            JSR         PRINTZERO           ; prints a zero
00001DF2                          1275                            
00001DF2  3401                    1276                            MOVE.W      D1,D2               ; copies number to D2
00001DF4  C47C 0F00               1277                            AND.W       #$0F00,D2           ; gets the second digit
00001DF8  B47C 0000               1278                            CMP.W       #0, D2              ; checks if it is 0
00001DFC  6600 00C8               1279                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E00  4EB9 00001ED6           1280                            JSR         PRINTZERO           ; prints a zero
00001E06                          1281                            
00001E06  3401                    1282                            MOVE.W      D1,D2               ; copies number to D2
00001E08  C47C 00F0               1283                            AND.W       #$00F0,D2           ; gets the third digit
00001E0C  B47C 0000               1284                            CMP.W       #0, D2              ; checks if it is 0
00001E10  6600 00B4               1285                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E14  4EB9 00001ED6           1286                            JSR         PRINTZERO           ; prints a zero
00001E1A  6000 00AA               1287                            BRA         PRINTASHEX          ; prints last digit
00001E1E                          1288                            
00001E1E  2401                    1289  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001E20  C4BC F0000000           1290                            AND.L       #$F0000000,D2       ; gets the first digit
00001E26  B4BC 00000000           1291                            CMP.L       #0, D2              ; checks if it is 0
00001E2C  6600 0098               1292                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E30  4EB9 00001ED6           1293                            JSR         PRINTZERO           ; prints a zero
00001E36                          1294                            
00001E36  2401                    1295                            MOVE.L      D1,D2               ; copies number to D2
00001E38  C4BC 0F000000           1296                            AND.L       #$0F000000,D2       ; gets the second digit
00001E3E  B4BC 00000000           1297                            CMP.L       #0, D2              ; checks if it is 0
00001E44  6600 0080               1298                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E48  4EB9 00001ED6           1299                            JSR         PRINTZERO           ; prints a zero
00001E4E                          1300                            
00001E4E  2401                    1301                            MOVE.L      D1,D2               ; copies number to D2
00001E50  C4BC 00F00000           1302                            AND.L       #$00F00000,D2       ; gets the third digit
00001E56  B4BC 00000000           1303                            CMP.L       #0, D2              ; checks if it is 0
00001E5C  6600 0068               1304                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E60  4EB9 00001ED6           1305                            JSR         PRINTZERO           ; prints a zero
00001E66                          1306                            
00001E66  2401                    1307                            MOVE.L      D1,D2               ; copies number to D2
00001E68  C4BC 000F0000           1308                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001E6E  B4BC 00000000           1309                            CMP.L       #0, D2              ; checks if it is 0
00001E74  6600 0050               1310                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E78  4EB9 00001ED6           1311                            JSR         PRINTZERO           ; prints a zero
00001E7E                          1312                            
00001E7E  2401                    1313                            MOVE.L      D1,D2               ; copies number to D2
00001E80  C4BC 0000F000           1314                            AND.L       #$0000F000,D2       ; gets the fith digit
00001E86  B4BC 00000000           1315                            CMP.L       #0, D2              ; checks if it is 0
00001E8C  6600 0038               1316                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001E90  4EB9 00001ED6           1317                            JSR         PRINTZERO           ; prints a zero
00001E96                          1318                            
00001E96  2401                    1319                            MOVE.L      D1,D2               ; copies number to D2
00001E98  C4BC 00000F00           1320                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001E9E  B4BC 00000000           1321                            CMP.L       #0, D2              ; checks if it is 0
00001EA4  6600 0020               1322                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001EA8  4EB9 00001ED6           1323                            JSR         PRINTZERO           ; prints a zero
00001EAE                          1324                            
00001EAE  2401                    1325                            MOVE.L      D1,D2               ; copies number to D2
00001EB0  C4BC 000000F0           1326                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001EB6  B4BC 00000000           1327                            CMP.L       #0, D2              ; checks if it is 0
00001EBC  6600 0008               1328                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001EC0  4EB9 00001ED6           1329                            JSR         PRINTZERO           ; prints a zero
00001EC6                          1330  
00001EC6  143C 0010               1331  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001ECA  103C 000F               1332                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001ECE  4E4F                    1333                            TRAP        #15                 ; is trap task 15
00001ED0  4CDF 0007               1334                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001ED4  4E75                    1335                            RTS                             ; returns from subroutine    
00001ED6                          1336  * Prints a zero
00001ED6                          1337  * Input: nothing
00001ED6                          1338  * Output: 0 printed out to the console
00001ED6  2F01                    1339  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001ED8  7200                    1340                            MOVE.L      #0,D1               ; moves 0 to D1
00001EDA  4EB8 1DAE               1341                            JSR         PRINTNUM            ; prints the number
00001EDE  221F                    1342                            MOVE.L      (SP)+,D1            ; restores D1
00001EE0  4E75                    1343                            RTS                             ; returns from subroutine
00001EE2                          1344              
00001EE2                          1345  * Prints contents of things between a range
00001EE2                          1346  * input: A5, A6 (the range)
00001EE2                          1347  * output: prints memory contents from A5 to A6 as strings   
00001EE2  48E7 C040               1348  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001EE6  224D                    1349                  MOVEA.L     A5, A1           ; loads A5 into A1
00001EE8  9DCD                    1350                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001EEA  320E                    1351                  MOVE.W      A6, D1           ; move n into D1
00001EEC  103C 0001               1352                  MOVE.B      #1, D0           ; display n characters of string at A1
00001EF0  4E4F                    1353                  TRAP        #15              ; is trap task 1
00001EF2  4CDF 0203               1354                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001EF6  4E75                    1355                  RTS                          ; returns
00001EF8                          1356      
00001EF8                          1357  * Prints null terminated string
00001EF8                          1358  * input: string pointed to by A5
00001EF8                          1359  * output: prints out the null terminated string
00001EF8  48E7 8040               1360  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001EFC  224D                    1361                  MOVE.L      A5,A1           ; loads A5 into A1
00001EFE  103C 000E               1362                  MOVE.B      #14,D0          ; prints null terminated string
00001F02  4E4F                    1363                  TRAP        #15             ; is trap task 10
00001F04  4CDF 0201               1364                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001F08  4E75                    1365                  RTS                         ; returns from subroutine
00001F0A                          1366                  
00001F0A  2F0D                    1367  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001F0C  4BF9 00002140           1368                  LEA         NEW_LINE,A5     ; Prints null
00001F12  4EB8 1EF8               1369                  JSR         PRINTNULL       ; prints the new line
00001F16  2A5F                    1370                  MOVE.L      (SP)+,A5        ; returns A5
00001F18  4E75                    1371                  RTS
00001F1A                          1372  
00001F1A                          1373  * Prints the size of the MOVE or MOVEA operation  
00001F1A                          1374  * input: D0
00001F1A                          1375  * output: prints out the size of a MOVE or MOVEA operation        
00001F1A  48E7 8004               1376  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001F1E  3200                    1377                  MOVE.W  D0,D1               ; stores d0 in d1
00001F20  C07C 3000               1378                  AND.W   #$3000,D0           ; gets the size
00001F24  B07C 2000               1379                  CMP.W   #$2000,D0           ; checks if is long
00001F28  6700 001E               1380                  BEQ     MOVE_LONG
00001F2C  B07C 3000               1381                  CMP.W   #$3000,D0           ; checks if is word
00001F30  6700 000C               1382                  BEQ     MOVE_WORD      
00001F34                          1383                  
00001F34  4BF9 0000224B           1384  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001F3A  6000 0012               1385                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001F3E                          1386  
00001F3E  4BF9 00002251           1387  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001F44  6000 0008               1388                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001F48                          1389  
00001F48  4BF9 00002257           1390  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001F4E                          1391                  
00001F4E  4EB8 1EF8               1392  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001F52  4CDF 2001               1393                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001F56  4E75                    1394                  RTS
00001F58                          1395  
00001F58  43F9 000020E6           1396  ERROR           LEA     ERROR_MSG,A1
00001F5E  103C 000E               1397                  MOVE.B  #14,D0
00001F62  4E4F                    1398                  TRAP    #15 
00001F64                          1399         
00001F64                          1400  * DELETE THIS: Test                
00001F64  2661                    1401  DELETEME        MOVEA.L  -(A1),A3
00001F66  6700 0038               1402                  BEQ      DELETEMEAGAIN  
00001F6A  6F00 0034               1403                  BLE      DELETEMEAGAIN
00001F6E  6E00 0030               1404                  BGT      DELETEMEAGAIN
00001F72                          1405  
00001F72  E40A                    1406                  LSR.B      #2,D2
00001F74  E2E2                    1407                  LSR.W      -(A2)
00001F76  E2DA                    1408                  LSR.W      (A2)+
00001F78  E4AA                    1409                  LSR.L      D2,D2 
00001F7A  E50A                    1410                  LSL.B      #2,D2
00001F7C  E3E2                    1411                  LSL.W      -(A2)
00001F7E  E3DA                    1412                  LSL.W      (A2)+
00001F80  E5AA                    1413                  LSL.L      D2,D2
00001F82  E51A                    1414                  ROL.B      #2,D2
00001F84  E7E2                    1415                  ROL.W      -(A2)
00001F86  E7DA                    1416                  ROL.W      (A2)+
00001F88  E5BA                    1417                  ROL.L      D2,D2
00001F8A  E41A                    1418                  ROR.B      #2,D2
00001F8C  E6E2                    1419                  ROR.W      -(A2)
00001F8E  E6DA                    1420                  ROR.W      (A2)+
00001F90  E4BA                    1421                  ROR.L      D2,D2
00001F92                          1422                  
00001F92  504D                    1423                  ADDQ.W      #8,A5
00001F94  D6C2                    1424                  ADDA.W      D2,A3
00001F96  9BCB                    1425                  SUB.L       A3,A5        
00001F98  8A43                    1426                  OR.W        D3,D5
00001F9A  4642                    1427                  NOT.W       D2
00001F9C                          1428                  
00001F9C  C5FC 0010               1429                  MULS.W    #$0010,D2
00001FA0                          1430                  
00001FA0                          1431  DELETEMEAGAIN                 
00001FA0                          1432            
00001FA0  FFFF FFFF               1433      SIMHALT             ; halt simulator
00001FA4                          1434  
00001FA4                          1435  * Put variables and constants here
00001FA4                          1436  
00001FA4  =0000000D               1437  CR                              EQU     $0D
00001FA4  =0000000A               1438  LF                              EQU     $0A 
00001FA4  =00000009               1439  TAB                             EQU     $09  
00001FA4                          1440  
00001FA4                          1441  * Addressing Modes
00001FA4  =00000000               1442  Dn                              EQU     0
00001FA4  =00000001               1443  An                              EQU     1
00001FA4  =00000002               1444  AnIndirect                      EQU     2
00001FA4  =00000003               1445  AnPost                          EQU     3
00001FA4  =00000004               1446  AnPre                           EQU     4
00001FA4  =00000007               1447  Other                           EQU     7           ; short, long, immediate
00001FA4                          1448  
00001FA4                          1449  * Xn
00001FA4  =00000000               1450  ABSShort                        EQU     0
00001FA4  =00000001               1451  ABSLong                         EQU     1
00001FA4  =00000004               1452  XnImmediate                     EQU     4
00001FA4                          1453  
00001FA4                          1454  * Valid Addressing Modes
00001FA4= 00 01 02 03 04 07 FF    1455  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001FAB                          1456  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001FAB= 00 02 03 04 07 FF       1457  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001FB1= 02 04 07 FF             1458  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001FB5= 02 03 07 FF             1459  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001FB9= 02 03 04 07 FF          1460  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001FBE= 00 02 03 04 07 FF       1461  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001FC4= 01 07 FF                1462  VALIDEA_LEA                     DC.B    An,Other,-1
00001FC7= 00 02 03 04 07 FF       1463  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001FCD= 02 03 04 07 FF          1464  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001FD2= 02 03 04 07 FF          1465  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001FD7= 02 07 FF                1466  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001FDA                          1467  
00001FDA                          1468  * Valid Xn
00001FDA= 00 01 04 FF             1469  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001FDE                          1470  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001FDE= 00 01 FF                1471  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001FE1                          1472  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001FE1                          1473  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001FE1                          1474  
00001FE1                          1475  * posible memory ASd/LSd rotation values
00001FE1  =00000000               1476  ASd_MEM                         EQU     0   
00001FE1  =00000001               1477  LSd_MEM                         EQU     1 
00001FE1  =00000003               1478  ROd_MEM                         EQU     3
00001FE1                          1479   
00001FE1  =00000000               1480  ASd_REG                         EQU     0   
00001FE1  =00000001               1481  LSd_REG                         EQU     1 
00001FE1  =00000003               1482  ROd_REG                         EQU     3
00001FE1                          1483  
00001FE1                          1484  * Messages
00001FE1= 57 65 6C 63 6F 6D ...   1485  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00002008= 46 6F 72 6D 61 74 ...   1486                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00002057= 50 6C 65 61 73 65 ...   1487  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
0000208E= 50 6C 65 61 73 65 ...   1488  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
000020C4= 49 6E 76 61 6C 69 ...   1489  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
000020E6= 45 72 72 6F 72 20 ...   1490  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00002102= 31 30 30 30 09 44 ...   1491  INVALID_INSTR                   DC.B    '1000',TAB,'DATA',TAB,'$',0
0000210E= 46 69 6E 69 73 68 ...   1492  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
00002140= 0D 0A 00                1493  NEW_LINE                        DC.B    CR,LF,0
00002143= 09 09 09 00             1494  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00002147                          1495  
00002147                          1496  * Opcode Messages
00002147= 09 4E 4F 50 00          1497  MSG_NOP                         DC.B    TAB,'NOP',0
0000214C= 09 4D 4F 56 45 00       1498  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00002152= 09 4D 4F 56 45 41 00    1499  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00002159= 09 4D 4F 56 45 51 00    1500  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00002160= 09 4D 4F 56 45 4D 00    1501  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00002167= 09 41 44 44 00          1502  MSG_ADD                         DC.B    TAB,'ADD',0
0000216C= 09 41 44 44 41 00       1503  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002172= 09 41 44 44 51 00       1504  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00002178= 09 53 55 42 00          1505  MSG_SUB                         DC.B    TAB,'SUB',0
0000217D= 09 4D 55 4C 53 00       1506  MSG_MULS                        DC.B    TAB,'MULS',0
00002183= 09 44 49 56 55 00       1507  MSG_DIVU                        DC.B    TAB,'DIVU',0
00002189= 09 4C 45 41 09 09 ...   1508  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00002191= 09 41 4E 44 00          1509  MSG_AND                         DC.B    TAB,'AND',0
00002196= 09 4F 52 00             1510  MSG_OR                          DC.B    TAB,'OR',0
0000219A= 09 4E 4F 54 00          1511  MSG_NOT                         DC.B    TAB,'NOT',0
0000219F= 09 4C 53 00             1512  MSG_LSd                         DC.B    TAB,'LS',0
000021A3= 09 41 53 00             1513  MSG_ASd                         DC.B    TAB,'AS',0
000021A7= 09 52 4F 00             1514  MSG_ROd                         DC.B    TAB,'RO',0
000021AB= 09 42 43 43 09 09 ...   1515  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
000021B3= 09 42 43 53 09 09 ...   1516  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
000021BB= 09 42 45 51 09 09 ...   1517  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
000021C3= 09 42 4E 45 09 09 ...   1518  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
000021CB= 09 42 47 45 09 09 ...   1519  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
000021D3= 09 42 47 54 09 09 ...   1520  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
000021DB= 09 42 48 49 09 09 ...   1521  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
000021E3= 09 42 4C 45 09 09 ...   1522  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
000021EB= 09 42 4C 53 09 09 ...   1523  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
000021F3= 09 42 4C 54 09 09 ...   1524  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
000021FB= 09 42 4D 49 09 09 ...   1525  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00002203= 09 42 50 4C 09 09 ...   1526  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
0000220B= 09 42 56 43 09 09 ...   1527  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00002213= 09 42 56 53 09 09 ...   1528  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
0000221B= 09 4A 53 52 09 09 ...   1529  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00002223= 09 52 54 53 00          1530  MSG_RTS                         DC.B    TAB,'RTS',0
00002228= 09 42 52 41 09 09 ...   1531  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00002230                          1532  
00002230                          1533  * Direction for LSd and ASd
00002230= 52 00                   1534  MSG_RIGHT                       DC.B    'R',0
00002232= 4C 00                   1535  MSG_LEFT                        DC.B    'L',0
00002234                          1536  
00002234                          1537  * Effective Addresses Messages
00002234= 44 00                   1538  MSG_DR                          DC.B    'D',0
00002236= 41 00                   1539  MSG_AR                          DC.B    'A',0
00002238= 28 00                   1540  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
0000223A= 29 00                   1541  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
0000223C= 2B 00                   1542  MSG_PLUS                        DC.B    '+',0
0000223E= 2D 00                   1543  MSG_MINUS                       DC.B    '-',0
00002240= 23 00                   1544  MSG_POUND                       DC.B    '#',0 
00002242= 24 00                   1545  MSG_HEX                         DC.B    '$',0 
00002244= 2C 20 00                1546  MSG_COMMA                       DC.B    ', ',0 
00002247= 20 00                   1547  MSG_SPACE                       DC.B    ' ',0
00002249= 09 00                   1548  MSG_TAB                         DC.B    TAB,0
0000224B                          1549  
0000224B                          1550  * Size Messages
0000224B= 2E 42 09 09 09 00       1551  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00002251= 2E 57 09 09 09 00       1552  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00002257= 2E 4C 09 09 09 00       1553  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
0000225D                          1554  
0000225D                          1555  * Variables
0000225D  =00000100               1556  STARTING_ADDRESS                EQU     $100
0000225D  =00000150               1557  ENDING_ADDRESS                  EQU     $150
0000225D  =00000200               1558  CURRENT_INSTR                   EQU     $200
0000225D  =00000250               1559  REG_VAR                         EQU     $250 * Hold bits 11-9
0000225D  =00000300               1560  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
0000225D  =00000350               1561  EA_MODE                         EQU     $350 * Hold bits 5-3
0000225D  =00000400               1562  EA_REG                          EQU     $400 * Hold bits 2-0
0000225D                          1563  
0000225D                          1564              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           14D0
ADDQ_BYTE           1566
ADDQ_LONG           1586
ADDQ_WORD           1576
ADD_SUB_BYTE        140C
ADD_SUB_HELP        138A
ADD_SUB_LONG        1428
ADD_SUB_OPERAND     143E
ADD_SUB_SIZE        13E8
ADD_SUB_WORD        141A
AN                  1
AND_BYTE            1750
AND_LONG            1770
AND_WORD            1760
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           20C4
CASE_ADD            135E
CASE_ADDA           14A4
CASE_ADDQ           150C
CASE_AND            1706
CASE_AR             1C76
CASE_ARI            1C8E
CASE_ARIPOST        1CBE
CASE_ARIPRE         1CFA
CASE_ASDMEM         1898
CASE_ASDREG         1960
CASE_BCC            1A98
CASE_BEQ            1ACA
CASE_BGT            1ADE
CASE_BLE            1AD4
CASE_BRA            1A74
CASE_DATA           1B0E
CASE_DR             1C5E
CASE_EPICFAIL       1B10
CASE_IMMEDIATE      1D48
CASE_JSR            1AF8
CASE_LEA            1674
CASE_LEFTMEM        18BE
CASE_LEFTREG        1986
CASE_LONG           1D88
CASE_LSDASD         1858
CASE_LSDMEM         188E
CASE_LSDREG         1956
CASE_MOVE           11FA
CASE_MOVEM          12A0
CASE_MOVEQ          1306
CASE_NOP            11E0
CASE_NOT            17FC
CASE_OR             17A4
CASE_OTHER          1D36
CASE_RIGHTMEM       18C8
CASE_RIGHTREG       1990
CASE_RODMEM         18A2
CASE_RODREG         196A
CASE_RTS            1AF8
CASE_SHIFTMEM       1876
CASE_SHIFTREG       193C
CASE_SUB            15E4
CASE_SUBA           165E
CASE_WORD           1D6C
CHECKEAEXIT         1C2E
CHECKEAMLOOP        1C00
CHECKEAXN_IFVALID   1BFE
CHECKGET_EAXN       1B66
CHECKMEMSOURE       18FC
CHECKSHIFT_XN       1926
CHECK_LENGTH        1132
CHECK_ODD           11C8
CHECK_ORDER         109A
CHECK_XN            1B96
CONCAT              117A
CONVERT             1144
CR                  D
CURRENT_INSTR       200
DELETEME            1F64
DELETEMEAGAIN       1FA0
DESTEA              1B1C
DESTXN              1B46
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          1478
DONE                210E
EASHIFT_VALID       191A
EAXN_INVALID        1BA8
EAXN_VALID          1B8E
EA_MODE             350
EA_REG              400
EA_TO_STRING        1C32
EA_TO_STRING_EXIT   1DA8
ENDING              208E
ENDING_ADDRESS      150
END_CHECKGET        1BAC
ERROR               1F58
ERROR_MSG           20E6
FINDTYPEEA          1B30
FINDTYPEXN          1B5A
FINISHED            10B4
FINISHMOVE          1F4E
FINISH_ADD          1436
FINISH_ADDA         14E0
FINISH_ADDQ         1596
FINISH_AND          1780
FINISH_SUB          1624
FINISH_SUBA         162A
GETDIRECTION        1BE6
GETDISPLACEMENT     1BAE
GETMEMSOURCE        18E4
GETROTATION         1BDC
GETROTATIONLOCATION  1BF6
GETROTATIONSIZE     1BEE
GET_EA              1B12
GET_XN              1B3C
INPUT1              100C
INPUT2              1052
INSERTA             126C
INVALID             1192
INVALIDEA           1C12
INVALID_INSTR       2102
INV_INSTR           178A
ISNUMBER            115A
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       1306
MOVEM_REG2MEM       12D6
MOVE_BYTE           1F34
MOVE_LONG           1F48
MOVE_WORD           1F3E
MSG_ADD             2167
MSG_ADDA            216C
MSG_ADDQ            2172
MSG_AND             2191
MSG_AR              2236
MSG_ASD             21A3
MSG_B               224B
MSG_BCC             21AB
MSG_BCS             21B3
MSG_BEQ             21BB
MSG_BGE             21CB
MSG_BGT             21D3
MSG_BHI             21DB
MSG_BLE             21E3
MSG_BLS             21EB
MSG_BLT             21F3
MSG_BMI             21FB
MSG_BNE             21C3
MSG_BPL             2203
MSG_BRA             2228
MSG_BVC             220B
MSG_BVS             2213
MSG_COMMA           2244
MSG_DIVU            2183
MSG_DR              2234
MSG_HEX             2242
MSG_JSR             221B
MSG_L               2257
MSG_LB              2238
MSG_LEA             2189
MSG_LEFT            2232
MSG_LSD             219F
MSG_MINUS           223E
MSG_MOVE            214C
MSG_MOVEA           2152
MSG_MOVEM           2160
MSG_MOVEQ           2159
MSG_MULS            217D
MSG_NOP             2147
MSG_NOT             219A
MSG_OR              2196
MSG_PLUS            223C
MSG_POUND           2240
MSG_RB              223A
MSG_RIGHT           2230
MSG_ROD             21A7
MSG_RTS             2223
MSG_SPACE           2247
MSG_SUB             2178
MSG_TAB             2249
MSG_W               2251
NEW_LINE            2140
NOTNUMBER           1162
OPCODE_DECODE       11DC
OPMODE_VAR          300
OR_SIZE             17E4
OTHER               7
OTHEREA             1C2A
PRINTADD            13D0
PRINTADDRESS        1BBE
PRINTASHEX          1EC6
PRINTBCC            1AE8
PRINTENTER          1F0A
PRINTHEXNUM         1DBE
PRINTLONGZERO       1E1E
PRINTMOVE           1272
PRINTMOVESIZE       1F1A
PRINTNULL           1EF8
PRINTNUM            1DAE
PRINTRANGE          1EE2
PRINTREGEA          19D2
PRINTREGSIZE        19A0
PRINTSHIFTMEM       18A8
PRINTSHIFTREG       1970
PRINTSHORTLONGNUM   1DD2
PRINTSHORTZERO      1DDE
PRINTSUB            15FE
PRINTZERO           1ED6
PRINT_8             15D8
PRINT_ADDQ_DATA     15B4
PRINT_ADDR          11D0
PRINT_MEMDIR        18CE
PRINT_MOVEQ         1328
PRINT_REGDIR        199A
REG2MEMXNCHECK      12F0
REG_BYTE            19B8
REG_IMMEDIATE       19E8
REG_LONG            19CC
REG_REGISTER        1A2E
REG_VAR             250
REG_WORD            19C2
RESET_INPUT         112A
RESTART             10D4
RETURN              1190
ROD_MEM             3
ROD_REG             3
SOURCEEA            1B28
SOURCEXN            1B52
START               1000
STARTING            2057
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11B0
THREE_TAB           2143
VALIDEA             1C1A
VALIDEA_ADDSUB_DESTOPERAND  1FB9
VALIDEA_ALL         1FA4
VALIDEA_ANDORNOT    1FC7
VALIDEA_ANDOR_DESTOPERAND  1FCD
VALIDEA_JSR         1FD7
VALIDEA_LEA         1FC4
VALIDEA_MOVEM_MEMTOREG  1FB5
VALIDEA_MOVEM_REGTOMEM  1FB1
VALIDEA_MOVEQ       1FAB
VALIDEA_MULSDIVU    1FBE
VALIDEA_SHIFT       1FD2
VALIDXN_ALL         1FDA
VALIDXN_SHORTLONG   1FDE
WELCOME             1FE1
XNIMMEDIATE         4
