00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/6/2020 10:14:00 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001BF5             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001C6B             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001CA2             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 000019F4             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001B2C             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6E00 0052                 78                  BGT     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 00001CD8            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C                           138                  
0000116C  B07C 4E71                139  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001170  6600 0010                140                  BNE     CASE_MOVE               ; checks the next case if not equal
00001174  4BF9 00001D1D            141                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117A  4EB9 00001B1A            142                  JSR     PRINTNULL               ; prints NOP                
00001180  4E75                     143                  RTS                             ; returns from the subroutine
00001182                           144                  
00001182                           145                  * if first two bits are 00, next two are not 00
00001182  3200                     146  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001184  C27C C000                147                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001188  6600 009A                148                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
0000118C  B07C 0FFF                149                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001190  6F00 0092                150                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001194                           151                  
00001194                           152                  ; Check source
00001194  4BF9 00001BB8            153                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119A  4DF9 00001BEE            154                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A0  3E3C 0000                155                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A4  4EB9 00001788            156                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AA  B27C 0001                157                  CMP.W   #1,D1                    ; checks if invalid
000011AE  6700 0580                158                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B2  3802                     159                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B4  3A03                     160                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011B6                           161                  
000011B6                           162                  ; Check destination
000011B6  4BF9 00001BB8            163                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011BC  4DF9 00001BF2            164                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C2  3E3C 0001                165                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011C6  4EB9 00001788            166                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011CC  B27C 0001                167                  CMP.W   #1,D1                    ; checks if invalid
000011D0  6700 055E                168                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D4  3C02                     169                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011D6  3E03                     170                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011D8                           171                  
000011D8                           172                  ; Checking if it is MOVEA
000011D8  3200                     173                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DA  C27C 01C0                174                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011DE  B27C 0040                175                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E2  6700 000C                176                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011E6                           177   
000011E6  4BF9 00001D22            178                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011EC  6000 0008                179                  BRA     PRINTMOVE                ; Branches to print move
000011F0                           180                  
000011F0  4BF9 00001D28            181  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011F6                           182   
000011F6  4EB9 00001B1A            183  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
000011FC  4EB9 00001B3C            184                  JSR     PRINTMOVESIZE            ; prints out the size  
00001202  3404                     185                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001204  3605                     186                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001206  4EB9 00001854            187                  JSR     EA_TO_STRING             ; outputs it into a string
0000120C                           188                  
0000120C                           189                  ; prints a comma to seperate
0000120C  4BF9 00001E1A            190                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001212  4EB9 00001B1A            191                  JSR     PRINTNULL                ; prints out MOVE
00001218                           192                  
00001218                           193                  ; print destination
00001218  3406                     194                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121A  3607                     195                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000121C  4EB9 00001854            196                  JSR     EA_TO_STRING             ; outputs it into a string
00001222  4E75                     197                  RTS                              ; exits subroutine                 
00001224                           198                
00001224                           199                  
00001224  3200                     200  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001226  C27C FB80                201                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122A  B27C 4880                202                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000122E  6600 005A                203                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001232                           204                  
00001232                           205                  ; loads EA and XN
00001232  323C 0000                206                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001236  4EB9 00001734            207                  JSR     GET_EA                          ; gets EA and puts in D1
0000123C  3401                     208                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
0000123E  323C 0000                209                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001242  4EB9 0000175E            210                  JSR     GET_XN                          ; gets XN and puts in D1
00001248  3601                     211                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
0000124A                           212                  
0000124A                           213                  ; Check D
0000124A  3200                     214                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000124C  C27C 0400                215                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001250  3E01                     216                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001252  B27C 0400                217                  CMP.W   #$0400,D1                       ; checks if value is 1
00001256  6700 0032                218                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000125A                           219  
0000125A  4BF9 00001BC5            220  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001260  3202                     221                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001262  4EB9 00001820            222                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001268  B27C 0001                223                  CMP.W   #1,D1                           ; checks if D1 invalid
0000126C  6700 04C2                224                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001270  B27C 0002                225                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001274                           226                  
00001274  4BF9 00001BC5            227  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127A  3203                     228                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
0000127C  4EB9 00001820            229                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001282  B27C 0001                230                  CMP.W   #1,D1                           ; checks if D1 invalid
00001286  6700 04A8                231                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128A                           232  
0000128A                           233                  
0000128A                           234  
0000128A                           235  MOVEM_MEM2REG    
0000128A                           236                          
0000128A                           237  
0000128A                           238  
0000128A  3200                     239  CASE_MOVEQ      MOVE.W  D0,D1
0000128C  C27C F100                240                  AND.W   #$F100,D1
00001290  B27C 7000                241                  CMP.W   #$7000,D1
00001294  6600 0048                242                  BNE     CASE_ADD
00001298                           243                  
00001298                           244                  ;loads Register
00001298  323C 0001                245                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000129C  4EB9 0000175E            246                  JSR     GET_XN                          ; gets XN and puts in D1
000012A2  3401                     247                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012A4                           248                  
000012A4                           249                  ;loads DATA
000012A4  3200                     250                  MOVE.W  D0,D1
000012A6  C27C 00FF                251                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012AA  3601                     252                  MOVE.W  D1,D3                          ;copy data into D3
000012AC                           253                                                          ;must convert bits to hex
000012AC                           254                  
000012AC                           255                  
000012AC  4BF9 00001D2F            256  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B2  4EB9 00001B1A            257                  JSR     PRINTNULL  
000012B8                           258                  
000012B8  4BF9 00001E2D            259                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012BE  4EB9 00001B1A            260                  JSR     PRINTNULL
000012C4                           261      
000012C4  4BF9 00001D19            262                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000012CA  4EB9 00001B1A            263                  JSR     PRINTNULL
000012D0                           264                  
000012D0  4BF9 00001E16            265                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012D6  4EB9 00001B1A            266                  JSR     PRINTNULL
000012DC  4E75                     267                  RTS
000012DE                           268                  
000012DE                           269  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000012DE  3200                     270  CASE_ADD        MOVE.W  D0,D1
000012E0  C27C F000                271                  AND.W   #$F000,D1
000012E4  B27C D000                272                  CMP.W   #$D000,D1
000012E8  6600 00FE                273                  BNE     CASE_ADDQ
000012EC                           274                  
000012EC                           275                  ; Check bits 0-6 
000012EC  4BF9 00001BB8            276                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012F2  4DF9 00001BEE            277                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012F8  3E3C 0000                278                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012FC  4EB9 00001788            279                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001302  B27C 0001                280                  CMP.W   #1,D1                    ; checks if invalid
00001306  6700 0428                281                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000130A  3802                     282                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
0000130C  3A03                     283                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000130E                           284                  
0000130E                           285                  ; get bits 9-11
0000130E  3200                     286                  MOVE.W  D0,D1
00001310  E949                     287                  LSL.W   #4,D1                   ; get rid of left 4 bits
00001312  E849                     288                  LSR.W   #4,D1
00001314  E049                     289                  LSR.W   #8,D1                   ; get rid of right 6 bits
00001316  E249                     290                  LSR.W   #1,D1                   ; get rid of right 6 bits
00001318  3C01                     291                  MOVE.W  D1,D6
0000131A                           292                  
0000131A                           293                  ; bits 7-8 determine if it is ADDA or ADD
0000131A  3200                     294                  MOVE.W  D0,D1
0000131C  E149                     295                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000131E  E049                     296                  LSR.W   #8,D1
00001320  EC49                     297                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001322  B27C 0003                298                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001326  6700 00C0                299                  BEQ     CASE_ADDA
0000132A                           300                  
0000132A  4BF9 00001D3D            301                  LEA     MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001330  6000 0002                302                  BRA     PRINTADD                ; Branches to print move
00001334                           303                  
00001334  4EB9 00001B1A            304  PRINTADD        JSR     PRINTNULL
0000133A  3200                     305                  MOVE.W  D0,D1                   ; bits 7-8 contain size
0000133C  E149                     306                  LSL.W   #8,D1
0000133E  E049                     307                  LSR.W   #8,D1
00001340  EC49                     308                  LSR.W   #6,D1                   ; gets bits 7-8
00001342                           309                  
00001342  B27C 0001                310                  CMP.W   #1,D1                   ; if 1, it is a word
00001346  6700 001A                311                  BEQ     ADD_WORD
0000134A  B27C 0002                312                  CMP.W   #2,D1                   ; if 2, it is a long
0000134E  6700 0022                313                  BEQ     ADD_LONG
00001352                           314                  
00001352  4BF9 00001E21            315  ADD_BYTE        LEA     MSG_B,A5
00001358  4EB9 00001B1A            316                  JSR     PRINTNULL
0000135E  6000 0022                317                  BRA     FINISH_ADD  
00001362                           318  
00001362  4BF9 00001E27            319  ADD_WORD        LEA     MSG_W,A5
00001368  4EB9 00001B1A            320                  JSR     PRINTNULL
0000136E  6000 0012                321                  BRA     FINISH_ADD  
00001372                           322                  
00001372                           323  
00001372  4BF9 00001E2D            324  ADD_LONG        LEA     MSG_L,A5
00001378  4EB9 00001B1A            325                  JSR     PRINTNULL
0000137E  6000 0002                326                  BRA     FINISH_ADD  
00001382                           327  
00001382  EF49                     328  FINISH_ADD      LSL.W   #7,D1
00001384  EE49                     329                  LSR.W   #7,D1
00001386  E049                     330                  LSR.W   #8,D1
00001388                           331  
00001388  B27C 0001                332                  CMP.W   #1,D1
0000138C  6000 002E                333                  BRA     Dn_PLUS_EA          
00001390                           334                  
00001390                           335                  ; print Data Register
00001390  4BF9 00001E0A            336                  LEA     MSG_DR,A5
00001396  4EB9 00001B1A            337                  JSR     PRINTNULL
0000139C  3206                     338                  MOVE.W  D6,D1
0000139E  4EB9 000019D0            339                  JSR     PRINTNUM                
000013A4                           340                  
000013A4                           341                  ; prints a comma to seperate
000013A4  4BF9 00001E1A            342                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000013AA  4EB9 00001B1A            343                  JSR     PRINTNULL                ; prints out MOVE
000013B0                           344                  
000013B0                           345                  ; below is EA+Dn->Dn  
000013B0  3404                     346                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013B2  3605                     347                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013B4  4EB9 00001854            348                  JSR     EA_TO_STRING             ; outputs it into a string
000013BA  4E75                     349                  RTS                              ; exits subroutine 
000013BC                           350  
000013BC                           351  Dn_PLUS_EA      ; below is Dn+EA->EA  
000013BC  3404                     352                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
000013BE  3605                     353                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
000013C0  4EB9 00001854            354                  JSR     EA_TO_STRING             ; outputs it into a string   
000013C6                           355                  
000013C6                           356                  ; prints a comma to seperate
000013C6  4BF9 00001E1A            357                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000013CC  4EB9 00001B1A            358                  JSR     PRINTNULL                ; prints out MOVE
000013D2                           359                  
000013D2                           360                  ; below is Dn+EA->EA
000013D2  4BF9 00001E0A            361                  LEA     MSG_DR,A5                  ; print data register
000013D8  4EB9 00001B1A            362                  JSR     PRINTNULL
000013DE  3206                     363                  MOVE.W  D6,D1
000013E0  4EB9 000019D0            364                  JSR     PRINTNUM             
000013E6  4E75                     365                  RTS                              ; exits subroutine                
000013E8                           366                   
000013E8                           367  
000013E8                           368  CASE_ADDA       
000013E8                           369  *
000013E8                           370  *CASE_ADDA       LEA         MSG_ADDA,A1
000013E8                           371  *                MOVE.B      #14,D0
000013E8                           372  *                TRAP        #15                 ; print "ADDA"
000013E8                           373  *                MOVE.W      OPMODE_VAR,D3
000013E8                           374  *                JSR         ADDA_SIZE
000013E8                           375  *                JSR         ADDR_MODE_JUMP_TABLE
000013E8                           376  *                    
000013E8                           377  *            
000013E8                           378  *ADDA_SIZE       CMP.W       #%111,D3
000013E8                           379  *                BEQ         PRINT_WORD 
000013E8                           380  *                BRA         PRINT_LONG          
000013E8                           381                  
000013E8                           382  
000013E8                           383  CASE_ADDQ       
000013E8                           384  
000013E8                           385  CASE_SUB
000013E8                           386  
000013E8  3200                     387  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000013EA  C27C F000                388                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000013EE  B27C 4000                389                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
000013F2  6600 0086                390                  BNE.W   CASE_AND                             ; If its not, check AND
000013F6  3200                     391                  MOVE.W  D0,D1                                ; Copies instruction word to D1
000013F8  C27C 01C0                392                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
000013FC  B27C 01C0                393                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001400  6600 0078                394                  BNE.W   CASE_AND                             ; If its not, check AND
00001404                           395                  
00001404                           396                  ; Check source
00001404  4BF9 00001BD8            397                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000140A  4DF9 00001BF2            398                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001410  3E3C 0000                399                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001414  4EB9 00001788            400                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000141A  3802                     401                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000141C  3A03                     402                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000141E                           403                  
0000141E                           404                  ; Check destination
0000141E  4BF9 00001BD8            405                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001424  4DF9 00001BF2            406                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000142A  3E3C 0001                407                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000142E  4EB9 00001788            408                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001434  3C02                     409                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001436  3E03                     410                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001438                           411  
00001438  4BF9 00001D5F            412                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000143E  4EB9 00001B1A            413                  JSR     PRINTNULL                            ; prints LEA
00001444                           414                  
00001444                           415                  ; print source
00001444  3404                     416                  MOVE.W  D4,D2
00001446  3605                     417                  MOVE.W  D5,D3
00001448  4EB9 00001854            418                  JSR     EA_TO_STRING                         ; Prints out the EA
0000144E                           419                  
0000144E                           420                  ; comma
0000144E  4BF9 00001E1A            421                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001454  4EB9 00001B1A            422                  JSR     PRINTNULL                       
0000145A                           423                   
0000145A                           424                  ; register
0000145A  4BF9 00001E0C            425                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001460  4EB9 00001B1A            426                  JSR     PRINTNULL 
00001466  3401                     427                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
00001468  323C 0001                428                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
0000146C  4EB9 0000175E            429                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001472  4EB9 000019D0            430                  JSR     PRINTNUM                             ; Prints the number in D1
00001478  4E75                     431                  RTS
0000147A                           432  
0000147A                           433  **---------------AND opcode----------------------
0000147A                           434  CASE_AND
0000147A                           435  *CASE_AND        LEA         MSG_AND,A1
0000147A                           436  *                MOVE.B      #14,D0
0000147A                           437  *                TRAP        #15 
0000147A                           438  *                JSR         GET_VARS
0000147A                           439  *                JSR         AND_SIZE                        ; .B, .W, or .L  
0000147A                           440  *                MOVE.W      CURRENT_INSTR, D5                         
0000147A                           441  *                LSL.W       #7, D5                        
0000147A                           442  *                LSR.W       #8, D5                   
0000147A                           443  *                LSR.W       #7, D5                     
0000147A                           444  *                CMP.B       #00, D5                         ; check if destination is a Dn?
0000147A                           445  *                BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
0000147A                           446  *                CMP.B       #$01,D5                         ; Is the destination not a Dn?
0000147A                           447  *                BEQ         DEST_EA                         ; branch to DEST_EA            
0000147A                           448  *                RTS
0000147A                           449     
0000147A                           450  *AND_SIZE        CMP.B       #%00,OPMODE_VAR       
0000147A                           451  *                BEQ         PRINT_BYTE
0000147A                           452  *                CMP.B       #$01, OPMODE_VAR
0000147A                           453  *                BEQ         PRINT_WORD
0000147A                           454  *                CMP.B       #$02, OPMODE_VAR
0000147A                           455  *                BEQ         PRINT_LONG    
0000147A                           456  *    
0000147A                           457  *DEST_DN         MOVE.W      CURRENT_INSTR, D5               
0000147A                           458  *                LSL.W       #6,D5
0000147A                           459  *                LSL.W       #4,D5
0000147A                           460  *                LSR.W       #6,D5
0000147A                           461  *                LSR.W       #4,D5
0000147A                           462  *                LSR.W       #3,D5                           ; d5 stores EA mode                
0000147A                           463  *                  
0000147A                           464  *                MOVE.W      CURRENT_INSTR, D6               
0000147A                           465  *                LSL.W       #6,D5
0000147A                           466  *                LSL.W       #4,D5
0000147A                           467  *                LSL.W       #3,D6
0000147A                           468  *                LSR.W       #6,D6
0000147A                           469  *                LSR.W       #4,D6
0000147A                           470  *                LSR.W       #3,D6                           ; d6 stores EA register
0000147A                           471  *                JSR         FIND_EA
0000147A                           472  *
0000147A                           473  *                
0000147A                           474  *                MOVE.W      CURRENT_INSTR, D5               
0000147A                           475  *                LSL.W       #4, D5                         
0000147A                           476  *                LSR.W       #8, D5                          ; shift bits to get register
0000147A                           477  *                LSR.W       #5, D5                          ; D5 contains register
0000147A                           478  *                LEA         MSG_COMMA, A1                   
0000147A                           479  *                MOVE.B      #14,D0
0000147A                           480  *                TRAP        #15                             ; print comma
0000147A                           481  *                LEA         MSG_DR, A1                      ; print D
0000147A                           482  *                MOVE.B      #14,D0
0000147A                           483  *                TRAP        #15
0000147A                           484  *                MOVEA.L     D5,A1
0000147A                           485  *                MOVE.B      #14,D0
0000147A                           486  *                TRAP        #15                              
0000147A                           487  *                RTS        
0000147A                           488  *
0000147A                           489  *FIND_EA        CMP.W       #%010,D5
0000147A                           490  *                BEQ         CASE_ARI
0000147A                           491  *                CMP.W       #%011,D5
0000147A                           492  *                BEQ         CASE_ARIPOST
0000147A                           493  *                CMP.W       #%100,D5
0000147A                           494  *                BEQ         CASE_ARIPRE
0000147A                           495  *                CMP.W       #%111,D5
0000147A                           496  *                BEQ         CASE_OTHER
0000147A                           497  *                BRA         ERROR    
0000147A                           498  *                                     
0000147A                           499  *DEST_EA         MOVE.W      CURRENT_INSTR, D5               
0000147A                           500  *                LSL.W       #4, D5                         
0000147A                           501  *                LSR.W       #8, D5                          ; shift bits to get register
0000147A                           502  *                LSR.W       #5, D5                          ; D5 contains register
0000147A                           503  *
0000147A                           504  *                LEA         MSG_DR, A1                   
0000147A                           505  *                MOVE.B      #14,D0
0000147A                           506  *                TRAP        #15                             ; print D
0000147A                           507  *                MOVEA.L     D5,A1  
0000147A                           508  *                MOVE.B      #14,D0                          ; print register
0000147A                           509  *                TRAP        #15
0000147A                           510  *                
0000147A                           511  *                LEA         MSG_COMMA, A1                   
0000147A                           512  *                MOVE.B      #14,D0
0000147A                           513  *                TRAP        #15                             ; print comma
0000147A                           514  *                
0000147A                           515  *                MOVE.W      CURRENT_INSTR, D5               
0000147A                           516  *                LSL.W       #6,D5
0000147A                           517  *                LSL.W       #4,D5
0000147A                           518  *                LSR.W       #6,D5
0000147A                           519  *                LSR.W       #4,D5
0000147A                           520  *                LSR.W       #3,D5                           ; d5 stores EA mode                
0000147A                           521  *                  
0000147A                           522  *                MOVE.W      CURRENT_INSTR, D6               
0000147A                           523  *                LSL.W       #6,D6
0000147A                           524  *                LSL.W       #4,D6
0000147A                           525  *                LSL.W       #3,D6
0000147A                           526  *                LSR.W       #6,D6
0000147A                           527  *                LSR.W       #4,D6
0000147A                           528  *                LSR.W       #3,D6                           ; d6 stores EA register
0000147A                           529  *                JSR         FIND_EA                          
0000147A                           530  *                RTS                                     Return full instruction   
0000147A                           531              
0000147A                           532  CASE_OR
0000147A                           533  
0000147A                           534  CASE_NOT
0000147A                           535  
0000147A  3200                     536  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
0000147C  C27C F000                537                  AND.W       #$F000, D1                       ; gets first 4 bits
00001480  B27C E000                538                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001484  6600 0210                539                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001488  3400                     540                  MOVE.W      D0,D2                            ; copies D0 to D2
0000148A  4EB9 00001810            541                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001490  B47C 0003                542                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001494  6600 00C8                543                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001498                           544                  
00001498  3400                     545  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000149A  4EB9 000017FE            546                  JSR         GETROTATION                      ; gets rotation value of D2
000014A0  B47C 0000                547                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
000014A4  6700 0014                548                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
000014A8  B47C 0003                549                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
000014AC  6700 0016                550                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
000014B0                           551                  
000014B0  4BF9 00001D75            552  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
000014B6  6000 0012                553                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000014BA                           554  
000014BA  4BF9 00001D79            555  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
000014C0  6000 0008                556                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
000014C4                           557  
000014C4  4BF9 00001D7D            558  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
000014CA                           559                  
000014CA  4EB9 00001B1A            560  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
000014D0  3400                     561                  MOVE.W      D0,D2                            ; copies D0 to D2
000014D2  4EB9 00001808            562                  JSR         GETDIRECTION                     ; gets direction
000014D8  B47C 0000                563                  CMP.W       #0,D2                            ; checking if its right
000014DC  6700 000C                564                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
000014E0                           565  
000014E0  4BF9 00001E08            566  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
000014E6  6000 0008                567                  BRA         PRINT_MEMDIR                     ; branches for printing
000014EA                           568          
000014EA  4BF9 00001E06            569  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
000014F0                           570  
000014F0  4EB9 00001B1A            571  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
000014F6  4BF9 00001E27            572                  LEA         MSG_W,A5                         ; loads .W into A5
000014FC  4EB9 00001B1A            573                  JSR         PRINTNULL                        ; Prints .W
00001502  6000 0002                574                  BRA         GETMEMSOURCE                     ; checks the source 
00001506                           575                  
00001506                           576  ; get source addressing mode       
00001506                           577  GETMEMSOURCE                                                 
00001506  323C 0000                578                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000150A  4EB9 00001734            579                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001510  3801                     580                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001512  323C 0000                581                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001516  4EB9 0000175E            582                  JSR         GET_XN                           ; Gets Xn, puts it into D1
0000151C  3A01                     583                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
0000151E                           584  
0000151E  4BF9 00001BE6            585  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001524  3204                     586                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001526  4EB9 00001820            587                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
0000152C  B27C 0002                588                  CMP.W       #2,D1                            ; checks if it is Xn
00001530  6700 0016                589                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001534  B27C 0001                590                  CMP.W       #1,D1                            ; Checks if it is invalid
00001538  6700 01F6                591                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
0000153C                           592  
0000153C  3404                     593  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
0000153E  3605                     594                  MOVE.W      D5,D3                            ; moves EA to D3
00001540  4EB9 00001854            595                  JSR         EA_TO_STRING                     ; prints out the EA
00001546  4E75                     596                  RTS                
00001548                           597                  
00001548                           598                  
00001548  4BF9 00001BF2            599  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
0000154E  3205                     600                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001550  4EB9 00001820            601                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001556  4A41                     602                  TST.W       D1                               ; checks if it is valid
00001558  67E2                     603                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
0000155A  6000 01D4                604                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
0000155E                           605  
0000155E                           606  
0000155E  3602                     607  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001560  3200                     608                  MOVE.W      D0,D1                            ; copies D0 to D1
00001562  C27C 0018                609                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001566  E649                     610                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001568  B27C 0000                611                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
0000156C  6700 0014                612                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001570  B27C 0003                613                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001574  6700 0016                614                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001578                           615                  
00001578  4BF9 00001D75            616  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
0000157E  6000 0012                617                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001582                           618  
00001582  4BF9 00001D79            619  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001588  6000 0008                620                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
0000158C                           621  
0000158C  4BF9 00001D7D            622  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001592                           623                  
00001592  4EB9 00001B1A            624  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
00001598  3400                     625                  MOVE.W      D0,D2                            ; copies D0 to D2
0000159A  4EB9 00001808            626                  JSR         GETDIRECTION                     ; gets direction
000015A0  B47C 0000                627                  CMP.W       #0,D2                            ; checking if its right
000015A4  6700 000C                628                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
000015A8                           629  
000015A8  4BF9 00001E08            630  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
000015AE  6000 000C                631                  BRA         PRINT_REGDIR                     ; branches for printing
000015B2                           632          
000015B2  4BF9 00001E06            633  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
000015B8  6000 0002                634                  BRA         PRINT_REGDIR                     ; branches for printing
000015BC                           635                  
000015BC  4EB9 00001B1A            636  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
000015C2                           637  
000015C2  3400                     638  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
000015C4  4EB9 00001810            639                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000015CA  B47C 0001                640                  CMP.W       #1,D2                            ; Checks if it is word size
000015CE  6700 0014                641                  BEQ         REG_WORD                         ; Prints .W
000015D2  B47C 0002                642                  CMP.W       #2,D2                            ; Checks if it is long size
000015D6  6700 0016                643                  BEQ         REG_LONG                         ; Prints .L
000015DA                           644  
000015DA  4BF9 00001E21            645  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
000015E0  6000 0012                646                  BRA         PRINTREGEA      
000015E4                           647  
000015E4  4BF9 00001E27            648  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
000015EA  6000 0008                649                  BRA         PRINTREGEA      
000015EE                           650                             
000015EE  4BF9 00001E2D            651  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
000015F4                           652  
000015F4  4EB9 00001B1A            653  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
000015FA  3400                     654                  MOVE.W      D0,D2                            ; copies D0 to D1
000015FC  4EB9 00001818            655                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001602  B27C 0001                656                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001606  6700 0048                657                  BEQ         REG_REGISTER                     ; goes to ASd case if so
0000160A                           658                                  
0000160A  3400                     659  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
0000160C  4EB9 00001810            660                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001612  3202                     661                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001614  4BF9 00001E16            662                  LEA         MSG_POUND, A5                    ; loads # into A5
0000161A  4EB9 00001B1A            663                  JSR         PRINTNULL                        ; prints #
00001620  4EB9 000019D0            664                  JSR         PRINTNUM                         ; prints shift count
00001626  4BF9 00001E1A            665                  LEA         MSG_COMMA, A5                    ; loads , into A5
0000162C  4EB9 00001B1A            666                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001632  4BF9 00001E0A            667                  LEA         MSG_DR, A5                       ; loads D into A5
00001638  4EB9 00001B1A            668                  JSR         PRINTNULL                        ; prints out D 
0000163E  323C 0000                669                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001642  4EB9 0000175E            670                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001648  4EB9 000019D0            671                  JSR         PRINTNUM                         ; prints data register number in D1          
0000164E  4E75                     672                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001650                           673                  
00001650  3400                     674  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001652  4EB9 00001810            675                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001658  3202                     676                  MOVE.W      D2, D1                           ; moves rotation size to D1
0000165A  4BF9 00001E0A            677                  LEA         MSG_DR, A5                       ; loads D into A5
00001660  4EB9 00001B1A            678                  JSR         PRINTNULL                        ; prints D
00001666  4EB9 000019D0            679                  JSR         PRINTNUM                         ; prints register number
0000166C  4BF9 00001E1A            680                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001672  4EB9 00001B1A            681                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001678  4BF9 00001E0A            682                  LEA         MSG_DR, A5                       ; loads D into A5
0000167E  4EB9 00001B1A            683                  JSR         PRINTNULL                        ; prints out D 
00001684  323C 0000                684                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001688  4EB9 0000175E            685                  JSR         GET_XN                           ; gets the data register number, stores in D1
0000168E  4EB9 000019D0            686                  JSR         PRINTNUM                         ; prints data register number in D1          
00001694  4E75                     687                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001696                           688               
00001696  3200                     689  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001698  C27C FF00                690                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
0000169C  B27C 6000                691                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
000016A0  6600 0018                692                  BNE.W   CASE_BCC                             ; If its not, check BCC
000016A4                           693                  
000016A4  4BF9 00001DFE            694                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
000016AA  4EB9 00001B1A            695                  JSR     PRINTNULL                            ; prints BRA
000016B0                           696  
000016B0  3400                     697                  MOVE.W  D0,D2                                ; Copies instruction word to D1
000016B2  4EB9 000017D0            698                  JSR     GETDISPLACEMENT                      ; finds the displacement
000016B8  4E75                     699                  RTS
000016BA                           700                  
000016BA                           701  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
000016BA                           702  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
000016BA  3200                     703  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
000016BC  C27C F000                704                  AND.W   #$F000,D1                            ; get top 4 bits
000016C0  B27C 6000                705                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
000016C4  6600 0054                706                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
000016C8  3200                     707                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
000016CA  C27C 0F00                708                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
000016CE  E049                     709                  LSR.W   #8,D1                                ; shifts 8 bits to the right
000016D0                           710                  
000016D0  B27C 000E                711                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
000016D4  6700 002A                712                  BEQ     CASE_BGT                             ; branches to BGT if it is
000016D8                           713                  
000016D8  B27C 000F                714                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
000016DC  6700 0018                715                  BEQ     CASE_BLE                             ; branches to BLE if it is
000016E0                           716                      
000016E0  B27C 0007                717                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
000016E4  6700 0006                718                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
000016E8  6000 0046                719                  BRA     CASE_DATA                            ; BCC condition code not in the system
000016EC                           720     
000016EC  4BF9 00001D91            721  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
000016F2  6000 0016                722                  BRA     PRINTBCC
000016F6                           723  
000016F6  4BF9 00001DB9            724  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
000016FC  6000 000C                725                  BRA     PRINTBCC
00001700                           726                  
00001700  4BF9 00001DA9            727  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001706  6000 0002                728                  BRA     PRINTBCC
0000170A                           729  
0000170A  4EB9 00001B1A            730  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001710  3400                     731                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001712  4EB9 000017D0            732                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001718  4E75                     733                  RTS              
0000171A                           734                  
0000171A                           735  
0000171A                           736  CASE_JSR       
0000171A                           737  
0000171A  B07C 4E75                738  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
0000171E  6600 FA62                739                  BNE     CASE_MOVE           ; checks the next case if not equal
00001722  4BF9 00001DF9            740                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001728  4EB9 00001B1A            741                  JSR     PRINTNULL           ; prints RTS                
0000172E  4E75                     742                  RTS                         ; returns from the subroutine
00001730                           743  
00001730                           744                  
00001730                           745  
00001730                           746  CASE_DATA           
00001730  4E75                     747                      RTS               
00001732                           748  
00001732  4E75                     749  CASE_EPICFAIL       RTS
00001734                           750  
00001734                           751  
00001734                           752  * Finds the EA type
00001734                           753  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001734                           754  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001734  48E7 3000                755  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001738  4A41                     756                      TST.W     D1                    ; compares D1 to 0
0000173A  6700 000E                757                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
0000173E                           758                      
0000173E  343C 01C0                759  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001742  363C 0006                760                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001746  6000 000A                761                      BRA       FINDTYPEEA            
0000174A                           762  
0000174A  343C 0038                763  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
0000174E  363C 0003                764                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001752                           765  
00001752                           766  
00001752  3200                     767  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001754  C242                     768                      AND.W     D2,D1                 ; applies bitmask to D1
00001756  E669                     769                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001758  4CDF 000C                770                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
0000175C  4E75                     771                      RTS                             ; returns from subroutine    
0000175E                           772                      
0000175E                           773  * Finds Xn type
0000175E                           774  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
0000175E                           775  * Output: Addressing Mode (3 bits, 0 to 7) in D1
0000175E  48E7 3000                776  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001762  4A41                     777                      TST.W     D1                    ; compares D1 to 0
00001764  6700 000E                778                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001768                           779  
00001768  343C 0E00                780  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
0000176C  363C 0009                781                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001770  6000 000A                782                      BRA       FINDTYPEXN            ; finds the type of Xn
00001774                           783  
00001774  343C 0007                784  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001778  363C 0000                785                      MOVE.W    #0,D3                 ; stores the shift amount to D3
0000177C                           786                      
0000177C  3200                     787  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
0000177E  C242                     788                      AND.W     D2,D1                 ; applies bitmask to D1
00001780  E669                     789                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001782  4CDF 000C                790                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001786  4E75                     791                      RTS                             ; returns from subroutine 
00001788                           792                      
00001788                           793  * Checks and gets the EA and Xn
00001788                           794  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001788                           795  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001788  3207                     796  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
0000178A  4EB8 1734                797                  JSR     GET_EA                  ; Gets EA
0000178E  3401                     798                  MOVE.W  D1,D2                   ; Stores EA in D2
00001790  3207                     799                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001792  4EB8 175E                800                  JSR     GET_XN                  ; Gets Xn
00001796  3601                     801                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001798  3202                     802                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
0000179A                           803                  
0000179A  4EB9 00001820            804                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
000017A0  B27C 0002                805                  CMP.W   #2,D1                   ; checks if it is Xn
000017A4  6700 0012                806                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
000017A8  B27C 0001                807                  CMP.W   #1,D1                   ; Checks if it is invalid
000017AC  6700 001C                808                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
000017B0                           809                  
000017B0                           810                  
000017B0  323C 0000                811  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
000017B4  6000 0018                812                  BRA     END_CHECKGET
000017B8                           813        
000017B8                           814  ; need XN
000017B8  2A4E                     815  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
000017BA  3203                     816                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
000017BC  4EB9 00001820            817                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
000017C2  4A41                     818                  TST.W   D1                      ; checks if it is valid
000017C4  67EA                     819                  BEQ     EAXN_VALID              ; go to EA_VALID to print
000017C6  6000 0002                820                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
000017CA                           821   
000017CA  323C 0001                822  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
000017CE                           823  
000017CE  4E75                     824  END_CHECKGET    RTS          
000017D0                           825                                            
000017D0                           826                                            
000017D0                           827  * Gets the displacement and pritns it 
000017D0                           828  * Inputs: D2 = instruction word, A2 = address of next word
000017D0                           829  * Outputs: prints out displacement
000017D0  48E7 4004                830  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
000017D4  3A4A                     831                      MOVE.W    A2,A5                 ; copies A2 to A5
000017D6  C47C 00FF                832                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
000017DA  6600 0004                833                      BNE       PRINTADDRESS          ; prints address if not 0
000017DE  341A                     834                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
000017E0                           835                      
000017E0  D44D                     836  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
000017E2  3202                     837                      MOVE.W    D2,D1                 ; moves address to D1 for printing
000017E4  183C 0000                838                      MOVE.B    #0,D4                 ; marks address as word  length
000017E8  4BF9 00001E18            839                      LEA       MSG_HEX,A5            ; loads hex sign to A5
000017EE  4EB9 00001B1A            840                      JSR       PRINTNULL             ; prints null
000017F4  4EB9 000019F4            841                      JSR       PRINTSHORTLONGNUM     ; prints address
000017FA                           842                      
000017FA  4CDF 2002                843                      MOVEM.L    (SP)+,D1/A5              ; restores D1
000017FE                           844                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
000017FE                           845  
000017FE                           846  * Gets the rotation value for ASd and LSd
000017FE                           847  * Input: D2 = instruction word copy (of D0)                                    
000017FE                           848  * Output: rotation  value in D2             
000017FE  C47C 0E00                849  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001802  E04A                     850                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001804  E24A                     851                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001806  4E75                     852                      RTS                             ; return from subroutine
00001808                           853  
00001808                           854  * Gets the direction value for ASd and LSd
00001808                           855  * Input: D2 = instruction word copy (of D0)                                    
00001808                           856  * Output: direction value in D2             
00001808  C47C 0100                857  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
0000180C  E04A                     858                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
0000180E  4E75                     859                      RTS                             ; return from subroutine
00001810                           860  
00001810                           861  * Gets the rotation size value for ASd and LSd
00001810                           862  * Input: D2 = instruction word copy (of D0)                                    
00001810                           863  * Output: rotation size value in D2             
00001810  C47C 00C0                864  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001814  EC4A                     865                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001816  4E75                     866                      RTS                             ; return from subroutine
00001818                           867  
00001818                           868  * Gets the rotation location  value for ASd and LSd
00001818                           869  * Input: D2 = instruction word copy (of D0)                                    
00001818                           870  * Output: rotation location value in D2             
00001818  C47C 0020                871  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
0000181C  EA4A                     872                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
0000181E  4E75                     873                      RTS                             ; return from subroutine
00001820                           874  
00001820                           875                          
00001820                           876  * Checks if EA or Xn is valid
00001820                           877  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001820                           878  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001820  2F02                     879  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001822                           880  
00001822  141D                     881  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001824  B43C 00FF                882                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001828  6700 000A                883                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
0000182C  B202                     884                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
0000182E  6700 000C                885                     BEQ        VALIDEA               ; branches to valid EA
00001832  60EE                     886                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001834                           887                     
00001834  323C 0001                888  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001838  6000 0016                889                     BRA        CHECKEAEXIT           ; exists the subroutine        
0000183C                           890                    
0000183C  B43C 0007                891  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001840  6700 000A                892                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001844  323C 0000                893                     MOVE.W     #$0,D1                ; marks that it is valid
00001848  6000 0006                894                     BRA        CHECKEAEXIT           ; exits the subroutine
0000184C                           895  
0000184C  323C 0002                896  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001850                           897  
00001850  241F                     898  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001852  4E75                     899                     RTS                              ; returns from subroutine
00001854                           900  
00001854                           901  * Converts EA and Xn into a string                                
00001854                           902  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001854                           903  * Outputs: Prints out EA and Xn into a string
00001854  48E7 C004                904  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001858  B47C 0001                905                     CMP.W    #An,D2                  ; checks if it is An
0000185C  6700 003A                906                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001860                           907                     
00001860  B47C 0002                908                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001864  6700 004A                909                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001868                           910                     
00001868  B47C 0003                911                     CMP.W    #AnPost,D2              ; checks if it is (An)+
0000186C  6700 0072                912                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001870                           913                     
00001870  B47C 0004                914                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001874  6700 00A6                915                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001878                           916                     
00001878  B47C 0007                917                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
0000187C  6700 00DA                918                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001880                           919                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001880                           920  
00001880                           921  * data register, Dn
00001880  4BF9 00001E0A            922  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001886  4EB9 00001B1A            923                     JSR      PRINTNULL               ; Prints D
0000188C  3203                     924                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000188E  4EB9 000019D0            925                     JSR      PRINTNUM                ; Prints the Xn
00001894  6000 0134                926                     BRA      EA_TO_STRING_EXIT       ; exits           
00001898                           927  
00001898                           928  
00001898                           929  * address register
00001898  4BF9 00001E0C            930  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
0000189E  4EB9 00001B1A            931                     JSR      PRINTNULL               ; Prints A
000018A4  3203                     932                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000018A6  4EB9 000019D0            933                     JSR      PRINTNUM                ; Prints the Xn
000018AC  6000 011C                934                     BRA      EA_TO_STRING_EXIT       ; exits
000018B0                           935  
000018B0                           936  * address register indirect
000018B0  4BF9 00001E0E            937  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
000018B6  4EB9 00001B1A            938                     JSR      PRINTNULL               ; Prints (
000018BC  4BF9 00001E0C            939                     LEA      MSG_AR,A5               ; Loads A into A5
000018C2  4EB9 00001B1A            940                     JSR      PRINTNULL               ; Prints A
000018C8  3203                     941                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000018CA  4EB9 000019D0            942                     JSR      PRINTNUM                ; Prints the Xn
000018D0  4BF9 00001E10            943                     LEA      MSG_RB,A5               ; Loads ) into A5
000018D6  4EB9 00001B1A            944                     JSR      PRINTNULL               ; Prints )
000018DC  6000 00EC                945                     BRA      EA_TO_STRING_EXIT       ; exits
000018E0                           946  
000018E0                           947  * address register indirect post increment
000018E0  4BF9 00001E0E            948  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
000018E6  4EB9 00001B1A            949                     JSR      PRINTNULL               ; Prints (
000018EC  4BF9 00001E0C            950                     LEA      MSG_AR,A5               ; Loads A into A5
000018F2  4EB9 00001B1A            951                     JSR      PRINTNULL               ; Prints A
000018F8  3203                     952                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000018FA  4EB9 000019D0            953                     JSR      PRINTNUM                ; Prints the Xn
00001900  4BF9 00001E10            954                     LEA      MSG_RB,A5               ; Loads ) into A5
00001906  4EB9 00001B1A            955                     JSR      PRINTNULL               ; Prints )
0000190C  4BF9 00001E12            956                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001912  4EB9 00001B1A            957                     JSR      PRINTNULL               ; Prints +
00001918  6000 00B0                958                     BRA      EA_TO_STRING_EXIT       ; exits
0000191C                           959  
0000191C                           960  
0000191C                           961  * address register indirect pre increment
0000191C  4BF9 00001E14            962  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001922  4EB9 00001B1A            963                     JSR      PRINTNULL               ; Prints -
00001928  4BF9 00001E0E            964                     LEA      MSG_LB,A5               ; Loads ( into A5
0000192E  4EB9 00001B1A            965                     JSR      PRINTNULL               ; Prints (
00001934  4BF9 00001E0C            966                     LEA      MSG_AR,A5               ; Loads A into A5
0000193A  4EB9 00001B1A            967                     JSR      PRINTNULL               ; Prints A
00001940  3203                     968                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001942  4EB9 000019D0            969                     JSR      PRINTNUM                ; Prints the Xn
00001948  4BF9 00001E10            970                     LEA      MSG_RB,A5               ; Loads ) into A5
0000194E  4EB9 00001B1A            971                     JSR      PRINTNULL               ; Prints )
00001954  6000 0074                972                     BRA      EA_TO_STRING_EXIT       ; exits
00001958                           973  
00001958                           974  * other (long, short, immediate) with Xn yes
00001958  301A                     975  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
0000195A  B67C 0000                976                     CMP.W    #ABSShort,D3            ; checks if it is a word
0000195E  6700 002E                977                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001962                           978                     
00001962  B67C 0001                979                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001966  6700 0042                980                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
0000196A                           981  
0000196A                           982  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
0000196A                           983  * immediate
0000196A  4BF9 00001E16            984  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001970  4EB9 00001B1A            985                     JSR      PRINTNULL               ; Prints #  
00001976  4BF9 00001E18            986                     LEA      MSG_HEX,A5              ; Loads $ into A5
0000197C  4EB9 00001B1A            987                     JSR      PRINTNULL               ; Prints $
00001982  3200                     988                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001984  4EB9 000019E0            989                     JSR      PRINTHEXNUM 
0000198A  6000 003E                990                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
0000198E                           991                     
0000198E                           992  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
0000198E                           993  
0000198E                           994  * word address
0000198E                           995  CASE_WORD          
0000198E  4BF9 00001E18            996                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001994  4EB9 00001B1A            997                     JSR      PRINTNULL               ; Prints $
0000199A  3200                     998                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000199C  383C 0000                999                     MOVE.W   #0, D4                  ; moves length size (word) into d4
000019A0  4EB9 000019F4           1000                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000019A6  6000 0022               1001                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
000019AA                          1002  
000019AA                          1003  * long address 
000019AA                          1004  CASE_LONG          
000019AA  4BF9 00001E18           1005                     LEA      MSG_HEX,A5              ; Loads $ into A5
000019B0  4EB9 00001B1A           1006                     JSR      PRINTNULL               ; Prints $
000019B6  3200                    1007                     MOVE.W   D0, D1                  ; moves instruction word into d1
000019B8  383C 0001               1008                     MOVE.W   #1, D4                  ; moves length size (long) into d4
000019BC  4EB9 000019F4           1009                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000019C2  321A                    1010                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
000019C4  4EB9 000019D0           1011                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
000019CA                          1012  
000019CA                          1013  
000019CA                          1014  * exits subroutine
000019CA  4CDF 2003               1015  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
000019CE  4E75                    1016                      RTS                              ; returns from subroutine
000019D0                          1017  
000019D0                          1018  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
000019D0                          1019  
000019D0                          1020  * Prints out the content of D1 as a decimal number
000019D0                          1021  * Input: number in D1 to be printed
000019D0                          1022  * Output: contents of D1 printed
000019D0  48E7 C000               1023  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000019D4  103C 0003               1024                   MOVE.B      #3,D0               ; prints D1
000019D8  4E4F                    1025                   TRAP        #15                 ; is trap task 3
000019DA                          1026              
000019DA  4CDF 0003               1027                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000019DE  4E75                    1028                   RTS                             ; returns from subroutine
000019E0                          1029                   
000019E0                          1030  * Prints out the content of D1 as a hex number
000019E0                          1031  * Input: number in D1 to be printed
000019E0                          1032  * Output: contents of D1 printed
000019E0  48E7 C000               1033  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000019E4  143C 0010               1034                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000019E8  103C 000F               1035                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000019EC  4E4F                    1036                   TRAP        #15                 ; is trap task 15
000019EE  4CDF 0003               1037                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000019F2  4E75                    1038                   RTS                             ; returns from subroutine
000019F4                          1039                   
000019F4                          1040  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
000019F4                          1041  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
000019F4                          1042  * Output: contents of D1 printed
000019F4  48E7 E000               1043  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
000019F8  B83C 0001               1044                            CMP.B       #1,D4               ; checks size of number
000019FC  6700 0042               1045                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001A00                          1046  
00001A00  3401                    1047  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001A02  C47C F000               1048                            AND.W       #$F000,D2           ; gets the first digit
00001A06  B47C 0000               1049                            CMP.W       #0, D2              ; checks if it is 0
00001A0A  6600 00DC               1050                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A0E  4EB9 00001AF8           1051                            JSR         PRINTZERO           ; prints a zero
00001A14                          1052                            
00001A14  3401                    1053                            MOVE.W      D1,D2               ; copies number to D2
00001A16  C47C 0F00               1054                            AND.W       #$0F00,D2           ; gets the second digit
00001A1A  B47C 0000               1055                            CMP.W       #0, D2              ; checks if it is 0
00001A1E  6600 00C8               1056                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A22  4EB9 00001AF8           1057                            JSR         PRINTZERO           ; prints a zero
00001A28                          1058                            
00001A28  3401                    1059                            MOVE.W      D1,D2               ; copies number to D2
00001A2A  C47C 00F0               1060                            AND.W       #$00F0,D2           ; gets the third digit
00001A2E  B47C 0000               1061                            CMP.W       #0, D2              ; checks if it is 0
00001A32  6600 00B4               1062                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A36  4EB9 00001AF8           1063                            JSR         PRINTZERO           ; prints a zero
00001A3C  6000 00AA               1064                            BRA         PRINTASHEX          ; prints last digit
00001A40                          1065                            
00001A40  2401                    1066  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001A42  C4BC F0000000           1067                            AND.L       #$F0000000,D2       ; gets the first digit
00001A48  B4BC 00000000           1068                            CMP.L       #0, D2              ; checks if it is 0
00001A4E  6600 0098               1069                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A52  4EB9 00001AF8           1070                            JSR         PRINTZERO           ; prints a zero
00001A58                          1071                            
00001A58  2401                    1072                            MOVE.L      D1,D2               ; copies number to D2
00001A5A  C4BC 0F000000           1073                            AND.L       #$0F000000,D2       ; gets the second digit
00001A60  B4BC 00000000           1074                            CMP.L       #0, D2              ; checks if it is 0
00001A66  6600 0080               1075                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A6A  4EB9 00001AF8           1076                            JSR         PRINTZERO           ; prints a zero
00001A70                          1077                            
00001A70  2401                    1078                            MOVE.L      D1,D2               ; copies number to D2
00001A72  C4BC 00F00000           1079                            AND.L       #$00F00000,D2       ; gets the third digit
00001A78  B4BC 00000000           1080                            CMP.L       #0, D2              ; checks if it is 0
00001A7E  6600 0068               1081                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A82  4EB9 00001AF8           1082                            JSR         PRINTZERO           ; prints a zero
00001A88                          1083                            
00001A88  2401                    1084                            MOVE.L      D1,D2               ; copies number to D2
00001A8A  C4BC 000F0000           1085                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001A90  B4BC 00000000           1086                            CMP.L       #0, D2              ; checks if it is 0
00001A96  6600 0050               1087                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001A9A  4EB9 00001AF8           1088                            JSR         PRINTZERO           ; prints a zero
00001AA0                          1089                            
00001AA0  2401                    1090                            MOVE.L      D1,D2               ; copies number to D2
00001AA2  C4BC 0000F000           1091                            AND.L       #$0000F000,D2       ; gets the fith digit
00001AA8  B4BC 00000000           1092                            CMP.L       #0, D2              ; checks if it is 0
00001AAE  6600 0038               1093                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001AB2  4EB9 00001AF8           1094                            JSR         PRINTZERO           ; prints a zero
00001AB8                          1095                            
00001AB8  2401                    1096                            MOVE.L      D1,D2               ; copies number to D2
00001ABA  C4BC 00000F00           1097                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001AC0  B4BC 00000000           1098                            CMP.L       #0, D2              ; checks if it is 0
00001AC6  6600 0020               1099                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001ACA  4EB9 00001AF8           1100                            JSR         PRINTZERO           ; prints a zero
00001AD0                          1101                            
00001AD0  2401                    1102                            MOVE.L      D1,D2               ; copies number to D2
00001AD2  C4BC 000000F0           1103                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001AD8  B4BC 00000000           1104                            CMP.L       #0, D2              ; checks if it is 0
00001ADE  6600 0008               1105                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001AE2  4EB9 00001AF8           1106                            JSR         PRINTZERO           ; prints a zero
00001AE8                          1107  
00001AE8  143C 0010               1108  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001AEC  103C 000F               1109                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001AF0  4E4F                    1110                            TRAP        #15                 ; is trap task 15
00001AF2  4CDF 0007               1111                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001AF6  4E75                    1112                            RTS                             ; returns from subroutine    
00001AF8                          1113  * Prints a zero
00001AF8                          1114  * Input: nothing
00001AF8                          1115  * Output: 0 printed out to the console
00001AF8  2F01                    1116  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001AFA  7200                    1117                            MOVE.L      #0,D1               ; moves 0 to D1
00001AFC  4EB8 19D0               1118                            JSR         PRINTNUM            ; prints the number
00001B00  221F                    1119                            MOVE.L      (SP)+,D1            ; restores D1
00001B02  4E75                    1120                            RTS                             ; returns from subroutine
00001B04                          1121              
00001B04                          1122  * Prints contents of things between a range
00001B04                          1123  * input: A5, A6 (the range)
00001B04                          1124  * output: prints memory contents from A5 to A6 as strings   
00001B04  48E7 C040               1125  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001B08  224D                    1126                  MOVEA.L     A5, A1           ; loads A5 into A1
00001B0A  9DCD                    1127                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001B0C  320E                    1128                  MOVE.W      A6, D1           ; move n into D1
00001B0E  103C 0001               1129                  MOVE.B      #1, D0           ; display n characters of string at A1
00001B12  4E4F                    1130                  TRAP        #15              ; is trap task 1
00001B14  4CDF 0203               1131                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001B18  4E75                    1132                  RTS                          ; returns
00001B1A                          1133      
00001B1A                          1134  * Prints null terminated string
00001B1A                          1135  * input: string pointed to by A5
00001B1A                          1136  * output: prints out the null terminated string
00001B1A  48E7 8040               1137  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001B1E  224D                    1138                  MOVE.L      A5,A1           ; loads A5 into A1
00001B20  103C 000E               1139                  MOVE.B      #14,D0          ; prints null terminated string
00001B24  4E4F                    1140                  TRAP        #15             ; is trap task 10
00001B26  4CDF 0201               1141                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001B2A  4E75                    1142                  RTS                         ; returns from subroutine
00001B2C                          1143                  
00001B2C  2F0D                    1144  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001B2E  4BF9 00001D16           1145                  LEA         NEW_LINE,A5     ; Prints null
00001B34  4EB8 1B1A               1146                  JSR         PRINTNULL       ; prints the new line
00001B38  2A5F                    1147                  MOVE.L      (SP)+,A5        ; returns A5
00001B3A  4E75                    1148                  RTS
00001B3C                          1149  
00001B3C                          1150  * Prints the size of the MOVE or MOVEA operation  
00001B3C                          1151  * input: D0
00001B3C                          1152  * output: prints out the size of a MOVE or MOVEA operation        
00001B3C  48E7 8004               1153  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001B40  3200                    1154                  MOVE.W  D0,D1               ; stores d0 in d1
00001B42  C07C 3000               1155                  AND.W   #$3000,D0           ; gets the size
00001B46  B07C 2000               1156                  CMP.W   #$2000,D0           ; checks if is long
00001B4A  6700 001E               1157                  BEQ     MOVE_LONG
00001B4E  B07C 3000               1158                  CMP.W   #$3000,D0           ; checks if is word
00001B52  6700 000C               1159                  BEQ     MOVE_WORD      
00001B56                          1160                  
00001B56  4BF9 00001E21           1161  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001B5C  6000 0012               1162                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001B60                          1163  
00001B60  4BF9 00001E27           1164  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001B66  6000 0008               1165                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001B6A                          1166  
00001B6A  4BF9 00001E2D           1167  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001B70                          1168                  
00001B70  4EB8 1B1A               1169  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001B74  4CDF 2001               1170                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001B78  4E75                    1171                  RTS
00001B7A                          1172  
00001B7A  43F9 00001CFA           1173  ERROR           LEA     ERROR_MSG,A1
00001B80  103C 000E               1174                  MOVE.B  #14,D0
00001B84  4E4F                    1175                  TRAP    #15 
00001B86                          1176         
00001B86                          1177  * DELETE THIS: Test                
00001B86  2661                    1178  DELETEME        MOVEA.L  -(A1),A3
00001B88  6700 002A               1179                  BEQ      DELETEMEAGAIN  
00001B8C  6F00 0026               1180                  BLE      DELETEMEAGAIN
00001B90  6E00 0022               1181                  BGT      DELETEMEAGAIN
00001B94                          1182  
00001B94  E40A                    1183                  LSR.B      #2,D2
00001B96  E2E2                    1184                  LSR.W      -(A2)
00001B98  E2DA                    1185                  LSR.W      (A2)+
00001B9A  E4AA                    1186                  LSR.L      D2,D2 
00001B9C  E50A                    1187                  LSL.B      #2,D2
00001B9E  E3E2                    1188                  LSL.W      -(A2)
00001BA0  E3DA                    1189                  LSL.W      (A2)+
00001BA2  E5AA                    1190                  LSL.L      D2,D2
00001BA4  E51A                    1191                  ROL.B      #2,D2
00001BA6  E7E2                    1192                  ROL.W      -(A2)
00001BA8  E7DA                    1193                  ROL.W      (A2)+
00001BAA  E5BA                    1194                  ROL.L      D2,D2
00001BAC  E41A                    1195                  ROR.B      #2,D2
00001BAE  E6E2                    1196                  ROR.W      -(A2)
00001BB0  E6DA                    1197                  ROR.W      (A2)+
00001BB2  E4BA                    1198                  ROR.L      D2,D2
00001BB4                          1199                         
00001BB4                          1200                  
00001BB4                          1201  DELETEMEAGAIN                 
00001BB4                          1202            
00001BB4  FFFF FFFF               1203      SIMHALT             ; halt simulator
00001BB8                          1204  
00001BB8                          1205  * Put variables and constants here
00001BB8                          1206  
00001BB8  =0000000D               1207  CR                              EQU     $0D
00001BB8  =0000000A               1208  LF                              EQU     $0A 
00001BB8  =00000009               1209  TAB                             EQU     $09  
00001BB8                          1210  
00001BB8                          1211  * Addressing Modes
00001BB8  =00000000               1212  Dn                              EQU     0
00001BB8  =00000001               1213  An                              EQU     1
00001BB8  =00000002               1214  AnIndirect                      EQU     2
00001BB8  =00000003               1215  AnPost                          EQU     3
00001BB8  =00000004               1216  AnPre                           EQU     4
00001BB8  =00000007               1217  Other                           EQU     7           ; short, long, immediate
00001BB8                          1218  
00001BB8                          1219  * Xn
00001BB8  =00000000               1220  ABSShort                        EQU     0
00001BB8  =00000001               1221  ABSLong                         EQU     1
00001BB8  =00000004               1222  XnImmediate                     EQU     4
00001BB8                          1223  
00001BB8                          1224  * Valid Addressing Modes
00001BB8= 00 01 02 03 04 07 FF    1225  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001BBF                          1226  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001BBF= 00 02 03 04 07 FF       1227  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001BC5= 02 04 07 FF             1228  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001BC9= 02 03 07 FF             1229  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001BCD= 02 03 04 07 FF          1230  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001BD2= 00 02 03 04 07 FF       1231  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001BD8= 01 07 FF                1232  VALIDEA_LEA                     DC.B    An,Other,-1
00001BDB= 00 02 03 04 07 FF       1233  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001BE1= 02 03 04 07 FF          1234  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001BE6= 02 03 04 07 FF          1235  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001BEB= 02 07 FF                1236  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001BEE                          1237  
00001BEE                          1238  * Valid Xn
00001BEE= 00 01 04 FF             1239  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001BF2                          1240  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001BF2= 00 01 FF                1241  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001BF5                          1242  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001BF5                          1243  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001BF5                          1244  
00001BF5                          1245  * posible memory ASd/LSd rotation values
00001BF5  =00000000               1246  ASd_MEM                         EQU     0   
00001BF5  =00000001               1247  LSd_MEM                         EQU     1 
00001BF5  =00000003               1248  ROd_MEM                         EQU     3
00001BF5                          1249   
00001BF5  =00000000               1250  ASd_REG                         EQU     0   
00001BF5  =00000001               1251  LSd_REG                         EQU     1 
00001BF5  =00000003               1252  ROd_REG                         EQU     3
00001BF5                          1253  
00001BF5                          1254  * Starting messages
00001BF5= 57 65 6C 63 6F 6D ...   1255  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001C1C= 46 6F 72 6D 61 74 ...   1256                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001C6B= 50 6C 65 61 73 65 ...   1257  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001CA2= 50 6C 65 61 73 65 ...   1258  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001CD8= 49 6E 76 61 6C 69 ...   1259  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001CFA= 45 72 72 6F 72 20 ...   1260  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001D16= 0D 0A 00                1261  NEW_LINE                        DC.B    CR,LF,0
00001D19= 09 09 09 00             1262  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001D1D                          1263  
00001D1D                          1264  * Opcode Messages
00001D1D= 09 4E 4F 50 00          1265  MSG_NOP                         DC.B    TAB,'NOP',0
00001D22= 09 4D 4F 56 45 00       1266  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001D28= 09 4D 4F 56 45 41 00    1267  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001D2F= 09 4D 4F 56 45 51 00    1268  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001D36= 09 4D 4F 56 45 4D 00    1269  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001D3D= 09 41 44 44 00          1270  MSG_ADD                         DC.B    TAB,'ADD',0
00001D42= 09 41 44 44 41 00       1271  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001D48= 09 41 44 44 51 00       1272  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001D4E= 09 53 55 42 00          1273  MSG_SUB                         DC.B    TAB,'SUB',0
00001D53= 09 4D 55 4C 53 00       1274  MSG_MULS                        DC.B    TAB,'MULS',0
00001D59= 09 44 49 56 55 00       1275  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001D5F= 09 4C 45 41 09 09 ...   1276  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001D67= 09 41 4E 44 00          1277  MSG_AND                         DC.B    TAB,'AND',0
00001D6C= 09 4F 52 00             1278  MSG_OR                          DC.B    TAB,'OR',0
00001D70= 09 4E 4F 54 00          1279  MSG_NOT                         DC.B    TAB,'NOT',0
00001D75= 09 4C 53 00             1280  MSG_LSd                         DC.B    TAB,'LS',0
00001D79= 09 41 53 00             1281  MSG_ASd                         DC.B    TAB,'AS',0
00001D7D= 09 52 4F 00             1282  MSG_ROd                         DC.B    TAB,'RO',0
00001D81= 09 42 43 43 09 09 ...   1283  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001D89= 09 42 43 53 09 09 ...   1284  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001D91= 09 42 45 51 09 09 ...   1285  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001D99= 09 42 4E 45 09 09 ...   1286  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001DA1= 09 42 47 45 09 09 ...   1287  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001DA9= 09 42 47 54 09 09 ...   1288  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001DB1= 09 42 48 49 09 09 ...   1289  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001DB9= 09 42 4C 45 09 09 ...   1290  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001DC1= 09 42 4C 53 09 09 ...   1291  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001DC9= 09 42 4C 54 09 09 ...   1292  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001DD1= 09 42 4D 49 09 09 ...   1293  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001DD9= 09 42 50 4C 09 09 ...   1294  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001DE1= 09 42 56 43 09 09 ...   1295  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001DE9= 09 42 56 53 09 09 ...   1296  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001DF1= 09 4A 53 52 09 09 ...   1297  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001DF9= 09 52 54 53 00          1298  MSG_RTS                         DC.B    TAB,'RTS',0
00001DFE= 09 42 52 41 09 09 ...   1299  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001E06                          1300  
00001E06                          1301  * Direction for LSd and ASd
00001E06= 52 00                   1302  MSG_RIGHT                       DC.B    'R',0
00001E08= 4C 00                   1303  MSG_LEFT                        DC.B    'L',0
00001E0A                          1304  
00001E0A                          1305  * Effective Addresses Messages
00001E0A= 44 00                   1306  MSG_DR                          DC.B    'D',0
00001E0C= 41 00                   1307  MSG_AR                          DC.B    'A',0
00001E0E= 28 00                   1308  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001E10= 29 00                   1309  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001E12= 2B 00                   1310  MSG_PLUS                        DC.B    '+',0
00001E14= 2D 00                   1311  MSG_MINUS                       DC.B    '-',0
00001E16= 23 00                   1312  MSG_POUND                       DC.B    '#',0 
00001E18= 24 00                   1313  MSG_HEX                         DC.B    '$',0 
00001E1A= 2C 20 00                1314  MSG_COMMA                       DC.B    ', ',0 
00001E1D= 20 00                   1315  MSG_SPACE                       DC.B    ' ',0
00001E1F= 09 00                   1316  MSG_TAB                         DC.B    TAB,0
00001E21                          1317  
00001E21                          1318  * Size Messages
00001E21= 2E 42 09 09 09 00       1319  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001E27= 2E 57 09 09 09 00       1320  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001E2D= 2E 4C 09 09 09 00       1321  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001E33                          1322  
00001E33                          1323  * Variables
00001E33  =00000100               1324  STARTING_ADDRESS                EQU     $100
00001E33  =00000150               1325  ENDING_ADDRESS                  EQU     $150
00001E33  =00000200               1326  CURRENT_INSTR                   EQU     $200
00001E33  =00000250               1327  REG_VAR                         EQU     $250 * Hold bits 11-9
00001E33  =00000300               1328  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001E33  =00000350               1329  EA_MODE                         EQU     $350 * Hold bits 5-3
00001E33  =00000400               1330  EA_REG                          EQU     $400 * Hold bits 2-0
00001E33                          1331  
00001E33                          1332              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADD_BYTE            1352
ADD_LONG            1372
ADD_WORD            1362
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1CD8
CASE_ADD            12DE
CASE_ADDA           13E8
CASE_ADDQ           13E8
CASE_AND            147A
CASE_AR             1898
CASE_ARI            18B0
CASE_ARIPOST        18E0
CASE_ARIPRE         191C
CASE_ASDMEM         14BA
CASE_ASDREG         1582
CASE_BCC            16BA
CASE_BEQ            16EC
CASE_BGT            1700
CASE_BLE            16F6
CASE_BRA            1696
CASE_DATA           1730
CASE_DR             1880
CASE_EPICFAIL       1732
CASE_IMMEDIATE      196A
CASE_JSR            171A
CASE_LEA            13E8
CASE_LEFTMEM        14E0
CASE_LEFTREG        15A8
CASE_LONG           19AA
CASE_LSDASD         147A
CASE_LSDMEM         14B0
CASE_LSDREG         1578
CASE_MOVE           1182
CASE_MOVEM          1224
CASE_MOVEQ          128A
CASE_NOP            116C
CASE_NOT            147A
CASE_OR             147A
CASE_OTHER          1958
CASE_RIGHTMEM       14EA
CASE_RIGHTREG       15B2
CASE_RODMEM         14C4
CASE_RODREG         158C
CASE_RTS            171A
CASE_SHIFTMEM       1498
CASE_SHIFTREG       155E
CASE_SUB            13E8
CASE_WORD           198E
CHECKEAEXIT         1850
CHECKEAMLOOP        1822
CHECKEAXN_IFVALID   1820
CHECKGET_EAXN       1788
CHECKMEMSOURE       151E
CHECKSHIFT_XN       1548
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            17B8
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1B86
DELETEMEAGAIN       1BB4
DESTEA              173E
DESTXN              1768
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          13BC
EASHIFT_VALID       153C
EAXN_INVALID        17CA
EAXN_VALID          17B0
EA_MODE             350
EA_REG              400
EA_TO_STRING        1854
EA_TO_STRING_EXIT   19CA
ENDING              1CA2
ENDING_ADDRESS      150
END_CHECKGET        17CE
ERROR               1B7A
ERROR_MSG           1CFA
FINDTYPEEA          1752
FINDTYPEXN          177C
FINISHMOVE          1B70
FINISH_ADD          1382
GETDIRECTION        1808
GETDISPLACEMENT     17D0
GETMEMSOURCE        1506
GETROTATION         17FE
GETROTATIONLOCATION  1818
GETROTATIONSIZE     1810
GET_EA              1734
GET_XN              175E
INPUT1              100C
INPUT2              1052
INSERTA             11F0
INVALID             112C
INVALIDEA           1834
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128A
MOVEM_REG2MEM       125A
MOVE_BYTE           1B56
MOVE_LONG           1B6A
MOVE_WORD           1B60
MSG_ADD             1D3D
MSG_ADDA            1D42
MSG_ADDQ            1D48
MSG_AND             1D67
MSG_AR              1E0C
MSG_ASD             1D79
MSG_B               1E21
MSG_BCC             1D81
MSG_BCS             1D89
MSG_BEQ             1D91
MSG_BGE             1DA1
MSG_BGT             1DA9
MSG_BHI             1DB1
MSG_BLE             1DB9
MSG_BLS             1DC1
MSG_BLT             1DC9
MSG_BMI             1DD1
MSG_BNE             1D99
MSG_BPL             1DD9
MSG_BRA             1DFE
MSG_BVC             1DE1
MSG_BVS             1DE9
MSG_COMMA           1E1A
MSG_DIVU            1D59
MSG_DR              1E0A
MSG_HEX             1E18
MSG_JSR             1DF1
MSG_L               1E2D
MSG_LB              1E0E
MSG_LEA             1D5F
MSG_LEFT            1E08
MSG_LSD             1D75
MSG_MINUS           1E14
MSG_MOVE            1D22
MSG_MOVEA           1D28
MSG_MOVEM           1D36
MSG_MOVEQ           1D2F
MSG_MULS            1D53
MSG_NOP             1D1D
MSG_NOT             1D70
MSG_OR              1D6C
MSG_PLUS            1E12
MSG_POUND           1E16
MSG_RB              1E10
MSG_RIGHT           1E06
MSG_ROD             1D7D
MSG_RTS             1DF9
MSG_SPACE           1E1D
MSG_SUB             1D4E
MSG_TAB             1E1F
MSG_W               1E27
NEW_LINE            1D16
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OTHER               7
OTHEREA             184C
PRINTADD            1334
PRINTADDRESS        17E0
PRINTASHEX          1AE8
PRINTBCC            170A
PRINTENTER          1B2C
PRINTHEXNUM         19E0
PRINTLONGZERO       1A40
PRINTMOVE           11F6
PRINTMOVESIZE       1B3C
PRINTNULL           1B1A
PRINTNUM            19D0
PRINTRANGE          1B04
PRINTREGEA          15F4
PRINTREGSIZE        15C2
PRINTSHIFTMEM       14CA
PRINTSHIFTREG       1592
PRINTSHORTLONGNUM   19F4
PRINTSHORTZERO      1A00
PRINTZERO           1AF8
PRINT_MEMDIR        14F0
PRINT_MOVEQ         12AC
PRINT_REGDIR        15BC
REG2MEMXNCHECK      1274
REG_BYTE            15DA
REG_IMMEDIATE       160A
REG_LONG            15EE
REG_REGISTER        1650
REG_VAR             250
REG_WORD            15E4
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            174A
SOURCEXN            1774
START               1000
STARTING            1C6B
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           1D19
VALIDEA             183C
VALIDEA_ADDSUB_DESTOPERAND  1BCD
VALIDEA_ALL         1BB8
VALIDEA_ANDORNOT    1BDB
VALIDEA_ANDOR_DESTOPERAND  1BE1
VALIDEA_JSR         1BEB
VALIDEA_LEA         1BD8
VALIDEA_MOVEM_MEMTOREG  1BC9
VALIDEA_MOVEM_REGTOMEM  1BC5
VALIDEA_MOVEQ       1BBF
VALIDEA_MULSDIVU    1BD2
VALIDEA_SHIFT       1BE6
VALIDXN_ALL         1BEE
VALIDXN_SHORTLONG   1BF2
WELCOME             1BF5
XNIMMEDIATE         4
