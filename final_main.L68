00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/7/2020 6:42:35 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001E85             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 00001EFB             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CC             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DE             28                  JSR     CONVERT
0000103E  4EB9 0000114A             29                  JSR     TEST_RANGE
00001044  4EB9 00001162             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001F32             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CC             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DE             47                  JSR     CONVERT
00001086  4EB9 0000114A             48                  JSR     TEST_RANGE
0000108C  4EB9 00001162             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0022                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  7801                      59                  MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010A8  4EB9 00001C7E             60                  JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010AE  4EB9 0000116A             61                  JSR     OPCODE_DECODE       ; decode the opcode
000010B4  4EB9 00001DB6             62                  JSR     PRINTENTER          ; prints a new line
000010BA  B5CB                      63                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BC  6FE6                      64                  BLE     DISASSEMBLE         ; if not, loop
000010BE                            65  
000010BE  103C 0009                 66  STOP            MOVE.B  #9,D0
000010C2  4E4F                      67                  TRAP    #15
000010C4                            68  
000010C4                            69  *--------------------SUBROUTINES------------------    
000010C4                            70  
000010C4  143C 0001                 71  RESET_INPUT     MOVE.B  #1,D2
000010C8  6000 0062                 72                  BRA     INVALID            
000010CC                            73                  
000010CC  7800                      74  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CE  B204                      75                  CMP.B   D4,D1               ; D1 stores length
000010D0  6700 005A                 76                  BEQ     INVALID             ; input is null
000010D4  0C41 0008                 77                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D8  6600 0052                 78                  BNE     INVALID             ; input is longer than a longword
000010DC  4E75                      79                  RTS
000010DE                            80                              
000010DE  4283                      81  CONVERT         CLR.L   D3
000010E0  4284                      82                  CLR.L   D4
000010E2  1619                      83                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E4  B63C 0039                 84                  CMP.B   #57,D3
000010E8  6E00 0012                 85                  BGT     NOTNUMBER
000010EC                            86                  
000010EC  B63C 002F                 87                  CMP.B   #47,D3
000010F0  6E00 0002                 88                  BGT     ISNUMBER
000010F4                            89                  
000010F4  0603 00D0                 90  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F8  6000 001A                 91                  BRA     CONCAT
000010FC                            92              
000010FC  B63C 0041                 93  NOTNUMBER       CMP.B   #65,D3
00001100  6D00 002A                 94                  BLT     INVALID
00001104  B63C 0046                 95                  CMP.B   #70,D3
00001108  6E00 0022                 96                  BGT     INVALID  
0000110C  0603 00C9                 97                  ADD.B   #-55,D3             ; is letter             
00001110  6000 0002                 98                  BRA     CONCAT
00001114                            99              
00001114  BC3C 0000                100  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001118  6D00 0010                101                  BLT     RETURN
0000111C  1806                     102                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111E  E50C                     103                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001120  E9AB                     104                  LSL.L   D4,D3               ; moves current char to correct position  
00001122  DA83                     105                  ADD.L   D3,D5               ; D5 stores converted input so far
00001124  0606 00FF                106                  ADD.B   #-1,D6  
00001128  60B4                     107                  BRA     CONVERT             ; continue loop for remaining chars
0000112A                           108                  
0000112A  4E75                     109  RETURN          RTS
0000112C                           110                  
0000112C  227C 00000000            111  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001132  43F9 00001F68            112                  LEA     BAD_INPUT,A1        ; output invalid message
00001138  103C 000E                113                  MOVE.B  #14,D0
0000113C  4E4F                     114                  TRAP    #15
0000113E  B47C 0001                115                  CMP     #1,D2
00001142  6700 FEC8                116                  BEQ     INPUT1
00001146  6000 FF0A                117                  BRA     INPUT2
0000114A                           118  
0000114A  4284                     119  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114C  223C 00001000            120                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001152  BA81                     121                  CMP.L      D1,D5            ; Compare minimum address with input
00001154  6DD6                     122                  BLT        INVALID          ; input is too low. 
00001156  223C 00FFFFFE            123                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115C  BA81                     124                  CMP.L      D1,D5            ; compare maximum address with input
0000115E  6ECC                     125                  BGT        INVALID          ; input too large
00001160  4E75                     126                  RTS                         ; input is within range
00001162                           127             
00001162  0805 0000                128  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001166  66C4                     129                  BNE        INVALID
00001168  4E75                     130                  RTS
0000116A                           131  
0000116A                           132  
0000116A                           133  * Checks every single possible opcode we could have. Jump table
0000116A                           134  * Inputs: (A2) which is a pointer to intruction word to be translated
0000116A                           135  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000116A                           136  
0000116A  301A                     137  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116C                           138                  
0000116C  B07C 4E71                139  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001170  6600 0010                140                  BNE     CASE_MOVE               ; checks the next case if not equal
00001174  4BF9 00001FBF            141                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117A  4EB9 00001DA4            142                  JSR     PRINTNULL               ; prints NOP                
00001180  4E75                     143                  RTS                             ; returns from the subroutine
00001182                           144                  
00001182                           145                  * if first two bits are 00, next two are not 00
00001182  3200                     146  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001184  C27C C000                147                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001188  6600 009A                148                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
0000118C  B07C 0FFF                149                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001190  6F00 0092                150                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001194                           151                  
00001194                           152                  ; Check source
00001194  4BF9 00001E48            153                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119A  4DF9 00001E7E            154                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A0  3E3C 0000                155                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A4  4EB9 00001A12            156                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AA  B27C 0001                157                  CMP.W   #1,D1                    ; checks if invalid
000011AE  6700 080A                158                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B2  3802                     159                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B4  3A03                     160                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011B6                           161                  
000011B6                           162                  ; Check destination
000011B6  4BF9 00001E48            163                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011BC  4DF9 00001E82            164                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C2  3E3C 0001                165                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011C6  4EB9 00001A12            166                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011CC  B27C 0001                167                  CMP.W   #1,D1                    ; checks if invalid
000011D0  6700 07E8                168                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D4  3C02                     169                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011D6  3E03                     170                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011D8                           171                  
000011D8                           172                  ; Checking if it is MOVEA
000011D8  3200                     173                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DA  C27C 01C0                174                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011DE  B27C 0040                175                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E2  6700 000C                176                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011E6                           177   
000011E6  4BF9 00001FC4            178                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011EC  6000 0008                179                  BRA     PRINTMOVE                ; Branches to print move
000011F0                           180                  
000011F0  4BF9 00001FCA            181  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011F6                           182   
000011F6  4EB9 00001DA4            183  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
000011FC  4EB9 00001DC6            184                  JSR     PRINTMOVESIZE            ; prints out the size  
00001202  3404                     185                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001204  3605                     186                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001206  4EB9 00001ADE            187                  JSR     EA_TO_STRING             ; outputs it into a string
0000120C                           188                  
0000120C                           189                  ; prints a comma to seperate
0000120C  4BF9 000020BC            190                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001212  4EB9 00001DA4            191                  JSR     PRINTNULL                ; prints out MOVE
00001218                           192                  
00001218                           193                  ; print destination
00001218  3406                     194                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121A  3607                     195                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000121C  4EB9 00001ADE            196                  JSR     EA_TO_STRING             ; outputs it into a string
00001222  4E75                     197                  RTS                              ; exits subroutine                 
00001224                           198                
00001224                           199                  
00001224  3200                     200  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001226  C27C FB80                201                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122A  B27C 4880                202                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000122E  6600 005A                203                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001232                           204                  
00001232                           205                  ; loads EA and XN
00001232  323C 0000                206                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001236  4EB9 000019BE            207                  JSR     GET_EA                          ; gets EA and puts in D1
0000123C  3401                     208                  MOVE.W  D1,D2                           ; copies EA to D1 so it won't be overwritten
0000123E  323C 0000                209                  MOVE.W  #0,D1                           ; copies instruction word to D1
00001242  4EB9 000019E8            210                  JSR     GET_XN                          ; gets XN and puts in D1
00001248  3601                     211                  MOVE.W  D1,D3                           ; copies EA to D1 so it won't be overwritten
0000124A                           212                  
0000124A                           213                  ; Check D
0000124A  3200                     214                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000124C  C27C 0400                215                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001250  3E01                     216                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001252  B27C 0400                217                  CMP.W   #$0400,D1                       ; checks if value is 1
00001256  6700 0032                218                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000125A                           219  
0000125A  4BF9 00001E55            220  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001260  3202                     221                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001262  4EB9 00001AAA            222                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001268  B27C 0001                223                  CMP.W   #1,D1                           ; checks if D1 invalid
0000126C  6700 074C                224                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001270  B27C 0002                225                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001274                           226                  
00001274  4BF9 00001E55            227  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127A  3203                     228                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
0000127C  4EB9 00001AAA            229                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001282  B27C 0001                230                  CMP.W   #1,D1                           ; checks if D1 invalid
00001286  6700 0732                231                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128A                           232  
0000128A                           233                  
0000128A                           234  
0000128A                           235  MOVEM_MEM2REG    
0000128A                           236                          
0000128A                           237  
0000128A                           238  
0000128A  3200                     239  CASE_MOVEQ      MOVE.W  D0,D1
0000128C  C27C F100                240                  AND.W   #$F100,D1
00001290  B27C 7000                241                  CMP.W   #$7000,D1
00001294  6600 0048                242                  BNE     CASE_ADD
00001298                           243                  
00001298                           244                  ;loads Register
00001298  323C 0001                245                  MOVE.W  #1,D1                           ; copies instruction word to D1
0000129C  4EB9 000019E8            246                  JSR     GET_XN                          ; gets XN and puts in D1
000012A2  3401                     247                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000012A4                           248                  
000012A4                           249                  ;loads DATA
000012A4  3200                     250                  MOVE.W  D0,D1
000012A6  C27C 00FF                251                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000012AA  3601                     252                  MOVE.W  D1,D3                          ;copy data into D3
000012AC                           253                                                          ;must convert bits to hex
000012AC                           254                  
000012AC                           255                  
000012AC  4BF9 00001FD1            256  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000012B2  4EB9 00001DA4            257                  JSR     PRINTNULL  
000012B8                           258                  
000012B8  4BF9 000020CF            259                  LEA     MSG_L,A5                        ;PRINT SIZE L
000012BE  4EB9 00001DA4            260                  JSR     PRINTNULL
000012C4                           261      
000012C4  4BF9 00001FBB            262                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000012CA  4EB9 00001DA4            263                  JSR     PRINTNULL
000012D0                           264                  
000012D0  4BF9 000020B8            265                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000012D6  4EB9 00001DA4            266                  JSR     PRINTNULL
000012DC  4E75                     267                  RTS
000012DE                           268                  
000012DE                           269  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000012DE  3200                     270  CASE_ADD        MOVE.W  D0,D1
000012E0  C27C F000                271                  AND.W   #$F000,D1
000012E4  B27C D000                272                  CMP.W   #$D000,D1
000012E8  6600 019E                273                  BNE     CASE_ADDQ
000012EC                           274                  
000012EC  4EB9 0000130C            275                  JSR     ADD_SUB_HELP
000012F2                           276                  
000012F2                           277                  ; bits 7-8 determine if it is ADDA or ADD
000012F2  3200                     278                  MOVE.W  D0,D1
000012F4  E149                     279                  LSL.W   #8,D1                   ; get rid of left 8 bits
000012F6  E049                     280                  LSR.W   #8,D1
000012F8  EC49                     281                  LSR.W   #6,D1                   ; get rid of right 6 bits
000012FA  B27C 0003                282                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000012FE  6700 0120                283                  BEQ     CASE_ADDA
00001302                           284                  
00001302  4BF9 00001FDF            285                  LEA     MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001308  6000 0048                286                  BRA     PRINTADD                ; Branches to print move
0000130C                           287                  
0000130C                           288                  ; Check bits 0-5 
0000130C  4BF9 00001E48            289  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001312  4DF9 00001E7E            290                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001318  3E3C 0000                291                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000131C  4EB9 00001A12            292                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001322  B27C 0001                293                  CMP.W       #1,D1                    ; checks if invalid
00001326  6700 0692                294                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000132A  3802                     295                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
0000132C  3A03                     296                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000132E                           297                  
0000132E                           298                  ; Check 6-11
0000132E  4BF9 00001E48            299                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001334  4DF9 00001E82            300                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000133A  3E3C 0001                301                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000133E  4EB9 00001A12            302                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001344  B27C 0001                303                  CMP.W       #1,D1                    ; checks if invalid
00001348  6700 0670                304                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000134C  3C02                     305                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
0000134E  3E03                     306                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001350                           307    
00001350  4E75                     308                  RTS                
00001352                           309                    
00001352  4EB9 00001DA4            310  PRINTADD        JSR         PRINTNULL
00001358  3200                     311                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000135A  4EB9 00001364            312                  JSR         ADD_SUB_SIZE
00001360  6000 0050                313                  BRA         FINISH_ADD
00001364                           314                    
00001364  3200                     315  ADD_SUB_SIZE    MOVE.W      D0,D1
00001366  E149                     316                  LSL.W       #8,D1
00001368  E049                     317                  LSR.W       #8,D1
0000136A  EC49                     318                  LSR.W       #6,D1                   ; gets bits 6-7
0000136C                           319                    
0000136C  B27C 0000                320                  CMP.W       #0,D1
00001370  6700 0016                321                  BEQ         ADD_SUB_BYTE
00001374  B27C 0001                322                  CMP.W       #1,D1                   ; if 1, it is a word
00001378  6700 001C                323                  BEQ         ADD_SUB_WORD
0000137C  B27C 0002                324                  CMP.W       #2,D1                   ; if 2, it is a long
00001380  6700 0022                325                  BEQ         ADD_SUB_LONG
00001384  6000 024C                326                  BRA         CASE_SUBA                    ; error
00001388                           327                    
00001388  4BF9 000020C3            328  ADD_SUB_BYTE    LEA         MSG_B,A5
0000138E  4EB9 00001DA4            329                  JSR         PRINTNULL
00001394  4E75                     330                  RTS
00001396                           331                    
00001396  4BF9 000020C9            332  ADD_SUB_WORD    LEA         MSG_W,A5
0000139C  4EB9 00001DA4            333                  JSR         PRINTNULL
000013A2  4E75                     334                  RTS
000013A4                           335    
000013A4  4BF9 000020CF            336  ADD_SUB_LONG    LEA         MSG_L,A5
000013AA  4EB9 00001DA4            337                  JSR         PRINTNULL
000013B0  4E75                     338                  RTS
000013B2                           339        
000013B2  4EB9 000013BA            340  FINISH_ADD      JSR         ADD_SUB_OPERAND
000013B8  4E75                     341                  RTS
000013BA                           342    
000013BA  EF49                     343  ADD_SUB_OPERAND LSL.W       #7,D1
000013BC  EE49                     344                  LSR.W       #7,D1
000013BE  E049                     345                  LSR.W       #8,D1
000013C0  B27C 0001                346                  CMP.W       #1,D1
000013C4  6600 002E                347                  BNE         Dn_PLUS_EA          
000013C8                           348                    
000013C8                           349                  ; print Data Register
000013C8  4BF9 000020AC            350                  LEA         MSG_DR,A5
000013CE  4EB9 00001DA4            351                  JSR         PRINTNULL
000013D4  3207                     352                  MOVE.W      D7,D1
000013D6  4EB9 00001C5A            353                  JSR         PRINTNUM                
000013DC                           354                  
000013DC                           355                  ; prints a comma to seperate
000013DC  4BF9 000020BC            356                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000013E2  4EB9 00001DA4            357                  JSR         PRINTNULL                ; prints out MOVE
000013E8                           358                 
000013E8                           359                  ; below is EA+Dn->Dn  
000013E8  3404                     360                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000013EA  3605                     361                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000013EC  4EB9 00001ADE            362                  JSR         EA_TO_STRING             ; outputs it into a string
000013F2  4E75                     363                  RTS                                 ; exits subroutine 
000013F4                           364  
000013F4                           365  Dn_PLUS_EA      ; below is Dn+EA->EA  
000013F4  3404                     366                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000013F6  3605                     367                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000013F8  4EB9 00001ADE            368                  JSR         EA_TO_STRING             ; outputs it into a string   
000013FE                           369                  
000013FE                           370                  ; prints a comma to seperate
000013FE  4BF9 000020BC            371                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001404  4EB9 00001DA4            372                  JSR         PRINTNULL                ; prints out MOVE
0000140A                           373                  
0000140A                           374                  ; below is Dn+EA->EA
0000140A  4BF9 000020AC            375                  LEA         MSG_DR,A5                ; print data register
00001410  4EB9 00001DA4            376                  JSR         PRINTNULL
00001416  3207                     377                  MOVE.W      D7,D1
00001418  4EB9 00001C5A            378                  JSR         PRINTNUM             
0000141E  4E75                     379                  RTS                                  ; exits subroutine                                
00001420                           380  
00001420  3200                     381  CASE_ADDA       MOVE.W      D0,D1
00001422  EF49                     382                  LSL.W       #7,D1
00001424  EE49                     383                  LSR.W       #7,D1
00001426  E049                     384                  LSR         #8,D1                               ; gets bit 8 (size bit)
00001428                           385                  
00001428  4BF9 00001FE4            386                  LEA         MSG_ADDA,A5
0000142E  4EB9 00001DA4            387                  JSR         PRINTNULL
00001434                           388                   
00001434  B27C 0001                389                  CMP.W       #1,D1
00001438  6700 0012                390                  BEQ         ADDA_LONG
0000143C                           391                    
0000143C  4BF9 000020C9            392                  LEA         MSG_W,A5
00001442  4EB9 00001DA4            393                  JSR         PRINTNULL
00001448  6000 0012                394                  BRA         FINISH_ADDA   
0000144C                           395                    
0000144C  4BF9 000020CF            396  ADDA_LONG       LEA         MSG_L,A5
00001452  4EB9 00001DA4            397                  JSR         PRINTNULL
00001458  6000 0002                398                  BRA         FINISH_ADDA
0000145C                           399                    
0000145C  3404                     400  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000145E  3605                     401                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001460  4EB9 00001ADE            402                  JSR         EA_TO_STRING             ; outputs it into a string
00001466                           403                    
00001466                           404                  ; prints a comma to seperate
00001466  4BF9 000020BC            405                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000146C  4EB9 00001DA4            406                  JSR         PRINTNULL                ; prints out MOVE
00001472                           407            
00001472  4BF9 000020AE            408                  LEA         MSG_AR,A5                ; print address register
00001478  4EB9 00001DA4            409                  JSR         PRINTNULL
0000147E  3207                     410                  MOVE.W      D7,D1
00001480  4EB9 00001C5A            411                  JSR         PRINTNUM             
00001486  4E75                     412                  RTS                              ; exits subroutine
00001488                           413                    
00001488  3200                     414  CASE_ADDQ       MOVE.W      D0,D1
0000148A  C27C F000                415                  AND.W       #$F000,D1       
0000148E  B27C 5000                416                  CMP.W       #$5000,D1
00001492  6600 00C8                417                  BNE         CASE_SUB
00001496                           418                   
00001496                           419                  ; Check bits 0-5 
00001496  4BF9 00001E48            420                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000149C  4DF9 00001E7E            421                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000014A2  3E3C 0000                422                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000014A6  4EB9 00001A12            423                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000014AC  B27C 0001                424                  CMP.W       #1,D1                    ; checks if invalid
000014B0  6700 0508                425                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000014B4  3802                     426                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000014B6  3A03                     427                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000014B8                           428                    
000014B8                           429                  ; get bits 6-7 (size bits)
000014B8  3200                     430                  MOVE.W      D0,D1
000014BA  E149                     431                  LSL.W       #8,D1
000014BC  E049                     432                  LSR.W       #8,D1
000014BE  EC49                     433                  LSR.W       #6,D1
000014C0  3401                     434                  MOVE.W      D1,D2
000014C2                           435    
000014C2                           436                  ; gets bits 9-11 (data bits)
000014C2  E949                     437                  LSL.W       #4,D1
000014C4  E849                     438                  LSR.W       #4,D1                               ; get rid of left 4 bits
000014C6  E049                     439                  LSR.W       #8,D1
000014C8  E249                     440                  LSR.W       #1,D1                               ; get rid of right 9 bits
000014CA                           441                    
000014CA  4BF9 00001FEA            442                  LEA         MSG_ADDQ,A5
000014D0  4EB9 00001DA4            443                  JSR         PRINTNULL
000014D6                           444                    
000014D6  B47C 0001                445                  CMP.W       #1,D2
000014DA  6700 001A                446                  BEQ         ADDQ_WORD
000014DE  B47C 0002                447                  CMP.W       #2,D2
000014E2  6700 0022                448                  BEQ         ADDQ_LONG
000014E6                           449                    
000014E6  4BF9 000020C3            450  ADDQ_BYTE       LEA         MSG_B,A5
000014EC  4EB9 00001DA4            451                  JSR         PRINTNULL
000014F2  6000 0022                452                  BRA         FINISH_ADDQ  
000014F6                           453   
000014F6  4BF9 000020C9            454  ADDQ_WORD       LEA         MSG_W,A5
000014FC  4EB9 00001DA4            455                  JSR         PRINTNULL
00001502  6000 0012                456                  BRA         FINISH_ADDQ                 
00001506                           457    
00001506  4BF9 000020CF            458  ADDQ_LONG       LEA         MSG_L,A5
0000150C  4EB9 00001DA4            459                  JSR         PRINTNULL
00001512  6000 0002                460                  BRA         FINISH_ADDQ                  
00001516                           461                    
00001516  4EB9 00001534            462  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000151C                           463   
0000151C                           464                  ; prints a comma to seperate
0000151C  4BF9 000020BC            465                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001522  4EB9 00001DA4            466                  JSR         PRINTNULL                ; prints out MOVE
00001528                           467                    
00001528                           468                  ; prints destination
00001528  3404                     469                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000152A  3605                     470                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000152C  4EB9 00001ADE            471                  JSR         EA_TO_STRING             ; outputs it into a string
00001532                           472                 
00001532  4E75                     473                  RTS
00001534                           474   
00001534  4BF9 000020B8            475  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
0000153A  4EB9 00001DA4            476                  JSR         PRINTNULL
00001540  B27C 0000                477                  CMP.W       #0,D1
00001544  6700 000A                478                  BEQ         PRINT_8
00001548  4EB9 00001C5A            479                  JSR         PRINTNUM
0000154E  4E75                     480                  RTS 
00001550                           481  
00001550  123C 0008                482  PRINT_8         MOVE.B      #8,D1
00001554  4EB9 00001C5A            483                  JSR         PRINTNUM
0000155A  4E75                     484                  RTS           
0000155C                           485   
0000155C  3200                     486  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000155E  C27C F000                487                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001562  B27C 9000                488                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001566  6600 0080                489                  BNE         CASE_LEA
0000156A                           490                 
0000156A  4EB8 130C                491                  JSR         ADD_SUB_HELP
0000156E                           492                                 
0000156E  4BF9 00001FF0            493                  LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
00001574  6000 0002                494                  BRA         PRINTSUB                            ; Branches to print move
00001578                           495  
00001578  4EB9 00001DA4            496  PRINTSUB        JSR         PRINTNULL
0000157E  3200                     497                  MOVE.W      D0,D1                               ; bits 6-7 contain size
00001580  4EB8 1364                498                  JSR         ADD_SUB_SIZE
00001584  3200                     499                  MOVE.W      D0,D1
00001586  E149                     500                  LSL.W       #8,D1
00001588  E049                     501                  LSR.W       #8,D1
0000158A  EC49                     502                  LSR.W       #6,D1
0000158C  B27C 0003                503                  CMP.W       #3,D1
00001590  6600 0006                504                  BNE         FINISH_SUB
00001594  6000 0008                505                  BRA         FINISH_SUBA                         ; same as ADDA
00001598                           506                  
00001598  4EB8 13BA                507  FINISH_SUB      JSR     ADD_SUB_OPERAND
0000159C  4E75                     508                  RTS
0000159E                           509                    
0000159E  3404                     510  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015A0  3605                     511                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015A2  4EB9 00001ADE            512                  JSR         EA_TO_STRING             ; outputs it into a string
000015A8                           513                
000015A8                           514                  ; prints a comma to seperate
000015A8  4BF9 000020BC            515                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015AE  4EB9 00001DA4            516                  JSR         PRINTNULL                ; prints out MOVE
000015B4                           517          
000015B4  4BF9 000020AE            518                  LEA         MSG_AR,A5                ; print address register
000015BA  4EB9 00001DA4            519                  JSR         PRINTNULL
000015C0  3200                     520                  MOVE.W      D0,D1
000015C2  E949                     521                  LSL.W       #4,D1
000015C4  E849                     522                  LSR.W       #4,D1
000015C6  E049                     523                  LSR.W       #8,D1
000015C8  E249                     524                  LSR.W       #1,D1
000015CA  4EB9 00001C5A            525                  JSR         PRINTNUM             
000015D0  4E75                     526                  RTS                              ; exits subroutine
000015D2                           527  
000015D2                           528  
000015D2                           529  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
000015D2  3200                     530  CASE_SUBA       MOVE.W      D0,D1
000015D4  EF49                     531                  LSL.W       #7,D1
000015D6  EE49                     532                  LSR.W       #7,D1
000015D8  E049                     533                  LSR.W       #8,D1
000015DA  B23C 0000                534                  CMP.B       #0,D1
000015DE  6700 FDB6                535                  BEQ         ADD_SUB_WORD
000015E2  6000 FDC0                536                  BRA         ADD_SUB_LONG
000015E6  4E75                     537                  RTS         
000015E8                           538                   
000015E8  3200                     539  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
000015EA  C27C F000                540                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000015EE  B27C 4000                541                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
000015F2  6600 0086                542                  BNE.W   CASE_AND                             ; If its not, check AND
000015F6  3200                     543                  MOVE.W  D0,D1                                ; Copies instruction word to D1
000015F8  C27C 01C0                544                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
000015FC  B27C 01C0                545                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001600  6600 0078                546                  BNE.W   CASE_AND                             ; If its not, check AND
00001604                           547                  
00001604                           548                  ; Check source
00001604  4BF9 00001E68            549                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000160A  4DF9 00001E82            550                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001610  3E3C 0000                551                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001614  4EB9 00001A12            552                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000161A  3802                     553                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000161C  3A03                     554                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000161E                           555                  
0000161E                           556                  ; Check destination
0000161E  4BF9 00001E68            557                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001624  4DF9 00001E82            558                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000162A  3E3C 0001                559                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000162E  4EB9 00001A12            560                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001634  3C02                     561                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001636  3E03                     562                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001638                           563  
00001638  4BF9 00002001            564                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000163E  4EB9 00001DA4            565                  JSR     PRINTNULL                            ; prints LEA
00001644                           566                  
00001644                           567                  ; print source
00001644  3404                     568                  MOVE.W  D4,D2
00001646  3605                     569                  MOVE.W  D5,D3
00001648  4EB9 00001ADE            570                  JSR     EA_TO_STRING                         ; Prints out the EA
0000164E                           571                  
0000164E                           572                  ; comma
0000164E  4BF9 000020BC            573                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001654  4EB9 00001DA4            574                  JSR     PRINTNULL                       
0000165A                           575                   
0000165A                           576                  ; register
0000165A  4BF9 000020AE            577                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001660  4EB9 00001DA4            578                  JSR     PRINTNULL 
00001666  3401                     579                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
00001668  323C 0001                580                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
0000166C  4EB9 000019E8            581                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001672  4EB9 00001C5A            582                  JSR     PRINTNUM                             ; Prints the number in D1
00001678  4E75                     583                  RTS
0000167A                           584  
0000167A                           585  *---------------AND opcode----------------------
0000167A  3200                     586  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
0000167C  C27C F000                587                  AND.W       #$F000,D1       
00001680  B27C C000                588                  CMP.W       #$C000,D1
00001684  6600 007E                589                  BNE         CASE_OR
00001688                           590                                
00001688  4EB8 130C                591                  JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
0000168C                           592                  
0000168C  3200                     593                  MOVE.W      D0,D1
0000168E  E149                     594                  LSL.W       #8,D1
00001690  E049                     595                  LSR.W       #8,D1
00001692  EC49                     596                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001694  B27C 0003                597                  CMP.W       #3,D1
00001698  6700 005C                598                  BEQ         INV_INSTR
0000169C                           599                  
0000169C  4BF9 00002009            600                  LEA         MSG_AND,A5
000016A2  4EB9 00001DA4            601                  JSR         PRINTNULL
000016A8                           602                  
000016A8  B27C 0000                603                  CMP.W       #0,D1
000016AC  6700 0012                604                  BEQ         AND_BYTE
000016B0  B27C 0001                605                  CMP.W       #1,D1                   ; if 1, it is a word
000016B4  6700 001A                606                  BEQ         AND_WORD
000016B8  B27C 0002                607                  CMP.W       #2,D1                   ; if 2, it is a long
000016BC  6700 0022                608                  BEQ         AND_LONG
000016C0                           609                  
000016C0  4BF9 000020C3            610  AND_BYTE        LEA         MSG_B,A5
000016C6  4EB9 00001DA4            611                  JSR         PRINTNULL
000016CC  6000 0022                612                  BRA         FINISH_AND
000016D0                           613                                    
000016D0  4BF9 000020C9            614  AND_WORD        LEA         MSG_W,A5
000016D6  4EB9 00001DA4            615                  JSR         PRINTNULL
000016DC  6000 0012                616                  BRA         FINISH_AND
000016E0                           617    
000016E0  4BF9 000020CF            618  AND_LONG        LEA         MSG_L,A5
000016E6  4EB9 00001DA4            619                  JSR         PRINTNULL
000016EC  6000 0002                620                  BRA         FINISH_AND
000016F0                           621        
000016F0  4EB8 13BA                622  FINISH_AND      JSR         ADD_SUB_OPERAND
000016F4  4E75                     623                  RTS
000016F6                           624                  
000016F6  4BF9 00001FA6            625  INV_INSTR       LEA         INVALID_INSTR,A5
000016FC  4EB9 00001DA4            626                  JSR         PRINTNULL
00001702  4E75                     627                  RTS               
00001704                           628                  
00001704                           629              
00001704                           630  CASE_OR
00001704                           631  
00001704                           632  CASE_NOT
00001704                           633  
00001704  3200                     634  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
00001706  C27C F000                635                  AND.W       #$F000, D1                       ; gets first 4 bits
0000170A  B27C E000                636                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
0000170E  6600 0210                637                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001712  3400                     638                  MOVE.W      D0,D2                            ; copies D0 to D2
00001714  4EB9 00001A9A            639                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000171A  B47C 0003                640                  CMP.W       #$3, D2                          ; checks if it is memory or register option
0000171E  6600 00C8                641                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001722                           642                  
00001722  3400                     643  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001724  4EB9 00001A88            644                  JSR         GETROTATION                      ; gets rotation value of D2
0000172A  B47C 0000                645                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
0000172E  6700 0014                646                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001732  B47C 0003                647                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001736  6700 0016                648                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
0000173A                           649                  
0000173A  4BF9 00002017            650  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001740  6000 0012                651                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001744                           652  
00001744  4BF9 0000201B            653  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
0000174A  6000 0008                654                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000174E                           655  
0000174E  4BF9 0000201F            656  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001754                           657                  
00001754  4EB9 00001DA4            658  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
0000175A  3400                     659                  MOVE.W      D0,D2                            ; copies D0 to D2
0000175C  4EB9 00001A92            660                  JSR         GETDIRECTION                     ; gets direction
00001762  B47C 0000                661                  CMP.W       #0,D2                            ; checking if its right
00001766  6700 000C                662                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
0000176A                           663  
0000176A  4BF9 000020AA            664  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001770  6000 0008                665                  BRA         PRINT_MEMDIR                     ; branches for printing
00001774                           666          
00001774  4BF9 000020A8            667  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
0000177A                           668  
0000177A  4EB9 00001DA4            669  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001780  4BF9 000020C9            670                  LEA         MSG_W,A5                         ; loads .W into A5
00001786  4EB9 00001DA4            671                  JSR         PRINTNULL                        ; Prints .W
0000178C  6000 0002                672                  BRA         GETMEMSOURCE                     ; checks the source 
00001790                           673                  
00001790                           674  ; get source addressing mode       
00001790                           675  GETMEMSOURCE                                                 
00001790  323C 0000                676                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001794  4EB9 000019BE            677                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
0000179A  3801                     678                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
0000179C  323C 0000                679                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
000017A0  4EB9 000019E8            680                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000017A6  3A01                     681                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000017A8                           682  
000017A8  4BF9 00001E76            683  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000017AE  3204                     684                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000017B0  4EB9 00001AAA            685                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000017B6  B27C 0002                686                  CMP.W       #2,D1                            ; checks if it is Xn
000017BA  6700 0016                687                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000017BE  B27C 0001                688                  CMP.W       #1,D1                            ; Checks if it is invalid
000017C2  6700 01F6                689                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000017C6                           690  
000017C6  3404                     691  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000017C8  3605                     692                  MOVE.W      D5,D3                            ; moves EA to D3
000017CA  4EB9 00001ADE            693                  JSR         EA_TO_STRING                     ; prints out the EA
000017D0  4E75                     694                  RTS                
000017D2                           695                  
000017D2                           696                  
000017D2  4BF9 00001E82            697  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000017D8  3205                     698                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000017DA  4EB9 00001AAA            699                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000017E0  4A41                     700                  TST.W       D1                               ; checks if it is valid
000017E2  67E2                     701                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000017E4  6000 01D4                702                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000017E8                           703  
000017E8                           704  
000017E8  3602                     705  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000017EA  3200                     706                  MOVE.W      D0,D1                            ; copies D0 to D1
000017EC  C27C 0018                707                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000017F0  E649                     708                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000017F2  B27C 0000                709                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000017F6  6700 0014                710                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
000017FA  B27C 0003                711                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
000017FE  6700 0016                712                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001802                           713                  
00001802  4BF9 00002017            714  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001808  6000 0012                715                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
0000180C                           716  
0000180C  4BF9 0000201B            717  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001812  6000 0008                718                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001816                           719  
00001816  4BF9 0000201F            720  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000181C                           721                  
0000181C  4EB9 00001DA4            722  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
00001822  3400                     723                  MOVE.W      D0,D2                            ; copies D0 to D2
00001824  4EB9 00001A92            724                  JSR         GETDIRECTION                     ; gets direction
0000182A  B47C 0000                725                  CMP.W       #0,D2                            ; checking if its right
0000182E  6700 000C                726                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001832                           727  
00001832  4BF9 000020AA            728  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001838  6000 000C                729                  BRA         PRINT_REGDIR                     ; branches for printing
0000183C                           730          
0000183C  4BF9 000020A8            731  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001842  6000 0002                732                  BRA         PRINT_REGDIR                     ; branches for printing
00001846                           733                  
00001846  4EB9 00001DA4            734  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
0000184C                           735  
0000184C  3400                     736  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
0000184E  4EB9 00001A9A            737                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001854  B47C 0001                738                  CMP.W       #1,D2                            ; Checks if it is word size
00001858  6700 0014                739                  BEQ         REG_WORD                         ; Prints .W
0000185C  B47C 0002                740                  CMP.W       #2,D2                            ; Checks if it is long size
00001860  6700 0016                741                  BEQ         REG_LONG                         ; Prints .L
00001864                           742  
00001864  4BF9 000020C3            743  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
0000186A  6000 0012                744                  BRA         PRINTREGEA      
0000186E                           745  
0000186E  4BF9 000020C9            746  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001874  6000 0008                747                  BRA         PRINTREGEA      
00001878                           748                             
00001878  4BF9 000020CF            749  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
0000187E                           750  
0000187E  4EB9 00001DA4            751  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001884  3400                     752                  MOVE.W      D0,D2                            ; copies D0 to D1
00001886  4EB9 00001AA2            753                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
0000188C  B27C 0001                754                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001890  6700 0048                755                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001894                           756                                  
00001894  3400                     757  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001896  4EB9 00001A9A            758                  JSR         GETROTATIONSIZE                  ; gets the rotation size
0000189C  3202                     759                  MOVE.W      D2, D1                           ; moves rotation size to D1
0000189E  4BF9 000020B8            760                  LEA         MSG_POUND, A5                    ; loads # into A5
000018A4  4EB9 00001DA4            761                  JSR         PRINTNULL                        ; prints #
000018AA  4EB9 00001C5A            762                  JSR         PRINTNUM                         ; prints shift count
000018B0  4BF9 000020BC            763                  LEA         MSG_COMMA, A5                    ; loads , into A5
000018B6  4EB9 00001DA4            764                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000018BC  4BF9 000020AC            765                  LEA         MSG_DR, A5                       ; loads D into A5
000018C2  4EB9 00001DA4            766                  JSR         PRINTNULL                        ; prints out D 
000018C8  323C 0000                767                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000018CC  4EB9 000019E8            768                  JSR         GET_XN                           ; gets the data register number, stores in D1
000018D2  4EB9 00001C5A            769                  JSR         PRINTNUM                         ; prints data register number in D1          
000018D8  4E75                     770                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000018DA                           771                  
000018DA  3400                     772  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
000018DC  4EB9 00001A9A            773                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000018E2  3202                     774                  MOVE.W      D2, D1                           ; moves rotation size to D1
000018E4  4BF9 000020AC            775                  LEA         MSG_DR, A5                       ; loads D into A5
000018EA  4EB9 00001DA4            776                  JSR         PRINTNULL                        ; prints D
000018F0  4EB9 00001C5A            777                  JSR         PRINTNUM                         ; prints register number
000018F6  4BF9 000020BC            778                  LEA         MSG_COMMA, A5                    ; loads , into A5
000018FC  4EB9 00001DA4            779                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001902  4BF9 000020AC            780                  LEA         MSG_DR, A5                       ; loads D into A5
00001908  4EB9 00001DA4            781                  JSR         PRINTNULL                        ; prints out D 
0000190E  323C 0000                782                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001912  4EB9 000019E8            783                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001918  4EB9 00001C5A            784                  JSR         PRINTNUM                         ; prints data register number in D1          
0000191E  4E75                     785                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001920                           786               
00001920  3200                     787  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001922  C27C FF00                788                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001926  B27C 6000                789                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
0000192A  6600 0018                790                  BNE.W   CASE_BCC                             ; If its not, check BCC
0000192E                           791                  
0000192E  4BF9 000020A0            792                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001934  4EB9 00001DA4            793                  JSR     PRINTNULL                            ; prints BRA
0000193A                           794  
0000193A  3400                     795                  MOVE.W  D0,D2                                ; Copies instruction word to D1
0000193C  4EB9 00001A5A            796                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001942  4E75                     797                  RTS
00001944                           798                  
00001944                           799  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001944                           800  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001944  3200                     801  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001946  C27C F000                802                  AND.W   #$F000,D1                            ; get top 4 bits
0000194A  B27C 6000                803                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
0000194E  6600 0054                804                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001952  3200                     805                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001954  C27C 0F00                806                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001958  E049                     807                  LSR.W   #8,D1                                ; shifts 8 bits to the right
0000195A                           808                  
0000195A  B27C 000E                809                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
0000195E  6700 002A                810                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001962                           811                  
00001962  B27C 000F                812                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001966  6700 0018                813                  BEQ     CASE_BLE                             ; branches to BLE if it is
0000196A                           814                      
0000196A  B27C 0007                815                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
0000196E  6700 0006                816                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001972  6000 0046                817                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001976                           818     
00001976  4BF9 00002033            819  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
0000197C  6000 0016                820                  BRA     PRINTBCC
00001980                           821  
00001980  4BF9 0000205B            822  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001986  6000 000C                823                  BRA     PRINTBCC
0000198A                           824                  
0000198A  4BF9 0000204B            825  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001990  6000 0002                826                  BRA     PRINTBCC
00001994                           827  
00001994  4EB9 00001DA4            828  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
0000199A  3400                     829                  MOVE.W  D0,D2                                ; Copies instruction word to D1
0000199C  4EB9 00001A5A            830                  JSR     GETDISPLACEMENT                      ; finds the displacement
000019A2  4E75                     831                  RTS              
000019A4                           832                  
000019A4                           833  
000019A4                           834  CASE_JSR       
000019A4                           835  
000019A4  B07C 4E75                836  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
000019A8  6600 F7D8                837                  BNE     CASE_MOVE           ; checks the next case if not equal
000019AC  4BF9 0000209B            838                  LEA     MSG_RTS,A5          ; loads string pointer into A5
000019B2  4EB9 00001DA4            839                  JSR     PRINTNULL           ; prints RTS                
000019B8  4E75                     840                  RTS                         ; returns from the subroutine
000019BA                           841  
000019BA                           842                  
000019BA                           843  
000019BA                           844  CASE_DATA           
000019BA  4E75                     845                      RTS               
000019BC                           846  
000019BC  4E75                     847  CASE_EPICFAIL       RTS
000019BE                           848  
000019BE                           849  
000019BE                           850  * Finds the EA type
000019BE                           851  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
000019BE                           852  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000019BE  48E7 3000                853  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000019C2  4A41                     854                      TST.W     D1                    ; compares D1 to 0
000019C4  6700 000E                855                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
000019C8                           856                      
000019C8  343C 01C0                857  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
000019CC  363C 0006                858                      MOVE.W    #6,D3                 ; stores the shift amount to D3
000019D0  6000 000A                859                      BRA       FINDTYPEEA            
000019D4                           860  
000019D4  343C 0038                861  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
000019D8  363C 0003                862                      MOVE.W    #3,D3                 ; stores the shift amount to D3
000019DC                           863  
000019DC                           864  
000019DC  3200                     865  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
000019DE  C242                     866                      AND.W     D2,D1                 ; applies bitmask to D1
000019E0  E669                     867                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000019E2  4CDF 000C                868                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
000019E6  4E75                     869                      RTS                             ; returns from subroutine    
000019E8                           870                      
000019E8                           871  * Finds Xn type
000019E8                           872  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
000019E8                           873  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000019E8  48E7 3000                874  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000019EC  4A41                     875                      TST.W     D1                    ; compares D1 to 0
000019EE  6700 000E                876                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
000019F2                           877  
000019F2  343C 0E00                878  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
000019F6  363C 0009                879                      MOVE.W    #9,D3                 ; stores the shift amount to D3
000019FA  6000 000A                880                      BRA       FINDTYPEXN            ; finds the type of Xn
000019FE                           881  
000019FE  343C 0007                882  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001A02  363C 0000                883                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001A06                           884                      
00001A06  3200                     885  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001A08  C242                     886                      AND.W     D2,D1                 ; applies bitmask to D1
00001A0A  E669                     887                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001A0C  4CDF 000C                888                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001A10  4E75                     889                      RTS                             ; returns from subroutine 
00001A12                           890                      
00001A12                           891  * Checks and gets the EA and Xn
00001A12                           892  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001A12                           893  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001A12  3207                     894  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001A14  4EB8 19BE                895                  JSR     GET_EA                  ; Gets EA
00001A18  3401                     896                  MOVE.W  D1,D2                   ; Stores EA in D2
00001A1A  3207                     897                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001A1C  4EB8 19E8                898                  JSR     GET_XN                  ; Gets Xn
00001A20  3601                     899                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001A22  3202                     900                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001A24                           901                  
00001A24  4EB9 00001AAA            902                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001A2A  B27C 0002                903                  CMP.W   #2,D1                   ; checks if it is Xn
00001A2E  6700 0012                904                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001A32  B27C 0001                905                  CMP.W   #1,D1                   ; Checks if it is invalid
00001A36  6700 001C                906                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001A3A                           907                  
00001A3A                           908                  
00001A3A  323C 0000                909  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001A3E  6000 0018                910                  BRA     END_CHECKGET
00001A42                           911        
00001A42                           912  ; need XN
00001A42  2A4E                     913  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001A44  3203                     914                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001A46  4EB9 00001AAA            915                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001A4C  4A41                     916                  TST.W   D1                      ; checks if it is valid
00001A4E  67EA                     917                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001A50  6000 0002                918                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001A54                           919   
00001A54  323C 0001                920  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001A58                           921  
00001A58  4E75                     922  END_CHECKGET    RTS          
00001A5A                           923                                            
00001A5A                           924                                            
00001A5A                           925  * Gets the displacement and pritns it 
00001A5A                           926  * Inputs: D2 = instruction word, A2 = address of next word
00001A5A                           927  * Outputs: prints out displacement
00001A5A  48E7 4004                928  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001A5E  3A4A                     929                      MOVE.W    A2,A5                 ; copies A2 to A5
00001A60  C47C 00FF                930                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001A64  6600 0004                931                      BNE       PRINTADDRESS          ; prints address if not 0
00001A68  341A                     932                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001A6A                           933                      
00001A6A  D44D                     934  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001A6C  3202                     935                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001A6E  183C 0000                936                      MOVE.B    #0,D4                 ; marks address as word  length
00001A72  4BF9 000020BA            937                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001A78  4EB9 00001DA4            938                      JSR       PRINTNULL             ; prints null
00001A7E  4EB9 00001C7E            939                      JSR       PRINTSHORTLONGNUM     ; prints address
00001A84                           940                      
00001A84  4CDF 2002                941                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001A88                           942                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001A88                           943  
00001A88                           944  * Gets the rotation value for ASd and LSd
00001A88                           945  * Input: D2 = instruction word copy (of D0)                                    
00001A88                           946  * Output: rotation  value in D2             
00001A88  C47C 0E00                947  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001A8C  E04A                     948                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001A8E  E24A                     949                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001A90  4E75                     950                      RTS                             ; return from subroutine
00001A92                           951  
00001A92                           952  * Gets the direction value for ASd and LSd
00001A92                           953  * Input: D2 = instruction word copy (of D0)                                    
00001A92                           954  * Output: direction value in D2             
00001A92  C47C 0100                955  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001A96  E04A                     956                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001A98  4E75                     957                      RTS                             ; return from subroutine
00001A9A                           958  
00001A9A                           959  * Gets the rotation size value for ASd and LSd
00001A9A                           960  * Input: D2 = instruction word copy (of D0)                                    
00001A9A                           961  * Output: rotation size value in D2             
00001A9A  C47C 00C0                962  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001A9E  EC4A                     963                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001AA0  4E75                     964                      RTS                             ; return from subroutine
00001AA2                           965  
00001AA2                           966  * Gets the rotation location  value for ASd and LSd
00001AA2                           967  * Input: D2 = instruction word copy (of D0)                                    
00001AA2                           968  * Output: rotation location value in D2             
00001AA2  C47C 0020                969  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001AA6  EA4A                     970                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001AA8  4E75                     971                      RTS                             ; return from subroutine
00001AAA                           972  
00001AAA                           973                          
00001AAA                           974  * Checks if EA or Xn is valid
00001AAA                           975  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001AAA                           976  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001AAA  2F02                     977  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001AAC                           978  
00001AAC  141D                     979  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001AAE  B43C 00FF                980                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001AB2  6700 000A                981                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001AB6  B202                     982                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001AB8  6700 000C                983                     BEQ        VALIDEA               ; branches to valid EA
00001ABC  60EE                     984                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001ABE                           985                     
00001ABE  323C 0001                986  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001AC2  6000 0016                987                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001AC6                           988                    
00001AC6  B43C 0007                989  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001ACA  6700 000A                990                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001ACE  323C 0000                991                     MOVE.W     #$0,D1                ; marks that it is valid
00001AD2  6000 0006                992                     BRA        CHECKEAEXIT           ; exits the subroutine
00001AD6                           993  
00001AD6  323C 0002                994  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001ADA                           995  
00001ADA  241F                     996  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001ADC  4E75                     997                     RTS                              ; returns from subroutine
00001ADE                           998  
00001ADE                           999  * Converts EA and Xn into a string                                
00001ADE                          1000  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001ADE                          1001  * Outputs: Prints out EA and Xn into a string
00001ADE  48E7 C004               1002  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001AE2  B47C 0001               1003                     CMP.W    #An,D2                  ; checks if it is An
00001AE6  6700 003A               1004                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001AEA                          1005                     
00001AEA  B47C 0002               1006                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001AEE  6700 004A               1007                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001AF2                          1008                     
00001AF2  B47C 0003               1009                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001AF6  6700 0072               1010                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001AFA                          1011                     
00001AFA  B47C 0004               1012                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001AFE  6700 00A6               1013                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001B02                          1014                     
00001B02  B47C 0007               1015                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001B06  6700 00DA               1016                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001B0A                          1017                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001B0A                          1018  
00001B0A                          1019  * data register, Dn
00001B0A  4BF9 000020AC           1020  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001B10  4EB9 00001DA4           1021                     JSR      PRINTNULL               ; Prints D
00001B16  3203                    1022                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001B18  4EB9 00001C5A           1023                     JSR      PRINTNUM                ; Prints the Xn
00001B1E  6000 0134               1024                     BRA      EA_TO_STRING_EXIT       ; exits           
00001B22                          1025  
00001B22                          1026  
00001B22                          1027  * address register
00001B22  4BF9 000020AE           1028  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001B28  4EB9 00001DA4           1029                     JSR      PRINTNULL               ; Prints A
00001B2E  3203                    1030                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001B30  4EB9 00001C5A           1031                     JSR      PRINTNUM                ; Prints the Xn
00001B36  6000 011C               1032                     BRA      EA_TO_STRING_EXIT       ; exits
00001B3A                          1033  
00001B3A                          1034  * address register indirect
00001B3A  4BF9 000020B0           1035  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001B40  4EB9 00001DA4           1036                     JSR      PRINTNULL               ; Prints (
00001B46  4BF9 000020AE           1037                     LEA      MSG_AR,A5               ; Loads A into A5
00001B4C  4EB9 00001DA4           1038                     JSR      PRINTNULL               ; Prints A
00001B52  3203                    1039                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001B54  4EB9 00001C5A           1040                     JSR      PRINTNUM                ; Prints the Xn
00001B5A  4BF9 000020B2           1041                     LEA      MSG_RB,A5               ; Loads ) into A5
00001B60  4EB9 00001DA4           1042                     JSR      PRINTNULL               ; Prints )
00001B66  6000 00EC               1043                     BRA      EA_TO_STRING_EXIT       ; exits
00001B6A                          1044  
00001B6A                          1045  * address register indirect post increment
00001B6A  4BF9 000020B0           1046  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001B70  4EB9 00001DA4           1047                     JSR      PRINTNULL               ; Prints (
00001B76  4BF9 000020AE           1048                     LEA      MSG_AR,A5               ; Loads A into A5
00001B7C  4EB9 00001DA4           1049                     JSR      PRINTNULL               ; Prints A
00001B82  3203                    1050                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001B84  4EB9 00001C5A           1051                     JSR      PRINTNUM                ; Prints the Xn
00001B8A  4BF9 000020B2           1052                     LEA      MSG_RB,A5               ; Loads ) into A5
00001B90  4EB9 00001DA4           1053                     JSR      PRINTNULL               ; Prints )
00001B96  4BF9 000020B4           1054                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001B9C  4EB9 00001DA4           1055                     JSR      PRINTNULL               ; Prints +
00001BA2  6000 00B0               1056                     BRA      EA_TO_STRING_EXIT       ; exits
00001BA6                          1057  
00001BA6                          1058  
00001BA6                          1059  * address register indirect pre increment
00001BA6  4BF9 000020B6           1060  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001BAC  4EB9 00001DA4           1061                     JSR      PRINTNULL               ; Prints -
00001BB2  4BF9 000020B0           1062                     LEA      MSG_LB,A5               ; Loads ( into A5
00001BB8  4EB9 00001DA4           1063                     JSR      PRINTNULL               ; Prints (
00001BBE  4BF9 000020AE           1064                     LEA      MSG_AR,A5               ; Loads A into A5
00001BC4  4EB9 00001DA4           1065                     JSR      PRINTNULL               ; Prints A
00001BCA  3203                    1066                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001BCC  4EB9 00001C5A           1067                     JSR      PRINTNUM                ; Prints the Xn
00001BD2  4BF9 000020B2           1068                     LEA      MSG_RB,A5               ; Loads ) into A5
00001BD8  4EB9 00001DA4           1069                     JSR      PRINTNULL               ; Prints )
00001BDE  6000 0074               1070                     BRA      EA_TO_STRING_EXIT       ; exits
00001BE2                          1071  
00001BE2                          1072  * other (long, short, immediate) with Xn yes
00001BE2  301A                    1073  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001BE4  B67C 0000               1074                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001BE8  6700 002E               1075                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001BEC                          1076                     
00001BEC  B67C 0001               1077                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001BF0  6700 0042               1078                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001BF4                          1079  
00001BF4                          1080  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001BF4                          1081  * immediate
00001BF4  4BF9 000020B8           1082  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001BFA  4EB9 00001DA4           1083                     JSR      PRINTNULL               ; Prints #  
00001C00  4BF9 000020BA           1084                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001C06  4EB9 00001DA4           1085                     JSR      PRINTNULL               ; Prints $
00001C0C  3200                    1086                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001C0E  4EB9 00001C6A           1087                     JSR      PRINTHEXNUM 
00001C14  6000 003E               1088                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001C18                          1089                     
00001C18                          1090  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001C18                          1091  
00001C18                          1092  * word address
00001C18                          1093  CASE_WORD          
00001C18  4BF9 000020BA           1094                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001C1E  4EB9 00001DA4           1095                     JSR      PRINTNULL               ; Prints $
00001C24  3200                    1096                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001C26  383C 0000               1097                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001C2A  4EB9 00001C7E           1098                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001C30  6000 0022               1099                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001C34                          1100  
00001C34                          1101  * long address 
00001C34                          1102  CASE_LONG          
00001C34  4BF9 000020BA           1103                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001C3A  4EB9 00001DA4           1104                     JSR      PRINTNULL               ; Prints $
00001C40  3200                    1105                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001C42  383C 0001               1106                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001C46  4EB9 00001C7E           1107                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001C4C  321A                    1108                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001C4E  4EB9 00001C5A           1109                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001C54                          1110  
00001C54                          1111  
00001C54                          1112  * exits subroutine
00001C54  4CDF 2003               1113  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001C58  4E75                    1114                      RTS                              ; returns from subroutine
00001C5A                          1115  
00001C5A                          1116  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001C5A                          1117  
00001C5A                          1118  * Prints out the content of D1 as a decimal number
00001C5A                          1119  * Input: number in D1 to be printed
00001C5A                          1120  * Output: contents of D1 printed
00001C5A  48E7 C000               1121  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001C5E  103C 0003               1122                   MOVE.B      #3,D0               ; prints D1
00001C62  4E4F                    1123                   TRAP        #15                 ; is trap task 3
00001C64                          1124              
00001C64  4CDF 0003               1125                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001C68  4E75                    1126                   RTS                             ; returns from subroutine
00001C6A                          1127                   
00001C6A                          1128  * Prints out the content of D1 as a hex number
00001C6A                          1129  * Input: number in D1 to be printed
00001C6A                          1130  * Output: contents of D1 printed
00001C6A  48E7 C000               1131  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001C6E  143C 0010               1132                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001C72  103C 000F               1133                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001C76  4E4F                    1134                   TRAP        #15                 ; is trap task 15
00001C78  4CDF 0003               1135                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001C7C  4E75                    1136                   RTS                             ; returns from subroutine
00001C7E                          1137                   
00001C7E                          1138  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001C7E                          1139  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001C7E                          1140  * Output: contents of D1 printed
00001C7E  48E7 E000               1141  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001C82  B83C 0001               1142                            CMP.B       #1,D4               ; checks size of number
00001C86  6700 0042               1143                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001C8A                          1144  
00001C8A  3401                    1145  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001C8C  C47C F000               1146                            AND.W       #$F000,D2           ; gets the first digit
00001C90  B47C 0000               1147                            CMP.W       #0, D2              ; checks if it is 0
00001C94  6600 00DC               1148                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001C98  4EB9 00001D82           1149                            JSR         PRINTZERO           ; prints a zero
00001C9E                          1150                            
00001C9E  3401                    1151                            MOVE.W      D1,D2               ; copies number to D2
00001CA0  C47C 0F00               1152                            AND.W       #$0F00,D2           ; gets the second digit
00001CA4  B47C 0000               1153                            CMP.W       #0, D2              ; checks if it is 0
00001CA8  6600 00C8               1154                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001CAC  4EB9 00001D82           1155                            JSR         PRINTZERO           ; prints a zero
00001CB2                          1156                            
00001CB2  3401                    1157                            MOVE.W      D1,D2               ; copies number to D2
00001CB4  C47C 00F0               1158                            AND.W       #$00F0,D2           ; gets the third digit
00001CB8  B47C 0000               1159                            CMP.W       #0, D2              ; checks if it is 0
00001CBC  6600 00B4               1160                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001CC0  4EB9 00001D82           1161                            JSR         PRINTZERO           ; prints a zero
00001CC6  6000 00AA               1162                            BRA         PRINTASHEX          ; prints last digit
00001CCA                          1163                            
00001CCA  2401                    1164  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001CCC  C4BC F0000000           1165                            AND.L       #$F0000000,D2       ; gets the first digit
00001CD2  B4BC 00000000           1166                            CMP.L       #0, D2              ; checks if it is 0
00001CD8  6600 0098               1167                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001CDC  4EB9 00001D82           1168                            JSR         PRINTZERO           ; prints a zero
00001CE2                          1169                            
00001CE2  2401                    1170                            MOVE.L      D1,D2               ; copies number to D2
00001CE4  C4BC 0F000000           1171                            AND.L       #$0F000000,D2       ; gets the second digit
00001CEA  B4BC 00000000           1172                            CMP.L       #0, D2              ; checks if it is 0
00001CF0  6600 0080               1173                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001CF4  4EB9 00001D82           1174                            JSR         PRINTZERO           ; prints a zero
00001CFA                          1175                            
00001CFA  2401                    1176                            MOVE.L      D1,D2               ; copies number to D2
00001CFC  C4BC 00F00000           1177                            AND.L       #$00F00000,D2       ; gets the third digit
00001D02  B4BC 00000000           1178                            CMP.L       #0, D2              ; checks if it is 0
00001D08  6600 0068               1179                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D0C  4EB9 00001D82           1180                            JSR         PRINTZERO           ; prints a zero
00001D12                          1181                            
00001D12  2401                    1182                            MOVE.L      D1,D2               ; copies number to D2
00001D14  C4BC 000F0000           1183                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001D1A  B4BC 00000000           1184                            CMP.L       #0, D2              ; checks if it is 0
00001D20  6600 0050               1185                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D24  4EB9 00001D82           1186                            JSR         PRINTZERO           ; prints a zero
00001D2A                          1187                            
00001D2A  2401                    1188                            MOVE.L      D1,D2               ; copies number to D2
00001D2C  C4BC 0000F000           1189                            AND.L       #$0000F000,D2       ; gets the fith digit
00001D32  B4BC 00000000           1190                            CMP.L       #0, D2              ; checks if it is 0
00001D38  6600 0038               1191                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D3C  4EB9 00001D82           1192                            JSR         PRINTZERO           ; prints a zero
00001D42                          1193                            
00001D42  2401                    1194                            MOVE.L      D1,D2               ; copies number to D2
00001D44  C4BC 00000F00           1195                            AND.L       #$00000F00,D2       ; gets the sixth digit
00001D4A  B4BC 00000000           1196                            CMP.L       #0, D2              ; checks if it is 0
00001D50  6600 0020               1197                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D54  4EB9 00001D82           1198                            JSR         PRINTZERO           ; prints a zero
00001D5A                          1199                            
00001D5A  2401                    1200                            MOVE.L      D1,D2               ; copies number to D2
00001D5C  C4BC 000000F0           1201                            AND.L       #$000000F0,D2       ; gets the seventh digit
00001D62  B4BC 00000000           1202                            CMP.L       #0, D2              ; checks if it is 0
00001D68  6600 0008               1203                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001D6C  4EB9 00001D82           1204                            JSR         PRINTZERO           ; prints a zero
00001D72                          1205  
00001D72  143C 0010               1206  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001D76  103C 000F               1207                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001D7A  4E4F                    1208                            TRAP        #15                 ; is trap task 15
00001D7C  4CDF 0007               1209                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00001D80  4E75                    1210                            RTS                             ; returns from subroutine    
00001D82                          1211  * Prints a zero
00001D82                          1212  * Input: nothing
00001D82                          1213  * Output: 0 printed out to the console
00001D82  2F01                    1214  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00001D84  7200                    1215                            MOVE.L      #0,D1               ; moves 0 to D1
00001D86  4EB8 1C5A               1216                            JSR         PRINTNUM            ; prints the number
00001D8A  221F                    1217                            MOVE.L      (SP)+,D1            ; restores D1
00001D8C  4E75                    1218                            RTS                             ; returns from subroutine
00001D8E                          1219              
00001D8E                          1220  * Prints contents of things between a range
00001D8E                          1221  * input: A5, A6 (the range)
00001D8E                          1222  * output: prints memory contents from A5 to A6 as strings   
00001D8E  48E7 C040               1223  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001D92  224D                    1224                  MOVEA.L     A5, A1           ; loads A5 into A1
00001D94  9DCD                    1225                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001D96  320E                    1226                  MOVE.W      A6, D1           ; move n into D1
00001D98  103C 0001               1227                  MOVE.B      #1, D0           ; display n characters of string at A1
00001D9C  4E4F                    1228                  TRAP        #15              ; is trap task 1
00001D9E  4CDF 0203               1229                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001DA2  4E75                    1230                  RTS                          ; returns
00001DA4                          1231      
00001DA4                          1232  * Prints null terminated string
00001DA4                          1233  * input: string pointed to by A5
00001DA4                          1234  * output: prints out the null terminated string
00001DA4  48E7 8040               1235  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001DA8  224D                    1236                  MOVE.L      A5,A1           ; loads A5 into A1
00001DAA  103C 000E               1237                  MOVE.B      #14,D0          ; prints null terminated string
00001DAE  4E4F                    1238                  TRAP        #15             ; is trap task 10
00001DB0  4CDF 0201               1239                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001DB4  4E75                    1240                  RTS                         ; returns from subroutine
00001DB6                          1241                  
00001DB6  2F0D                    1242  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00001DB8  4BF9 00001FB8           1243                  LEA         NEW_LINE,A5     ; Prints null
00001DBE  4EB8 1DA4               1244                  JSR         PRINTNULL       ; prints the new line
00001DC2  2A5F                    1245                  MOVE.L      (SP)+,A5        ; returns A5
00001DC4  4E75                    1246                  RTS
00001DC6                          1247  
00001DC6                          1248  * Prints the size of the MOVE or MOVEA operation  
00001DC6                          1249  * input: D0
00001DC6                          1250  * output: prints out the size of a MOVE or MOVEA operation        
00001DC6  48E7 8004               1251  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001DCA  3200                    1252                  MOVE.W  D0,D1               ; stores d0 in d1
00001DCC  C07C 3000               1253                  AND.W   #$3000,D0           ; gets the size
00001DD0  B07C 2000               1254                  CMP.W   #$2000,D0           ; checks if is long
00001DD4  6700 001E               1255                  BEQ     MOVE_LONG
00001DD8  B07C 3000               1256                  CMP.W   #$3000,D0           ; checks if is word
00001DDC  6700 000C               1257                  BEQ     MOVE_WORD      
00001DE0                          1258                  
00001DE0  4BF9 000020C3           1259  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001DE6  6000 0012               1260                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001DEA                          1261  
00001DEA  4BF9 000020C9           1262  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
00001DF0  6000 0008               1263                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001DF4                          1264  
00001DF4  4BF9 000020CF           1265  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00001DFA                          1266                  
00001DFA  4EB8 1DA4               1267  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00001DFE  4CDF 2001               1268                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
00001E02  4E75                    1269                  RTS
00001E04                          1270  
00001E04  43F9 00001F8A           1271  ERROR           LEA     ERROR_MSG,A1
00001E0A  103C 000E               1272                  MOVE.B  #14,D0
00001E0E  4E4F                    1273                  TRAP    #15 
00001E10                          1274         
00001E10                          1275  * DELETE THIS: Test                
00001E10  2661                    1276  DELETEME        MOVEA.L  -(A1),A3
00001E12  6700 0030               1277                  BEQ      DELETEMEAGAIN  
00001E16  6F00 002C               1278                  BLE      DELETEMEAGAIN
00001E1A  6E00 0028               1279                  BGT      DELETEMEAGAIN
00001E1E                          1280  
00001E1E  E40A                    1281                  LSR.B      #2,D2
00001E20  E2E2                    1282                  LSR.W      -(A2)
00001E22  E2DA                    1283                  LSR.W      (A2)+
00001E24  E4AA                    1284                  LSR.L      D2,D2 
00001E26  E50A                    1285                  LSL.B      #2,D2
00001E28  E3E2                    1286                  LSL.W      -(A2)
00001E2A  E3DA                    1287                  LSL.W      (A2)+
00001E2C  E5AA                    1288                  LSL.L      D2,D2
00001E2E  E51A                    1289                  ROL.B      #2,D2
00001E30  E7E2                    1290                  ROL.W      -(A2)
00001E32  E7DA                    1291                  ROL.W      (A2)+
00001E34  E5BA                    1292                  ROL.L      D2,D2
00001E36  E41A                    1293                  ROR.B      #2,D2
00001E38  E6E2                    1294                  ROR.W      -(A2)
00001E3A  E6DA                    1295                  ROR.W      (A2)+
00001E3C  E4BA                    1296                  ROR.L      D2,D2
00001E3E                          1297                  
00001E3E  504D                    1298                  ADDQ.W      #8,A5
00001E40  D6C2                    1299                  ADDA.W      D2,A3
00001E42  9BCB                    1300                  SUB.L       A3,A5        
00001E44                          1301                  
00001E44                          1302  DELETEMEAGAIN                 
00001E44                          1303            
00001E44  FFFF FFFF               1304      SIMHALT             ; halt simulator
00001E48                          1305  
00001E48                          1306  * Put variables and constants here
00001E48                          1307  
00001E48  =0000000D               1308  CR                              EQU     $0D
00001E48  =0000000A               1309  LF                              EQU     $0A 
00001E48  =00000009               1310  TAB                             EQU     $09  
00001E48                          1311  
00001E48                          1312  * Addressing Modes
00001E48  =00000000               1313  Dn                              EQU     0
00001E48  =00000001               1314  An                              EQU     1
00001E48  =00000002               1315  AnIndirect                      EQU     2
00001E48  =00000003               1316  AnPost                          EQU     3
00001E48  =00000004               1317  AnPre                           EQU     4
00001E48  =00000007               1318  Other                           EQU     7           ; short, long, immediate
00001E48                          1319  
00001E48                          1320  * Xn
00001E48  =00000000               1321  ABSShort                        EQU     0
00001E48  =00000001               1322  ABSLong                         EQU     1
00001E48  =00000004               1323  XnImmediate                     EQU     4
00001E48                          1324  
00001E48                          1325  * Valid Addressing Modes
00001E48= 00 01 02 03 04 07 FF    1326  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00001E4F                          1327  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00001E4F= 00 02 03 04 07 FF       1328  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001E55= 02 04 07 FF             1329  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001E59= 02 03 07 FF             1330  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00001E5D= 02 03 04 07 FF          1331  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001E62= 00 02 03 04 07 FF       1332  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001E68= 01 07 FF                1333  VALIDEA_LEA                     DC.B    An,Other,-1
00001E6B= 00 02 03 04 07 FF       1334  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001E71= 02 03 04 07 FF          1335  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001E76= 02 03 04 07 FF          1336  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001E7B= 02 07 FF                1337  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00001E7E                          1338  
00001E7E                          1339  * Valid Xn
00001E7E= 00 01 04 FF             1340  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001E82                          1341  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001E82= 00 01 FF                1342  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001E85                          1343  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001E85                          1344  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001E85                          1345  
00001E85                          1346  * posible memory ASd/LSd rotation values
00001E85  =00000000               1347  ASd_MEM                         EQU     0   
00001E85  =00000001               1348  LSd_MEM                         EQU     1 
00001E85  =00000003               1349  ROd_MEM                         EQU     3
00001E85                          1350   
00001E85  =00000000               1351  ASd_REG                         EQU     0   
00001E85  =00000001               1352  LSd_REG                         EQU     1 
00001E85  =00000003               1353  ROd_REG                         EQU     3
00001E85                          1354  
00001E85                          1355  * Starting messages
00001E85= 57 65 6C 63 6F 6D ...   1356  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
00001EAC= 46 6F 72 6D 61 74 ...   1357                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001EFB= 50 6C 65 61 73 65 ...   1358  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001F32= 50 6C 65 61 73 65 ...   1359  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001F68= 49 6E 76 61 6C 69 ...   1360  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001F8A= 45 72 72 6F 72 20 ...   1361  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001FA6= 31 30 30 30 09 44 ...   1362  INVALID_INSTR                   DC.B    '1000',TAB,'DATA',TAB,'$WXYZ',CR,LF,0
00001FB8= 0D 0A 00                1363  NEW_LINE                        DC.B    CR,LF,0
00001FBB= 09 09 09 00             1364  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001FBF                          1365  
00001FBF                          1366  * Opcode Messages
00001FBF= 09 4E 4F 50 00          1367  MSG_NOP                         DC.B    TAB,'NOP',0
00001FC4= 09 4D 4F 56 45 00       1368  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001FCA= 09 4D 4F 56 45 41 00    1369  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001FD1= 09 4D 4F 56 45 51 00    1370  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001FD8= 09 4D 4F 56 45 4D 00    1371  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001FDF= 09 41 44 44 00          1372  MSG_ADD                         DC.B    TAB,'ADD',0
00001FE4= 09 41 44 44 41 00       1373  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001FEA= 09 41 44 44 51 00       1374  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001FF0= 09 53 55 42 00          1375  MSG_SUB                         DC.B    TAB,'SUB',0
00001FF5= 09 4D 55 4C 53 00       1376  MSG_MULS                        DC.B    TAB,'MULS',0
00001FFB= 09 44 49 56 55 00       1377  MSG_DIVU                        DC.B    TAB,'DIVU',0
00002001= 09 4C 45 41 09 09 ...   1378  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00002009= 09 41 4E 44 00          1379  MSG_AND                         DC.B    TAB,'AND',0
0000200E= 09 4F 52 00             1380  MSG_OR                          DC.B    TAB,'OR',0
00002012= 09 4E 4F 54 00          1381  MSG_NOT                         DC.B    TAB,'NOT',0
00002017= 09 4C 53 00             1382  MSG_LSd                         DC.B    TAB,'LS',0
0000201B= 09 41 53 00             1383  MSG_ASd                         DC.B    TAB,'AS',0
0000201F= 09 52 4F 00             1384  MSG_ROd                         DC.B    TAB,'RO',0
00002023= 09 42 43 43 09 09 ...   1385  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
0000202B= 09 42 43 53 09 09 ...   1386  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00002033= 09 42 45 51 09 09 ...   1387  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
0000203B= 09 42 4E 45 09 09 ...   1388  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00002043= 09 42 47 45 09 09 ...   1389  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
0000204B= 09 42 47 54 09 09 ...   1390  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00002053= 09 42 48 49 09 09 ...   1391  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
0000205B= 09 42 4C 45 09 09 ...   1392  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00002063= 09 42 4C 53 09 09 ...   1393  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
0000206B= 09 42 4C 54 09 09 ...   1394  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00002073= 09 42 4D 49 09 09 ...   1395  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
0000207B= 09 42 50 4C 09 09 ...   1396  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00002083= 09 42 56 43 09 09 ...   1397  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
0000208B= 09 42 56 53 09 09 ...   1398  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00002093= 09 4A 53 52 09 09 ...   1399  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
0000209B= 09 52 54 53 00          1400  MSG_RTS                         DC.B    TAB,'RTS',0
000020A0= 09 42 52 41 09 09 ...   1401  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
000020A8                          1402  
000020A8                          1403  * Direction for LSd and ASd
000020A8= 52 00                   1404  MSG_RIGHT                       DC.B    'R',0
000020AA= 4C 00                   1405  MSG_LEFT                        DC.B    'L',0
000020AC                          1406  
000020AC                          1407  * Effective Addresses Messages
000020AC= 44 00                   1408  MSG_DR                          DC.B    'D',0
000020AE= 41 00                   1409  MSG_AR                          DC.B    'A',0
000020B0= 28 00                   1410  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000020B2= 29 00                   1411  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000020B4= 2B 00                   1412  MSG_PLUS                        DC.B    '+',0
000020B6= 2D 00                   1413  MSG_MINUS                       DC.B    '-',0
000020B8= 23 00                   1414  MSG_POUND                       DC.B    '#',0 
000020BA= 24 00                   1415  MSG_HEX                         DC.B    '$',0 
000020BC= 2C 20 00                1416  MSG_COMMA                       DC.B    ', ',0 
000020BF= 20 00                   1417  MSG_SPACE                       DC.B    ' ',0
000020C1= 09 00                   1418  MSG_TAB                         DC.B    TAB,0
000020C3                          1419  
000020C3                          1420  * Size Messages
000020C3= 2E 42 09 09 09 00       1421  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
000020C9= 2E 57 09 09 09 00       1422  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
000020CF= 2E 4C 09 09 09 00       1423  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
000020D5                          1424  
000020D5                          1425  * Variables
000020D5  =00000100               1426  STARTING_ADDRESS                EQU     $100
000020D5  =00000150               1427  ENDING_ADDRESS                  EQU     $150
000020D5  =00000200               1428  CURRENT_INSTR                   EQU     $200
000020D5  =00000250               1429  REG_VAR                         EQU     $250 * Hold bits 11-9
000020D5  =00000300               1430  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000020D5  =00000350               1431  EA_MODE                         EQU     $350 * Hold bits 5-3
000020D5  =00000400               1432  EA_REG                          EQU     $400 * Hold bits 2-0
000020D5                          1433  
000020D5                          1434              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           144C
ADDQ_BYTE           14E6
ADDQ_LONG           1506
ADDQ_WORD           14F6
ADD_SUB_BYTE        1388
ADD_SUB_HELP        130C
ADD_SUB_LONG        13A4
ADD_SUB_OPERAND     13BA
ADD_SUB_SIZE        1364
ADD_SUB_WORD        1396
AN                  1
AND_BYTE            16C0
AND_LONG            16E0
AND_WORD            16D0
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1F68
CASE_ADD            12DE
CASE_ADDA           1420
CASE_ADDQ           1488
CASE_AND            167A
CASE_AR             1B22
CASE_ARI            1B3A
CASE_ARIPOST        1B6A
CASE_ARIPRE         1BA6
CASE_ASDMEM         1744
CASE_ASDREG         180C
CASE_BCC            1944
CASE_BEQ            1976
CASE_BGT            198A
CASE_BLE            1980
CASE_BRA            1920
CASE_DATA           19BA
CASE_DR             1B0A
CASE_EPICFAIL       19BC
CASE_IMMEDIATE      1BF4
CASE_JSR            19A4
CASE_LEA            15E8
CASE_LEFTMEM        176A
CASE_LEFTREG        1832
CASE_LONG           1C34
CASE_LSDASD         1704
CASE_LSDMEM         173A
CASE_LSDREG         1802
CASE_MOVE           1182
CASE_MOVEM          1224
CASE_MOVEQ          128A
CASE_NOP            116C
CASE_NOT            1704
CASE_OR             1704
CASE_OTHER          1BE2
CASE_RIGHTMEM       1774
CASE_RIGHTREG       183C
CASE_RODMEM         174E
CASE_RODREG         1816
CASE_RTS            19A4
CASE_SHIFTMEM       1722
CASE_SHIFTREG       17E8
CASE_SUB            155C
CASE_SUBA           15D2
CASE_WORD           1C18
CHECKEAEXIT         1ADA
CHECKEAMLOOP        1AAC
CHECKEAXN_IFVALID   1AAA
CHECKGET_EAXN       1A12
CHECKMEMSOURE       17A8
CHECKSHIFT_XN       17D2
CHECK_LENGTH        10CC
CHECK_ODD           1162
CHECK_ORDER         109A
CHECK_XN            1A42
CONCAT              1114
CONVERT             10DE
CR                  D
CURRENT_INSTR       200
DELETEME            1E10
DELETEMEAGAIN       1E44
DESTEA              19C8
DESTXN              19F2
DISASSEMBLE         10A4
DN                  0
DN_PLUS_EA          13F4
EASHIFT_VALID       17C6
EAXN_INVALID        1A54
EAXN_VALID          1A3A
EA_MODE             350
EA_REG              400
EA_TO_STRING        1ADE
EA_TO_STRING_EXIT   1C54
ENDING              1F32
ENDING_ADDRESS      150
END_CHECKGET        1A58
ERROR               1E04
ERROR_MSG           1F8A
FINDTYPEEA          19DC
FINDTYPEXN          1A06
FINISHMOVE          1DFA
FINISH_ADD          13B2
FINISH_ADDA         145C
FINISH_ADDQ         1516
FINISH_AND          16F0
FINISH_SUB          1598
FINISH_SUBA         159E
GETDIRECTION        1A92
GETDISPLACEMENT     1A5A
GETMEMSOURCE        1790
GETROTATION         1A88
GETROTATIONLOCATION  1AA2
GETROTATIONSIZE     1A9A
GET_EA              19BE
GET_XN              19E8
INPUT1              100C
INPUT2              1052
INSERTA             11F0
INVALID             112C
INVALIDEA           1ABE
INVALID_INSTR       1FA6
INV_INSTR           16F6
ISNUMBER            10F4
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128A
MOVEM_REG2MEM       125A
MOVE_BYTE           1DE0
MOVE_LONG           1DF4
MOVE_WORD           1DEA
MSG_ADD             1FDF
MSG_ADDA            1FE4
MSG_ADDQ            1FEA
MSG_AND             2009
MSG_AR              20AE
MSG_ASD             201B
MSG_B               20C3
MSG_BCC             2023
MSG_BCS             202B
MSG_BEQ             2033
MSG_BGE             2043
MSG_BGT             204B
MSG_BHI             2053
MSG_BLE             205B
MSG_BLS             2063
MSG_BLT             206B
MSG_BMI             2073
MSG_BNE             203B
MSG_BPL             207B
MSG_BRA             20A0
MSG_BVC             2083
MSG_BVS             208B
MSG_COMMA           20BC
MSG_DIVU            1FFB
MSG_DR              20AC
MSG_HEX             20BA
MSG_JSR             2093
MSG_L               20CF
MSG_LB              20B0
MSG_LEA             2001
MSG_LEFT            20AA
MSG_LSD             2017
MSG_MINUS           20B6
MSG_MOVE            1FC4
MSG_MOVEA           1FCA
MSG_MOVEM           1FD8
MSG_MOVEQ           1FD1
MSG_MULS            1FF5
MSG_NOP             1FBF
MSG_NOT             2012
MSG_OR              200E
MSG_PLUS            20B4
MSG_POUND           20B8
MSG_RB              20B2
MSG_RIGHT           20A8
MSG_ROD             201F
MSG_RTS             209B
MSG_SPACE           20BF
MSG_SUB             1FF0
MSG_TAB             20C1
MSG_W               20C9
NEW_LINE            1FB8
NOTNUMBER           10FC
OPCODE_DECODE       116A
OPMODE_VAR          300
OTHER               7
OTHEREA             1AD6
PRINTADD            1352
PRINTADDRESS        1A6A
PRINTASHEX          1D72
PRINTBCC            1994
PRINTENTER          1DB6
PRINTHEXNUM         1C6A
PRINTLONGZERO       1CCA
PRINTMOVE           11F6
PRINTMOVESIZE       1DC6
PRINTNULL           1DA4
PRINTNUM            1C5A
PRINTRANGE          1D8E
PRINTREGEA          187E
PRINTREGSIZE        184C
PRINTSHIFTMEM       1754
PRINTSHIFTREG       181C
PRINTSHORTLONGNUM   1C7E
PRINTSHORTZERO      1C8A
PRINTSUB            1578
PRINTZERO           1D82
PRINT_8             1550
PRINT_ADDQ_DATA     1534
PRINT_MEMDIR        177A
PRINT_MOVEQ         12AC
PRINT_REGDIR        1846
REG2MEMXNCHECK      1274
REG_BYTE            1864
REG_IMMEDIATE       1894
REG_LONG            1878
REG_REGISTER        18DA
REG_VAR             250
REG_WORD            186E
RESET_INPUT         10C4
RETURN              112A
ROD_MEM             3
ROD_REG             3
SOURCEEA            19D4
SOURCEXN            19FE
START               1000
STARTING            1EFB
STARTING_ADDRESS    100
STOP                10BE
TAB                 9
TEST_RANGE          114A
THREE_TAB           1FBB
VALIDEA             1AC6
VALIDEA_ADDSUB_DESTOPERAND  1E5D
VALIDEA_ALL         1E48
VALIDEA_ANDORNOT    1E6B
VALIDEA_ANDOR_DESTOPERAND  1E71
VALIDEA_JSR         1E7B
VALIDEA_LEA         1E68
VALIDEA_MOVEM_MEMTOREG  1E59
VALIDEA_MOVEM_REGTOMEM  1E55
VALIDEA_MOVEQ       1E4F
VALIDEA_MULSDIVU    1E62
VALIDEA_SHIFT       1E76
VALIDXN_ALL         1E7E
VALIDXN_SHORTLONG   1E82
WELCOME             1E85
XNIMMEDIATE         4
