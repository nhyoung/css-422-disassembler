00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/8/2020 3:52:47 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 0000214D             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 00002175             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 000021C0             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000021E0             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 00001146             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 00001158             36                  JSR     CONVERT
00001052  4EB9 000011C4             37                  JSR     TEST_RANGE
00001058  4EB9 000011DC             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 00002217             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 00001146             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 00001158             55                  JSR     CONVERT
0000109A  4EB9 000011C4             56                  JSR     TEST_RANGE
000010A0  4EB9 000011DC             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0088                 64                  BLT     RESET_INPUT
000010B8                            65                                 
000010B8                            66  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010B8                            67                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010B8                            68                  ; JSR     PRINTSHORTLONGNUM   ; prints out address                    
000010B8  4EB9 000011F0             69                  JSR     OPCODE_DECODE       ; decode the opcode
000010BE  4EB9 00002076             70                  JSR     PRINTENTER          ; prints a new line
000010C4  B5CB                      71                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010C6  6FF0                      72                  BLE     DISASSEMBLE         ; if not, loop
000010C8                            73  
000010C8  4BF9 0000229D             74  FINISHED        LEA     DONE,A5
000010CE  4EB9 00002064             75                  JSR     PRINTNULL
000010D4  103C 0005                 76                  MOVE.B  #5,D0
000010D8  4E4F                      77                  TRAP    #15
000010DA                            78                  
000010DA  B23C 000D                 79                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000010DE  6700 0008                 80                  BEQ     RESTART             ; it's Enter, restart
000010E2                            81                  
000010E2  103C 0009                 82                  MOVE.B  #9,D0
000010E6  4E4F                      83                  TRAP    #15
000010E8                            84                  
000010E8  103C 000B                 85  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
000010EC  323C FF00                 86                  MOVE.W  #$FF00, D1          Clear Screen
000010F0  4E4F                      87                  TRAP    #15                 Call Trap
000010F2                            88                  
000010F2  103C 000C                 89                  MOVE.B  #12,D0              Keyboard echo
000010F6  123C 0001                 90                  MOVE.B  #1,D1               Visible
000010FA  4E4F                      91                  TRAP    #15
000010FC                            92                  
000010FC  207C 00000000             93                  MOVE.L  #$0000000, A0       ; Reset A1
00001102  227C 00000000             94                  MOVE.L  #$0000000, A1       ; Reset A1
00001108  247C 00000000             95                  MOVE.L  #$0000000, A2       ; Reset A2
0000110E  267C 00000000             96                  MOVE.L  #$0000000, A3       ; Reset A3
00001114  287C 00000000             97                  MOVE.L  #$0000000, A4       ; Reset A4
0000111A  2A7C 00000000             98                  MOVE.L  #$0000000, A5       ; Reset A5
00001120  2C7C 00000000             99                  MOVE.L  #$0000000, A6       ; Reset A6
00001126  2E7C 01000000            100                  MOVEA.L #$01000000,A7       ; Reset A7
0000112C  4281                     101                  CLR.L   D1                  ; Reset D1
0000112E  4281                     102                  CLR.L   D1                  ; Reset D1
00001130  4282                     103                  CLR.L   D2                  ; Reset D2
00001132  4283                     104                  CLR.L   D3                  ; Reset D3
00001134  4284                     105                  CLR.L   D4                  ; Reset D4
00001136  4285                     106                  CLR.L   D5                  ; Reset D5
00001138  4286                     107                  CLR.L   D6                  ; Reset D6
0000113A  6000 FEC4                108                  BRA     START               ; branch to start of program
0000113E                           109  
0000113E                           110  *--------------------SUBROUTINES------------------    
0000113E                           111  
0000113E  143C 0001                112  RESET_INPUT     MOVE.B  #1,D2
00001142  6000 0062                113                  BRA     INVALID            
00001146                           114                  
00001146  7800                     115  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
00001148  B204                     116                  CMP.B   D4,D1               ; D1 stores length
0000114A  6700 005A                117                  BEQ     INVALID             ; input is null
0000114E  0C41 0008                118                  CMPI    #$8,D1              ; check if input is longer than a longword
00001152  6600 0052                119                  BNE     INVALID             ; input is longer than a longword
00001156  4E75                     120                  RTS
00001158                           121                              
00001158  4283                     122  CONVERT         CLR.L   D3
0000115A  4284                     123                  CLR.L   D4
0000115C  1619                     124                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000115E  B63C 0039                125                  CMP.B   #57,D3
00001162  6E00 0012                126                  BGT     NOTNUMBER
00001166                           127                  
00001166  B63C 002F                128                  CMP.B   #47,D3
0000116A  6E00 0002                129                  BGT     ISNUMBER
0000116E                           130                  
0000116E  0603 00D0                131  ISNUMBER        ADD.B   #-48,D3             ; current char is number
00001172  6000 001A                132                  BRA     CONCAT
00001176                           133              
00001176  B63C 0041                134  NOTNUMBER       CMP.B   #65,D3
0000117A  6D00 002A                135                  BLT     INVALID
0000117E  B63C 0046                136                  CMP.B   #70,D3
00001182  6E00 0022                137                  BGT     INVALID  
00001186  0603 00C9                138                  ADD.B   #-55,D3             ; is letter             
0000118A  6000 0002                139                  BRA     CONCAT
0000118E                           140              
0000118E  BC3C 0000                141  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001192  6D00 0010                142                  BLT     RETURN
00001196  1806                     143                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001198  E50C                     144                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
0000119A  E9AB                     145                  LSL.L   D4,D3               ; moves current char to correct position  
0000119C  DA83                     146                  ADD.L   D3,D5               ; D5 stores converted input so far
0000119E  0606 00FF                147                  ADD.B   #-1,D6  
000011A2  60B4                     148                  BRA     CONVERT             ; continue loop for remaining chars
000011A4                           149                  
000011A4  4E75                     150  RETURN          RTS
000011A6                           151                  
000011A6  227C 00000000            152  INVALID         MOVEA.L #$0000000, A1       ; clear A1
000011AC  43F9 0000224D            153                  LEA     BAD_INPUT,A1        ; output invalid message
000011B2  103C 000E                154                  MOVE.B  #14,D0
000011B6  4E4F                     155                  TRAP    #15
000011B8  B47C 0001                156                  CMP     #1,D2
000011BC  6700 FE62                157                  BEQ     INPUT1
000011C0  6000 FEA4                158                  BRA     INPUT2
000011C4                           159  
000011C4  4284                     160  TEST_RANGE      CLR.L      D4               ; D4 will store test results
000011C6  223C 00001000            161                  MOVE.L     #$1000,D1        ; D1 stores minimum address
000011CC  BA81                     162                  CMP.L      D1,D5            ; Compare minimum address with input
000011CE  6DD6                     163                  BLT        INVALID          ; input is too low. 
000011D0  223C 00FFFFFE            164                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
000011D6  BA81                     165                  CMP.L      D1,D5            ; compare maximum address with input
000011D8  6ECC                     166                  BGT        INVALID          ; input too large
000011DA  4E75                     167                  RTS                         ; input is within range
000011DC                           168             
000011DC  0805 0000                169  CHECK_ODD       BTST       #0,D5            ; check if input is odd
000011E0  66C4                     170                  BNE        INVALID
000011E2  4E75                     171                  RTS
000011E4                           172  
000011E4                           173  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
000011E4                           174  *                MOVE.L  A6,D1                   ; loads current address in D1
000011E4                           175  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E4                           176  *                JSR     PRINTSHORTLONGNUM       ; prints out address
000011E4                           177  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
000011E4                           178  *                RTS
000011E4  220E                     179                  MOVE.L  A6,D1                   ; loads current address in D1
000011E6  7801                     180                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
000011E8  4EB9 00001F3E            181                  JSR     PRINTSHORTLONGNUM       ; prints out address
000011EE  4E75                     182                  RTS
000011F0                           183  
000011F0                           184  
000011F0                           185  
000011F0                           186  * Checks every single possible opcode we could have. Jump table
000011F0                           187  * Inputs: (A2) which is a pointer to intruction word to be translated
000011F0                           188  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000011F0                           189  
000011F0  3C4A                     190  OPCODE_DECODE   MOVE.W  A2,A6
000011F2  301A                     191                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
000011F4                           192                  
000011F4                           193  
000011F4                           194  *---------------NOP opcode----------------------                
000011F4  B07C 4E71                195  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
000011F8  6600 0014                196                  BNE     CASE_MOVE               ; checks the next case if not equal
000011FC                           197                  
000011FC  4EB8 11E4                198                  JSR     PRINT_ADDR
00001200  4BF9 000022D6            199                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001206  4EB9 00002064            200                  JSR     PRINTNULL               ; prints NOP                
0000120C  4E75                     201                  RTS                             ; returns from the subroutine
0000120E                           202  
0000120E                           203  *---------------MOVE opcode----------------------              
0000120E                           204                  * if first two bits are 00, next two are not 00
0000120E  3200                     205  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001210  C27C C000                206                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001214  6600 009E                207                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001218  B07C 0FFF                208                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
0000121C  6F00 0096                209                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001220                           210                  
00001220                           211                  ; Check source
00001220  4BF9 00002110            212                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001226  4DF9 00002146            213                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000122C  3E3C 0000                214                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001230  4EB9 00001C30            215                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001236  B27C 0001                216                  CMP.W   #1,D1                    ; checks if invalid
0000123A  6700 0998                217                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
0000123E  3802                     218                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
00001240  3A03                     219                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001242                           220                  
00001242                           221                  ; Check destination
00001242  4BF9 00002110            222                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001248  4DF9 0000214A            223                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000124E  3E3C 0001                224                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001252  4EB9 00001C30            225                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001258  B27C 0001                226                  CMP.W   #1,D1                    ; checks if invalid
0000125C  6700 0976                227                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
00001260  3C02                     228                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
00001262  3E03                     229                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
00001264                           230                  
00001264                           231                  ; Checking if it is MOVEA
00001264  3200                     232                  MOVE.W  D0,D1                    ; stores d0 in d1
00001266  C27C 01C0                233                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
0000126A  B27C 0040                234                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
0000126E  6700 0010                235                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
00001272                           236                  
00001272  4EB8 11E4                237                  JSR     PRINT_ADDR               ; print address
00001276  4BF9 000022DB            238                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
0000127C  6000 0008                239                  BRA     PRINTMOVE                ; Branches to print move
00001280                           240                  
00001280  4BF9 000022E1            241  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001286                           242   
00001286  4EB9 00002064            243  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
0000128C  4EB9 00002086            244                  JSR     PRINTMOVESIZE            ; prints out the size  
00001292  3404                     245                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001294  3605                     246                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001296  4EB9 00001D9E            247                  JSR     EA_TO_STRING             ; outputs it into a string
0000129C                           248                  
0000129C                           249                  ; prints a comma to seperate
0000129C  4BF9 000023D3            250                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
000012A2  4EB9 00002064            251                  JSR     PRINTNULL                ; prints out MOVE
000012A8                           252                  
000012A8                           253                  ; print destination
000012A8  3406                     254                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
000012AA  3607                     255                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
000012AC  4EB9 00001D9E            256                  JSR     EA_TO_STRING             ; outputs it into a string
000012B2  4E75                     257                  RTS                              ; exits subroutine                 
000012B4                           258                
000012B4                           259  *---------------MOVEM opcode----------------------                
000012B4  3200                     260  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
000012B6  C27C FB80                261                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
000012BA  B27C 4880                262                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
000012BE  6600 00F4                263                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
000012C2                           264                  
000012C2                           265                  ; Check D
000012C2  3200                     266                  MOVE.W  D0,D1                           ; copies instruction word to D1
000012C4  C27C 0400                267                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
000012C8  3E01                     268                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
000012CA  B27C 0400                269                  CMP.W   #$0400,D1                       ; checks if value is 1
000012CE  6700 0074                270                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
000012D2                           271  
000012D2                           272  MOVEM_REG2MEM   ; loads EA and XN
000012D2  3E3C 0000                273                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000012D6  4BF9 0000211D            274                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
000012DC  4DF9 0000214A            275                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000012E2  4EB9 00001C30            276                  JSR     CHECKGET_EAXN
000012E8  B27C 0001                277                  CMP.W   #1,D1                           ; checks if D1 invalid
000012EC  6700 08E6                278                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000012F0  4EB8 11E4                279                  JSR     PRINT_ADDR                      ; prints the address
000012F4  4BF9 000022EF            280                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000012FA  4EB9 00002064            281                  JSR     PRINTNULL                       ; prints MOVEM
00001300                           282                  
00001300                           283                  ; finds and prints size
00001300  3200                     284                  MOVE.W  D0,D1                           ; copies D0
00001302  C27C 0040                285                  AND.W   #$0040,D1                       ; gets the size bit
00001306  6600 0012                286                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
0000130A                           287  
0000130A  4BF9 000023E2            288  REG2MEMWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001310  4EB9 00002064            289                  JSR     PRINTNULL                       ; prints MOVEM
00001316  6000 000E                290                  BRA     PRINTREG2MEM                    ; prints the registers           
0000131A                           291                  
0000131A  4BF9 000023E8            292  REG2MEMLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001320  4EB9 00002064            293                  JSR     PRINTNULL                       ; prints MOVEM 
00001326                           294             
00001326  383C 0001                295  PRINTREG2MEM    MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
0000132A  4EB9 00001CC8            296                  JSR     PRINTREGISTERS                  ; prints registers
00001330  4BF9 000023D3            297                  LEA     MSG_COMMA,A5                    ; loads comma
00001336  4EB9 00002064            298                  JSR     PRINTNULL                       ; prints comma
0000133C  4EB9 00001D9E            299                  JSR     EA_TO_STRING                    ; prints EA
00001342  4E75                     300                  RTS
00001344                           301  
00001344                           302  MOVEM_MEM2REG  ; loads EA and XN
00001344  3E3C 0000                303                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001348  4BF9 00002121            304                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
0000134E  4DF9 0000214A            305                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001354  4EB9 00001C30            306                  JSR     CHECKGET_EAXN
0000135A  B27C 0001                307                  CMP.W   #1,D1                           ; checks if D1 invalid
0000135E  6700 0874                308                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001362  4EB8 11E4                309                  JSR     PRINT_ADDR                      ; prints the address
00001366  4BF9 000022EF            310                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000136C  4EB9 00002064            311                  JSR     PRINTNULL                       ; prints MOVEM
00001372                           312                  
00001372                           313                  ; finds and prints size
00001372  3200                     314                  MOVE.W  D0,D1                           ; copies D0
00001374  C27C 0040                315                  AND.W   #$0040,D1                       ; gets the size bit
00001378  6600 0010                316                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
0000137C                           317  
0000137C  4BF9 000023E2            318  MEM2REGWORD     LEA     MSG_W,A5                        ; loads MOVEM
00001382  4EB9 00002064            319                  JSR     PRINTNULL                       ; prints MOVEM
00001388  609C                     320                  BRA     PRINTREG2MEM                    ; prints the registers           
0000138A                           321                  
0000138A  4BF9 000023E8            322  MEM2REGLONG     LEA     MSG_L,A5                        ; loads MOVEM
00001390  4EB9 00002064            323                  JSR     PRINTNULL                       ; prints MOVEM 
00001396                           324             
00001396  4EB9 00001D9E            325  PRINTMEM2REG    JSR     EA_TO_STRING                    ; prints EA
0000139C  4BF9 000023D3            326                  LEA     MSG_COMMA,A5                    ; loads comma
000013A2  4EB9 00002064            327                  JSR     PRINTNULL                       ; prints comma
000013A8  383C FFFF                328                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
000013AC  4EB9 00001CC8            329                  JSR     PRINTREGISTERS                  ; prints registers
000013B2  4E75                     330                  RTS
000013B4                           331                          
000013B4                           332  
000013B4                           333  *---------------MOVEQ opcode----------------------
000013B4  3200                     334  CASE_MOVEQ      MOVE.W  D0,D1
000013B6  C27C F100                335                  AND.W   #$F100,D1
000013BA  B27C 7000                336                  CMP.W   #$7000,D1
000013BE  6600 004C                337                  BNE     CASE_ADD
000013C2                           338                  
000013C2                           339                  ;loads Register
000013C2  323C 0001                340                  MOVE.W  #1,D1                           ; copies instruction word to D1
000013C6  4EB9 00001C06            341                  JSR     GET_XN                          ; gets XN and puts in D1
000013CC  3401                     342                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
000013CE                           343                  
000013CE                           344                  ;loads DATA
000013CE  3200                     345                  MOVE.W  D0,D1
000013D0  C27C 00FF                346                  AND.W   #$00FF,D1                       ;bit mask to get DATA
000013D4  3601                     347                  MOVE.W  D1,D3                          ;copy data into D3
000013D6                           348                                                        ;must convert bits to hex
000013D6                           349                                  
000013D6  4EB8 11E4                350  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
000013DA                           351  
000013DA  4BF9 000022E8            352                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
000013E0  4EB9 00002064            353                  JSR     PRINTNULL  
000013E6                           354                  
000013E6  4BF9 000023E8            355                  LEA     MSG_L,A5                        ;PRINT SIZE L
000013EC  4EB9 00002064            356                  JSR     PRINTNULL
000013F2                           357      
000013F2  4BF9 000022D2            358                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000013F8  4EB9 00002064            359                  JSR     PRINTNULL
000013FE                           360                  
000013FE  4BF9 000023CF            361                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
00001404  4EB9 00002064            362                  JSR     PRINTNULL
0000140A  4E75                     363                  RTS
0000140C                           364                  
0000140C                           365  *---------------ADD opcode----------------------                
0000140C                           366  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
0000140C  3200                     367  CASE_ADD        MOVE.W  D0,D1
0000140E  C27C F000                368                  AND.W   #$F000,D1
00001412  B27C D000                369                  CMP.W   #$D000,D1
00001416  6600 019A                370                  BNE     CASE_ADDQ
0000141A                           371   
0000141A  4EB8 11E4                372                  JSR     PRINT_ADDR              ; print address
0000141E                           373                  
0000141E  4EB9 00001438            374                  JSR     ADD_SUB_HELP
00001424                           375                  
00001424                           376                  ; bits 7-8 determine if it is ADDA or ADD
00001424  3200                     377                  MOVE.W  D0,D1
00001426  E149                     378                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001428  E049                     379                  LSR.W   #8,D1
0000142A  EC49                     380                  LSR.W   #6,D1                   ; get rid of right 6 bits
0000142C  B27C 0003                381                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001430  6700 0118                382                  BEQ     CASE_ADDA
00001434                           383                  
00001434  6000 0040                384                  BRA     PRINTADD                ; Branches to print add
00001438                           385                  
00001438                           386                  ; Check bits 0-5 
00001438  4BF9 00002110            387  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000143E  4DF9 00002146            388                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001444  3E3C 0000                389                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001448  4EB9 00001C30            390                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000144E  B27C 0001                391                  CMP.W       #1,D1                    ; checks if invalid
00001452  6700 0780                392                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001456  3802                     393                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001458  3A03                     394                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
0000145A                           395                  
0000145A                           396                  ; Check 6-11
0000145A  4BF9 00002110            397                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001460  4DF9 0000214A            398                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001466  3E3C 0001                399                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
0000146A  4EB9 00001C30            400                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001470  3C02                     401                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001472  3E03                     402                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001474                           403    
00001474  4E75                     404                  RTS                
00001476                           405                    
00001476  4BF9 000022F6            406  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
0000147C  4EB9 00002064            407                  JSR         PRINTNULL               ; print ADD
00001482  3200                     408                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001484  4EB9 0000148E            409                  JSR         ADD_SUB_SIZE
0000148A  6000 0050                410                  BRA         FINISH_ADD
0000148E                           411                    
0000148E  3200                     412  ADD_SUB_SIZE    MOVE.W      D0,D1
00001490  E149                     413                  LSL.W       #8,D1
00001492  E049                     414                  LSR.W       #8,D1
00001494  EC49                     415                  LSR.W       #6,D1                   ; gets bits 6-7
00001496                           416                    
00001496  B27C 0000                417                  CMP.W       #0,D1
0000149A  6700 0016                418                  BEQ         ADD_SUB_BYTE
0000149E  B27C 0001                419                  CMP.W       #1,D1                   ; if 1, it is a word
000014A2  6700 001C                420                  BEQ         ADD_SUB_WORD
000014A6  B27C 0002                421                  CMP.W       #2,D1                   ; if 2, it is a long
000014AA  6700 0022                422                  BEQ         ADD_SUB_LONG
000014AE  6000 0254                423                  BRA         CASE_SUBA                    ; error
000014B2                           424                    
000014B2  4BF9 000023DC            425  ADD_SUB_BYTE    LEA         MSG_B,A5
000014B8  4EB9 00002064            426                  JSR         PRINTNULL
000014BE  4E75                     427                  RTS
000014C0                           428                    
000014C0  4BF9 000023E2            429  ADD_SUB_WORD    LEA         MSG_W,A5
000014C6  4EB9 00002064            430                  JSR         PRINTNULL
000014CC  4E75                     431                  RTS
000014CE                           432    
000014CE  4BF9 000023E8            433  ADD_SUB_LONG    LEA         MSG_L,A5
000014D4  4EB9 00002064            434                  JSR         PRINTNULL
000014DA  4E75                     435                  RTS
000014DC                           436        
000014DC  4EB9 000014E4            437  FINISH_ADD      JSR         ADD_SUB_OPERAND
000014E2  4E75                     438                  RTS
000014E4                           439    
000014E4  EF49                     440  ADD_SUB_OPERAND LSL.W       #7,D1
000014E6  EE49                     441                  LSR.W       #7,D1
000014E8  E049                     442                  LSR.W       #8,D1
000014EA  B27C 0001                443                  CMP.W       #1,D1
000014EE  6600 002E                444                  BNE         Dn_PLUS_EA          
000014F2                           445                    
000014F2                           446                  ; print Data Register
000014F2  4BF9 000023C3            447                  LEA         MSG_DR,A5
000014F8  4EB9 00002064            448                  JSR         PRINTNULL
000014FE  3207                     449                  MOVE.W      D7,D1
00001500  4EB9 00001F1A            450                  JSR         PRINTNUM                
00001506                           451                  
00001506                           452                  ; prints a comma to seperate
00001506  4BF9 000023D3            453                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000150C  4EB9 00002064            454                  JSR         PRINTNULL                ; prints out MOVE
00001512                           455                 
00001512                           456                  ; below is EA+Dn->Dn  
00001512  3404                     457                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001514  3605                     458                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001516  4EB9 00001D9E            459                  JSR         EA_TO_STRING             ; outputs it into a string
0000151C  4E75                     460                  RTS                                 ; exits subroutine 
0000151E                           461  
0000151E                           462  Dn_PLUS_EA      ; below is Dn+EA->EA  
0000151E  3404                     463                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001520  3605                     464                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001522  4EB9 00001D9E            465                  JSR         EA_TO_STRING             ; outputs it into a string   
00001528                           466                  
00001528                           467                  ; prints a comma to seperate
00001528  4BF9 000023D3            468                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000152E  4EB9 00002064            469                  JSR         PRINTNULL                ; prints out MOVE
00001534                           470                  
00001534                           471                  ; below is Dn+EA->EA
00001534  4BF9 000023C3            472                  LEA         MSG_DR,A5                ; print data register
0000153A  4EB9 00002064            473                  JSR         PRINTNULL
00001540  3207                     474                  MOVE.W      D7,D1
00001542  4EB9 00001F1A            475                  JSR         PRINTNUM             
00001548  4E75                     476                  RTS                                  ; exits subroutine          
0000154A                           477                        
0000154A                           478  *---------------ADDA opcode----------------------
0000154A                           479  CASE_ADDA       ; gets bit 8 (size bit)
0000154A  3200                     480                  MOVE.W      D0,D1
0000154C  EF49                     481                  LSL.W       #7,D1
0000154E  EE49                     482                  LSR.W       #7,D1
00001550  E049                     483                  LSR         #8,D1                   
00001552                           484                  
00001552  4BF9 000022FB            485                  LEA         MSG_ADDA,A5             ; print ADDA
00001558  4EB9 00002064            486                  JSR         PRINTNULL
0000155E                           487                   
0000155E  B27C 0001                488                  CMP.W       #1,D1
00001562  6700 0012                489                  BEQ         ADDA_LONG
00001566                           490                    
00001566  4BF9 000023E2            491                  LEA         MSG_W,A5
0000156C  4EB9 00002064            492                  JSR         PRINTNULL
00001572  6000 0012                493                  BRA         FINISH_ADDA   
00001576                           494                    
00001576  4BF9 000023E8            495  ADDA_LONG       LEA         MSG_L,A5
0000157C  4EB9 00002064            496                  JSR         PRINTNULL
00001582  6000 0002                497                  BRA         FINISH_ADDA
00001586                           498                    
00001586  3404                     499  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001588  3605                     500                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000158A  4EB9 00001D9E            501                  JSR         EA_TO_STRING             ; outputs it into a string
00001590                           502                    
00001590                           503                  ; prints a comma to seperate
00001590  4BF9 000023D3            504                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001596  4EB9 00002064            505                  JSR         PRINTNULL                ; prints out MOVE
0000159C                           506            
0000159C  4BF9 000023C5            507                  LEA         MSG_AR,A5                ; print address register
000015A2  4EB9 00002064            508                  JSR         PRINTNULL
000015A8  3207                     509                  MOVE.W      D7,D1
000015AA  4EB9 00001F1A            510                  JSR         PRINTNUM             
000015B0  4E75                     511                  RTS                              ; exits subroutine
000015B2                           512                  
000015B2                           513  *---------------ADDQ opcode----------------------                  
000015B2  3200                     514  CASE_ADDQ       MOVE.W      D0,D1
000015B4  C27C F000                515                  AND.W       #$F000,D1       
000015B8  B27C 5000                516                  CMP.W       #$5000,D1
000015BC  6600 00CC                517                  BNE         CASE_SUB
000015C0                           518                                                   
000015C0  4EB8 11E4                519                  JSR         PRINT_ADDR              ; print address  
000015C4  4BF9 00002301            520                  LEA         MSG_ADDQ,A5             ; print ADDQ
000015CA  4EB9 00002064            521                  JSR         PRINTNULL
000015D0                           522                  
000015D0                           523                  ; get bits 6-7 (size bits)
000015D0  3200                     524                  MOVE.W      D0,D1
000015D2  E149                     525                  LSL.W       #8,D1
000015D4  E049                     526                  LSR.W       #8,D1
000015D6  EC49                     527                  LSR.W       #6,D1
000015D8  3401                     528                  MOVE.W      D1,D2
000015DA                           529                  
000015DA                           530                  ; Check bits 0-5 
000015DA  4BF9 00002110            531                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000015E0  4DF9 00002146            532                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000015E6  3E3C 0000                533                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000015EA  4EB9 00001C30            534                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000015F0  B27C 0001                535                  CMP.W       #1,D1                    ; checks if invalid
000015F4  6700 05DE                536                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000015F8  3802                     537                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000015FA  3A03                     538                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000015FC                           539                  
000015FC  B47C 0001                540                  CMP.W       #1,D2
00001600  6700 001A                541                  BEQ         ADDQ_WORD
00001604  B47C 0002                542                  CMP.W       #2,D2
00001608  6700 0022                543                  BEQ         ADDQ_LONG
0000160C                           544                    
0000160C  4BF9 000023DC            545  ADDQ_BYTE       LEA         MSG_B,A5
00001612  4EB9 00002064            546                  JSR         PRINTNULL
00001618  6000 0022                547                  BRA         FINISH_ADDQ  
0000161C                           548   
0000161C  4BF9 000023E2            549  ADDQ_WORD       LEA         MSG_W,A5
00001622  4EB9 00002064            550                  JSR         PRINTNULL
00001628  6000 0012                551                  BRA         FINISH_ADDQ                 
0000162C                           552    
0000162C  4BF9 000023E8            553  ADDQ_LONG       LEA         MSG_L,A5
00001632  4EB9 00002064            554                  JSR         PRINTNULL
00001638  6000 0002                555                  BRA         FINISH_ADDQ                  
0000163C                           556                    
0000163C  4EB9 0000165A            557  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001642                           558   
00001642                           559                  ; prints a comma to seperate
00001642  4BF9 000023D3            560                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001648  4EB9 00002064            561                  JSR         PRINTNULL                ; prints out MOVE
0000164E                           562                    
0000164E                           563                  ; prints destination
0000164E  3404                     564                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001650  3605                     565                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001652  4EB9 00001D9E            566                  JSR         EA_TO_STRING             ; outputs it into a string
00001658                           567                 
00001658  4E75                     568                  RTS
0000165A                           569   
0000165A  4BF9 000023CF            570  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
00001660  4EB9 00002064            571                  JSR         PRINTNULL
00001666                           572                  ; gets bits 9-11 (data bits)
00001666  E949                     573                  LSL.W       #4,D1
00001668  E849                     574                  LSR.W       #4,D1                               ; get rid of left 4 bits
0000166A  E049                     575                  LSR.W       #8,D1
0000166C  E249                     576                  LSR.W       #1,D1                               ; get rid of right 9 bits
0000166E                           577                  
0000166E  B27C 0000                578                  CMP.W       #0,D1
00001672  6700 000A                579                  BEQ         PRINT_8
00001676  4EB9 00001F1A            580                  JSR         PRINTNUM
0000167C  4E75                     581                  RTS 
0000167E                           582  
0000167E  123C 0008                583  PRINT_8         MOVE.B      #8,D1
00001682  4EB9 00001F1A            584                  JSR         PRINTNUM
00001688  4E75                     585                  RTS   
0000168A                           586         
0000168A                           587  *---------------SUB opcode---------------------- 
0000168A  3200                     588  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000168C  C27C F000                589                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001690  B27C 9000                590                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001694  6600 0084                591                  BNE         CASE_LEA
00001698                           592                 
00001698  4EB8 1438                593                  JSR         ADD_SUB_HELP
0000169C  4EB8 11E4                594                  JSR         PRINT_ADDR                          ; print address               
000016A0                           595                  
000016A0  6000 0002                596                  BRA         PRINTSUB                            ; Branches to print move
000016A4                           597  
000016A4  4BF9 00002307            598  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for MOVE into A5
000016AA  4EB9 00002064            599                  JSR         PRINTNULL
000016B0  3200                     600                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000016B2  4EB8 148E                601                  JSR         ADD_SUB_SIZE
000016B6  3200                     602                  MOVE.W      D0,D1
000016B8  E149                     603                  LSL.W       #8,D1
000016BA  E049                     604                  LSR.W       #8,D1
000016BC  EC49                     605                  LSR.W       #6,D1
000016BE  B27C 0003                606                  CMP.W       #3,D1
000016C2  6600 0006                607                  BNE         FINISH_SUB
000016C6  6000 0008                608                  BRA         FINISH_SUBA                         ; same as ADDA
000016CA                           609                  
000016CA  4EB8 14E4                610  FINISH_SUB      JSR     ADD_SUB_OPERAND
000016CE  4E75                     611                  RTS
000016D0                           612                    
000016D0  3404                     613  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016D2  3605                     614                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016D4  4EB9 00001D9E            615                  JSR         EA_TO_STRING             ; outputs it into a string
000016DA                           616                
000016DA                           617                  ; prints a comma to seperate
000016DA  4BF9 000023D3            618                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016E0  4EB9 00002064            619                  JSR         PRINTNULL                ; prints out MOVE
000016E6                           620          
000016E6  4BF9 000023C5            621                  LEA         MSG_AR,A5                ; print address register
000016EC  4EB9 00002064            622                  JSR         PRINTNULL
000016F2  3200                     623                  MOVE.W      D0,D1
000016F4  E949                     624                  LSL.W       #4,D1
000016F6  E849                     625                  LSR.W       #4,D1
000016F8  E049                     626                  LSR.W       #8,D1
000016FA  E249                     627                  LSR.W       #1,D1
000016FC  4EB9 00001F1A            628                  JSR         PRINTNUM             
00001702  4E75                     629                  RTS                              ; exits subroutine
00001704                           630  
00001704                           631  
00001704                           632  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
00001704  3200                     633  CASE_SUBA       MOVE.W      D0,D1
00001706  EF49                     634                  LSL.W       #7,D1
00001708  EE49                     635                  LSR.W       #7,D1
0000170A  E049                     636                  LSR.W       #8,D1
0000170C  B23C 0000                637                  CMP.B       #0,D1
00001710  6700 FDAE                638                  BEQ         ADD_SUB_WORD
00001714  6000 FDB8                639                  BRA         ADD_SUB_LONG
00001718  4E75                     640                  RTS         
0000171A                           641                   
0000171A  3200                     642  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000171C  C27C F000                643                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001720  B27C 4000                644                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001724  6600 0086                645                  BNE.W   CASE_AND                             ; If its not, check AND
00001728  3200                     646                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000172A  C27C 01C0                647                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
0000172E  B27C 01C0                648                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001732  6600 0078                649                  BNE.W   CASE_AND                             ; If its not, check AND
00001736                           650                  
00001736                           651                  ; Check source
00001736  4BF9 00002130            652                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000173C  4DF9 0000214A            653                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001742  3E3C 0000                654                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001746  4EB9 00001C30            655                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000174C  3802                     656                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000174E  3A03                     657                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001750                           658                  
00001750                           659                  ; Check destination
00001750  4BF9 00002130            660                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001756  4DF9 0000214A            661                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000175C  3E3C 0001                662                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
00001760  4EB9 00001C30            663                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001766  3C02                     664                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001768  3E03                     665                  MOVE.W  D3,D7                                ; Saves D2 in D4
0000176A                           666  
0000176A  4BF9 00002318            667                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
00001770  4EB9 00002064            668                  JSR     PRINTNULL                            ; prints LEA
00001776                           669                  
00001776                           670                  ; print source
00001776  3404                     671                  MOVE.W  D4,D2
00001778  3605                     672                  MOVE.W  D5,D3
0000177A  4EB9 00001D9E            673                  JSR     EA_TO_STRING                         ; Prints out the EA
00001780                           674                  
00001780                           675                  ; comma
00001780  4BF9 000023D3            676                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
00001786  4EB9 00002064            677                  JSR     PRINTNULL                       
0000178C                           678                   
0000178C                           679                  ; register
0000178C  4BF9 000023C5            680                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001792  4EB9 00002064            681                  JSR     PRINTNULL 
00001798  3401                     682                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
0000179A  323C 0001                683                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
0000179E  4EB9 00001C06            684                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000017A4  4EB9 00001F1A            685                  JSR     PRINTNUM                             ; Prints the number in D1
000017AA  4E75                     686                  RTS
000017AC                           687  
000017AC                           688  *---------------AND opcode----------------------
000017AC  3200                     689  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000017AE  C27C F000                690                  AND.W       #$F000,D1       
000017B2  B27C C000                691                  CMP.W       #$C000,D1
000017B6  6600 009E                692                  BNE         CASE_OR
000017BA                           693                  
000017BA  3200                     694                  MOVE.W      D0,D1
000017BC  E149                     695                  LSL.W       #8,D1
000017BE  E049                     696                  LSR.W       #8,D1
000017C0  EC49                     697                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000017C2  3C01                     698                  MOVE.W      D1,D6
000017C4  BC7C 0003                699                  CMP.W       #3,D6
000017C8  6700 0066                700                  BEQ         INV_INSTR
000017CC                           701                  
000017CC  4EB8 11E4                702                  JSR         PRINT_ADDR                      ; print address
000017D0  4BF9 00002320            703                  LEA         MSG_AND,A5                      ; print AND
000017D6  4EB9 00002064            704                  JSR         PRINTNULL
000017DC                           705                  
000017DC  3206                     706                  MOVE.W      D6,D1
000017DE  B27C 0000                707                  CMP.W       #0,D1
000017E2  6700 0012                708                  BEQ         AND_BYTE
000017E6  B27C 0001                709                  CMP.W       #1,D1                   ; if 1, it is a word
000017EA  6700 001A                710                  BEQ         AND_WORD
000017EE  B27C 0002                711                  CMP.W       #2,D1                   ; if 2, it is a long
000017F2  6700 0022                712                  BEQ         AND_LONG
000017F6                           713                  
000017F6  4BF9 000023DC            714  AND_BYTE        LEA         MSG_B,A5
000017FC  4EB9 00002064            715                  JSR         PRINTNULL
00001802  6000 0022                716                  BRA         FINISH_AND
00001806                           717                                    
00001806  4BF9 000023E2            718  AND_WORD        LEA         MSG_W,A5
0000180C  4EB9 00002064            719                  JSR         PRINTNULL
00001812  6000 0012                720                  BRA         FINISH_AND
00001816                           721    
00001816  4BF9 000023E8            722  AND_LONG        LEA         MSG_L,A5
0000181C  4EB9 00002064            723                  JSR         PRINTNULL
00001822  6000 0002                724                  BRA         FINISH_AND
00001826                           725        
00001826  4EB8 1438                726  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
0000182A  4EB8 14E4                727                  JSR         ADD_SUB_OPERAND
0000182E  4E75                     728                  RTS
00001830                           729                  
00001830  4BF9 0000228B            730  INV_INSTR       LEA         INVALID_INSTR,A5
00001836  4EB9 00002064            731                  JSR         PRINTNULL
0000183C  2200                     732                  MOVE.L      D0,D1
0000183E  383C 0000                733                  MOVE.W      #0,D4
00001842  4EB9 00001F3E            734                  JSR         PRINTSHORTLONGNUM
00001848  4BF9 000022CF            735                  LEA         NEW_LINE,A5
0000184E  4EB9 00002064            736                  JSR         PRINTNULL
00001854  4E75                     737                  RTS               
00001856                           738                  
00001856                           739  *---------------OR opcode----------------------            
00001856  3200                     740  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001858  C27C F000                741                  AND.W       #$F000,D1       
0000185C  B27C 8000                742                  CMP.W       #$8000,D1
00001860  6600 004C                743                  BNE         CASE_NOT
00001864                           744                                                
00001864  3200                     745                  MOVE.W      D0,D1
00001866  E149                     746                  LSL.W       #8,D1
00001868  E049                     747                  LSR.W       #8,D1
0000186A  EC49                     748                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000186C  B27C 0003                749                  CMP.W       #3,D1
00001870  3C01                     750                  MOVE.W      D1,D6
00001872  67BC                     751                  BEQ         INV_INSTR
00001874                           752                  
00001874  4EB8 11E4                753                  JSR         PRINT_ADDR                      ; print address
00001878                           754                  
00001878  4BF9 00002325            755                  LEA         MSG_OR,A5
0000187E  4EB9 00002064            756                  JSR         PRINTNULL                       ; print "OR"
00001884                           757                  
00001884  3206                     758                  MOVE.W      D6,D1
00001886  4EB9 00001896            759                  JSR         OR_SIZE                         ; print ".B",".W",".L"
0000188C                           760  
0000188C  4EB8 1438                761                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001890  4EB8 14E4                762                  JSR         ADD_SUB_OPERAND                 ; print 
00001894  4E75                     763                  RTS
00001896                           764  
00001896  B27C 0000                765  OR_SIZE         CMP.W       #0,D1
0000189A  6700 FC16                766                  BEQ         ADD_SUB_BYTE
0000189E  B27C 0001                767                  CMP.W       #1,D1                   ; if 1, it is a word
000018A2  6700 FC1C                768                  BEQ         ADD_SUB_WORD
000018A6  B27C 0002                769                  CMP.W       #2,D1                   ; if 2, it is a long
000018AA  6700 FC22                770                  BEQ         ADD_SUB_LONG
000018AE                           771                  ; no need for rts, since ADD_SUB_ already has                
000018AE                           772  
000018AE                           773  *---------------NOT opcode----------------------
000018AE  3200                     774  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018B0  C27C FF00                775                  AND.W       #$FF00,D1       
000018B4  B27C 4600                776                  CMP.W       #$4600,D1
000018B8  6600 0050                777                  BNE         CASE_LSDASDROD
000018BC                           778                 
000018BC                           779                  ; get bits 6-7 (size)
000018BC  3200                     780                  MOVE.W      D0,D1
000018BE  E149                     781                  LSL.W       #8,D1
000018C0  E049                     782                  LSR.W       #8,D1
000018C2  EC49                     783                  LSR.W       #6,D1 
000018C4  3C01                     784                  MOVE.W      D1,D6                         
000018C6  BC7C 0003                785                  CMP.W       #3,D6
000018CA  6700 FF64                786                  BEQ         INV_INSTR
000018CE                           787                  
000018CE  4EB8 11E4                788                  JSR         PRINT_ADDR
000018D2                           789                  
000018D2  4BF9 00002329            790                  LEA         MSG_NOT,A5
000018D8  4EB9 00002064            791                  JSR         PRINTNULL                       ; print "NOT"
000018DE                           792                                 
000018DE  3206                     793                  MOVE.W      D6,D1
000018E0                           794  
000018E0  4EB8 1896                795                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000018E4                           796                  
000018E4                           797                  ; get bits 0-5 
000018E4  4BF9 00002110            798                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000018EA  4DF9 00002146            799                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000018F0  3E3C 0000                800                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000018F4  4EB9 00001C30            801                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000018FA  B27C 0001                802                  CMP.W       #1,D1                    ; checks if invalid
000018FE  6700 02D4                803                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001902  4EB9 00001D9E            804                  JSR         EA_TO_STRING             ; outputs it into a string
00001908                           805    
00001908  4E75                     806                  RTS
0000190A                           807  
0000190A  3200                     808  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
0000190C  C27C F000                809                  AND.W       #$F000, D1                       ; gets first 4 bits
00001910  B27C E000                810                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001914  6600 0218                811                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001918  3400                     812                  MOVE.W      D0,D2                            ; copies D0 to D2
0000191A  4EB9 00001CB8            813                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001920  B47C 0003                814                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001924  6600 00CC                815                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001928                           816                  
00001928  3400                     817  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
0000192A  4EB9 00001CA6            818                  JSR         GETROTATION                      ; gets rotation value of D2
00001930  B47C 0000                819                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001934  6700 0014                820                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001938  B47C 0003                821                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
0000193C  6700 0016                822                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001940                           823                  
00001940  4BF9 0000232E            824  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001946  6000 0012                825                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000194A                           826  
0000194A  4BF9 00002332            827  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001950  6000 0008                828                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001954                           829  
00001954  4BF9 00002336            830  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
0000195A                           831                  
0000195A  4EB8 11E4                832  PRINTSHIFTMEM   JSR         PRINT_ADDR                       ; prints address
0000195E  4EB9 00002064            833                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001964  3400                     834                  MOVE.W      D0,D2                            ; copies D0 to D2
00001966  4EB9 00001CB0            835                  JSR         GETDIRECTION                     ; gets direction
0000196C  B47C 0000                836                  CMP.W       #0,D2                            ; checking if its right
00001970  6700 000C                837                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001974                           838  
00001974  4BF9 000023C1            839  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000197A  6000 0008                840                  BRA         PRINT_MEMDIR                     ; branches for printing
0000197E                           841          
0000197E  4BF9 000023BF            842  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001984                           843  
00001984  4EB9 00002064            844  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000198A  4BF9 000023E2            845                  LEA         MSG_W,A5                         ; loads .W into A5
00001990  4EB9 00002064            846                  JSR         PRINTNULL                        ; Prints .W
00001996  6000 0002                847                  BRA         GETMEMSOURCE                     ; checks the source 
0000199A                           848                  
0000199A                           849  ; get source addressing mode       
0000199A                           850  GETMEMSOURCE                                                 
0000199A  323C 0000                851                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
0000199E  4EB9 00001BDC            852                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
000019A4  3801                     853                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
000019A6  323C 0000                854                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
000019AA  4EB9 00001C06            855                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000019B0  3A01                     856                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000019B2                           857  
000019B2  4BF9 0000213E            858  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000019B8  3204                     859                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000019BA  4EB9 00001D6A            860                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000019C0  B27C 0002                861                  CMP.W       #2,D1                            ; checks if it is Xn
000019C4  6700 0016                862                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000019C8  B27C 0001                863                  CMP.W       #1,D1                            ; Checks if it is invalid
000019CC  6700 0206                864                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000019D0                           865  
000019D0  3404                     866  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000019D2  3605                     867                  MOVE.W      D5,D3                            ; moves EA to D3
000019D4  4EB9 00001D9E            868                  JSR         EA_TO_STRING                     ; prints out the EA
000019DA  4E75                     869                  RTS                
000019DC                           870                  
000019DC                           871                  
000019DC  4BF9 0000214A            872  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000019E2  3205                     873                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000019E4  4EB9 00001D6A            874                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000019EA  4A41                     875                  TST.W       D1                               ; checks if it is valid
000019EC  67E2                     876                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
000019EE  6000 01E4                877                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
000019F2                           878  
000019F2                           879  
000019F2  3602                     880  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
000019F4  3200                     881                  MOVE.W      D0,D1                            ; copies D0 to D1
000019F6  C27C 0018                882                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
000019FA  E649                     883                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
000019FC  B27C 0000                884                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001A00  6700 0014                885                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001A04  B27C 0003                886                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001A08  6700 0016                887                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001A0C                           888                  
00001A0C  4BF9 0000232E            889  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001A12  6000 0012                890                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A16                           891  
00001A16  4BF9 00002332            892  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001A1C  6000 0008                893                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001A20                           894  
00001A20  4BF9 00002336            895  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001A26                           896                  
00001A26  4EB8 11E4                897  PRINTSHIFTREG   JSR         PRINT_ADDR                       ; prints address
00001A2A  4EB9 00002064            898                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001A30  3400                     899                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A32  4EB9 00001CB0            900                  JSR         GETDIRECTION                     ; gets direction
00001A38  B47C 0000                901                  CMP.W       #0,D2                            ; checking if its right
00001A3C  6700 000C                902                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001A40                           903  
00001A40  4BF9 000023C1            904  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001A46  6000 000C                905                  BRA         PRINT_REGDIR                     ; branches for printing
00001A4A                           906          
00001A4A  4BF9 000023BF            907  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001A50  6000 0002                908                  BRA         PRINT_REGDIR                     ; branches for printing
00001A54                           909                  
00001A54  4EB9 00002064            910  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001A5A                           911  
00001A5A  3400                     912  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001A5C  4EB9 00001CB8            913                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A62  B47C 0001                914                  CMP.W       #1,D2                            ; Checks if it is word size
00001A66  6700 0014                915                  BEQ         REG_WORD                         ; Prints .W
00001A6A  B47C 0002                916                  CMP.W       #2,D2                            ; Checks if it is long size
00001A6E  6700 0016                917                  BEQ         REG_LONG                         ; Prints .L
00001A72                           918  
00001A72  4BF9 000023DC            919  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001A78  6000 0012                920                  BRA         PRINTREGEA      
00001A7C                           921  
00001A7C  4BF9 000023E2            922  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001A82  6000 0008                923                  BRA         PRINTREGEA      
00001A86                           924                             
00001A86  4BF9 000023E8            925  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001A8C                           926  
00001A8C  4EB9 00002064            927  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001A92  3400                     928                  MOVE.W      D0,D2                            ; copies D0 to D1
00001A94  4EB9 00001CC0            929                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001A9A  B27C 0001                930                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001A9E  6700 0048                931                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001AA2                           932                                  
00001AA2  3400                     933  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001AA4  4EB9 00001CB8            934                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AAA  3202                     935                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AAC  4BF9 000023CF            936                  LEA         MSG_POUND, A5                    ; loads # into A5
00001AB2  4EB9 00002064            937                  JSR         PRINTNULL                        ; prints #
00001AB8  4EB9 00001F1A            938                  JSR         PRINTNUM                         ; prints shift count
00001ABE  4BF9 000023D3            939                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001AC4  4EB9 00002064            940                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001ACA  4BF9 000023C3            941                  LEA         MSG_DR, A5                       ; loads D into A5
00001AD0  4EB9 00002064            942                  JSR         PRINTNULL                        ; prints out D 
00001AD6  323C 0000                943                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001ADA  4EB9 00001C06            944                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001AE0  4EB9 00001F1A            945                  JSR         PRINTNUM                         ; prints data register number in D1          
00001AE6  4E75                     946                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001AE8                           947                  
00001AE8  3400                     948  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001AEA  4EB9 00001CB8            949                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AF0  3202                     950                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001AF2  4BF9 000023C3            951                  LEA         MSG_DR, A5                       ; loads D into A5
00001AF8  4EB9 00002064            952                  JSR         PRINTNULL                        ; prints D
00001AFE  4EB9 00001F1A            953                  JSR         PRINTNUM                         ; prints register number
00001B04  4BF9 000023D3            954                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001B0A  4EB9 00002064            955                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001B10  4BF9 000023C3            956                  LEA         MSG_DR, A5                       ; loads D into A5
00001B16  4EB9 00002064            957                  JSR         PRINTNULL                        ; prints out D 
00001B1C  323C 0000                958                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001B20  4EB9 00001C06            959                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001B26  4EB9 00001F1A            960                  JSR         PRINTNUM                         ; prints data register number in D1          
00001B2C  4E75                     961                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001B2E                           962               
00001B2E  3200                     963  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001B30  C27C FF00                964                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001B34  B27C 6000                965                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001B38  6600 001C                966                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001B3C                           967                  
00001B3C  4EB8 11E4                968                  JSR     PRINT_ADDR
00001B40  4BF9 000023B7            969                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001B46  4EB9 00002064            970                  JSR     PRINTNULL                            ; prints BRA
00001B4C                           971  
00001B4C  3400                     972                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001B4E  4EB9 00001C78            973                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001B54  4E75                     974                  RTS
00001B56                           975                  
00001B56                           976  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001B56                           977  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001B56  3200                     978  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B58  C27C F000                979                  AND.W   #$F000,D1                            ; get top 4 bits
00001B5C  B27C 6000                980                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001B60  6600 0058                981                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001B64  3200                     982                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001B66  C27C 0F00                983                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001B6A  E049                     984                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001B6C                           985                  
00001B6C  B27C 000E                986                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001B70  6700 002A                987                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001B74                           988                  
00001B74  B27C 000F                989                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001B78  6700 0018                990                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001B7C                           991                      
00001B7C  B27C 0007                992                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001B80  6700 0006                993                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001B84  6000 004E                994                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001B88                           995     
00001B88  4BF9 0000234A            996  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001B8E  6000 0016                997                  BRA     PRINTBCC
00001B92                           998  
00001B92  4BF9 00002372            999  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001B98  6000 000C               1000                  BRA     PRINTBCC
00001B9C                          1001                  
00001B9C  4BF9 00002362           1002  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001BA2  6000 0002               1003                  BRA     PRINTBCC
00001BA6                          1004  
00001BA6  4EB8 11E4               1005  PRINTBCC        JSR     PRINT_ADDR                           ; prints address
00001BAA  4EB9 00002064           1006                  JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001BB0  3400                    1007                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001BB2  4EB9 00001C78           1008                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001BB8  4E75                    1009                  RTS              
00001BBA                          1010                  
00001BBA                          1011  
00001BBA                          1012  CASE_JSR       
00001BBA                          1013  
00001BBA  B07C 4E75               1014  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001BBE  6600 0014               1015                  BNE     CASE_DATA           ; checks the next case if not equal
00001BC2  4EB8 11E4               1016                  JSR     PRINT_ADDR          ; prints address
00001BC6  4BF9 000023B2           1017                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001BCC  4EB9 00002064           1018                  JSR     PRINTNULL           ; prints RTS                
00001BD2  4E75                    1019                  RTS                         ; returns from the subroutine
00001BD4                          1020  
00001BD4                          1021                  
00001BD4                          1022  
00001BD4  4EB8 1830               1023  CASE_DATA           JSR INV_INSTR  
00001BD8  4E75                    1024                      RTS               
00001BDA                          1025  
00001BDA  4E75                    1026  CASE_EPICFAIL       RTS
00001BDC                          1027  
00001BDC                          1028  
00001BDC                          1029  * Finds the EA type
00001BDC                          1030  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001BDC                          1031  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001BDC  48E7 3000               1032  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001BE0  4A41                    1033                      TST.W     D1                    ; compares D1 to 0
00001BE2  6700 000E               1034                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001BE6                          1035                      
00001BE6  343C 01C0               1036  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001BEA  363C 0006               1037                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001BEE  6000 000A               1038                      BRA       FINDTYPEEA            
00001BF2                          1039  
00001BF2  343C 0038               1040  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001BF6  363C 0003               1041                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001BFA                          1042  
00001BFA                          1043  
00001BFA  3200                    1044  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001BFC  C242                    1045                      AND.W     D2,D1                 ; applies bitmask to D1
00001BFE  E669                    1046                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C00  4CDF 000C               1047                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C04  4E75                    1048                      RTS                             ; returns from subroutine    
00001C06                          1049                      
00001C06                          1050  * Finds Xn type
00001C06                          1051  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001C06                          1052  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001C06  48E7 3000               1053  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001C0A  4A41                    1054                      TST.W     D1                    ; compares D1 to 0
00001C0C  6700 000E               1055                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001C10                          1056  
00001C10  343C 0E00               1057  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001C14  363C 0009               1058                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001C18  6000 000A               1059                      BRA       FINDTYPEXN            ; finds the type of Xn
00001C1C                          1060  
00001C1C  343C 0007               1061  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001C20  363C 0000               1062                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001C24                          1063                      
00001C24  3200                    1064  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001C26  C242                    1065                      AND.W     D2,D1                 ; applies bitmask to D1
00001C28  E669                    1066                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001C2A  4CDF 000C               1067                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001C2E  4E75                    1068                      RTS                             ; returns from subroutine 
00001C30                          1069                      
00001C30                          1070  * Checks and gets the EA and Xn
00001C30                          1071  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001C30                          1072  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001C30  3207                    1073  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001C32  4EB8 1BDC               1074                  JSR     GET_EA                  ; Gets EA
00001C36  3401                    1075                  MOVE.W  D1,D2                   ; Stores EA in D2
00001C38  3207                    1076                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001C3A  4EB8 1C06               1077                  JSR     GET_XN                  ; Gets Xn
00001C3E  3601                    1078                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001C40  3202                    1079                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001C42                          1080                  
00001C42  4EB9 00001D6A           1081                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001C48  B27C 0002               1082                  CMP.W   #2,D1                   ; checks if it is Xn
00001C4C  6700 0012               1083                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001C50  B27C 0001               1084                  CMP.W   #1,D1                   ; Checks if it is invalid
00001C54  6700 001C               1085                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001C58                          1086                  
00001C58                          1087                  
00001C58  323C 0000               1088  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001C5C  6000 0018               1089                  BRA     END_CHECKGET
00001C60                          1090        
00001C60                          1091  ; need XN
00001C60  2A4E                    1092  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001C62  3203                    1093                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001C64  4EB9 00001D6A           1094                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001C6A  4A41                    1095                  TST.W   D1                      ; checks if it is valid
00001C6C  67EA                    1096                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001C6E  6000 0002               1097                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001C72                          1098   
00001C72  323C 0001               1099  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001C76                          1100  
00001C76  4E75                    1101  END_CHECKGET    RTS          
00001C78                          1102                                            
00001C78                          1103                                            
00001C78                          1104  * Gets the displacement and pritns it 
00001C78                          1105  * Inputs: D2 = instruction word, A2 = address of next word
00001C78                          1106  * Outputs: prints out displacement
00001C78  48E7 4004               1107  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001C7C  3A4A                    1108                      MOVE.W    A2,A5                 ; copies A2 to A5
00001C7E  C47C 00FF               1109                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001C82  6600 0004               1110                      BNE       PRINTADDRESS          ; prints address if not 0
00001C86  341A                    1111                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001C88                          1112                      
00001C88  D44D                    1113  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001C8A  3202                    1114                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001C8C  183C 0000               1115                      MOVE.B    #0,D4                 ; marks address as word  length
00001C90  4BF9 000023D1           1116                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001C96  4EB9 00002064           1117                      JSR       PRINTNULL             ; prints null
00001C9C  4EB9 00001F3E           1118                      JSR       PRINTSHORTLONGNUM     ; prints address
00001CA2                          1119                      
00001CA2  4CDF 2002               1120                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001CA6                          1121                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001CA6                          1122  
00001CA6                          1123  * Gets the rotation value for ASd and LSd
00001CA6                          1124  * Input: D2 = instruction word copy (of D0)                                    
00001CA6                          1125  * Output: rotation  value in D2             
00001CA6  C47C 0E00               1126  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001CAA  E04A                    1127                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CAC  E24A                    1128                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001CAE  4E75                    1129                      RTS                             ; return from subroutine
00001CB0                          1130  
00001CB0                          1131  * Gets the direction value for ASd and LSd
00001CB0                          1132  * Input: D2 = instruction word copy (of D0)                                    
00001CB0                          1133  * Output: direction value in D2             
00001CB0  C47C 0100               1134  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001CB4  E04A                    1135                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001CB6  4E75                    1136                      RTS                             ; return from subroutine
00001CB8                          1137  
00001CB8                          1138  * Gets the rotation size value for ASd and LSd
00001CB8                          1139  * Input: D2 = instruction word copy (of D0)                                    
00001CB8                          1140  * Output: rotation size value in D2             
00001CB8  C47C 00C0               1141  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001CBC  EC4A                    1142                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CBE  4E75                    1143                      RTS                             ; return from subroutine
00001CC0                          1144  
00001CC0                          1145  * Gets the rotation location  value for ASd and LSd
00001CC0                          1146  * Input: D2 = instruction word copy (of D0)                                    
00001CC0                          1147  * Output: rotation location value in D2             
00001CC0  C47C 0020               1148  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001CC4  EA4A                    1149                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001CC6  4E75                    1150                      RTS                             ; return from subroutine
00001CC8                          1151  
00001CC8                          1152  * Prints out registers for MOVEM
00001CC8                          1153  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001CC8                          1154  * Output: printed out registers
00001CC8                          1155  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001CC8  48E7 0706               1156  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001CCC  3A3C 0000               1157                      MOVE.W     #0,D5                ; sets counter to 0
00001CD0  3E1A                    1158                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001CD2  B83C 0001               1159                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001CD6  6600 0010               1160                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001CDA                          1161  
00001CDA  3C3C 0000               1162  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001CDE  4BF9 000023C3           1163                      LEA        MSG_DR,A5            ; loads D to A5
00001CE4  6000 000C               1164                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001CE8                          1165                      
00001CE8  3C3C 0007               1166  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001CEC  4BF9 000023C5           1167                      LEA        MSG_AR,A5            ; loads A to A5
00001CF2                          1168                      
00001CF2  E34F                    1169  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001CF4  6500 0018               1170                      BCS        PRINTREG             ; if pushes out a 1
00001CF8  DC44                    1171                      ADD.W      D4,D6                ; decrements or increments
00001CFA  5245                    1172                      ADD.W      #1,D5                ; increments D5
00001CFC  BA7C 0008               1173                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D00  66F0                    1174                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D02  B83C 0001               1175                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D06  6600 0052               1176                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D0A  6000 0042               1177                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001D0E                          1178                      
00001D0E  4EB9 00002064           1179  PRINTREG            JSR        PRINTNULL
00001D14  3206                    1180                      MOVE.W     D6,D1
00001D16  4EB9 00001F1A           1181                      JSR        PRINTNUM 
00001D1C                          1182    
00001D1C  BE7C 0000               1183  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001D20  6600 0006               1184                      BNE        PRINTMORE            ; continue if there is more
00001D24  6000 0040               1185                      BRA        DONEPRINTINGREG      ; exit case
00001D28                          1186  
00001D28  2C4D                    1187  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001D2A  4BF9 000023D6           1188                      LEA        MSG_SLASH,A5         ; leads / into A5
00001D30  4EB9 00002064           1189                      JSR        PRINTNULL            ; prints the slash
00001D36  2A4E                    1190                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001D38  DC44                    1191                      ADD.W      D4,D6                ; decrements or increments
00001D3A  5245                    1192                      ADD.W      #1,D5                ; increments D5
00001D3C  BA7C 0008               1193                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001D40  66B0                    1194                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001D42  B83C 0001               1195                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001D46  6600 0012               1196                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001D4A  6000 0002               1197                      BRA        REGTOMEM2            ; loops
00001D4E                          1198  
00001D4E  3C3C 0000               1199  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001D52  4BF9 000023C5           1200                      LEA        MSG_AR,A5            ; loads A to A5
00001D58  6098                    1201                      BRA        PRINTREGISTERLOOP    ; loops
00001D5A                          1202  
00001D5A  3C3C 0007               1203  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001D5E  4BF9 000023C3           1204                      LEA        MSG_DR,A5            ; loads D to A5
00001D64  608C                    1205                      BRA        PRINTREGISTERLOOP    ; loops
00001D66                          1206  
00001D66  4CDF 60E0               1207  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001D6A                          1208  
00001D6A                          1209                          
00001D6A                          1210  * Checks if EA or Xn is valid
00001D6A                          1211  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001D6A                          1212  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001D6A  2F02                    1213  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001D6C                          1214  
00001D6C  141D                    1215  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001D6E  B43C 00FF               1216                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001D72  6700 000A               1217                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001D76  B202                    1218                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001D78  6700 000C               1219                     BEQ        VALIDEA               ; branches to valid EA
00001D7C  60EE                    1220                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001D7E                          1221                     
00001D7E  323C 0001               1222  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001D82  6000 0016               1223                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001D86                          1224                    
00001D86  B43C 0007               1225  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001D8A  6700 000A               1226                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001D8E  323C 0000               1227                     MOVE.W     #$0,D1                ; marks that it is valid
00001D92  6000 0006               1228                     BRA        CHECKEAEXIT           ; exits the subroutine
00001D96                          1229  
00001D96  323C 0002               1230  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001D9A                          1231  
00001D9A  241F                    1232  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001D9C  4E75                    1233                     RTS                              ; returns from subroutine
00001D9E                          1234  
00001D9E                          1235  * Converts EA and Xn into a string                                
00001D9E                          1236  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001D9E                          1237  * Outputs: Prints out EA and Xn into a string
00001D9E  48E7 C004               1238  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001DA2  B47C 0001               1239                     CMP.W    #An,D2                  ; checks if it is An
00001DA6  6700 003A               1240                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001DAA                          1241                     
00001DAA  B47C 0002               1242                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001DAE  6700 004A               1243                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001DB2                          1244                     
00001DB2  B47C 0003               1245                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001DB6  6700 0072               1246                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001DBA                          1247                     
00001DBA  B47C 0004               1248                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001DBE  6700 00A6               1249                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001DC2                          1250                     
00001DC2  B47C 0007               1251                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001DC6  6700 00DA               1252                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001DCA                          1253                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001DCA                          1254  
00001DCA                          1255  * data register, Dn
00001DCA  4BF9 000023C3           1256  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001DD0  4EB9 00002064           1257                     JSR      PRINTNULL               ; Prints D
00001DD6  3203                    1258                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DD8  4EB9 00001F1A           1259                     JSR      PRINTNUM                ; Prints the Xn
00001DDE  6000 0134               1260                     BRA      EA_TO_STRING_EXIT       ; exits           
00001DE2                          1261  
00001DE2                          1262  
00001DE2                          1263  * address register
00001DE2  4BF9 000023C5           1264  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001DE8  4EB9 00002064           1265                     JSR      PRINTNULL               ; Prints A
00001DEE  3203                    1266                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001DF0  4EB9 00001F1A           1267                     JSR      PRINTNUM                ; Prints the Xn
00001DF6  6000 011C               1268                     BRA      EA_TO_STRING_EXIT       ; exits
00001DFA                          1269  
00001DFA                          1270  * address register indirect
00001DFA  4BF9 000023C7           1271  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001E00  4EB9 00002064           1272                     JSR      PRINTNULL               ; Prints (
00001E06  4BF9 000023C5           1273                     LEA      MSG_AR,A5               ; Loads A into A5
00001E0C  4EB9 00002064           1274                     JSR      PRINTNULL               ; Prints A
00001E12  3203                    1275                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E14  4EB9 00001F1A           1276                     JSR      PRINTNUM                ; Prints the Xn
00001E1A  4BF9 000023C9           1277                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E20  4EB9 00002064           1278                     JSR      PRINTNULL               ; Prints )
00001E26  6000 00EC               1279                     BRA      EA_TO_STRING_EXIT       ; exits
00001E2A                          1280  
00001E2A                          1281  * address register indirect post increment
00001E2A  4BF9 000023C7           1282  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001E30  4EB9 00002064           1283                     JSR      PRINTNULL               ; Prints (
00001E36  4BF9 000023C5           1284                     LEA      MSG_AR,A5               ; Loads A into A5
00001E3C  4EB9 00002064           1285                     JSR      PRINTNULL               ; Prints A
00001E42  3203                    1286                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E44  4EB9 00001F1A           1287                     JSR      PRINTNUM                ; Prints the Xn
00001E4A  4BF9 000023C9           1288                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E50  4EB9 00002064           1289                     JSR      PRINTNULL               ; Prints )
00001E56  4BF9 000023CB           1290                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001E5C  4EB9 00002064           1291                     JSR      PRINTNULL               ; Prints +
00001E62  6000 00B0               1292                     BRA      EA_TO_STRING_EXIT       ; exits
00001E66                          1293  
00001E66                          1294  
00001E66                          1295  * address register indirect pre increment
00001E66  4BF9 000023CD           1296  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001E6C  4EB9 00002064           1297                     JSR      PRINTNULL               ; Prints -
00001E72  4BF9 000023C7           1298                     LEA      MSG_LB,A5               ; Loads ( into A5
00001E78  4EB9 00002064           1299                     JSR      PRINTNULL               ; Prints (
00001E7E  4BF9 000023C5           1300                     LEA      MSG_AR,A5               ; Loads A into A5
00001E84  4EB9 00002064           1301                     JSR      PRINTNULL               ; Prints A
00001E8A  3203                    1302                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001E8C  4EB9 00001F1A           1303                     JSR      PRINTNUM                ; Prints the Xn
00001E92  4BF9 000023C9           1304                     LEA      MSG_RB,A5               ; Loads ) into A5
00001E98  4EB9 00002064           1305                     JSR      PRINTNULL               ; Prints )
00001E9E  6000 0074               1306                     BRA      EA_TO_STRING_EXIT       ; exits
00001EA2                          1307  
00001EA2                          1308  * other (long, short, immediate) with Xn yes
00001EA2  301A                    1309  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
00001EA4  B67C 0000               1310                     CMP.W    #ABSShort,D3            ; checks if it is a word
00001EA8  6700 002E               1311                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00001EAC                          1312                     
00001EAC  B67C 0001               1313                     CMP.W    #ABSLong,D3             ; checks if it is (An)
00001EB0  6700 0042               1314                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001EB4                          1315  
00001EB4                          1316  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001EB4                          1317  * immediate
00001EB4  4BF9 000023CF           1318  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001EBA  4EB9 00002064           1319                     JSR      PRINTNULL               ; Prints #  
00001EC0  4BF9 000023D1           1320                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EC6  4EB9 00002064           1321                     JSR      PRINTNULL               ; Prints $
00001ECC  3200                    1322                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001ECE  4EB9 00001F2A           1323                     JSR      PRINTHEXNUM 
00001ED4  6000 003E               1324                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001ED8                          1325                     
00001ED8                          1326  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001ED8                          1327  
00001ED8                          1328  * word address
00001ED8                          1329  CASE_WORD          
00001ED8  4BF9 000023D1           1330                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EDE  4EB9 00002064           1331                     JSR      PRINTNULL               ; Prints $
00001EE4  3200                    1332                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001EE6  383C 0000               1333                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00001EEA  4EB9 00001F3E           1334                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001EF0  6000 0022               1335                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001EF4                          1336  
00001EF4                          1337  * long address 
00001EF4                          1338  CASE_LONG          
00001EF4  4BF9 000023D1           1339                     LEA      MSG_HEX,A5              ; Loads $ into A5
00001EFA  4EB9 00002064           1340                     JSR      PRINTNULL               ; Prints $
00001F00  3200                    1341                     MOVE.W   D0, D1                  ; moves instruction word into d1
00001F02  383C 0001               1342                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00001F06  4EB9 00001F3E           1343                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00001F0C  321A                    1344                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001F0E  4EB9 00001F1A           1345                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001F14                          1346  
00001F14                          1347  
00001F14                          1348  * exits subroutine
00001F14  4CDF 2003               1349  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001F18  4E75                    1350                      RTS                              ; returns from subroutine
00001F1A                          1351  
00001F1A                          1352  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001F1A                          1353  
00001F1A                          1354  * Prints out the content of D1 as a decimal number
00001F1A                          1355  * Input: number in D1 to be printed
00001F1A                          1356  * Output: contents of D1 printed
00001F1A  48E7 C000               1357  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F1E  103C 0003               1358                   MOVE.B      #3,D0               ; prints D1
00001F22  4E4F                    1359                   TRAP        #15                 ; is trap task 3
00001F24                          1360              
00001F24  4CDF 0003               1361                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F28  4E75                    1362                   RTS                             ; returns from subroutine
00001F2A                          1363                   
00001F2A                          1364  * Prints out the content of D1 as a hex number
00001F2A                          1365  * Input: number in D1 to be printed
00001F2A                          1366  * Output: contents of D1 printed
00001F2A  48E7 C000               1367  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001F2E  143C 0010               1368                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00001F32  103C 000F               1369                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00001F36  4E4F                    1370                   TRAP        #15                 ; is trap task 15
00001F38  4CDF 0003               1371                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001F3C  4E75                    1372                   RTS                             ; returns from subroutine
00001F3E                          1373                   
00001F3E                          1374  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00001F3E                          1375  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001F3E                          1376  * Output: contents of D1 printed
00001F3E  48E7 E000               1377  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00001F42  B83C 0001               1378                            CMP.B       #1,D4               ; checks size of number
00001F46  6700 0042               1379                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00001F4A                          1380  
00001F4A  3401                    1381  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00001F4C  C47C F000               1382                            AND.W       #$F000,D2           ; gets the first digit
00001F50  B47C 0000               1383                            CMP.W       #0, D2              ; checks if it is 0
00001F54  6600 00DC               1384                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F58  4EB9 00002042           1385                            JSR         PRINTZERO           ; prints a zero
00001F5E                          1386                            
00001F5E  3401                    1387                            MOVE.W      D1,D2               ; copies number to D2
00001F60  C47C 0F00               1388                            AND.W       #$0F00,D2           ; gets the second digit
00001F64  B47C 0000               1389                            CMP.W       #0, D2              ; checks if it is 0
00001F68  6600 00C8               1390                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F6C  4EB9 00002042           1391                            JSR         PRINTZERO           ; prints a zero
00001F72                          1392                            
00001F72  3401                    1393                            MOVE.W      D1,D2               ; copies number to D2
00001F74  C47C 00F0               1394                            AND.W       #$00F0,D2           ; gets the third digit
00001F78  B47C 0000               1395                            CMP.W       #0, D2              ; checks if it is 0
00001F7C  6600 00B4               1396                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F80  4EB9 00002042           1397                            JSR         PRINTZERO           ; prints a zero
00001F86  6000 00AA               1398                            BRA         PRINTASHEX          ; prints last digit
00001F8A                          1399                            
00001F8A  2401                    1400  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00001F8C  C4BC F0000000           1401                            AND.L       #$F0000000,D2       ; gets the first digit
00001F92  B4BC 00000000           1402                            CMP.L       #0, D2              ; checks if it is 0
00001F98  6600 0098               1403                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001F9C  4EB9 00002042           1404                            JSR         PRINTZERO           ; prints a zero
00001FA2                          1405                            
00001FA2  2401                    1406                            MOVE.L      D1,D2               ; copies number to D2
00001FA4  C4BC 0F000000           1407                            AND.L       #$0F000000,D2       ; gets the second digit
00001FAA  B4BC 00000000           1408                            CMP.L       #0, D2              ; checks if it is 0
00001FB0  6600 0080               1409                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FB4  4EB9 00002042           1410                            JSR         PRINTZERO           ; prints a zero
00001FBA                          1411                            
00001FBA  2401                    1412                            MOVE.L      D1,D2               ; copies number to D2
00001FBC  C4BC 00F00000           1413                            AND.L       #$00F00000,D2       ; gets the third digit
00001FC2  B4BC 00000000           1414                            CMP.L       #0, D2              ; checks if it is 0
00001FC8  6600 0068               1415                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FCC  4EB9 00002042           1416                            JSR         PRINTZERO           ; prints a zero
00001FD2                          1417                            
00001FD2  2401                    1418                            MOVE.L      D1,D2               ; copies number to D2
00001FD4  C4BC 000F0000           1419                            AND.L       #$000F0000,D2       ; gets the fourth digit
00001FDA  B4BC 00000000           1420                            CMP.L       #0, D2              ; checks if it is 0
00001FE0  6600 0050               1421                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FE4  4EB9 00002042           1422                            JSR         PRINTZERO           ; prints a zero
00001FEA                          1423                            
00001FEA  2401                    1424                            MOVE.L      D1,D2               ; copies number to D2
00001FEC  C4BC 0000F000           1425                            AND.L       #$0000F000,D2       ; gets the fith digit
00001FF2  B4BC 00000000           1426                            CMP.L       #0, D2              ; checks if it is 0
00001FF8  6600 0038               1427                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00001FFC  4EB9 00002042           1428                            JSR         PRINTZERO           ; prints a zero
00002002                          1429                            
00002002  2401                    1430                            MOVE.L      D1,D2               ; copies number to D2
00002004  C4BC 00000F00           1431                            AND.L       #$00000F00,D2       ; gets the sixth digit
0000200A  B4BC 00000000           1432                            CMP.L       #0, D2              ; checks if it is 0
00002010  6600 0020               1433                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002014  4EB9 00002042           1434                            JSR         PRINTZERO           ; prints a zero
0000201A                          1435                            
0000201A  2401                    1436                            MOVE.L      D1,D2               ; copies number to D2
0000201C  C4BC 000000F0           1437                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002022  B4BC 00000000           1438                            CMP.L       #0, D2              ; checks if it is 0
00002028  6600 0008               1439                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000202C  4EB9 00002042           1440                            JSR         PRINTZERO           ; prints a zero
00002032                          1441  
00002032  143C 0010               1442  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002036  103C 000F               1443                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000203A  4E4F                    1444                            TRAP        #15                 ; is trap task 15
0000203C  4CDF 0007               1445                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002040  4E75                    1446                            RTS                             ; returns from subroutine    
00002042                          1447  * Prints a zero
00002042                          1448  * Input: nothing
00002042                          1449  * Output: 0 printed out to the console
00002042  2F01                    1450  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002044  7200                    1451                            MOVE.L      #0,D1               ; moves 0 to D1
00002046  4EB8 1F1A               1452                            JSR         PRINTNUM            ; prints the number
0000204A  221F                    1453                            MOVE.L      (SP)+,D1            ; restores D1
0000204C  4E75                    1454                            RTS                             ; returns from subroutine
0000204E                          1455              
0000204E                          1456  * Prints contents of things between a range
0000204E                          1457  * input: A5, A6 (the range)
0000204E                          1458  * output: prints memory contents from A5 to A6 as strings   
0000204E  48E7 C040               1459  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00002052  224D                    1460                  MOVEA.L     A5, A1           ; loads A5 into A1
00002054  9DCD                    1461                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00002056  320E                    1462                  MOVE.W      A6, D1           ; move n into D1
00002058  103C 0001               1463                  MOVE.B      #1, D0           ; display n characters of string at A1
0000205C  4E4F                    1464                  TRAP        #15              ; is trap task 1
0000205E  4CDF 0203               1465                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00002062  4E75                    1466                  RTS                          ; returns
00002064                          1467      
00002064                          1468  * Prints null terminated string
00002064                          1469  * input: string pointed to by A5
00002064                          1470  * output: prints out the null terminated string
00002064  48E7 8040               1471  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002068  224D                    1472                  MOVE.L      A5,A1           ; loads A5 into A1
0000206A  103C 000E               1473                  MOVE.B      #14,D0          ; prints null terminated string
0000206E  4E4F                    1474                  TRAP        #15             ; is trap task 10
00002070  4CDF 0201               1475                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00002074  4E75                    1476                  RTS                         ; returns from subroutine
00002076                          1477                  
00002076  2F0D                    1478  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002078  4BF9 000022CF           1479                  LEA         NEW_LINE,A5     ; Prints null
0000207E  4EB8 2064               1480                  JSR         PRINTNULL       ; prints the new line
00002082  2A5F                    1481                  MOVE.L      (SP)+,A5        ; returns A5
00002084  4E75                    1482                  RTS
00002086                          1483  
00002086                          1484  * Prints the size of the MOVE or MOVEA operation  
00002086                          1485  * input: D0
00002086                          1486  * output: prints out the size of a MOVE or MOVEA operation        
00002086  48E7 8004               1487  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
0000208A  3200                    1488                  MOVE.W  D0,D1               ; stores d0 in d1
0000208C  C07C 3000               1489                  AND.W   #$3000,D0           ; gets the size
00002090  B07C 2000               1490                  CMP.W   #$2000,D0           ; checks if is long
00002094  6700 001E               1491                  BEQ     MOVE_LONG
00002098  B07C 3000               1492                  CMP.W   #$3000,D0           ; checks if is word
0000209C  6700 000C               1493                  BEQ     MOVE_WORD      
000020A0                          1494                  
000020A0  4BF9 000023DC           1495  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000020A6  6000 0012               1496                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020AA                          1497  
000020AA  4BF9 000023E2           1498  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000020B0  6000 0008               1499                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000020B4                          1500  
000020B4  4BF9 000023E8           1501  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000020BA                          1502                  
000020BA  4EB8 2064               1503  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000020BE  4CDF 2001               1504                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000020C2  4E75                    1505                  RTS
000020C4                          1506  
000020C4  43F9 0000226F           1507  ERROR           LEA     ERROR_MSG,A1
000020CA  103C 000E               1508                  MOVE.B  #14,D0
000020CE  4E4F                    1509                  TRAP    #15 
000020D0                          1510         
000020D0                          1511  * DELETE THIS: Test                
000020D0  2661                    1512  DELETEME        MOVEA.L  -(A1),A3
000020D2  6700 0038               1513                  BEQ      DELETEMEAGAIN  
000020D6  6F00 0034               1514                  BLE      DELETEMEAGAIN
000020DA  6E00 0030               1515                  BGT      DELETEMEAGAIN
000020DE                          1516  
000020DE  E40A                    1517                  LSR.B      #2,D2
000020E0  E2E2                    1518                  LSR.W      -(A2)
000020E2  E2DA                    1519                  LSR.W      (A2)+
000020E4  E4AA                    1520                  LSR.L      D2,D2 
000020E6  E50A                    1521                  LSL.B      #2,D2
000020E8  E3E2                    1522                  LSL.W      -(A2)
000020EA  E3DA                    1523                  LSL.W      (A2)+
000020EC  E5AA                    1524                  LSL.L      D2,D2
000020EE  E51A                    1525                  ROL.B      #2,D2
000020F0  E7E2                    1526                  ROL.W      -(A2)
000020F2  E7DA                    1527                  ROL.W      (A2)+
000020F4  E5BA                    1528                  ROL.L      D2,D2
000020F6  E41A                    1529                  ROR.B      #2,D2
000020F8  E6E2                    1530                  ROR.W      -(A2)
000020FA  E6DA                    1531                  ROR.W      (A2)+
000020FC  E4BA                    1532                  ROR.L      D2,D2
000020FE                          1533                  
000020FE  504D                    1534                  ADDQ.W      #8,A5
00002100  D6C2                    1535                  ADDA.W      D2,A3
00002102  9BCB                    1536                  SUB.L       A3,A5        
00002104  8A43                    1537                  OR.W        D3,D5
00002106  4642                    1538                  NOT.W       D2
00002108                          1539                  
00002108  C5FC 0010               1540                  MULS.W    #$0010,D2
0000210C                          1541                  
0000210C                          1542  DELETEMEAGAIN                 
0000210C                          1543            
0000210C  FFFF FFFF               1544      SIMHALT             ; halt simulator
00002110                          1545  
00002110                          1546  * Put variables and constants here
00002110                          1547  
00002110  =0000000D               1548  CR                              EQU     $0D
00002110  =0000000A               1549  LF                              EQU     $0A 
00002110  =00000009               1550  TAB                             EQU     $09  
00002110                          1551  
00002110                          1552  * Addressing Modes
00002110  =00000000               1553  Dn                              EQU     0
00002110  =00000001               1554  An                              EQU     1
00002110  =00000002               1555  AnIndirect                      EQU     2
00002110  =00000003               1556  AnPost                          EQU     3
00002110  =00000004               1557  AnPre                           EQU     4
00002110  =00000007               1558  Other                           EQU     7           ; short, long, immediate
00002110                          1559  
00002110                          1560  * Xn
00002110  =00000000               1561  ABSShort                        EQU     0
00002110  =00000001               1562  ABSLong                         EQU     1
00002110  =00000004               1563  XnImmediate                     EQU     4
00002110                          1564  
00002110                          1565  * Valid Addressing Modes
00002110= 00 01 02 03 04 07 FF    1566  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00002117                          1567  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00002117= 00 02 03 04 07 FF       1568  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000211D= 02 04 07 FF             1569  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00002121= 02 03 07 FF             1570  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00002125= 02 03 04 07 FF          1571  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000212A= 00 02 03 04 07 FF       1572  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002130= 01 07 FF                1573  VALIDEA_LEA                     DC.B    An,Other,-1
00002133= 00 02 03 04 07 FF       1574  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002139= 02 03 04 07 FF          1575  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000213E= 02 03 04 07 FF          1576  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00002143= 02 07 FF                1577  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00002146                          1578  
00002146                          1579  * Valid Xn
00002146= 00 01 04 FF             1580  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
0000214A                          1581  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
0000214A= 00 01 FF                1582  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
0000214D                          1583  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
0000214D                          1584  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
0000214D                          1585  
0000214D                          1586  * posible memory ASd/LSd rotation values
0000214D  =00000000               1587  ASd_MEM                         EQU     0   
0000214D  =00000001               1588  LSd_MEM                         EQU     1 
0000214D  =00000003               1589  ROd_MEM                         EQU     3
0000214D                          1590   
0000214D  =00000000               1591  ASd_REG                         EQU     0   
0000214D  =00000001               1592  LSd_REG                         EQU     1 
0000214D  =00000003               1593  ROd_REG                         EQU     3
0000214D                          1594  
0000214D                          1595  * Messages
0000214D= 57 65 6C 63 6F 6D ...   1596  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
00002175= 46 6F 72 6D 61 74 ...   1597  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
000021C0= 4C 65 74 74 65 72 ...   1598  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000021E0= 50 6C 65 61 73 65 ...   1599  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002217= 50 6C 65 61 73 65 ...   1600  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
0000224D= 49 6E 76 61 6C 69 ...   1601  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
0000226F= 45 72 72 6F 72 20 ...   1602  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
0000228B= 31 30 30 30 20 20 ...   1603  INVALID_INSTR                   DC.B    '1000    ',TAB,'DATA',TAB,TAB,TAB,'$',0
0000229D= 46 69 6E 69 73 68 ...   1604  DONE                            DC.B    'Finished Disassembling. Press ENTER to restart.',CR,LF,0
000022CF= 0D 0A 00                1605  NEW_LINE                        DC.B    CR,LF,0
000022D2= 09 09 09 00             1606  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000022D6                          1607  
000022D6                          1608  * Opcode Messages
000022D6= 09 4E 4F 50 00          1609  MSG_NOP                         DC.B    TAB,'NOP',0
000022DB= 09 4D 4F 56 45 00       1610  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000022E1= 09 4D 4F 56 45 41 00    1611  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000022E8= 09 4D 4F 56 45 51 00    1612  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000022EF= 09 4D 4F 56 45 4D 00    1613  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000022F6= 09 41 44 44 00          1614  MSG_ADD                         DC.B    TAB,'ADD',0
000022FB= 09 41 44 44 41 00       1615  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002301= 09 41 44 44 51 00       1616  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00002307= 09 53 55 42 00          1617  MSG_SUB                         DC.B    TAB,'SUB',0
0000230C= 09 4D 55 4C 53 00       1618  MSG_MULS                        DC.B    TAB,'MULS',0
00002312= 09 44 49 56 55 00       1619  MSG_DIVU                        DC.B    TAB,'DIVU',0
00002318= 09 4C 45 41 09 09 ...   1620  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00002320= 09 41 4E 44 00          1621  MSG_AND                         DC.B    TAB,'AND',0
00002325= 09 4F 52 00             1622  MSG_OR                          DC.B    TAB,'OR',0
00002329= 09 4E 4F 54 00          1623  MSG_NOT                         DC.B    TAB,'NOT',0
0000232E= 09 4C 53 00             1624  MSG_LSd                         DC.B    TAB,'LS',0
00002332= 09 41 53 00             1625  MSG_ASd                         DC.B    TAB,'AS',0
00002336= 09 52 4F 00             1626  MSG_ROd                         DC.B    TAB,'RO',0
0000233A= 09 42 43 43 09 09 ...   1627  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00002342= 09 42 43 53 09 09 ...   1628  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
0000234A= 09 42 45 51 09 09 ...   1629  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00002352= 09 42 4E 45 09 09 ...   1630  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
0000235A= 09 42 47 45 09 09 ...   1631  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00002362= 09 42 47 54 09 09 ...   1632  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
0000236A= 09 42 48 49 09 09 ...   1633  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00002372= 09 42 4C 45 09 09 ...   1634  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
0000237A= 09 42 4C 53 09 09 ...   1635  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00002382= 09 42 4C 54 09 09 ...   1636  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
0000238A= 09 42 4D 49 09 09 ...   1637  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00002392= 09 42 50 4C 09 09 ...   1638  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
0000239A= 09 42 56 43 09 09 ...   1639  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
000023A2= 09 42 56 53 09 09 ...   1640  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
000023AA= 09 4A 53 52 09 09 ...   1641  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
000023B2= 09 52 54 53 00          1642  MSG_RTS                         DC.B    TAB,'RTS',0
000023B7= 09 42 52 41 09 09 ...   1643  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
000023BF                          1644  
000023BF                          1645  * Direction for LSd and ASd
000023BF= 52 00                   1646  MSG_RIGHT                       DC.B    'R',0
000023C1= 4C 00                   1647  MSG_LEFT                        DC.B    'L',0
000023C3                          1648  
000023C3                          1649  * Effective Addresses Messages
000023C3= 44 00                   1650  MSG_DR                          DC.B    'D',0
000023C5= 41 00                   1651  MSG_AR                          DC.B    'A',0
000023C7= 28 00                   1652  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000023C9= 29 00                   1653  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000023CB= 2B 00                   1654  MSG_PLUS                        DC.B    '+',0
000023CD= 2D 00                   1655  MSG_MINUS                       DC.B    '-',0
000023CF= 23 00                   1656  MSG_POUND                       DC.B    '#',0 
000023D1= 24 00                   1657  MSG_HEX                         DC.B    '$',0 
000023D3= 2C 20 00                1658  MSG_COMMA                       DC.B    ', ',0
000023D6= 2F 00                   1659  MSG_SLASH                       DC.B    '/',0  
000023D8= 20 00                   1660  MSG_SPACE                       DC.B    ' ',0
000023DA= 09 00                   1661  MSG_TAB                         DC.B    TAB,0
000023DC                          1662  
000023DC                          1663  * Size Messages
000023DC= 2E 42 09 09 09 00       1664  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
000023E2= 2E 57 09 09 09 00       1665  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
000023E8= 2E 4C 09 09 09 00       1666  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
000023EE                          1667  
000023EE                          1668  * Variables
000023EE  =00000100               1669  STARTING_ADDRESS                EQU     $100
000023EE  =00000150               1670  ENDING_ADDRESS                  EQU     $150
000023EE  =00000200               1671  CURRENT_INSTR                   EQU     $200
000023EE  =00000250               1672  REG_VAR                         EQU     $250 * Hold bits 11-9
000023EE  =00000300               1673  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000023EE  =00000350               1674  EA_MODE                         EQU     $350 * Hold bits 5-3
000023EE  =00000400               1675  EA_REG                          EQU     $400 * Hold bits 2-0
000023EE                          1676  
000023EE                          1677              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1576
ADDQ_BYTE           160C
ADDQ_LONG           162C
ADDQ_WORD           161C
ADD_SUB_BYTE        14B2
ADD_SUB_HELP        1438
ADD_SUB_LONG        14CE
ADD_SUB_OPERAND     14E4
ADD_SUB_SIZE        148E
ADD_SUB_WORD        14C0
AN                  1
AND_BYTE            17F6
AND_LONG            1816
AND_WORD            1806
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           224D
CASE_ADD            140C
CASE_ADDA           154A
CASE_ADDQ           15B2
CASE_AND            17AC
CASE_AR             1DE2
CASE_ARI            1DFA
CASE_ARIPOST        1E2A
CASE_ARIPRE         1E66
CASE_ASDMEM         194A
CASE_ASDREG         1A16
CASE_BCC            1B56
CASE_BEQ            1B88
CASE_BGT            1B9C
CASE_BLE            1B92
CASE_BRA            1B2E
CASE_DATA           1BD4
CASE_DR             1DCA
CASE_EPICFAIL       1BDA
CASE_IMMEDIATE      1EB4
CASE_JSR            1BBA
CASE_LEA            171A
CASE_LEFTMEM        1974
CASE_LEFTREG        1A40
CASE_LONG           1EF4
CASE_LSDASDROD      190A
CASE_LSDMEM         1940
CASE_LSDREG         1A0C
CASE_MOVE           120E
CASE_MOVEM          12B4
CASE_MOVEQ          13B4
CASE_NOP            11F4
CASE_NOT            18AE
CASE_OR             1856
CASE_OTHER          1EA2
CASE_RIGHTMEM       197E
CASE_RIGHTREG       1A4A
CASE_RODMEM         1954
CASE_RODREG         1A20
CASE_RTS            1BBA
CASE_SHIFTMEM       1928
CASE_SHIFTREG       19F2
CASE_SUB            168A
CASE_SUBA           1704
CASE_WORD           1ED8
CHECKEAEXIT         1D9A
CHECKEAMLOOP        1D6C
CHECKEAXN_IFVALID   1D6A
CHECKGET_EAXN       1C30
CHECKMEMSOURE       19B2
CHECKMOREBITS       1D1C
CHECKSHIFT_XN       19DC
CHECK_LENGTH        1146
CHECK_ODD           11DC
CHECK_ORDER         10AE
CHECK_XN            1C60
CONCAT              118E
CONVERT             1158
CR                  D
CURRENT_INSTR       200
DELETEME            20D0
DELETEMEAGAIN       210C
DESTEA              1BE6
DESTXN              1C10
DISASSEMBLE         10B8
DN                  0
DN_PLUS_EA          151E
DONE                229D
DONEPRINTINGREG     1D66
EASHIFT_VALID       19D0
EAXN_INVALID        1C72
EAXN_VALID          1C58
EA_MODE             350
EA_REG              400
EA_TO_STRING        1D9E
EA_TO_STRING_EXIT   1F14
ENDING              2217
ENDING_ADDRESS      150
END_CHECKGET        1C76
ERROR               20C4
ERROR_MSG           226F
FINDTYPEEA          1BFA
FINDTYPEXN          1C24
FINISHED            10C8
FINISHMOVE          20BA
FINISH_ADD          14DC
FINISH_ADDA         1586
FINISH_ADDQ         163C
FINISH_AND          1826
FINISH_SUB          16CA
FINISH_SUBA         16D0
FORMAT1             2175
FORMAT2             21C0
GETDIRECTION        1CB0
GETDISPLACEMENT     1C78
GETMEMSOURCE        199A
GETROTATION         1CA6
GETROTATIONLOCATION  1CC0
GETROTATIONSIZE     1CB8
GET_EA              1BDC
GET_XN              1C06
INPUT1              1020
INPUT2              1066
INSERTA             1280
INVALID             11A6
INVALIDEA           1D7E
INVALID_INSTR       228B
INV_INSTR           1830
ISNUMBER            116E
LF                  A
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         138A
MEM2REGWORD         137C
MEMTOREG1           1CE8
MEMTOREG2           1D5A
MOVEM_MEM2REG       1344
MOVEM_REG2MEM       12D2
MOVE_BYTE           20A0
MOVE_LONG           20B4
MOVE_WORD           20AA
MSG_ADD             22F6
MSG_ADDA            22FB
MSG_ADDQ            2301
MSG_AND             2320
MSG_AR              23C5
MSG_ASD             2332
MSG_B               23DC
MSG_BCC             233A
MSG_BCS             2342
MSG_BEQ             234A
MSG_BGE             235A
MSG_BGT             2362
MSG_BHI             236A
MSG_BLE             2372
MSG_BLS             237A
MSG_BLT             2382
MSG_BMI             238A
MSG_BNE             2352
MSG_BPL             2392
MSG_BRA             23B7
MSG_BVC             239A
MSG_BVS             23A2
MSG_COMMA           23D3
MSG_DIVU            2312
MSG_DR              23C3
MSG_HEX             23D1
MSG_JSR             23AA
MSG_L               23E8
MSG_LB              23C7
MSG_LEA             2318
MSG_LEFT            23C1
MSG_LSD             232E
MSG_MINUS           23CD
MSG_MOVE            22DB
MSG_MOVEA           22E1
MSG_MOVEM           22EF
MSG_MOVEQ           22E8
MSG_MULS            230C
MSG_NOP             22D6
MSG_NOT             2329
MSG_OR              2325
MSG_PLUS            23CB
MSG_POUND           23CF
MSG_RB              23C9
MSG_RIGHT           23BF
MSG_ROD             2336
MSG_RTS             23B2
MSG_SLASH           23D6
MSG_SPACE           23D8
MSG_SUB             2307
MSG_TAB             23DA
MSG_W               23E2
NEW_LINE            22CF
NOTNUMBER           1176
OPCODE_DECODE       11F0
OPMODE_VAR          300
OR_SIZE             1896
OTHER               7
OTHEREA             1D96
PRINTADD            1476
PRINTADDRESS        1C88
PRINTASHEX          2032
PRINTBCC            1BA6
PRINTENTER          2076
PRINTHEXNUM         1F2A
PRINTLONGZERO       1F8A
PRINTMEM2REG        1396
PRINTMORE           1D28
PRINTMOVE           1286
PRINTMOVESIZE       2086
PRINTNULL           2064
PRINTNUM            1F1A
PRINTRANGE          204E
PRINTREG            1D0E
PRINTREG2MEM        1326
PRINTREGEA          1A8C
PRINTREGISTERLOOP   1CF2
PRINTREGISTERS      1CC8
PRINTREGSIZE        1A5A
PRINTSHIFTMEM       195A
PRINTSHIFTREG       1A26
PRINTSHORTLONGNUM   1F3E
PRINTSHORTZERO      1F4A
PRINTSUB            16A4
PRINTZERO           2042
PRINT_8             167E
PRINT_ADDQ_DATA     165A
PRINT_ADDR          11E4
PRINT_MEMDIR        1984
PRINT_MOVEQ         13D6
PRINT_REGDIR        1A54
REG2MEMLONG         131A
REG2MEMWORD         130A
REGTOMEM1           1CDA
REGTOMEM2           1D4E
REG_BYTE            1A72
REG_IMMEDIATE       1AA2
REG_LONG            1A86
REG_REGISTER        1AE8
REG_VAR             250
REG_WORD            1A7C
RESET_INPUT         113E
RESTART             10E8
RETURN              11A4
ROD_MEM             3
ROD_REG             3
SOURCEEA            1BF2
SOURCEXN            1C1C
START               1000
STARTING            21E0
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          11C4
THREE_TAB           22D2
VALIDEA             1D86
VALIDEA_ADDSUB_DESTOPERAND  2125
VALIDEA_ALL         2110
VALIDEA_ANDORNOT    2133
VALIDEA_ANDOR_DESTOPERAND  2139
VALIDEA_JSR         2143
VALIDEA_LEA         2130
VALIDEA_MOVEM_MEMTOREG  2121
VALIDEA_MOVEM_REGTOMEM  211D
VALIDEA_MOVEQ       2117
VALIDEA_MULSDIVU    212A
VALIDEA_SHIFT       213E
VALIDXN_ALL         2146
VALIDXN_SHORTLONG   214A
WELCOME             214D
XNIMMEDIATE         4
