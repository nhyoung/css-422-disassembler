00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/5/2020 9:49:28 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00001953             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  227C 00000000             16  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001012  43F9 000019C9             17                  LEA     STARTING,A1         ; output starting address message
00001018  103C 000E                 18                  MOVE.B  #14,D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20              
0000101E  227C 00000000             21                  MOVE.L  #$0000000, A1       ;clear A1
00001024  103C 0002                 22                  MOVE.B  #2,D0                   
00001028  4E4F                      23                  TRAP    #15                 ; take input from user
0000102A  143C 0001                 24                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
0000102E                            25  
0000102E  4EB9 000010CA             26                  JSR     CHECK_LENGTH
00001034  1C3C 0007                 27                  MOVE.B  #7,D6               ; D6 stores counter               
00001038  4EB9 000010DC             28                  JSR     CONVERT
0000103E  4EB9 00001148             29                  JSR     TEST_RANGE
00001044  4EB9 00001160             30                  JSR     CHECK_ODD
0000104A  23C5 00000100             31                  MOVE.L  D5,STARTING_ADDRESS
00001050  2445                      32                  MOVEA.L D5,A2               ; store first input in A2
00001052                            33    
00001052  143C 0002                 34  INPUT2          MOVE.B  #2,D2
00001056  227C 00000000             35                  MOVE.L  #$0000000, A1       ;clear A1
0000105C  43F9 00001A00             36                  LEA     ENDING,A1           ; output ending address message
00001062  103C 000E                 37                  MOVE.B  #14,D0
00001066  4E4F                      38                  TRAP    #15         
00001068                            39  
00001068  227C 00000000             40                  MOVE.L  #$0000000, A1       ;clear A1
0000106E  103C 0002                 41                  MOVE.B  #2,D0
00001072  4E4F                      42                  TRAP    #15
00001074                            43                  
00001074  4EB9 000010CA             44                  JSR     CHECK_LENGTH
0000107A  1C3C 0007                 45                  MOVE.B  #7,D6               ; D6 stores counter
0000107E  4285                      46                  CLR.L   D5
00001080  4EB9 000010DC             47                  JSR     CONVERT
00001086  4EB9 00001148             48                  JSR     TEST_RANGE
0000108C  4EB9 00001160             49                  JSR     CHECK_ODD
00001092  23C5 00000150             50                  MOVE.L  D5,ENDING_ADDRESS
00001098  2645                      51                  MOVEA.L D5,A3               ; store second input in A3
0000109A                            52        
0000109A  260A                      53  CHECK_ORDER     MOVE.L  A2,D3
0000109C  280B                      54                  MOVE.L  A3,D4
0000109E  B883                      55                  CMP.L   D3,D4               ; make sure first input is less than second input
000010A0  6D00 0020                 56                  BLT     RESET_INPUT
000010A4                            57                                 
000010A4  220A                      58  DISASSEMBLE     MOVE.L  A2,D1               ; loads current address in D1
000010A6  4EB9 00001842             59                  JSR     PRINTNUM            ; prints out address                    
000010AC  4EB9 00001168             60                  JSR     OPCODE_DECODE       ; decode the opcode
000010B2  4EB9 0000188A             61                  JSR     PRINTENTER          ; prints a new line
000010B8  B5CB                      62                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010BA  6FE8                      63                  BLE     DISASSEMBLE         ; if not, loop
000010BC                            64  
000010BC  103C 0009                 65  STOP            MOVE.B  #9,D0
000010C0  4E4F                      66                  TRAP    #15
000010C2                            67  
000010C2                            68  *--------------------SUBROUTINES------------------    
000010C2                            69  
000010C2  143C 0001                 70  RESET_INPUT     MOVE.B  #1,D2
000010C6  6000 0062                 71                  BRA     INVALID            
000010CA                            72                  
000010CA  7800                      73  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000010CC  B204                      74                  CMP.B   D4,D1               ; D1 stores length
000010CE  6700 005A                 75                  BEQ     INVALID             ; input is null
000010D2  0C41 0008                 76                  CMPI    #$8,D1              ; check if input is longer than a longword
000010D6  6E00 0052                 77                  BGT     INVALID             ; input is longer than a longword
000010DA  4E75                      78                  RTS
000010DC                            79                              
000010DC  4283                      80  CONVERT         CLR.L   D3
000010DE  4284                      81                  CLR.L   D4
000010E0  1619                      82                  MOVE.B  (A1)+,D3            ; D3 stores current char
000010E2  B63C 0039                 83                  CMP.B   #57,D3
000010E6  6E00 0012                 84                  BGT     NOTNUMBER
000010EA                            85                  
000010EA  B63C 002F                 86                  CMP.B   #47,D3
000010EE  6E00 0002                 87                  BGT     ISNUMBER
000010F2                            88                  
000010F2  0603 00D0                 89  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000010F6  6000 001A                 90                  BRA     CONCAT
000010FA                            91              
000010FA  B63C 0041                 92  NOTNUMBER       CMP.B   #65,D3
000010FE  6D00 002A                 93                  BLT     INVALID
00001102  B63C 0046                 94                  CMP.B   #70,D3
00001106  6E00 0022                 95                  BGT     INVALID  
0000110A  0603 00C9                 96                  ADD.B   #-55,D3             ; is letter             
0000110E  6000 0002                 97                  BRA     CONCAT
00001112                            98              
00001112  BC3C 0000                 99  CONCAT          CMP.B   #0,D6               ; D6 stores counter
00001116  6D00 0010                100                  BLT     RETURN
0000111A  1806                     101                  MOVE.B  D6,D4               ; D4 stores modified counter 
0000111C  E50C                     102                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
0000111E  E9AB                     103                  LSL.L   D4,D3               ; moves current char to correct position  
00001120  DA83                     104                  ADD.L   D3,D5               ; D5 stores converted input so far
00001122  0606 00FF                105                  ADD.B   #-1,D6  
00001126  60B4                     106                  BRA     CONVERT             ; continue loop for remaining chars
00001128                           107                  
00001128  4E75                     108  RETURN          RTS
0000112A                           109                  
0000112A  227C 00000000            110  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001130  43F9 00001A36            111                  LEA     BAD_INPUT,A1        ; output invalid message
00001136  103C 000E                112                  MOVE.B  #14,D0
0000113A  4E4F                     113                  TRAP    #15
0000113C  B47C 0001                114                  CMP     #1,D2
00001140  6700 FECA                115                  BEQ     INPUT1
00001144  6000 FF0C                116                  BRA     INPUT2
00001148                           117  
00001148  4284                     118  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000114A  223C 00001000            119                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001150  BA81                     120                  CMP.L      D1,D5            ; Compare minimum address with input
00001152  6DD6                     121                  BLT        INVALID          ; input is too low. 
00001154  223C 00FFFFFE            122                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000115A  BA81                     123                  CMP.L      D1,D5            ; compare maximum address with input
0000115C  6ECC                     124                  BGT        INVALID          ; input too large
0000115E  4E75                     125                  RTS                         ; input is within range
00001160                           126             
00001160  0805 0000                127  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001164  66C4                     128                  BNE        INVALID
00001166  4E75                     129                  RTS
00001168                           130  
00001168                           131  
00001168                           132  * Checks every single possible opcode we could have. Jump table
00001168                           133  * Inputs: (A2) which is a pointer to intruction word to be translated
00001168                           134  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001168                           135  
00001168  301A                     136  OPCODE_DECODE   MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000116A  33C0 00000200            137                  MOVE.W  D0,CURRENT_INSTR
00001170                           138                  
00001170  B07C 4E71                139  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001174  6600 0010                140                  BNE     CASE_MOVE               ; checks the next case if not equal
00001178  4BF9 00001A7B            141                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000117E  4EB9 00001878            142                  JSR     PRINTNULL               ; prints NOP                
00001184  4E75                     143                  RTS                             ; returns from the subroutine
00001186                           144                  
00001186                           145                  * if first two bits are 00, next two are not 00
00001186  3200                     146  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001188  C27C C000                147                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000118C  6600 009A                148                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001190  B07C 0FFF                149                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001194  6F00 0092                150                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001198                           151                  
00001198                           152                  ; Check source
00001198  4BF9 00001916            153                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000119E  4DF9 0000194C            154                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000011A4  3E3C 0000                155                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011A8  4EB9 0000162E            156                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011AE  B27C 0001                157                  CMP.W   #1,D1                    ; checks if invalid
000011B2  6700 0422                158                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011B6  3802                     159                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000011B8  3A03                     160                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000011BA                           161                  
000011BA                           162                  ; Check destination
000011BA  4BF9 00001916            163                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000011C0  4DF9 00001950            164                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000011C6  3E3C 0001                165                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000011CA  4EB9 0000162E            166                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000011D0  B27C 0001                167                  CMP.W   #1,D1                    ; checks if invalid
000011D4  6700 0400                168                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000011D8  3C02                     169                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000011DA  3E03                     170                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000011DC                           171                  
000011DC                           172                  ; Checking if it is MOVEA
000011DC  3200                     173                  MOVE.W  D0,D1                    ; stores d0 in d1
000011DE  C27C 01C0                174                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000011E2  B27C 0040                175                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000011E6  6700 000C                176                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000011EA                           177   
000011EA  4BF9 00001A80            178                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000011F0  6000 0008                179                  BRA     PRINTMOVE                ; Branches to print move
000011F4                           180                  
000011F4  4BF9 00001A86            181  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
000011FA                           182   
000011FA  4EB9 00001878            183  PRINTMOVE       JSR     PRINTNULL                ; prints out MOVE/MOVEA
00001200  4EB9 0000189A            184                  JSR     PRINTMOVESIZE            ; prints out the size  
00001206  3404                     185                  MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001208  3605                     186                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000120A  4EB9 000016EA            187                  JSR     EA_TO_STRING             ; outputs it into a string
00001210                           188                  
00001210                           189                  ; prints a comma to seperate
00001210  4BF9 00001B78            190                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001216  4EB9 00001878            191                  JSR     PRINTNULL                ; prints out MOVE
0000121C                           192                  
0000121C                           193                  ; print destination
0000121C  3406                     194                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000121E  3607                     195                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001220  4EB9 000016EA            196                  JSR     EA_TO_STRING             ; outputs it into a string
00001226  4E75                     197                  RTS                              ; exits subroutine                 
00001228                           198                
00001228                           199                  
00001228  3200                     200  CASE_MOVEM      MOVE.W  D0,D1                   ; copies instruction word to D1
0000122A  C27C FB80                201                  AND.W   #$FB80,D1               ; check bitmask for MOVEM (1111 1011 1000 0000)
0000122E  B27C 4880                202                  CMP.W   #$4880,D1               ; sees if it matches MOVEM (0100 1000 1000 0000)
00001232  6600 005A                203                  BNE     CASE_MOVEQ                   ; checks MOVEQ if its not MOVEM
00001236                           204                  
00001236                           205                  ; loads EA and XN
00001236  323C 0000                206                  MOVE.W  #0,D1                   ; copies instruction word to D1
0000123A  4EB9 000015DA            207                  JSR     GET_EA                  ; gets EA and puts in D1
00001240  3401                     208                  MOVE.W  D1,D2                   ; copies EA to D1 so it won't be overwritten
00001242  323C 0000                209                  MOVE.W  #0,D1                   ; copies instruction word to D1
00001246  4EB9 00001604            210                  JSR     GET_XN                  ; gets XN and puts in D1
0000124C  3601                     211                  MOVE.W  D1,D3                   ; copies EA to D1 so it won't be overwritten
0000124E                           212                  
0000124E                           213                  ; Check D
0000124E  3200                     214                  MOVE.W  D0,D1                   ; copies instruction word to D1
00001250  C27C 0400                215                  AND.W   #$0400,D1               ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001254  3E01                     216                  MOVE.W  D1,D7                   ; stores D1 in D7 so it doesn't get overwritten
00001256  B27C 0400                217                  CMP.W   #$0400,D1               ; checks if value is 1
0000125A  6700 0032                218                  BEQ     MOVEM_MEM2REG           ; if value is 1, then it is Memory to Register   
0000125E                           219  
0000125E  4BF9 00001923            220  MOVEM_REG2MEM   LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
00001264  3202                     221                  MOVE.W  D2,D1                           ; Loads D2 into D1 to check the number representing EA
00001266  4EB9 000016B6            222                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
0000126C  B27C 0001                223                  CMP.W   #1,D1                           ; checks if D1 invalid
00001270  6700 0364                224                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001274  B27C 0002                225                  CMP.W   #2,D1                           ; checks if we need to check Xn
00001278                           226                  
00001278  4BF9 00001923            227  REG2MEMXNCHECK  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads valid addresses
0000127E  3203                     228                  MOVE.W  D3,D1                           ; Loads D2 into D1 to check the number representing EA
00001280  4EB9 000016B6            229                  JSR     CHECKEAXN_IFVALID               ; checks if the EA is valid
00001286  B27C 0001                230                  CMP.W   #1,D1                           ; checks if D1 invalid
0000128A  6700 034A                231                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000128E                           232  
0000128E                           233                  
0000128E                           234  
0000128E                           235  MOVEM_MEM2REG    
0000128E                           236                          
0000128E                           237  
0000128E                           238  
0000128E                           239  CASE_MOVEQ  
0000128E                           240  
0000128E                           241  *CASE_ADD        LEA         MSG_ADDA,A1
0000128E                           242  *                MOVE.B      #14,D0
0000128E                           243  *                TRAP        #15 
0000128E                           244  *
0000128E                           245  *CASE_ADDA       LEA         MSG_ADDA,A1
0000128E                           246  *                MOVE.B      #14,D0
0000128E                           247  *                TRAP        #15                 ; print "ADDA"
0000128E                           248  *                MOVE.W      OPMODE_VAR,D3
0000128E                           249  *                JSR         ADDA_SIZE
0000128E                           250  *                JSR         ADDR_MODE_JUMP_TABLE
0000128E                           251  *                    
0000128E                           252  *            
0000128E                           253  *ADDA_SIZE       CMP.W       #%111,D3
0000128E                           254  *                BEQ         PRINT_WORD 
0000128E                           255  *                BRA         PRINT_LONG          
0000128E                           256                  
0000128E                           257  
0000128E                           258  CASE_ADDQ
0000128E                           259  
0000128E                           260  CASE_SUB
0000128E                           261  
0000128E  3200                     262  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001290  C27C F000                263                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001294  B27C 4000                264                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001298  6600 0086                265                  BNE.W   CASE_AND                             ; If its not, check AND
0000129C  3200                     266                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000129E  C27C 01C0                267                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
000012A2  B27C 01C0                268                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
000012A6  6600 0078                269                  BNE.W   CASE_AND                             ; If its not, check AND
000012AA                           270                  
000012AA                           271                  ; Check source
000012AA  4BF9 00001936            272                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000012B0  4DF9 00001950            273                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000012B6  3E3C 0000                274                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
000012BA  4EB9 0000162E            275                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000012C0  3802                     276                  MOVE.W  D2,D4                                ; Saves D2 in D4
000012C2  3A03                     277                  MOVE.W  D3,D5                                ; Saves D2 in D4
000012C4                           278                  
000012C4                           279                  ; Check destination
000012C4  4BF9 00001936            280                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000012CA  4DF9 00001950            281                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000012D0  3E3C 0001                282                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000012D4  4EB9 0000162E            283                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000012DA  3C02                     284                  MOVE.W  D2,D6                                ; Saves D2 in D4
000012DC  3E03                     285                  MOVE.W  D3,D7                                ; Saves D2 in D4
000012DE                           286  
000012DE  4BF9 00001ABD            287                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000012E4  4EB9 00001878            288                  JSR     PRINTNULL                            ; prints LEA
000012EA                           289                  
000012EA                           290                  ; print source
000012EA  3404                     291                  MOVE.W  D4,D2
000012EC  3605                     292                  MOVE.W  D5,D3
000012EE  4EB9 000016EA            293                  JSR     EA_TO_STRING                         ; Prints out the EA
000012F4                           294                  
000012F4                           295                  ; comma
000012F4  4BF9 00001B78            296                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000012FA  4EB9 00001878            297                  JSR     PRINTNULL                       
00001300                           298                   
00001300                           299                  ; register
00001300  4BF9 00001B6A            300                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001306  4EB9 00001878            301                  JSR     PRINTNULL 
0000130C  3401                     302                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
0000130E  323C 0001                303                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
00001312  4EB9 00001604            304                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001318  4EB9 00001842            305                  JSR     PRINTNUM                             ; Prints the number in D1
0000131E  4E75                     306                  RTS
00001320                           307  
00001320                           308  **---------------AND opcode----------------------
00001320                           309  CASE_AND
00001320                           310  *CASE_AND        LEA         MSG_AND,A1
00001320                           311  *                MOVE.B      #14,D0
00001320                           312  *                TRAP        #15 
00001320                           313  *                JSR         GET_VARS
00001320                           314  *                JSR         AND_SIZE                        ; .B, .W, or .L  
00001320                           315  *                MOVE.W      CURRENT_INSTR, D5                         
00001320                           316  *                LSL.W       #7, D5                        
00001320                           317  *                LSR.W       #8, D5                   
00001320                           318  *                LSR.W       #7, D5                     
00001320                           319  *                CMP.B       #00, D5                         ; check if destination is a Dn?
00001320                           320  *                BEQ         DEST_DN                         ; Yes it is, go to DEST_DN
00001320                           321  *                CMP.B       #$01,D5                         ; Is the destination not a Dn?
00001320                           322  *                BEQ         DEST_EA                         ; branch to DEST_EA            
00001320                           323  *                RTS
00001320                           324     
00001320                           325  *AND_SIZE        CMP.B       #%00,OPMODE_VAR       
00001320                           326  *                BEQ         PRINT_BYTE
00001320                           327  *                CMP.B       #$01, OPMODE_VAR
00001320                           328  *                BEQ         PRINT_WORD
00001320                           329  *                CMP.B       #$02, OPMODE_VAR
00001320                           330  *                BEQ         PRINT_LONG    
00001320                           331  *    
00001320                           332  *DEST_DN         MOVE.W      CURRENT_INSTR, D5               
00001320                           333  *                LSL.W       #6,D5
00001320                           334  *                LSL.W       #4,D5
00001320                           335  *                LSR.W       #6,D5
00001320                           336  *                LSR.W       #4,D5
00001320                           337  *                LSR.W       #3,D5                           ; d5 stores EA mode                
00001320                           338  *                  
00001320                           339  *                MOVE.W      CURRENT_INSTR, D6               
00001320                           340  *                LSL.W       #6,D5
00001320                           341  *                LSL.W       #4,D5
00001320                           342  *                LSL.W       #3,D6
00001320                           343  *                LSR.W       #6,D6
00001320                           344  *                LSR.W       #4,D6
00001320                           345  *                LSR.W       #3,D6                           ; d6 stores EA register
00001320                           346  *                JSR         FIND_EA
00001320                           347  *
00001320                           348  *                
00001320                           349  *                MOVE.W      CURRENT_INSTR, D5               
00001320                           350  *                LSL.W       #4, D5                         
00001320                           351  *                LSR.W       #8, D5                          ; shift bits to get register
00001320                           352  *                LSR.W       #5, D5                          ; D5 contains register
00001320                           353  *                LEA         MSG_COMMA, A1                   
00001320                           354  *                MOVE.B      #14,D0
00001320                           355  *                TRAP        #15                             ; print comma
00001320                           356  *                LEA         MSG_DR, A1                      ; print D
00001320                           357  *                MOVE.B      #14,D0
00001320                           358  *                TRAP        #15
00001320                           359  *                MOVEA.L     D5,A1
00001320                           360  *                MOVE.B      #14,D0
00001320                           361  *                TRAP        #15                              
00001320                           362  *                RTS        
00001320                           363  *
00001320                           364  *FIND_EA        CMP.W       #%010,D5
00001320                           365  *                BEQ         CASE_ARI
00001320                           366  *                CMP.W       #%011,D5
00001320                           367  *                BEQ         CASE_ARIPOST
00001320                           368  *                CMP.W       #%100,D5
00001320                           369  *                BEQ         CASE_ARIPRE
00001320                           370  *                CMP.W       #%111,D5
00001320                           371  *                BEQ         CASE_OTHER
00001320                           372  *                BRA         ERROR    
00001320                           373  *                                     
00001320                           374  *DEST_EA         MOVE.W      CURRENT_INSTR, D5               
00001320                           375  *                LSL.W       #4, D5                         
00001320                           376  *                LSR.W       #8, D5                          ; shift bits to get register
00001320                           377  *                LSR.W       #5, D5                          ; D5 contains register
00001320                           378  *
00001320                           379  *                LEA         MSG_DR, A1                   
00001320                           380  *                MOVE.B      #14,D0
00001320                           381  *                TRAP        #15                             ; print D
00001320                           382  *                MOVEA.L     D5,A1  
00001320                           383  *                MOVE.B      #14,D0                          ; print register
00001320                           384  *                TRAP        #15
00001320                           385  *                
00001320                           386  *                LEA         MSG_COMMA, A1                   
00001320                           387  *                MOVE.B      #14,D0
00001320                           388  *                TRAP        #15                             ; print comma
00001320                           389  *                
00001320                           390  *                MOVE.W      CURRENT_INSTR, D5               
00001320                           391  *                LSL.W       #6,D5
00001320                           392  *                LSL.W       #4,D5
00001320                           393  *                LSR.W       #6,D5
00001320                           394  *                LSR.W       #4,D5
00001320                           395  *                LSR.W       #3,D5                           ; d5 stores EA mode                
00001320                           396  *                  
00001320                           397  *                MOVE.W      CURRENT_INSTR, D6               
00001320                           398  *                LSL.W       #6,D6
00001320                           399  *                LSL.W       #4,D6
00001320                           400  *                LSL.W       #3,D6
00001320                           401  *                LSR.W       #6,D6
00001320                           402  *                LSR.W       #4,D6
00001320                           403  *                LSR.W       #3,D6                           ; d6 stores EA register
00001320                           404  *                JSR         FIND_EA                          
00001320                           405  *                RTS                                     Return full instruction   
00001320                           406              
00001320                           407  CASE_OR
00001320                           408  
00001320                           409  CASE_NOT
00001320                           410  
00001320  3200                     411  CASE_LSDASD     MOVE.W      D0,D1                            ; copies D0 to D1
00001322  C27C F000                412                  AND.W       #$F000, D1                       ; gets first 4 bits
00001326  B27C E000                413                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
0000132A  6600 0210                414                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
0000132E  3400                     415                  MOVE.W      D0,D2                            ; copies D0 to D2
00001330  4EB9 000016A6            416                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001336  B47C 0003                417                  CMP.W       #$3, D2                          ; checks if it is memory or register option
0000133A  6600 00C8                418                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
0000133E                           419                  
0000133E  3400                     420  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001340  4EB9 00001694            421                  JSR         GETROTATION                      ; gets rotation value of D2
00001346  B47C 0000                422                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
0000134A  6700 0014                423                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
0000134E  B47C 0003                424                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001352  6700 0016                425                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001356                           426                  
00001356  4BF9 00001AD3            427  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
0000135C  6000 0012                428                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001360                           429  
00001360  4BF9 00001AD7            430  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001366  6000 0008                431                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
0000136A                           432  
0000136A  4BF9 00001ADB            433  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001370                           434                  
00001370  4EB9 00001878            435  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS   
00001376  3400                     436                  MOVE.W      D0,D2                            ; copies D0 to D2
00001378  4EB9 0000169E            437                  JSR         GETDIRECTION                     ; gets direction
0000137E  B47C 0000                438                  CMP.W       #0,D2                            ; checking if its right
00001382  6700 000C                439                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001386                           440  
00001386  4BF9 00001B66            441  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
0000138C  6000 0008                442                  BRA         PRINT_MEMDIR                     ; branches for printing
00001390                           443          
00001390  4BF9 00001B64            444  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001396                           445  
00001396  4EB9 00001878            446  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
0000139C  4BF9 00001B85            447                  LEA         MSG_W,A5                         ; loads .W into A5
000013A2  4EB9 00001878            448                  JSR         PRINTNULL                        ; Prints .W
000013A8  6000 0002                449                  BRA         GETMEMSOURCE                     ; checks the source 
000013AC                           450                  
000013AC                           451  ; get source addressing mode       
000013AC                           452  GETMEMSOURCE                                                 
000013AC  323C 0000                453                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
000013B0  4EB9 000015DA            454                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
000013B6  3801                     455                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
000013B8  323C 0000                456                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
000013BC  4EB9 00001604            457                  JSR         GET_XN                           ; Gets Xn, puts it into D1
000013C2  3A01                     458                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
000013C4                           459  
000013C4  4BF9 00001944            460  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
000013CA  3204                     461                  MOVE.W      D4,D1                            ; marks down that we are checking EA
000013CC  4EB9 000016B6            462                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
000013D2  B27C 0002                463                  CMP.W       #2,D1                            ; checks if it is Xn
000013D6  6700 0016                464                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
000013DA  B27C 0001                465                  CMP.W       #1,D1                            ; Checks if it is invalid
000013DE  6700 01F6                466                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
000013E2                           467  
000013E2  3404                     468  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
000013E4  3605                     469                  MOVE.W      D5,D3                            ; moves EA to D3
000013E6  4EB9 000016EA            470                  JSR         EA_TO_STRING                     ; prints out the EA
000013EC  4E75                     471                  RTS                
000013EE                           472                  
000013EE                           473                  
000013EE  4BF9 00001950            474  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
000013F4  3205                     475                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
000013F6  4EB9 000016B6            476                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
000013FC  4A41                     477                  TST.W       D1                               ; checks if it is valid
000013FE  67E2                     478                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001400  6000 01D4                479                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001404                           480  
00001404                           481  
00001404  3602                     482  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001406  3200                     483                  MOVE.W      D0,D1                            ; copies D0 to D1
00001408  C27C 0018                484                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
0000140C  E649                     485                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
0000140E  B27C 0000                486                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001412  6700 0014                487                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001416  B27C 0003                488                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
0000141A  6700 0016                489                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
0000141E                           490                  
0000141E  4BF9 00001AD3            491  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001424  6000 0012                492                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001428                           493  
00001428  4BF9 00001AD7            494  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
0000142E  6000 0008                495                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001432                           496  
00001432  4BF9 00001ADB            497  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001438                           498                  
00001438  4EB9 00001878            499  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS   
0000143E  3400                     500                  MOVE.W      D0,D2                            ; copies D0 to D2
00001440  4EB9 0000169E            501                  JSR         GETDIRECTION                     ; gets direction
00001446  B47C 0000                502                  CMP.W       #0,D2                            ; checking if its right
0000144A  6700 000C                503                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
0000144E                           504  
0000144E  4BF9 00001B66            505  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001454  6000 000C                506                  BRA         PRINT_REGDIR                     ; branches for printing
00001458                           507          
00001458  4BF9 00001B64            508  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
0000145E  6000 0002                509                  BRA         PRINT_REGDIR                     ; branches for printing
00001462                           510                  
00001462  4EB9 00001878            511  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001468                           512  
00001468  3400                     513  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
0000146A  4EB9 000016A6            514                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001470  B47C 0001                515                  CMP.W       #1,D2                            ; Checks if it is word size
00001474  6700 0014                516                  BEQ         REG_WORD                         ; Prints .W
00001478  B47C 0002                517                  CMP.W       #2,D2                            ; Checks if it is long size
0000147C  6700 0016                518                  BEQ         REG_LONG                         ; Prints .L
00001480                           519  
00001480  4BF9 00001B7F            520  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001486  6000 0012                521                  BRA         PRINTREGEA      
0000148A                           522  
0000148A  4BF9 00001B85            523  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001490  6000 0008                524                  BRA         PRINTREGEA      
00001494                           525                             
00001494  4BF9 00001B8B            526  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
0000149A                           527  
0000149A  4EB9 00001878            528  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
000014A0  3400                     529                  MOVE.W      D0,D2                            ; copies D0 to D1
000014A2  4EB9 000016AE            530                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
000014A8  B27C 0001                531                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
000014AC  6700 0048                532                  BEQ         REG_REGISTER                     ; goes to ASd case if so
000014B0                           533                                  
000014B0  3400                     534  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
000014B2  4EB9 000016A6            535                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000014B8  3202                     536                  MOVE.W      D2, D1                           ; moves rotation size to D1
000014BA  4BF9 00001B74            537                  LEA         MSG_POUND, A5                    ; loads # into A5
000014C0  4EB9 00001878            538                  JSR         PRINTNULL                        ; prints #
000014C6  4EB9 00001842            539                  JSR         PRINTNUM                         ; prints shift count
000014CC  4BF9 00001B78            540                  LEA         MSG_COMMA, A5                    ; loads , into A5
000014D2  4EB9 00001878            541                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
000014D8  4BF9 00001B68            542                  LEA         MSG_DR, A5                       ; loads D into A5
000014DE  4EB9 00001878            543                  JSR         PRINTNULL                        ; prints out D 
000014E4  323C 0000                544                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
000014E8  4EB9 00001604            545                  JSR         GET_XN                           ; gets the data register number, stores in D1
000014EE  4EB9 00001842            546                  JSR         PRINTNUM                         ; prints data register number in D1          
000014F4  4E75                     547                  RTS                                          ; ends subroutine to go onto the next instruction opcode
000014F6                           548                  
000014F6  3400                     549  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
000014F8  4EB9 000016A6            550                  JSR         GETROTATIONSIZE                  ; gets the rotation size
000014FE  3202                     551                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001500  4BF9 00001B68            552                  LEA         MSG_DR, A5                       ; loads D into A5
00001506  4EB9 00001878            553                  JSR         PRINTNULL                        ; prints D
0000150C  4EB9 00001842            554                  JSR         PRINTNUM                         ; prints register number
00001512  4BF9 00001B78            555                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001518  4EB9 00001878            556                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
0000151E  4BF9 00001B68            557                  LEA         MSG_DR, A5                       ; loads D into A5
00001524  4EB9 00001878            558                  JSR         PRINTNULL                        ; prints out D 
0000152A  323C 0000                559                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
0000152E  4EB9 00001604            560                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001534  4EB9 00001842            561                  JSR         PRINTNUM                         ; prints data register number in D1          
0000153A  4E75                     562                  RTS                                          ; ends subroutine to go onto the next instruction opcode
0000153C                           563               
0000153C  3200                     564  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000153E  C27C FF00                565                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001542  B27C 6000                566                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001546  6600 0018                567                  BNE.W   CASE_BCC                             ; If its not, check BCC
0000154A                           568                  
0000154A  4BF9 00001B5C            569                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001550  4EB9 00001878            570                  JSR     PRINTNULL                            ; prints BRA
00001556                           571  
00001556  3400                     572                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001558  4EB9 00001676            573                  JSR     GETDISPLACEMENT                      ; finds the displacement
0000155E  4E75                     574                  RTS
00001560                           575                  
00001560                           576  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001560                           577  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001560  3200                     578  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001562  C27C F000                579                  AND.W   #$F000,D1                            ; get top 4 bits
00001566  B27C 6000                580                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
0000156A  6600 0054                581                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
0000156E  3200                     582                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001570  C27C 0F00                583                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001574  E049                     584                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001576                           585                  
00001576  B27C 000E                586                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
0000157A  6700 002A                587                  BEQ     CASE_BGT                             ; branches to BGT if it is
0000157E                           588                  
0000157E  B27C 000F                589                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001582  6700 0018                590                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001586                           591                      
00001586  B27C 0007                592                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
0000158A  6700 0006                593                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
0000158E  6000 0046                594                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001592                           595     
00001592  4BF9 00001AEF            596  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001598  6000 0016                597                  BRA     PRINTBCC
0000159C                           598  
0000159C  4BF9 00001B17            599  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
000015A2  6000 000C                600                  BRA     PRINTBCC
000015A6                           601                  
000015A6  4BF9 00001B07            602  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
000015AC  6000 0002                603                  BRA     PRINTBCC
000015B0                           604  
000015B0  4EB9 00001878            605  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
000015B6  3400                     606                  MOVE.W  D0,D2                                ; Copies instruction word to D1
000015B8  4EB9 00001676            607                  JSR     GETDISPLACEMENT                      ; finds the displacement
000015BE  4E75                     608                  RTS              
000015C0                           609                  
000015C0                           610  
000015C0                           611  CASE_JSR       
000015C0                           612  
000015C0  B07C 4E75                613  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
000015C4  6600 FBC0                614                  BNE     CASE_MOVE           ; checks the next case if not equal
000015C8  4BF9 00001B57            615                  LEA     MSG_RTS,A5          ; loads string pointer into A5
000015CE  4EB9 00001878            616                  JSR     PRINTNULL           ; prints RTS                
000015D4  4E75                     617                  RTS                         ; returns from the subroutine
000015D6                           618  
000015D6                           619                  
000015D6                           620  
000015D6                           621  CASE_DATA           
000015D6  4E75                     622                      RTS               
000015D8                           623  
000015D8  4E75                     624  CASE_EPICFAIL       RTS
000015DA                           625  
000015DA                           626  
000015DA                           627  * Finds the EA type
000015DA                           628  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
000015DA                           629  * Output: Addressing Mode (3 bits, 0 to 7) in D1
000015DA  48E7 3000                630  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
000015DE  4A41                     631                      TST.W     D1                    ; compares D1 to 0
000015E0  6700 000E                632                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
000015E4                           633                      
000015E4  343C 01C0                634  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
000015E8  363C 0006                635                      MOVE.W    #6,D3                 ; stores the shift amount to D3
000015EC  6000 000A                636                      BRA       FINDTYPEEA            
000015F0                           637  
000015F0  343C 0038                638  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
000015F4  363C 0003                639                      MOVE.W    #3,D3                 ; stores the shift amount to D3
000015F8                           640  
000015F8                           641  
000015F8  3200                     642  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
000015FA  C242                     643                      AND.W     D2,D1                 ; applies bitmask to D1
000015FC  E669                     644                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
000015FE  4CDF 000C                645                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001602  4E75                     646                      RTS                             ; returns from subroutine    
00001604                           647                      
00001604                           648  * Finds Xn type
00001604                           649  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001604                           650  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001604  48E7 3000                651  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001608  4A41                     652                      TST.W     D1                    ; compares D1 to 0
0000160A  6700 000E                653                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
0000160E                           654  
0000160E  343C 0E00                655  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001612  363C 0009                656                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001616  6000 000A                657                      BRA       FINDTYPEXN            ; finds the type of Xn
0000161A                           658  
0000161A  343C 0007                659  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
0000161E  363C 0000                660                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001622                           661                      
00001622  3200                     662  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001624  C242                     663                      AND.W     D2,D1                 ; applies bitmask to D1
00001626  E669                     664                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001628  4CDF 000C                665                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
0000162C  4E75                     666                      RTS                             ; returns from subroutine 
0000162E                           667                      
0000162E                           668  * Checks and gets the EA and Xn
0000162E                           669  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
0000162E                           670  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
0000162E  3207                     671  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001630  4EB8 15DA                672                  JSR     GET_EA                  ; Gets EA
00001634  3401                     673                  MOVE.W  D1,D2                   ; Stores EA in D2
00001636  3207                     674                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001638  4EB8 1604                675                  JSR     GET_XN                  ; Gets Xn
0000163C  3601                     676                  MOVE.W  D1,D3                   ; Stores Xn in D3
0000163E  3202                     677                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001640                           678                  
00001640  4EB9 000016B6            679                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001646  B27C 0002                680                  CMP.W   #2,D1                   ; checks if it is Xn
0000164A  6700 0012                681                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
0000164E  B27C 0001                682                  CMP.W   #1,D1                   ; Checks if it is invalid
00001652  6700 001C                683                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001656                           684                  
00001656                           685                  
00001656  323C 0000                686  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
0000165A  6000 0018                687                  BRA     END_CHECKGET
0000165E                           688        
0000165E                           689  ; need XN
0000165E  2A4E                     690  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001660  3203                     691                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001662  4EB9 000016B6            692                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001668  4A41                     693                  TST.W   D1                      ; checks if it is valid
0000166A  67EA                     694                  BEQ     EAXN_VALID              ; go to EA_VALID to print
0000166C  6000 0002                695                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001670                           696   
00001670  323C 0001                697  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001674                           698  
00001674  4E75                     699  END_CHECKGET    RTS          
00001676                           700                                            
00001676                           701                                            
00001676                           702  * Gets the displacement and pritns it 
00001676                           703  * Inputs: D2 = instruction word, A2 = address of next word
00001676                           704  * Outputs: prints out displacement
00001676  48E7 4004                705  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
0000167A  3A4A                     706                      MOVE.W    A2,A5                 ; copies A2 to A5
0000167C  C47C 00FF                707                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001680  6600 0004                708                      BNE       PRINTADDRESS          ; prints address if not 0
00001684  341A                     709                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001686                           710                      
00001686  D44D                     711  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001688  3202                     712                      MOVE.W    D2,D1                 ; moves address to D1 to print it
0000168A  4EB9 00001842            713                      JSR       PRINTNUM              ; prints address
00001690                           714                      
00001690  4CDF 2002                715                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001694                           716                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001694                           717  
00001694                           718  * Gets the rotation value for ASd and LSd
00001694                           719  * Input: D2 = instruction word copy (of D0)                                    
00001694                           720  * Output: rotation  value in D2             
00001694  C47C 0E00                721  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001698  E04A                     722                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
0000169A  E24A                     723                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
0000169C  4E75                     724                      RTS                             ; return from subroutine
0000169E                           725  
0000169E                           726  * Gets the direction value for ASd and LSd
0000169E                           727  * Input: D2 = instruction word copy (of D0)                                    
0000169E                           728  * Output: direction value in D2             
0000169E  C47C 0100                729  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
000016A2  E04A                     730                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
000016A4  4E75                     731                      RTS                             ; return from subroutine
000016A6                           732  
000016A6                           733  * Gets the rotation size value for ASd and LSd
000016A6                           734  * Input: D2 = instruction word copy (of D0)                                    
000016A6                           735  * Output: rotation size value in D2             
000016A6  C47C 00C0                736  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
000016AA  EC4A                     737                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
000016AC  4E75                     738                      RTS                             ; return from subroutine
000016AE                           739  
000016AE                           740  * Gets the rotation location  value for ASd and LSd
000016AE                           741  * Input: D2 = instruction word copy (of D0)                                    
000016AE                           742  * Output: rotation location value in D2             
000016AE  C47C 0020                743  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
000016B2  EA4A                     744                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
000016B4  4E75                     745                      RTS                             ; return from subroutine
000016B6                           746  
000016B6                           747                          
000016B6                           748  * Checks if EA or Xn is valid
000016B6                           749  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
000016B6                           750  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
000016B6  2F02                     751  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
000016B8                           752  
000016B8  141D                     753  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
000016BA  B43C 00FF                754                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
000016BE  6700 000A                755                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
000016C2  B202                     756                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
000016C4  6700 000C                757                     BEQ        VALIDEA               ; branches to valid EA
000016C8  60EE                     758                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
000016CA                           759                     
000016CA  323C 0001                760  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
000016CE  6000 0016                761                     BRA        CHECKEAEXIT           ; exists the subroutine        
000016D2                           762                    
000016D2  B43C 0007                763  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
000016D6  6700 000A                764                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
000016DA  323C 0000                765                     MOVE.W     #$0,D1                ; marks that it is valid
000016DE  6000 0006                766                     BRA        CHECKEAEXIT           ; exits the subroutine
000016E2                           767  
000016E2  323C 0002                768  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
000016E6                           769  
000016E6  241F                     770  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
000016E8  4E75                     771                     RTS                              ; returns from subroutine
000016EA                           772  
000016EA                           773  * Converts EA and Xn into a string                                
000016EA                           774  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
000016EA                           775  * Outputs: Prints out EA and Xn into a string
000016EA  48E7 C004                776  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
000016EE  B47C 0001                777                     CMP.W    #An,D2                  ; checks if it is An
000016F2  6700 003A                778                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
000016F6                           779                     
000016F6  B47C 0002                780                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
000016FA  6700 004A                781                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
000016FE                           782                     
000016FE  B47C 0003                783                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001702  6700 0072                784                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001706                           785                     
00001706  B47C 0004                786                     CMP.W    #AnPre,D2               ; checks if it is -(An)
0000170A  6700 00A6                787                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
0000170E                           788                     
0000170E  B47C 0007                789                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001712  6700 00DA                790                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001716                           791                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001716                           792  
00001716                           793  * data register, Dn
00001716  4BF9 00001B68            794  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
0000171C  4EB9 00001878            795                     JSR      PRINTNULL               ; Prints D
00001722  3203                     796                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001724  4EB9 00001842            797                     JSR      PRINTNUM                ; Prints the Xn
0000172A  6000 0110                798                     BRA      EA_TO_STRING_EXIT       ; exits           
0000172E                           799  
0000172E                           800  
0000172E                           801  * address register
0000172E  4BF9 00001B6A            802  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001734  4EB9 00001878            803                     JSR      PRINTNULL               ; Prints A
0000173A  3203                     804                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000173C  4EB9 00001842            805                     JSR      PRINTNUM                ; Prints the Xn
00001742  6000 00F8                806                     BRA      EA_TO_STRING_EXIT       ; exits
00001746                           807  
00001746                           808  * address register indirect
00001746  4BF9 00001B6C            809  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
0000174C  4EB9 00001878            810                     JSR      PRINTNULL               ; Prints (
00001752  4BF9 00001B6A            811                     LEA      MSG_AR,A5               ; Loads A into A5
00001758  4EB9 00001878            812                     JSR      PRINTNULL               ; Prints A
0000175E  3203                     813                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001760  4EB9 00001842            814                     JSR      PRINTNUM                ; Prints the Xn
00001766  4BF9 00001B6E            815                     LEA      MSG_RB,A5               ; Loads ) into A5
0000176C  4EB9 00001878            816                     JSR      PRINTNULL               ; Prints )
00001772  6000 00C8                817                     BRA      EA_TO_STRING_EXIT       ; exits
00001776                           818  
00001776                           819  * address register indirect post increment
00001776  4BF9 00001B6C            820  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
0000177C  4EB9 00001878            821                     JSR      PRINTNULL               ; Prints (
00001782  4BF9 00001B6A            822                     LEA      MSG_AR,A5               ; Loads A into A5
00001788  4EB9 00001878            823                     JSR      PRINTNULL               ; Prints A
0000178E  3203                     824                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001790  4EB9 00001842            825                     JSR      PRINTNUM                ; Prints the Xn
00001796  4BF9 00001B6E            826                     LEA      MSG_RB,A5               ; Loads ) into A5
0000179C  4EB9 00001878            827                     JSR      PRINTNULL               ; Prints )
000017A2  4BF9 00001B70            828                     LEA      MSG_PLUS,A5             ; Loads + into A5
000017A8  4EB9 00001878            829                     JSR      PRINTNULL               ; Prints +
000017AE  6000 008C                830                     BRA      EA_TO_STRING_EXIT       ; exits
000017B2                           831  
000017B2                           832  
000017B2                           833  * address register indirect pre increment
000017B2  4BF9 00001B72            834  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
000017B8  4EB9 00001878            835                     JSR      PRINTNULL               ; Prints -
000017BE  4BF9 00001B6C            836                     LEA      MSG_LB,A5               ; Loads ( into A5
000017C4  4EB9 00001878            837                     JSR      PRINTNULL               ; Prints (
000017CA  4BF9 00001B6A            838                     LEA      MSG_AR,A5               ; Loads A into A5
000017D0  4EB9 00001878            839                     JSR      PRINTNULL               ; Prints A
000017D6  3203                     840                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000017D8  4EB9 00001842            841                     JSR      PRINTNUM                ; Prints the Xn
000017DE  4BF9 00001B6E            842                     LEA      MSG_RB,A5               ; Loads ) into A5
000017E4  4EB9 00001878            843                     JSR      PRINTNULL               ; Prints )
000017EA  6000 0050                844                     BRA      EA_TO_STRING_EXIT       ; exits
000017EE                           845  
000017EE                           846  * other (long, short, immediate) with Xn yes
000017EE  301A                     847  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000017F0  B67C 0000                848                     CMP.W    #ABSShort,D3            ; checks if it is a word
000017F4  6700 0022                849                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000017F8                           850                     
000017F8  B67C 0001                851                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000017FC  6700 002A                852                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
00001800                           853  
00001800                           854  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
00001800                           855  * immediate
00001800  4BF9 00001B74            856  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00001806  4EB9 00001878            857                     JSR      PRINTNULL               ; Prints #  
0000180C                           858                     * uncomment after converting to hex 
0000180C                           859                     *LEA      MSG_HEX,A5              ; Loads $ into A5
0000180C                           860                     *JSR      PRINTNULL               ; Prints $
0000180C  3200                     861                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000180E  4EB9 00001842            862                     JSR      PRINTNUM 
00001814  6000 0026                863                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00001818                           864                     
00001818                           865  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00001818                           866  
00001818                           867  * word address
00001818                           868  CASE_WORD          
00001818                           869                     *LEA      MSG_HEX,A5              ; Loads $ into A5
00001818                           870                     *JSR      PRINTNULL               ; Prints $
00001818  3200                     871                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000181A  383C 0000                872                     MOVE.W   #0, D4                  ; moves length size (word) into d4
0000181E  4EB9 00001842            873                     JSR      PRINTNUM               ; reformats the number to the proper length and prints out the number
00001824  6000 0016                874                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00001828                           875  
00001828                           876  * long address 
00001828                           877  CASE_LONG          
00001828                           878                     *LEA      MSG_HEX,A5              ; Loads $ into A5
00001828                           879                     *JSR      PRINTNULL               ; Prints $
00001828  3200                     880                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000182A  383C 0001                881                     MOVE.W   #1, D4                  ; moves length size (long) into d4
0000182E  4EB9 00001842            882                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
00001834  321A                     883                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00001836  4EB9 00001842            884                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
0000183C                           885  
0000183C                           886  
0000183C                           887  * exits subroutine
0000183C  4CDF 2003                888  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00001840  4E75                     889                      RTS                              ; returns from subroutine
00001842                           890  
00001842                           891  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001842                           892  
00001842                           893  * Prints out the content of D1
00001842                           894  * Input: number in D1 to be printed
00001842                           895  * Output: contents of D1 printed
00001842  48E7 C000                896  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00001846  103C 0003                897                   MOVE.B      #3,D0               ; prints D1
0000184A  4E4F                     898                   TRAP        #15                 ; is trap task 3
0000184C                           899              
0000184C  4CDF 0003                900                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001850  4E75                     901                   RTS                             ; returns from subroutine
00001852                           902                   
00001852                           903  * DELETE LATER: THIS IS A  WIP AND DOESNT ACHIEVE PROPER FUNCTIONALITY YET
00001852                           904                   
00001852                           905  * Prints out the content of D1 and formats it to have the length of WORD or a LONG
00001852                           906  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00001852                           907  * Output: contents of D1 printed
00001852  48E7 6000                908  PRINTSHORTLONGNUM         MOVEM.L     D1-D2, -(SP)        ; saves D0 and D1
00001856  103C 0003                909                            MOVE.B      #3,D0               ; prints D1
0000185A  4E4F                     910                            TRAP        #15                 ; is trap task 3
0000185C  4CDF 0003                911                            MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00001860  4E75                     912                  RTS                                       ; returns from subroutine    
00001862                           913               
00001862                           914              
00001862                           915  * Prints contents of things between a range
00001862                           916  * input: A5, A6 (the range)
00001862                           917  * output: prints memory contents from A5 to A6 as strings   
00001862  48E7 C040                918  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00001866  224D                     919                  MOVEA.L     A5, A1           ; loads A5 into A1
00001868  9DCD                     920                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
0000186A  320E                     921                  MOVE.W      A6, D1           ; move n into D1
0000186C  103C 0001                922                  MOVE.B      #1, D0           ; display n characters of string at A1
00001870  4E4F                     923                  TRAP        #15              ; is trap task 1
00001872  4CDF 0203                924                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00001876  4E75                     925                  RTS                          ; returns
00001878                           926      
00001878                           927  * Prints null terminated string
00001878                           928  * input: string pointed to by A5
00001878                           929  * output: prints out the null terminated string
00001878  48E7 8040                930  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
0000187C  224D                     931                  MOVE.L      A5,A1           ; loads A5 into A1
0000187E  103C 000E                932                  MOVE.B      #14,D0          ; prints null terminated string
00001882  4E4F                     933                  TRAP        #15             ; is trap task 10
00001884  4CDF 0201                934                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00001888  4E75                     935                  RTS                         ; returns from subroutine
0000188A                           936                  
0000188A  2F0D                     937  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
0000188C  4BF9 00001A74            938                  LEA         NEW_LINE,A5     ; Prints null
00001892  4EB8 1878                939                  JSR         PRINTNULL       ; prints the new line
00001896  2A5F                     940                  MOVE.L      (SP)+,A5        ; returns A5
00001898  4E75                     941                  RTS
0000189A                           942  
0000189A                           943  * Prints the size of the MOVE or MOVEA operation  
0000189A                           944  * input: D0
0000189A                           945  * output: prints out the size of a MOVE or MOVEA operation        
0000189A  48E7 8004                946  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
0000189E  3200                     947                  MOVE.W  D0,D1               ; stores d0 in d1
000018A0  C07C 3000                948                  AND.W   #$3000,D0           ; gets the size
000018A4  B07C 2000                949                  CMP.W   #$2000,D0           ; checks if is long
000018A8  6700 001E                950                  BEQ     MOVE_LONG
000018AC  B07C 3000                951                  CMP.W   #$3000,D0           ; checks if is word
000018B0  6700 000C                952                  BEQ     MOVE_WORD      
000018B4                           953                  
000018B4  4BF9 00001B7F            954  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000018BA  6000 0012                955                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000018BE                           956  
000018BE  4BF9 00001B85            957  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000018C4  6000 0008                958                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000018C8                           959  
000018C8  4BF9 00001B8B            960  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000018CE                           961                  
000018CE  4EB8 1878                962  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000018D2  4CDF 2001                963                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000018D6  4E75                     964                  RTS
000018D8                           965  
000018D8  43F9 00001A58            966  ERROR           LEA     ERROR_MSG,A1
000018DE  103C 000E                967                  MOVE.B  #14,D0
000018E2  4E4F                     968                  TRAP    #15 
000018E4                           969         
000018E4                           970  * DELETE THIS: Test                
000018E4  2661                     971  DELETEME        MOVEA.L  -(A1),A3
000018E6  6700 002A                972                  BEQ      DELETEMEAGAIN  
000018EA  6F00 0026                973                  BLE      DELETEMEAGAIN
000018EE  6E00 0022                974                  BGT      DELETEMEAGAIN
000018F2                           975  
000018F2  E40A                     976                  LSR.B      #2,D2
000018F4  E2E2                     977                  LSR.W      -(A2)
000018F6  E2DA                     978                  LSR.W      (A2)+
000018F8  E4AA                     979                  LSR.L      D2,D2 
000018FA  E50A                     980                  LSL.B      #2,D2
000018FC  E3E2                     981                  LSL.W      -(A2)
000018FE  E3DA                     982                  LSL.W      (A2)+
00001900  E5AA                     983                  LSL.L      D2,D2
00001902  E51A                     984                  ROL.B      #2,D2
00001904  E7E2                     985                  ROL.W      -(A2)
00001906  E7DA                     986                  ROL.W      (A2)+
00001908  E5BA                     987                  ROL.L      D2,D2
0000190A  E41A                     988                  ROR.B      #2,D2
0000190C  E6E2                     989                  ROR.W      -(A2)
0000190E  E6DA                     990                  ROR.W      (A2)+
00001910  E4BA                     991                  ROR.L      D2,D2
00001912                           992                         
00001912                           993                  
00001912                           994  DELETEMEAGAIN                 
00001912                           995            
00001912  FFFF FFFF                996      SIMHALT             ; halt simulator
00001916                           997  
00001916                           998  * Put variables and constants here
00001916                           999  
00001916  =0000000D               1000  CR                              EQU     $0D
00001916  =0000000A               1001  LF                              EQU     $0A 
00001916  =00000009               1002  TAB                             EQU     $09  
00001916                          1003  
00001916                          1004  * Addressing Modes
00001916  =00000000               1005  Dn                              EQU     0
00001916  =00000001               1006  An                              EQU     1
00001916  =00000002               1007  AnIndirect                      EQU     2
00001916  =00000003               1008  AnPost                          EQU     3
00001916  =00000004               1009  AnPre                           EQU     4
00001916  =00000007               1010  Other                           EQU     7           ; short, long, immediate
00001916                          1011  
00001916                          1012  * Xn
00001916  =00000000               1013  ABSShort                        EQU     0
00001916  =00000001               1014  ABSLong                         EQU     1
00001916  =00000004               1015  XnImmediate                     EQU     4
00001916                          1016  
00001916                          1017  * Valid Addressing Modes
00001916= 00 01 02 03 04 07 FF    1018  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
0000191D                          1019  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
0000191D= 00 02 03 04 07 FF       1020  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001923= 02 04 07 FF             1021  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
00001927= 02 03 07 FF             1022  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000192B= 02 03 04 07 FF          1023  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001930= 00 02 03 04 07 FF       1024  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00001936= 01 07 FF                1025  VALIDEA_LEA                     DC.B    An,Other,-1
00001939= 00 02 03 04 07 FF       1026  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000193F= 02 03 04 07 FF          1027  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00001944= 02 03 04 07 FF          1028  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00001949= 02 07 FF                1029  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
0000194C                          1030  
0000194C                          1031  * Valid Xn
0000194C= 00 01 04 FF             1032  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00001950                          1033  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00001950= 00 01 FF                1034  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00001953                          1035  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00001953                          1036  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00001953                          1037  
00001953                          1038  * posible memory ASd/LSd rotation values
00001953  =00000000               1039  ASd_MEM                         EQU     0   
00001953  =00000001               1040  LSd_MEM                         EQU     1 
00001953  =00000003               1041  ROd_MEM                         EQU     3
00001953                          1042   
00001953  =00000000               1043  ASd_REG                         EQU     0   
00001953  =00000001               1044  LSd_REG                         EQU     1 
00001953  =00000003               1045  ROd_REG                         EQU     3
00001953                          1046  
00001953                          1047  * Starting messages
00001953= 57 65 6C 63 6F 6D ...   1048  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
0000197A= 46 6F 72 6D 61 74 ...   1049                                  DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
000019C9= 50 6C 65 61 73 65 ...   1050  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00001A00= 50 6C 65 61 73 65 ...   1051  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00001A36= 49 6E 76 61 6C 69 ...   1052  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00001A58= 45 72 72 6F 72 20 ...   1053  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00001A74= 0D 0A 00                1054  NEW_LINE                        DC.B    CR,LF,0
00001A77= 09 09 09 00             1055  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00001A7B                          1056  
00001A7B                          1057  * Opcode Messages
00001A7B= 09 4E 4F 50 00          1058  MSG_NOP                         DC.B    TAB,'NOP',0
00001A80= 09 4D 4F 56 45 00       1059  MSG_MOVE                        DC.B    TAB,'MOVE',0  
00001A86= 09 4D 4F 56 45 41 00    1060  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00001A8D= 09 4D 4F 56 45 51 00    1061  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
00001A94= 09 4D 4F 56 45 4D 00    1062  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00001A9B= 09 41 44 44 00          1063  MSG_ADD                         DC.B    TAB,'ADD',0
00001AA0= 09 41 44 44 41 00       1064  MSG_ADDA                        DC.B    TAB,'ADDA',0
00001AA6= 09 41 44 44 51 00       1065  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00001AAC= 09 53 55 42 00          1066  MSG_SUB                         DC.B    TAB,'SUB',0
00001AB1= 09 4D 55 4C 53 00       1067  MSG_MULS                        DC.B    TAB,'MULS',0
00001AB7= 09 44 49 56 55 00       1068  MSG_DIVU                        DC.B    TAB,'DIVU',0
00001ABD= 09 4C 45 41 09 09 ...   1069  MSG_LEA                         DC.B    TAB,'LEA',TAB,TAB,TAB,0
00001AC5= 09 41 4E 44 00          1070  MSG_AND                         DC.B    TAB,'AND',0
00001ACA= 09 4F 52 00             1071  MSG_OR                          DC.B    TAB,'OR',0
00001ACE= 09 4E 4F 54 00          1072  MSG_NOT                         DC.B    TAB,'NOT',0
00001AD3= 09 4C 53 00             1073  MSG_LSd                         DC.B    TAB,'LS',0
00001AD7= 09 41 53 00             1074  MSG_ASd                         DC.B    TAB,'AS',0
00001ADB= 09 52 4F 00             1075  MSG_ROd                         DC.B    TAB,'RO',0
00001ADF= 09 42 43 43 09 09 ...   1076  MSG_BCC                         DC.B    TAB,'BCC',TAB,TAB,TAB,0
00001AE7= 09 42 43 53 09 09 ...   1077  MSG_BCS                         DC.B    TAB,'BCS',TAB,TAB,TAB,0
00001AEF= 09 42 45 51 09 09 ...   1078  MSG_BEQ                         DC.B    TAB,'BEQ',TAB,TAB,TAB,0
00001AF7= 09 42 4E 45 09 09 ...   1079  MSG_BNE                         DC.B    TAB,'BNE',TAB,TAB,TAB,0
00001AFF= 09 42 47 45 09 09 ...   1080  MSG_BGE                         DC.B    TAB,'BGE',TAB,TAB,TAB,0
00001B07= 09 42 47 54 09 09 ...   1081  MSG_BGT                         DC.B    TAB,'BGT',TAB,TAB,TAB,0
00001B0F= 09 42 48 49 09 09 ...   1082  MSG_BHI                         DC.B    TAB,'BHI',TAB,TAB,TAB,0
00001B17= 09 42 4C 45 09 09 ...   1083  MSG_BLE                         DC.B    TAB,'BLE',TAB,TAB,TAB,0
00001B1F= 09 42 4C 53 09 09 ...   1084  MSG_BLS                         DC.B    TAB,'BLS',TAB,TAB,TAB,0
00001B27= 09 42 4C 54 09 09 ...   1085  MSG_BLT                         DC.B    TAB,'BLT',TAB,TAB,TAB,0
00001B2F= 09 42 4D 49 09 09 ...   1086  MSG_BMI                         DC.B    TAB,'BMI',TAB,TAB,TAB,0
00001B37= 09 42 50 4C 09 09 ...   1087  MSG_BPL                         DC.B    TAB,'BPL',TAB,TAB,TAB,0
00001B3F= 09 42 56 43 09 09 ...   1088  MSG_BVC                         DC.B    TAB,'BVC',TAB,TAB,TAB,0
00001B47= 09 42 56 53 09 09 ...   1089  MSG_BVS                         DC.B    TAB,'BVS',TAB,TAB,TAB,0
00001B4F= 09 4A 53 52 09 09 ...   1090  MSG_JSR                         DC.B    TAB,'JSR',TAB,TAB,TAB,0
00001B57= 09 52 54 53 00          1091  MSG_RTS                         DC.B    TAB,'RTS',0
00001B5C= 09 42 52 41 09 09 ...   1092  MSG_BRA                         DC.B    TAB,'BRA',TAB,TAB,TAB,0
00001B64                          1093  
00001B64                          1094  * Direction for LSd and ASd
00001B64= 52 00                   1095  MSG_RIGHT                       DC.B    'R',0
00001B66= 4C 00                   1096  MSG_LEFT                        DC.B    'L',0
00001B68                          1097  
00001B68                          1098  * Effective Addresses Messages
00001B68= 44 00                   1099  MSG_DR                          DC.B    'D',0
00001B6A= 41 00                   1100  MSG_AR                          DC.B    'A',0
00001B6C= 28 00                   1101  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00001B6E= 29 00                   1102  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00001B70= 2B 00                   1103  MSG_PLUS                        DC.B    '+',0
00001B72= 2D 00                   1104  MSG_MINUS                       DC.B    '-',0
00001B74= 23 00                   1105  MSG_POUND                       DC.B    '#',0 
00001B76= 24 00                   1106  MSG_HEX                         DC.B    '$',0 
00001B78= 2C 20 00                1107  MSG_COMMA                       DC.B    ', ',0 
00001B7B= 20 00                   1108  MSG_SPACE                       DC.B    ' ',0
00001B7D= 09 00                   1109  MSG_TAB                         DC.B    TAB,0
00001B7F                          1110  
00001B7F                          1111  * Size Messages
00001B7F= 2E 42 09 09 09 00       1112  MSG_B                           DC.B    '.B',TAB,TAB,TAB,0
00001B85= 2E 57 09 09 09 00       1113  MSG_W                           DC.B    '.W',TAB,TAB,TAB,0
00001B8B= 2E 4C 09 09 09 00       1114  MSG_L                           DC.B    '.L',TAB,TAB,TAB,0
00001B91                          1115  
00001B91                          1116  * Variables
00001B91  =00000100               1117  STARTING_ADDRESS                EQU     $100
00001B91  =00000150               1118  ENDING_ADDRESS                  EQU     $150
00001B91  =00000200               1119  CURRENT_INSTR                   EQU     $200
00001B91  =00000250               1120  REG_VAR                         EQU     $250 * Hold bits 11-9
00001B91  =00000300               1121  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
00001B91  =00000350               1122  EA_MODE                         EQU     $350 * Hold bits 5-3
00001B91  =00000400               1123  EA_REG                          EQU     $400 * Hold bits 2-0
00001B91                          1124  
00001B91                          1125              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
AN                  1
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           1A36
CASE_ADDQ           128E
CASE_AND            1320
CASE_AR             172E
CASE_ARI            1746
CASE_ARIPOST        1776
CASE_ARIPRE         17B2
CASE_ASDMEM         1360
CASE_ASDREG         1428
CASE_BCC            1560
CASE_BEQ            1592
CASE_BGT            15A6
CASE_BLE            159C
CASE_BRA            153C
CASE_DATA           15D6
CASE_DR             1716
CASE_EPICFAIL       15D8
CASE_IMMEDIATE      1800
CASE_JSR            15C0
CASE_LEA            128E
CASE_LEFTMEM        1386
CASE_LEFTREG        144E
CASE_LONG           1828
CASE_LSDASD         1320
CASE_LSDMEM         1356
CASE_LSDREG         141E
CASE_MOVE           1186
CASE_MOVEM          1228
CASE_MOVEQ          128E
CASE_NOP            1170
CASE_NOT            1320
CASE_OR             1320
CASE_OTHER          17EE
CASE_RIGHTMEM       1390
CASE_RIGHTREG       1458
CASE_RODMEM         136A
CASE_RODREG         1432
CASE_RTS            15C0
CASE_SHIFTMEM       133E
CASE_SHIFTREG       1404
CASE_SUB            128E
CASE_WORD           1818
CHECKEAEXIT         16E6
CHECKEAMLOOP        16B8
CHECKEAXN_IFVALID   16B6
CHECKGET_EAXN       162E
CHECKMEMSOURE       13C4
CHECKSHIFT_XN       13EE
CHECK_LENGTH        10CA
CHECK_ODD           1160
CHECK_ORDER         109A
CHECK_XN            165E
CONCAT              1112
CONVERT             10DC
CR                  D
CURRENT_INSTR       200
DELETEME            18E4
DELETEMEAGAIN       1912
DESTEA              15E4
DESTXN              160E
DISASSEMBLE         10A4
DN                  0
EASHIFT_VALID       13E2
EAXN_INVALID        1670
EAXN_VALID          1656
EA_MODE             350
EA_REG              400
EA_TO_STRING        16EA
EA_TO_STRING_EXIT   183C
ENDING              1A00
ENDING_ADDRESS      150
END_CHECKGET        1674
ERROR               18D8
ERROR_MSG           1A58
FINDTYPEEA          15F8
FINDTYPEXN          1622
FINISHMOVE          18CE
GETDIRECTION        169E
GETDISPLACEMENT     1676
GETMEMSOURCE        13AC
GETROTATION         1694
GETROTATIONLOCATION  16AE
GETROTATIONSIZE     16A6
GET_EA              15DA
GET_XN              1604
INPUT1              100C
INPUT2              1052
INSERTA             11F4
INVALID             112A
INVALIDEA           16CA
ISNUMBER            10F2
LF                  A
LSD_MEM             1
LSD_REG             1
MOVEM_MEM2REG       128E
MOVEM_REG2MEM       125E
MOVE_BYTE           18B4
MOVE_LONG           18C8
MOVE_WORD           18BE
MSG_ADD             1A9B
MSG_ADDA            1AA0
MSG_ADDQ            1AA6
MSG_AND             1AC5
MSG_AR              1B6A
MSG_ASD             1AD7
MSG_B               1B7F
MSG_BCC             1ADF
MSG_BCS             1AE7
MSG_BEQ             1AEF
MSG_BGE             1AFF
MSG_BGT             1B07
MSG_BHI             1B0F
MSG_BLE             1B17
MSG_BLS             1B1F
MSG_BLT             1B27
MSG_BMI             1B2F
MSG_BNE             1AF7
MSG_BPL             1B37
MSG_BRA             1B5C
MSG_BVC             1B3F
MSG_BVS             1B47
MSG_COMMA           1B78
MSG_DIVU            1AB7
MSG_DR              1B68
MSG_HEX             1B76
MSG_JSR             1B4F
MSG_L               1B8B
MSG_LB              1B6C
MSG_LEA             1ABD
MSG_LEFT            1B66
MSG_LSD             1AD3
MSG_MINUS           1B72
MSG_MOVE            1A80
MSG_MOVEA           1A86
MSG_MOVEM           1A94
MSG_MOVEQ           1A8D
MSG_MULS            1AB1
MSG_NOP             1A7B
MSG_NOT             1ACE
MSG_OR              1ACA
MSG_PLUS            1B70
MSG_POUND           1B74
MSG_RB              1B6E
MSG_RIGHT           1B64
MSG_ROD             1ADB
MSG_RTS             1B57
MSG_SPACE           1B7B
MSG_SUB             1AAC
MSG_TAB             1B7D
MSG_W               1B85
NEW_LINE            1A74
NOTNUMBER           10FA
OPCODE_DECODE       1168
OPMODE_VAR          300
OTHER               7
OTHEREA             16E2
PRINTADDRESS        1686
PRINTBCC            15B0
PRINTENTER          188A
PRINTMOVE           11FA
PRINTMOVESIZE       189A
PRINTNULL           1878
PRINTNUM            1842
PRINTRANGE          1862
PRINTREGEA          149A
PRINTREGSIZE        1468
PRINTSHIFTMEM       1370
PRINTSHIFTREG       1438
PRINTSHORTLONGNUM   1852
PRINT_MEMDIR        1396
PRINT_REGDIR        1462
REG2MEMXNCHECK      1278
REG_BYTE            1480
REG_IMMEDIATE       14B0
REG_LONG            1494
REG_REGISTER        14F6
REG_VAR             250
REG_WORD            148A
RESET_INPUT         10C2
RETURN              1128
ROD_MEM             3
ROD_REG             3
SOURCEEA            15F0
SOURCEXN            161A
START               1000
STARTING            19C9
STARTING_ADDRESS    100
STOP                10BC
TAB                 9
TEST_RANGE          1148
THREE_TAB           1A77
VALIDEA             16D2
VALIDEA_ADDSUB_DESTOPERAND  192B
VALIDEA_ALL         1916
VALIDEA_ANDORNOT    1939
VALIDEA_ANDOR_DESTOPERAND  193F
VALIDEA_JSR         1949
VALIDEA_LEA         1936
VALIDEA_MOVEM_MEMTOREG  1927
VALIDEA_MOVEM_REGTOMEM  1923
VALIDEA_MOVEQ       191D
VALIDEA_MULSDIVU    1930
VALIDEA_SHIFT       1944
VALIDXN_ALL         194C
VALIDXN_SHORTLONG   1950
WELCOME             1953
XNIMMEDIATE         4
