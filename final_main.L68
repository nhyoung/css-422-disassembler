00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/9/2020 6:49:35 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 000022B7             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 000022DF             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 0000232A             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 0000234A             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011BE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011D0             36                  JSR     CONVERT
00001052  4EB9 0000123C             37                  JSR     TEST_RANGE
00001058  4EB9 00001254             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 00002381             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011BE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011D0             55                  JSR     CONVERT
0000109A  4EB9 0000123C             56                  JSR     TEST_RANGE
000010A0  4EB9 00001254             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0100                 64                  BLT     RESET_INPUT
000010B8  4BF9 0000246A             65                  LEA     NEW_LINE,A5
000010BE  4EB9 000021CE             66                  JSR     PRINTNULL
000010C4                            67                                 
000010C4                            68  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010C4                            69                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010C4                            70                  ; JSR     PRINTSHORTLONGNUM   ; prints out address
000010C4                            71                  
000010C4  1439 0000256B             72                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010CC  13C2 0000256B             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010D2                            75                  
000010D2  4EB9 00001268             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010D8                            77                  
000010D8  4EB9 00001166             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010DE                            79                  
000010DE  4EB9 000021E0             80                  JSR     PRINTENTER          ; prints a new line
000010E4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010E6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010E8                            83                  
000010E8                            84  
000010E8  4BF9 000023FB             85  FINISHED        LEA     DONE,A5
000010EE  4EB9 000021CE             86                  JSR     PRINTNULL
000010F4  103C 0005                 87                  MOVE.B  #5,D0
000010F8  4E4F                      88                  TRAP    #15
000010FA                            89                  
000010FA  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
000010FE  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001102                            92                  
00001102  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001106  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000110A                            95  
0000110A  103C 0009                 96                  MOVE.B  #9,D0
0000110E  4E4F                      97                  TRAP    #15
00001110                            98                  
00001110  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001114  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001118  4E4F                     101                  TRAP    #15                 Call Trap
0000111A                           102                  
0000111A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000111E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001122  4E4F                     105                  TRAP    #15
00001124                           106                  
00001124  207C 00000000            107                  MOVE.L  #$0000000, A0       ; Reset A1
0000112A  227C 00000000            108                  MOVE.L  #$0000000, A1       ; Reset A1
00001130  247C 00000000            109                  MOVE.L  #$0000000, A2       ; Reset A2
00001136  267C 00000000            110                  MOVE.L  #$0000000, A3       ; Reset A3
0000113C  287C 00000000            111                  MOVE.L  #$0000000, A4       ; Reset A4
00001142  2A7C 00000000            112                  MOVE.L  #$0000000, A5       ; Reset A5
00001148  2C7C 00000000            113                  MOVE.L  #$0000000, A6       ; Reset A6
0000114E  2E7C 01000000            114                  MOVEA.L #$01000000,A7       ; Reset A7
00001154  4281                     115                  CLR.L   D1                  ; Reset D1
00001156  4281                     116                  CLR.L   D1                  ; Reset D1
00001158  4282                     117                  CLR.L   D2                  ; Reset D2
0000115A  4283                     118                  CLR.L   D3                  ; Reset D3
0000115C  4284                     119                  CLR.L   D4                  ; Reset D4
0000115E  4285                     120                  CLR.L   D5                  ; Reset D5
00001160  4286                     121                  CLR.L   D6                  ; Reset D6
00001162  6000 FE9C                122                  BRA     START               ; branch to start of program
00001166                           123  
00001166                           124  *--------------------SUBROUTINES------------------
00001166  1439 0000256B            125  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000116C  1639 0000256C            126                  MOVE.B  LINE_MAX,D3                
00001172  B602                     127                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001174  6F00 0004                128                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001178  4E75                     129                  RTS
0000117A                           130  
0000117A  4BF9 0000243F            131  NEXT_SCREEN     LEA     CONTINUE,A5
00001180  4EB9 000021CE            132                  JSR     PRINTNULL
00001186  6000 0002                133                  BRA     READ_KEY
0000118A                           134                  
0000118A  103C 0005                135  READ_KEY        MOVE.B  #5,D0
0000118E  4E4F                     136                  TRAP    #15
00001190                           137                  
00001190  B23C 000D                138                  CMP.B   #$D,D1              ; Compare the key press with ENTER
00001194  6700 0004                139                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
00001198  60F0                     140                  BRA     READ_KEY
0000119A                           141                  
0000119A  103C 000B                142  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
0000119E  323C FF00                143                  MOVE.W  #$FF00, D1          Clear Screen
000011A2  4E4F                     144                  TRAP    #15                 Call Trap
000011A4                           145                  
000011A4                           146                  ; reset line counter
000011A4  1439 0000256B            147                  MOVE.B  LINE_COUNT,D2
000011AA  143C 0000                148                  MOVE.B  #$0,D2
000011AE  13C2 0000256B            149                  MOVE.B  D2,LINE_COUNT
000011B4  4E75                     150                  RTS       
000011B6                           151      
000011B6                           152  
000011B6  143C 0001                153  RESET_INPUT     MOVE.B  #1,D2
000011BA  6000 0062                154                  BRA     INVALID            
000011BE                           155                  
000011BE  7800                     156  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011C0  B204                     157                  CMP.B   D4,D1               ; D1 stores length
000011C2  6700 005A                158                  BEQ     INVALID             ; input is null
000011C6  0C41 0008                159                  CMPI    #$8,D1              ; check if input is longer than a longword
000011CA  6600 0052                160                  BNE     INVALID             ; input is longer than a longword
000011CE  4E75                     161                  RTS
000011D0                           162                              
000011D0  4283                     163  CONVERT         CLR.L   D3
000011D2  4284                     164                  CLR.L   D4
000011D4  1619                     165                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011D6  B63C 0039                166                  CMP.B   #57,D3
000011DA  6E00 0012                167                  BGT     NOTNUMBER
000011DE                           168                  
000011DE  B63C 002F                169                  CMP.B   #47,D3
000011E2  6E00 0002                170                  BGT     ISNUMBER
000011E6                           171                  
000011E6  0603 00D0                172  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000011EA  6000 001A                173                  BRA     CONCAT
000011EE                           174              
000011EE  B63C 0041                175  NOTNUMBER       CMP.B   #65,D3
000011F2  6D00 002A                176                  BLT     INVALID
000011F6  B63C 0046                177                  CMP.B   #70,D3
000011FA  6E00 0022                178                  BGT     INVALID  
000011FE  0603 00C9                179                  ADD.B   #-55,D3             ; is letter             
00001202  6000 0002                180                  BRA     CONCAT
00001206                           181              
00001206  BC3C 0000                182  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000120A  6D00 0010                183                  BLT     RETURN
0000120E  1806                     184                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001210  E50C                     185                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001212  E9AB                     186                  LSL.L   D4,D3               ; moves current char to correct position  
00001214  DA83                     187                  ADD.L   D3,D5               ; D5 stores converted input so far
00001216  0606 00FF                188                  ADD.B   #-1,D6  
0000121A  60B4                     189                  BRA     CONVERT             ; continue loop for remaining chars
0000121C                           190                  
0000121C  4E75                     191  RETURN          RTS
0000121E                           192                  
0000121E  227C 00000000            193  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001224  43F9 000023B7            194                  LEA     BAD_INPUT,A1        ; output invalid message
0000122A  103C 000E                195                  MOVE.B  #14,D0
0000122E  4E4F                     196                  TRAP    #15
00001230  B47C 0001                197                  CMP     #1,D2
00001234  6700 FDEA                198                  BEQ     INPUT1
00001238  6000 FE2C                199                  BRA     INPUT2
0000123C                           200  
0000123C  4284                     201  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000123E  223C 00001000            202                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001244  BA81                     203                  CMP.L      D1,D5            ; Compare minimum address with input
00001246  6DD6                     204                  BLT        INVALID          ; input is too low. 
00001248  223C 00FFFFFE            205                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000124E  BA81                     206                  CMP.L      D1,D5            ; compare maximum address with input
00001250  6ECC                     207                  BGT        INVALID          ; input too large
00001252  4E75                     208                  RTS                         ; input is within range
00001254                           209             
00001254  0805 0000                210  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001258  66C4                     211                  BNE        INVALID
0000125A  4E75                     212                  RTS
0000125C                           213  
0000125C                           214  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
0000125C                           215  *                MOVE.L  A6,D1                   ; loads current address in D1
0000125C                           216  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
0000125C                           217  *                JSR     PRINTSHORTLONGNUM       ; prints out address
0000125C                           218  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
0000125C                           219  *                RTS
0000125C  220E                     220                  MOVE.L  A6,D1                   ; loads current address in D1
0000125E  7801                     221                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001260  4EB9 000020A8            222                  JSR     PRINTSHORTLONGNUM       ; prints out address
00001266  4E75                     223                  RTS
00001268                           224  
00001268                           225  
00001268                           226  
00001268                           227  * Checks every single possible opcode we could have. Jump table
00001268                           228  * Inputs: (A2) which is a pointer to intruction word to be translated
00001268                           229  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001268                           230  
00001268  3C4A                     231  OPCODE_DECODE   MOVE.W  A2,A6
0000126A  301A                     232                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000126C  4EB8 125C                233                  JSR     PRINT_ADDR
00001270                           234                  
00001270                           235  
00001270                           236  *---------------NOP opcode----------------------                
00001270  B07C 4E71                237  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001274  6600 0010                238                  BNE     CASE_MOVE               ; checks the next case if not equal
00001278                           239                  
00001278  4BF9 00002471            240                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000127E  4EB9 000021CE            241                  JSR     PRINTNULL               ; prints NOP                
00001284  4E75                     242                  RTS                             ; returns from the subroutine
00001286                           243  
00001286                           244  *---------------MOVE opcode----------------------              
00001286                           245                  * if first two bits are 00, next two are not 00
00001286  3200                     246  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001288  C27C C000                247                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000128C  6600 00BE                248                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001290  B07C 0FFF                249                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001294  6F00 00B6                250                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
00001298                           251                  
00001298                           252                  ; Check source
00001298  4BF9 0000227A            253                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000129E  4DF9 000022B0            254                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012A4  3E3C 0000                255                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012A8  4EB9 00001D9A            256                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012AE  B27C 0001                257                  CMP.W   #1,D1                    ; checks if invalid
000012B2  6700 0A8A                258                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012B6  3802                     259                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012B8  3A03                     260                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012BA                           261                  
000012BA                           262                  ; Check destination
000012BA  4BF9 0000227A            263                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012C0  4DF9 000022B4            264                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012C6  3E3C 0001                265                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012CA  4EB9 00001D9A            266                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012D0  B27C 0001                267                  CMP.W   #1,D1                    ; checks if invalid
000012D4  6700 0A68                268                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012D8  3C02                     269                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012DA  3E03                     270                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012DC                           271                  
000012DC                           272                  ; Checking if it is MOVEA
000012DC  3200                     273                  MOVE.W  D0,D1                    ; stores d0 in d1
000012DE  C27C 01C0                274                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000012E2  B27C 0040                275                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000012E6  6700 0024                276                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000012EA                           277                  
000012EA  4BF9 00002476            278                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000012F0  4EB9 000021CE            279                  JSR     PRINTNULL                ; prints out MOVE
000012F6  4EB9 000021F0            280                  JSR     PRINTMOVESIZE            ; prints out the size 
000012FC  4BF9 00002548            281                  LEA     MSG_4SPACES,A5           ; loads spaces
00001302  4EB9 000021CE            282                  JSR     PRINTNULL                ; prints out spaces
00001308  6000 0020                283                  BRA     PRINTMOVE                ; Branches to print move
0000130C                           284                  
0000130C  4BF9 0000247C            285  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001312  4EB9 000021CE            286                  JSR     PRINTNULL                ; prints out MOVEA
00001318  4EB9 000021F0            287                  JSR     PRINTMOVESIZE            ; prints out the size 
0000131E  4BF9 00002544            288                  LEA     MSG_3SPACES,A5           ; loads spaces
00001324  4EB9 000021CE            289                  JSR     PRINTNULL                ; prints out spaces
0000132A                           290   
0000132A  3404                     291  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000132C  3605                     292                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000132E  4EB9 00001F08            293                  JSR     EA_TO_STRING             ; outputs it into a string
00001334                           294                  
00001334                           295                  ; prints a comma to seperate
00001334  4BF9 0000253B            296                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000133A  4EB9 000021CE            297                  JSR     PRINTNULL                ; prints out MOVE
00001340                           298                  
00001340                           299                  ; print destination
00001340  3406                     300                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001342  3607                     301                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001344  4EB9 00001F08            302                  JSR     EA_TO_STRING             ; outputs it into a string
0000134A  4E75                     303                  RTS                              ; exits subroutine                 
0000134C                           304                
0000134C                           305  *---------------MOVEM opcode----------------------                
0000134C  3200                     306  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000134E  C27C FB80                307                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001352  B27C 4880                308                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001356  6600 0106                309                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000135A                           310                  
0000135A                           311                  ; Check D
0000135A  3200                     312                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000135C  C27C 0400                313                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001360  3E01                     314                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001362  B27C 0400                315                  CMP.W   #$0400,D1                       ; checks if value is 1
00001366  6700 0076                316                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000136A                           317  
0000136A                           318  MOVEM_REG2MEM   ; loads EA and XN
0000136A  3E3C 0000                319                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000136E  4BF9 00002287            320                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001374  4DF9 000022B4            321                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000137A  4EB9 00001D9A            322                  JSR     CHECKGET_EAXN
00001380  B27C 0001                323                  CMP.W   #1,D1                           ; checks if D1 invalid
00001384  6700 09B8                324                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001388  4BF9 0000248A            325                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000138E  4EB9 000021CE            326                  JSR     PRINTNULL                       ; prints MOVEM
00001394                           327                  
00001394                           328                  ; finds and prints size
00001394  3200                     329                  MOVE.W  D0,D1                           ; copies D0
00001396  C27C 0040                330                  AND.W   #$0040,D1                       ; gets the size bit
0000139A  6600 000C                331                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
0000139E                           332  
0000139E  4BF9 00002565            333  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013A4  6000 0008                334                  BRA     PRINTREG2MEM                    ; prints the registers           
000013A8                           335                  
000013A8  4BF9 00002568            336  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013AE                           337             
000013AE  4EB9 000021CE            338  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013B4  4BF9 00002544            339                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013BA  4EB9 000021CE            340                  JSR     PRINTNULL                       ; prints out spaces
000013C0  383C 0001                341                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013C4  4EB9 00001E32            342                  JSR     PRINTREGISTERS                  ; prints registers
000013CA  4BF9 0000253B            343                  LEA     MSG_COMMA,A5                    ; loads comma
000013D0  4EB9 000021CE            344                  JSR     PRINTNULL                       ; prints comma
000013D6  4EB9 00001F08            345                  JSR     EA_TO_STRING                    ; prints EA
000013DC  4E75                     346                  RTS
000013DE                           347  
000013DE                           348  MOVEM_MEM2REG  ; loads EA and XN
000013DE  3E3C 0000                349                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000013E2  4BF9 0000228B            350                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
000013E8  4DF9 000022B4            351                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000013EE  4EB9 00001D9A            352                  JSR     CHECKGET_EAXN
000013F4  B27C 0001                353                  CMP.W   #1,D1                           ; checks if D1 invalid
000013F8  6700 0944                354                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000013FC  4BF9 0000248A            355                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001402  4EB9 000021CE            356                  JSR     PRINTNULL                       ; prints MOVEM
00001408                           357                  
00001408                           358                  ; finds and prints size
00001408  3200                     359                  MOVE.W  D0,D1                           ; copies D0
0000140A  C27C 0040                360                  AND.W   #$0040,D1                       ; gets the size bit
0000140E  6600 0012                361                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001412                           362  
00001412  4BF9 00002565            363  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001418  4EB9 000021CE            364                  JSR     PRINTNULL                       ; prints MOVEM
0000141E  6000 000E                365                  BRA     PRINTMEM2REG                    ; prints the registers           
00001422                           366                  
00001422  4BF9 00002568            367  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001428  4EB9 000021CE            368                  JSR     PRINTNULL                       ; prints MOVEM 
0000142E                           369             
0000142E  4EB9 000021CE            370  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
00001434  4BF9 00002544            371                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000143A  4EB9 000021CE            372                  JSR     PRINTNULL                       ; prints out spaces
00001440  4EB9 00001F08            373                  JSR     EA_TO_STRING                    ; prints EA
00001446  4BF9 0000253B            374                  LEA     MSG_COMMA,A5                    ; loads comma
0000144C  4EB9 000021CE            375                  JSR     PRINTNULL                       ; prints comma
00001452  383C FFFF                376                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001456  4EB9 00001E32            377                  JSR     PRINTREGISTERS                  ; prints registers
0000145C  4E75                     378                  RTS
0000145E                           379                          
0000145E                           380  
0000145E                           381  *---------------MOVEQ opcode----------------------
0000145E  3200                     382  CASE_MOVEQ      MOVE.W  D0,D1
00001460  C27C F100                383                  AND.W   #$F100,D1
00001464  B27C 7000                384                  CMP.W   #$7000,D1
00001468  6600 0054                385                  BNE     CASE_ADD
0000146C                           386                  
0000146C                           387                  ;loads Register
0000146C  323C 0001                388                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001470  4EB9 00001D70            389                  JSR     GET_XN                          ; gets XN and puts in D1
00001476  3401                     390                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
00001478                           391                  
00001478                           392                  ;loads DATA
00001478  3200                     393                  MOVE.W  D0,D1
0000147A  C27C 00FF                394                  AND.W   #$00FF,D1                       ;bit mask to get DATA
0000147E  3601                     395                  MOVE.W  D1,D3                          ;copy data into D3
00001480                           396                                                        ;must convert bits to hex
00001480                           397                                  
00001480  4BF9 00002483            398  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
00001486  4EB9 000021CE            399                  JSR     PRINTNULL  
0000148C                           400                  
0000148C  4BF9 00002544            401                  LEA     MSG_3SPACES,A5                  ; loads spaces
00001492  4EB9 000021CE            402                  JSR     PRINTNULL                       ; prints out spaces
00001498                           403                  
00001498  4BF9 00002568            404                  LEA     MSG_L,A5                        ;PRINT SIZE L
0000149E  4EB9 000021CE            405                  JSR     PRINTNULL
000014A4                           406      
000014A4  4BF9 0000246D            407                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000014AA  4EB9 000021CE            408                  JSR     PRINTNULL
000014B0                           409                  
000014B0  4BF9 00002537            410                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000014B6  4EB9 000021CE            411                  JSR     PRINTNULL
000014BC  4E75                     412                  RTS
000014BE                           413                  
000014BE                           414  *---------------ADD opcode----------------------                
000014BE                           415  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000014BE  3200                     416  CASE_ADD        MOVE.W  D0,D1
000014C0  C27C F000                417                  AND.W   #$F000,D1
000014C4  B27C D000                418                  CMP.W   #$D000,D1
000014C8  6600 01BA                419                  BNE     CASE_ADDQ
000014CC                           420                   
000014CC  4EB9 000014E6            421                  JSR     ADD_SUB_HELP
000014D2                           422                  
000014D2                           423                  ; bits 7-8 determine if it is ADDA or ADD
000014D2  3200                     424                  MOVE.W  D0,D1
000014D4  E149                     425                  LSL.W   #8,D1                   ; get rid of left 8 bits
000014D6  E049                     426                  LSR.W   #8,D1
000014D8  EC49                     427                  LSR.W   #6,D1                   ; get rid of right 6 bits
000014DA  B27C 0003                428                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000014DE  6700 0124                429                  BEQ     CASE_ADDA
000014E2                           430                  
000014E2  6000 0040                431                  BRA     PRINTADD                ; Branches to print add
000014E6                           432                  
000014E6                           433                  ; Check bits 0-5 
000014E6  4BF9 0000227A            434  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000014EC  4DF9 000022B0            435                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000014F2  3E3C 0000                436                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000014F6  4EB9 00001D9A            437                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000014FC  B27C 0001                438                  CMP.W       #1,D1                    ; checks if invalid
00001500  6700 083C                439                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001504  3802                     440                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001506  3A03                     441                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001508                           442                  
00001508                           443                  ; Check 6-11
00001508  4BF9 0000227A            444                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000150E  4DF9 000022B4            445                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001514  3E3C 0001                446                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001518  4EB9 00001D9A            447                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000151E  3C02                     448                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001520  3E03                     449                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001522                           450    
00001522  4E75                     451                  RTS                
00001524                           452                    
00001524  4BF9 00002491            453  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
0000152A  4EB9 000021CE            454                  JSR         PRINTNULL               ; print ADD
00001530  3200                     455                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001532  4EB9 00001548            456                  JSR         ADD_SUB_SIZE
00001538  4BF9 0000254D            457                  LEA         MSG_5SPACES,A5          ; loads spaces
0000153E  4EB9 000021CE            458                  JSR         PRINTNULL               ; prints out spaces
00001544  6000 0050                459                  BRA         FINISH_ADD
00001548                           460                    
00001548  3200                     461  ADD_SUB_SIZE    MOVE.W      D0,D1
0000154A  E149                     462                  LSL.W       #8,D1
0000154C  E049                     463                  LSR.W       #8,D1
0000154E  EC49                     464                  LSR.W       #6,D1                   ; gets bits 6-7
00001550                           465                    
00001550  B27C 0000                466                  CMP.W       #0,D1
00001554  6700 0016                467                  BEQ         ADD_SUB_BYTE
00001558  B27C 0001                468                  CMP.W       #1,D1                   ; if 1, it is a word
0000155C  6700 001C                469                  BEQ         ADD_SUB_WORD
00001560  B27C 0002                470                  CMP.W       #2,D1                   ; if 2, it is a long
00001564  6700 0022                471                  BEQ         ADD_SUB_LONG
00001568  6000 0294                472                  BRA         CASE_SUBA               ; error
0000156C                           473                    
0000156C  4BF9 00002562            474  ADD_SUB_BYTE    LEA         MSG_B,A5
00001572  4EB9 000021CE            475                  JSR         PRINTNULL
00001578  4E75                     476                  RTS
0000157A                           477                    
0000157A  4BF9 00002565            478  ADD_SUB_WORD    LEA         MSG_W,A5
00001580  4EB9 000021CE            479                  JSR         PRINTNULL
00001586  4E75                     480                  RTS
00001588                           481    
00001588  4BF9 00002568            482  ADD_SUB_LONG    LEA         MSG_L,A5
0000158E  4EB9 000021CE            483                  JSR         PRINTNULL
00001594  4E75                     484                  RTS
00001596                           485        
00001596  4EB9 0000159E            486  FINISH_ADD      JSR         ADD_SUB_OPERAND
0000159C  4E75                     487                  RTS
0000159E                           488    
0000159E  EF49                     489  ADD_SUB_OPERAND LSL.W       #7,D1
000015A0  EE49                     490                  LSR.W       #7,D1
000015A2  E049                     491                  LSR.W       #8,D1
000015A4  B27C 0001                492                  CMP.W       #1,D1
000015A8  6600 002E                493                  BNE         Dn_PLUS_EA          
000015AC                           494                    
000015AC                           495                  ; print Data Register
000015AC  4BF9 0000252B            496                  LEA         MSG_DR,A5
000015B2  4EB9 000021CE            497                  JSR         PRINTNULL
000015B8  3207                     498                  MOVE.W      D7,D1
000015BA  4EB9 00002084            499                  JSR         PRINTNUM                
000015C0                           500                  
000015C0                           501                  ; prints a comma to seperate
000015C0  4BF9 0000253B            502                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015C6  4EB9 000021CE            503                  JSR         PRINTNULL                ; prints out MOVE
000015CC                           504                 
000015CC                           505                  ; below is EA+Dn->Dn  
000015CC  3404                     506                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015CE  3605                     507                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015D0  4EB9 00001F08            508                  JSR         EA_TO_STRING             ; outputs it into a string
000015D6  4E75                     509                  RTS                                 ; exits subroutine 
000015D8                           510  
000015D8                           511  Dn_PLUS_EA      ; below is Dn+EA->EA  
000015D8  3404                     512                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015DA  3605                     513                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015DC  4EB9 00001F08            514                  JSR         EA_TO_STRING             ; outputs it into a string   
000015E2                           515                  
000015E2                           516                  ; prints a comma to seperate
000015E2  4BF9 0000253B            517                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015E8  4EB9 000021CE            518                  JSR         PRINTNULL                ; prints out MOVE
000015EE                           519                  
000015EE                           520                  ; below is Dn+EA->EA
000015EE  4BF9 0000252B            521                  LEA         MSG_DR,A5                ; print data register
000015F4  4EB9 000021CE            522                  JSR         PRINTNULL
000015FA  3207                     523                  MOVE.W      D7,D1
000015FC  4EB9 00002084            524                  JSR         PRINTNUM             
00001602  4E75                     525                  RTS                                  ; exits subroutine          
00001604                           526                        
00001604                           527  *---------------ADDA opcode----------------------
00001604                           528  CASE_ADDA       ; gets bit 8 (size bit)
00001604  3200                     529                  MOVE.W      D0,D1
00001606  EF49                     530                  LSL.W       #7,D1
00001608  EE49                     531                  LSR.W       #7,D1
0000160A  E049                     532                  LSR         #8,D1                   
0000160C                           533                  
0000160C  4BF9 00002496            534                  LEA         MSG_ADDA,A5             ; print ADDA
00001612  4EB9 000021CE            535                  JSR         PRINTNULL
00001618                           536                   
00001618  B27C 0001                537                  CMP.W       #1,D1
0000161C  6700 001E                538                  BEQ         ADDA_LONG
00001620                           539                    
00001620  4BF9 00002565            540                  LEA         MSG_W,A5
00001626  4EB9 000021CE            541                  JSR         PRINTNULL
0000162C  4BF9 00002548            542                  LEA         MSG_4SPACES,A5          ; loads spaces
00001632  4EB9 000021CE            543                  JSR         PRINTNULL               ; prints out spaces
00001638  6000 001E                544                  BRA         FINISH_ADDA   
0000163C                           545                    
0000163C  4BF9 00002568            546  ADDA_LONG       LEA         MSG_L,A5
00001642  4EB9 000021CE            547                  JSR         PRINTNULL
00001648  4BF9 00002548            548                  LEA         MSG_4SPACES,A5          ; loads spaces
0000164E  4EB9 000021CE            549                  JSR         PRINTNULL               ; prints out spaces
00001654  6000 0002                550                  BRA         FINISH_ADDA
00001658                           551                    
00001658  3404                     552  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000165A  3605                     553                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000165C  4EB9 00001F08            554                  JSR         EA_TO_STRING             ; outputs it into a string
00001662                           555                    
00001662                           556                  ; prints a comma to seperate
00001662  4BF9 0000253B            557                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001668  4EB9 000021CE            558                  JSR         PRINTNULL                ; prints out MOVE
0000166E                           559            
0000166E  4BF9 0000252D            560                  LEA         MSG_AR,A5                ; print address register
00001674  4EB9 000021CE            561                  JSR         PRINTNULL
0000167A  3207                     562                  MOVE.W      D7,D1
0000167C  4EB9 00002084            563                  JSR         PRINTNUM             
00001682  4E75                     564                  RTS                              ; exits subroutine
00001684                           565                  
00001684                           566  *---------------ADDQ opcode----------------------                  
00001684  3200                     567  CASE_ADDQ       MOVE.W      D0,D1
00001686  C27C F000                568                  AND.W       #$F000,D1       
0000168A  B27C 5000                569                  CMP.W       #$5000,D1
0000168E  6600 00EC                570                  BNE         CASE_SUB
00001692                           571                                                   
00001692  4BF9 0000249C            572                  LEA         MSG_ADDQ,A5             ; print ADDQ
00001698  4EB9 000021CE            573                  JSR         PRINTNULL
0000169E                           574                  
0000169E                           575                  ; get bits 6-7 (size bits)
0000169E  3200                     576                  MOVE.W      D0,D1
000016A0  E149                     577                  LSL.W       #8,D1
000016A2  E049                     578                  LSR.W       #8,D1
000016A4  EC49                     579                  LSR.W       #6,D1
000016A6  3401                     580                  MOVE.W      D1,D2
000016A8                           581                  
000016A8                           582                  ; Check bits 0-5 
000016A8  4BF9 0000227A            583                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016AE  4DF9 000022B0            584                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016B4  3E3C 0000                585                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016B8  4EB9 00001D9A            586                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000016BE  B27C 0001                587                  CMP.W       #1,D1                    ; checks if invalid
000016C2  6700 067A                588                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000016C6  3802                     589                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000016C8  3A03                     590                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000016CA                           591                  
000016CA  B47C 0001                592                  CMP.W       #1,D2
000016CE  6700 0026                593                  BEQ         ADDQ_WORD
000016D2  B47C 0002                594                  CMP.W       #2,D2
000016D6  6700 003A                595                  BEQ         ADDQ_LONG
000016DA                           596                    
000016DA  4BF9 00002562            597  ADDQ_BYTE       LEA         MSG_B,A5
000016E0  4EB9 000021CE            598                  JSR         PRINTNULL
000016E6  4BF9 00002548            599                  LEA         MSG_4SPACES,A5          ; loads spaces
000016EC  4EB9 000021CE            600                  JSR         PRINTNULL               ; prints out spaces
000016F2  6000 003A                601                  BRA         FINISH_ADDQ  
000016F6                           602   
000016F6  4BF9 00002565            603  ADDQ_WORD       LEA         MSG_W,A5
000016FC  4EB9 000021CE            604                  JSR         PRINTNULL
00001702  4BF9 00002548            605                  LEA         MSG_4SPACES,A5          ; loads spaces
00001708  4EB9 000021CE            606                  JSR         PRINTNULL               ; prints out spaces
0000170E  6000 001E                607                  BRA         FINISH_ADDQ                 
00001712                           608    
00001712  4BF9 00002568            609  ADDQ_LONG       LEA         MSG_L,A5
00001718  4EB9 000021CE            610                  JSR         PRINTNULL
0000171E  4BF9 00002548            611                  LEA         MSG_4SPACES,A5          ; loads spaces
00001724  4EB9 000021CE            612                  JSR         PRINTNULL               ; prints out spaces
0000172A  6000 0002                613                  BRA         FINISH_ADDQ                  
0000172E                           614                    
0000172E  4EB9 0000174C            615  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001734                           616   
00001734                           617                  ; prints a comma to seperate
00001734  4BF9 0000253B            618                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000173A  4EB9 000021CE            619                  JSR         PRINTNULL                ; prints out MOVE
00001740                           620                    
00001740                           621                  ; prints destination
00001740  3404                     622                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001742  3605                     623                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001744  4EB9 00001F08            624                  JSR         EA_TO_STRING             ; outputs it into a string
0000174A                           625                 
0000174A  4E75                     626                  RTS
0000174C                           627   
0000174C  4BF9 00002537            628  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
00001752  4EB9 000021CE            629                  JSR         PRINTNULL
00001758                           630                  ; gets bits 9-11 (data bits)
00001758  E949                     631                  LSL.W       #4,D1
0000175A  E849                     632                  LSR.W       #4,D1                               ; get rid of left 4 bits
0000175C  E049                     633                  LSR.W       #8,D1
0000175E  E249                     634                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001760                           635                  
00001760  B27C 0000                636                  CMP.W       #0,D1
00001764  6700 000A                637                  BEQ         PRINT_8
00001768  4EB9 00002084            638                  JSR         PRINTNUM
0000176E  4E75                     639                  RTS 
00001770                           640  
00001770  123C 0008                641  PRINT_8         MOVE.B      #8,D1
00001774  4EB9 00002084            642                  JSR         PRINTNUM
0000177A  4E75                     643                  RTS   
0000177C                           644         
0000177C                           645  *---------------SUB opcode---------------------- 
0000177C  3200                     646  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000177E  C27C F000                647                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001782  B27C 9000                648                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001786  6600 008C                649                  BNE         CASE_LEA
0000178A                           650                 
0000178A  4EB8 14E6                651                  JSR         ADD_SUB_HELP
0000178E                           652                  
0000178E  6000 0002                653                  BRA         PRINTSUB                            ; Branches to print sub
00001792                           654  
00001792  4BF9 000024A2            655  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
00001798  4EB9 000021CE            656                  JSR         PRINTNULL
0000179E  3200                     657                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017A0  4EB8 1548                658                  JSR         ADD_SUB_SIZE
000017A4  4BF9 0000254D            659                  LEA         MSG_5SPACES,A5                      ; loads spaces
000017AA  4EB9 000021CE            660                  JSR         PRINTNULL                           ; prints out spaces
000017B0  3200                     661                  MOVE.W      D0,D1
000017B2  E149                     662                  LSL.W       #8,D1
000017B4  E049                     663                  LSR.W       #8,D1
000017B6  EC49                     664                  LSR.W       #6,D1
000017B8  B27C 0003                665                  CMP.W       #3,D1
000017BC  6600 0006                666                  BNE         FINISH_SUB
000017C0  6000 0008                667                  BRA         FINISH_SUBA                         ; same as ADDA
000017C4                           668                  
000017C4  4EB8 159E                669  FINISH_SUB      JSR         ADD_SUB_OPERAND
000017C8  4E75                     670                  RTS
000017CA                           671                    
000017CA  3404                     672  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000017CC  3605                     673                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000017CE  4EB9 00001F08            674                  JSR         EA_TO_STRING             ; outputs it into a string
000017D4                           675                
000017D4                           676                  ; prints a comma to seperate
000017D4  4BF9 0000253B            677                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000017DA  4EB9 000021CE            678                  JSR         PRINTNULL                ; prints out MOVE
000017E0                           679                  
000017E0  4BF9 0000252D            680                  LEA         MSG_AR,A5                ; print address register
000017E6  4EB9 000021CE            681                  JSR         PRINTNULL
000017EC  3200                     682                  MOVE.W      D0,D1
000017EE  E949                     683                  LSL.W       #4,D1
000017F0  E849                     684                  LSR.W       #4,D1
000017F2  E049                     685                  LSR.W       #8,D1
000017F4  E249                     686                  LSR.W       #1,D1
000017F6  4EB9 00002084            687                  JSR         PRINTNUM             
000017FC  4E75                     688                  RTS                              ; exits subroutine
000017FE                           689  
000017FE                           690  
000017FE                           691  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
000017FE  3200                     692  CASE_SUBA       MOVE.W      D0,D1
00001800  EF49                     693                  LSL.W       #7,D1
00001802  EE49                     694                  LSR.W       #7,D1
00001804  E049                     695                  LSR.W       #8,D1
00001806  B23C 0000                696                  CMP.B       #0,D1
0000180A  6700 FD6E                697                  BEQ         ADD_SUB_WORD
0000180E  6000 FD78                698                  BRA         ADD_SUB_LONG
00001812  4E75                     699                  RTS         
00001814                           700                   
00001814  3200                     701  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001816  C27C F000                702                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000181A  B27C 4000                703                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000181E  6600 0092                704                  BNE.W   CASE_AND                             ; If its not, check AND
00001822  3200                     705                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001824  C27C 01C0                706                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001828  B27C 01C0                707                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000182C  6600 0084                708                  BNE.W   CASE_AND                             ; If its not, check AND
00001830                           709                  
00001830                           710                  ; Check source
00001830  4BF9 0000229A            711                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001836  4DF9 000022B4            712                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000183C  3E3C 0000                713                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001840  4EB9 00001D9A            714                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001846  3802                     715                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001848  3A03                     716                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000184A                           717                  
0000184A                           718                  ; Check destination
0000184A  4BF9 0000229A            719                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001850  4DF9 000022B4            720                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001856  3E3C 0001                721                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000185A  4EB9 00001D9A            722                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001860  3C02                     723                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001862  3E03                     724                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001864                           725  
00001864  4BF9 000024B3            726                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000186A  4EB9 000021CE            727                  JSR     PRINTNULL                            ; prints LEA
00001870  4BF9 0000255A            728                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001876  4EB9 000021CE            729                  JSR     PRINTNULL                            ; prints out spaces
0000187C                           730                  
0000187C                           731                  ; print source
0000187C  3404                     732                  MOVE.W  D4,D2
0000187E  3605                     733                  MOVE.W  D5,D3
00001880  4EB9 00001F08            734                  JSR     EA_TO_STRING                         ; Prints out the EA
00001886                           735                  
00001886                           736                  ; comma
00001886  4BF9 0000253B            737                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
0000188C  4EB9 000021CE            738                  JSR     PRINTNULL                       
00001892                           739                   
00001892                           740                  ; register
00001892  4BF9 0000252D            741                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
00001898  4EB9 000021CE            742                  JSR     PRINTNULL 
0000189E  3401                     743                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018A0  323C 0001                744                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000018A4  4EB9 00001D70            745                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000018AA  4EB9 00002084            746                  JSR     PRINTNUM                             ; Prints the number in D1
000018B0  4E75                     747                  RTS
000018B2                           748  
000018B2                           749  *---------------AND opcode----------------------
000018B2  3200                     750  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018B4  C27C F000                751                  AND.W       #$F000,D1       
000018B8  B27C C000                752                  CMP.W       #$C000,D1
000018BC  6600 00D6                753                  BNE         CASE_OR
000018C0                           754                  
000018C0  3200                     755                  MOVE.W      D0,D1
000018C2  E149                     756                  LSL.W       #8,D1
000018C4  E049                     757                  LSR.W       #8,D1
000018C6  EC49                     758                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000018C8  3C01                     759                  MOVE.W      D1,D6
000018CA  BC7C 0003                760                  CMP.W       #3,D6
000018CE  6700 0086                761                  BEQ         INV_INSTR
000018D2                           762                  
000018D2  4BF9 000024B8            763                  LEA         MSG_AND,A5                      ; print AND
000018D8  4EB9 000021CE            764                  JSR         PRINTNULL
000018DE                           765                  
000018DE  3206                     766                  MOVE.W      D6,D1
000018E0  B27C 0000                767                  CMP.W       #0,D1
000018E4  6700 0012                768                  BEQ         AND_BYTE
000018E8  B27C 0001                769                  CMP.W       #1,D1                   ; if 1, it is a word
000018EC  6700 0026                770                  BEQ         AND_WORD
000018F0  B27C 0002                771                  CMP.W       #2,D1                   ; if 2, it is a long
000018F4  6700 003A                772                  BEQ         AND_LONG
000018F8                           773                  
000018F8  4BF9 00002562            774  AND_BYTE        LEA         MSG_B,A5
000018FE  4EB9 000021CE            775                  JSR         PRINTNULL
00001904  4BF9 0000255A            776                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000190A  4EB9 000021CE            777                  JSR         PRINTNULL                       ; prints out spaces
00001910  6000 003A                778                  BRA         FINISH_AND
00001914                           779                                    
00001914  4BF9 00002565            780  AND_WORD        LEA         MSG_W,A5
0000191A  4EB9 000021CE            781                  JSR         PRINTNULL
00001920  4BF9 0000255A            782                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001926  4EB9 000021CE            783                  JSR         PRINTNULL                       ; prints out spaces
0000192C  6000 001E                784                  BRA         FINISH_AND
00001930                           785    
00001930  4BF9 00002568            786  AND_LONG        LEA         MSG_L,A5
00001936  4EB9 000021CE            787                  JSR         PRINTNULL
0000193C  4BF9 0000255A            788                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001942  4EB9 000021CE            789                  JSR         PRINTNULL                       ; prints out spaces
00001948  6000 0002                790                  BRA         FINISH_AND
0000194C                           791        
0000194C  4EB8 14E6                792  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001950  4EB8 159E                793                  JSR         ADD_SUB_OPERAND
00001954  4E75                     794                  RTS
00001956                           795                  
00001956  4BF9 000023F5            796  INV_INSTR       LEA         INVALID_INSTR,A5
0000195C  4EB9 000021CE            797                  JSR         PRINTNULL
00001962  4BF9 00002553            798                  LEA         MSG_6SPACES,A5
00001968  4EB9 000021CE            799                  JSR         PRINTNULL
0000196E  4BF9 00002539            800                  LEA         MSG_HEX,A5
00001974  4EB9 000021CE            801                  JSR         PRINTNULL
0000197A  2200                     802                  MOVE.L      D0,D1
0000197C  383C 0000                803                  MOVE.W      #0,D4
00001980  4EB9 000020A8            804                  JSR         PRINTSHORTLONGNUM
00001986  4BF9 0000246A            805                  LEA         NEW_LINE,A5
0000198C  4EB9 000021CE            806                  JSR         PRINTNULL
00001992  4E75                     807                  RTS               
00001994                           808                  
00001994                           809  *---------------OR opcode----------------------            
00001994  3200                     810  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001996  C27C F000                811                  AND.W       #$F000,D1       
0000199A  B27C 8000                812                  CMP.W       #$8000,D1
0000199E  6600 0054                813                  BNE         CASE_NOT
000019A2                           814                                                
000019A2  3200                     815                  MOVE.W      D0,D1
000019A4  E149                     816                  LSL.W       #8,D1
000019A6  E049                     817                  LSR.W       #8,D1
000019A8  EC49                     818                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019AA  B27C 0003                819                  CMP.W       #3,D1
000019AE  3C01                     820                  MOVE.W      D1,D6
000019B0  67A4                     821                  BEQ         INV_INSTR
000019B2                           822                  
000019B2                           823                  
000019B2  4BF9 000024BD            824                  LEA         MSG_OR,A5
000019B8  4EB9 000021CE            825                  JSR         PRINTNULL                       ; print "OR"
000019BE                           826                  
000019BE  3206                     827                  MOVE.W      D6,D1
000019C0  4EB9 000019DC            828                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000019C6  4BF9 00002553            829                  LEA         MSG_6SPACES,A5                  ; loads spaces
000019CC  4EB9 000021CE            830                  JSR         PRINTNULL                       ; prints out spaces
000019D2                           831  
000019D2  4EB8 14E6                832                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
000019D6  4EB8 159E                833                  JSR         ADD_SUB_OPERAND                 ; print 
000019DA  4E75                     834                  RTS
000019DC                           835  
000019DC  B27C 0000                836  OR_SIZE         CMP.W       #0,D1
000019E0  6700 FB8A                837                  BEQ         ADD_SUB_BYTE
000019E4  B27C 0001                838                  CMP.W       #1,D1                   ; if 1, it is a word
000019E8  6700 FB90                839                  BEQ         ADD_SUB_WORD
000019EC  B27C 0002                840                  CMP.W       #2,D1                   ; if 2, it is a long
000019F0  6700 FB96                841                  BEQ         ADD_SUB_LONG
000019F4                           842                  ; no need for rts, since ADD_SUB_ already has                
000019F4                           843  
000019F4                           844  *---------------NOT opcode----------------------
000019F4  3200                     845  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019F6  C27C FF00                846                  AND.W       #$FF00,D1       
000019FA  B27C 4600                847                  CMP.W       #$4600,D1
000019FE  6600 0058                848                  BNE         CASE_LSDASDROD
00001A02                           849                 
00001A02                           850                  ; get bits 6-7 (size)
00001A02  3200                     851                  MOVE.W      D0,D1
00001A04  E149                     852                  LSL.W       #8,D1
00001A06  E049                     853                  LSR.W       #8,D1
00001A08  EC49                     854                  LSR.W       #6,D1 
00001A0A  3C01                     855                  MOVE.W      D1,D6                         
00001A0C  BC7C 0003                856                  CMP.W       #3,D6
00001A10  6700 FF44                857                  BEQ         INV_INSTR
00001A14                           858                                  
00001A14  4BF9 000024C1            859                  LEA         MSG_NOT,A5
00001A1A  4EB9 000021CE            860                  JSR         PRINTNULL                       ; print "NOT"
00001A20                           861                                 
00001A20  3206                     862                  MOVE.W      D6,D1
00001A22                           863  
00001A22  4EB8 19DC                864                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A26  4BF9 0000254D            865                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A2C  4EB9 000021CE            866                  JSR         PRINTNULL                       ; prints out spaces
00001A32                           867                  
00001A32                           868                  ; get bits 0-5 
00001A32  4BF9 0000227A            869                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A38  4DF9 000022B0            870                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A3E  3E3C 0000                871                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A42  4EB9 00001D9A            872                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A48  B27C 0001                873                  CMP.W       #1,D1                    ; checks if invalid
00001A4C  6700 02F0                874                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001A50  4EB9 00001F08            875                  JSR         EA_TO_STRING             ; outputs it into a string
00001A56                           876    
00001A56  4E75                     877                  RTS
00001A58                           878  
00001A58  3200                     879  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001A5A  C27C F000                880                  AND.W       #$F000, D1                       ; gets first 4 bits
00001A5E  B27C E000                881                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001A62  6600 0228                882                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001A66  3400                     883                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A68  4EB9 00001E22            884                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A6E  B47C 0003                885                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001A72  6600 00D4                886                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001A76                           887                  
00001A76  3400                     888  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001A78  4EB9 00001E10            889                  JSR         GETROTATION                      ; gets rotation value of D2
00001A7E  B47C 0000                890                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001A82  6700 0014                891                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001A86  B47C 0003                892                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001A8A  6700 0016                893                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001A8E                           894                  
00001A8E  4BF9 000024C6            895  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001A94  6000 0012                896                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001A98                           897  
00001A98  4BF9 000024CA            898  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001A9E  6000 0008                899                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AA2                           900  
00001AA2  4BF9 000024CE            901  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AA8                           902                  
00001AA8  4EB9 000021CE            903  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001AAE  3400                     904                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AB0  4EB9 00001E1A            905                  JSR         GETDIRECTION                     ; gets direction
00001AB6  B47C 0000                906                  CMP.W       #0,D2                            ; checking if its right
00001ABA  6700 000C                907                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001ABE                           908  
00001ABE  4BF9 00002529            909  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001AC4  6000 0008                910                  BRA         PRINT_MEMDIR                     ; branches for printing
00001AC8                           911          
00001AC8  4BF9 00002527            912  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001ACE                           913  
00001ACE  4EB9 000021CE            914  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001AD4  4BF9 00002565            915                  LEA         MSG_W,A5                         ; loads .W into A5
00001ADA  4EB9 000021CE            916                  JSR         PRINTNULL                        ; Prints .W
00001AE0  4BF9 0000255A            917                  LEA         MSG_7SPACES,A5                   ; loads spaces
00001AE6  4EB9 000021CE            918                  JSR         PRINTNULL                        ; prints out spaces
00001AEC  6000 0002                919                  BRA         GETMEMSOURCE                     ; checks the source 
00001AF0                           920                  
00001AF0                           921  ; get source addressing mode       
00001AF0                           922  GETMEMSOURCE                                                 
00001AF0  323C 0000                923                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001AF4  4EB9 00001D46            924                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001AFA  3801                     925                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001AFC  323C 0000                926                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B00  4EB9 00001D70            927                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B06  3A01                     928                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B08                           929  
00001B08  4BF9 000022A8            930  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B0E  3204                     931                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B10  4EB9 00001ED4            932                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B16  B27C 0002                933                  CMP.W       #2,D1                            ; checks if it is Xn
00001B1A  6700 0016                934                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B1E  B27C 0001                935                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B22  6700 021A                936                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B26                           937  
00001B26  3404                     938  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B28  3605                     939                  MOVE.W      D5,D3                            ; moves EA to D3
00001B2A  4EB9 00001F08            940                  JSR         EA_TO_STRING                     ; prints out the EA
00001B30  4E75                     941                  RTS                
00001B32                           942                  
00001B32                           943                  
00001B32  4BF9 000022B4            944  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B38  3205                     945                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B3A  4EB9 00001ED4            946                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B40  4A41                     947                  TST.W       D1                               ; checks if it is valid
00001B42  67E2                     948                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B44  6000 01F8                949                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B48                           950  
00001B48                           951  
00001B48  3602                     952  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B4A  3200                     953                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B4C  C27C 0018                954                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001B50  E649                     955                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001B52  B27C 0000                956                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B56  6700 0014                957                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001B5A  B27C 0003                958                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B5E  6700 0016                959                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001B62                           960                  
00001B62  4BF9 000024C6            961  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001B68  6000 0012                962                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B6C                           963  
00001B6C  4BF9 000024CA            964  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001B72  6000 0008                965                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B76                           966  
00001B76  4BF9 000024CE            967  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001B7C                           968                  
00001B7C  4EB9 000021CE            969  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001B82  3400                     970                  MOVE.W      D0,D2                            ; copies D0 to D2
00001B84  4EB9 00001E1A            971                  JSR         GETDIRECTION                     ; gets direction
00001B8A  B47C 0000                972                  CMP.W       #0,D2                            ; checking if its right
00001B8E  6700 000C                973                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001B92                           974  
00001B92  4BF9 00002529            975  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001B98  6000 000C                976                  BRA         PRINT_REGDIR                     ; branches for printing
00001B9C                           977          
00001B9C  4BF9 00002527            978  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BA2  6000 0002                979                  BRA         PRINT_REGDIR                     ; branches for printing
00001BA6                           980                  
00001BA6  4EB9 000021CE            981  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BAC                           982  
00001BAC  3400                     983  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BAE  4EB9 00001E22            984                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BB4  B47C 0001                985                  CMP.W       #1,D2                            ; Checks if it is word size
00001BB8  6700 0014                986                  BEQ         REG_WORD                         ; Prints .W
00001BBC  B47C 0002                987                  CMP.W       #2,D2                            ; Checks if it is long size
00001BC0  6700 0016                988                  BEQ         REG_LONG                         ; Prints .L
00001BC4                           989  
00001BC4  4BF9 00002562            990  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001BCA  6000 0012                991                  BRA         PRINTREGEA      
00001BCE                           992  
00001BCE  4BF9 00002565            993  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001BD4  6000 0008                994                  BRA         PRINTREGEA      
00001BD8                           995                             
00001BD8  4BF9 00002568            996  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001BDE                           997  
00001BDE  4EB9 000021CE            998  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001BE4  4BF9 0000254D            999                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001BEA  4EB9 000021CE           1000                  JSR         PRINTNULL                        ; prints out spaces
00001BF0  3400                    1001                  MOVE.W      D0,D2                            ; copies D0 to D1
00001BF2  4EB9 00001E2A           1002                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001BF8  B27C 0001               1003                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001BFC  6700 0048               1004                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001C00                          1005                                  
00001C00  3400                    1006  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C02  4EB9 00001E22           1007                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C08  3202                    1008                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C0A  4BF9 00002537           1009                  LEA         MSG_POUND, A5                    ; loads # into A5
00001C10  4EB9 000021CE           1010                  JSR         PRINTNULL                        ; prints #
00001C16  4EB9 00002084           1011                  JSR         PRINTNUM                         ; prints shift count
00001C1C  4BF9 0000253B           1012                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C22  4EB9 000021CE           1013                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C28  4BF9 0000252B           1014                  LEA         MSG_DR, A5                       ; loads D into A5
00001C2E  4EB9 000021CE           1015                  JSR         PRINTNULL                        ; prints out D 
00001C34  323C 0000               1016                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C38  4EB9 00001D70           1017                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C3E  4EB9 00002084           1018                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C44  4E75                    1019                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C46                          1020                  
00001C46  3400                    1021  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001C48  4EB9 00001E22           1022                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C4E  3202                    1023                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C50  4BF9 0000252B           1024                  LEA         MSG_DR, A5                       ; loads D into A5
00001C56  4EB9 000021CE           1025                  JSR         PRINTNULL                        ; prints D
00001C5C  4EB9 00002084           1026                  JSR         PRINTNUM                         ; prints register number
00001C62  4BF9 0000253B           1027                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C68  4EB9 000021CE           1028                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C6E  4BF9 0000252B           1029                  LEA         MSG_DR, A5                       ; loads D into A5
00001C74  4EB9 000021CE           1030                  JSR         PRINTNULL                        ; prints out D 
00001C7A  323C 0000               1031                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C7E  4EB9 00001D70           1032                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C84  4EB9 00002084           1033                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C8A  4E75                    1034                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C8C                          1035               
00001C8C  3200                    1036  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001C8E  C27C FF00               1037                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001C92  B27C 6000               1038                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001C96  6600 0024               1039                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001C9A                          1040                  
00001C9A  4BF9 00002522           1041                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001CA0  4EB9 000021CE           1042                  JSR     PRINTNULL                            ; prints BRA
00001CA6  4BF9 0000255A           1043                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001CAC  4EB9 000021CE           1044                  JSR     PRINTNULL                            ; prints out spaces
00001CB2                          1045  
00001CB2  3400                    1046                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001CB4  4EB9 00001DE2           1047                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001CBA  4E75                    1048                  RTS
00001CBC                          1049                  
00001CBC                          1050  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001CBC                          1051  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001CBC  3200                    1052  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CBE  C27C F000               1053                  AND.W   #$F000,D1                            ; get top 4 bits
00001CC2  B27C 6000               1054                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001CC6  6600 0060               1055                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001CCA  3200                    1056                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CCC  C27C 0F00               1057                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001CD0  E049                    1058                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001CD2                          1059                  
00001CD2  B27C 000E               1060                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001CD6  6700 002A               1061                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001CDA                          1062                  
00001CDA  B27C 000F               1063                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001CDE  6700 0018               1064                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001CE2                          1065                      
00001CE2  B27C 0007               1066                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001CE6  6700 0006               1067                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001CEA  6000 0052               1068                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001CEE                          1069     
00001CEE  4BF9 000024DC           1070  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001CF4  6000 0016               1071                  BRA     PRINTBCC
00001CF8                          1072  
00001CF8  4BF9 000024F5           1073  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001CFE  6000 000C               1074                  BRA     PRINTBCC
00001D02                          1075                  
00001D02  4BF9 000024EB           1076  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D08  6000 0002               1077                  BRA     PRINTBCC
00001D0C                          1078  
00001D0C  4EB9 000021CE           1079  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D12  4BF9 0000255A           1080                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D18  4EB9 000021CE           1081                  JSR     PRINTNULL                            ; prints out spaces
00001D1E  3400                    1082                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D20  4EB9 00001DE2           1083                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D26  4E75                    1084                  RTS              
00001D28                          1085                  
00001D28                          1086  
00001D28                          1087  CASE_JSR       
00001D28                          1088  
00001D28  B07C 4E75               1089  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001D2C  6600 0010               1090                  BNE     CASE_DATA           ; checks the next case if not equal
00001D30  4BF9 0000251D           1091                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001D36  4EB9 000021CE           1092                  JSR     PRINTNULL           ; prints RTS                
00001D3C  4E75                    1093                  RTS                         ; returns from the subroutine
00001D3E                          1094  
00001D3E                          1095                  
00001D3E                          1096  
00001D3E  4EB8 1956               1097  CASE_DATA           JSR INV_INSTR  
00001D42  4E75                    1098                      RTS               
00001D44                          1099  
00001D44  4E75                    1100  CASE_EPICFAIL       RTS
00001D46                          1101  
00001D46                          1102  
00001D46                          1103  * Finds the EA type
00001D46                          1104  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001D46                          1105  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D46  48E7 3000               1106  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D4A  4A41                    1107                      TST.W     D1                    ; compares D1 to 0
00001D4C  6700 000E               1108                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001D50                          1109                      
00001D50  343C 01C0               1110  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001D54  363C 0006               1111                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001D58  6000 000A               1112                      BRA       FINDTYPEEA            
00001D5C                          1113  
00001D5C  343C 0038               1114  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001D60  363C 0003               1115                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001D64                          1116  
00001D64                          1117  
00001D64  3200                    1118  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001D66  C242                    1119                      AND.W     D2,D1                 ; applies bitmask to D1
00001D68  E669                    1120                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001D6A  4CDF 000C               1121                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001D6E  4E75                    1122                      RTS                             ; returns from subroutine    
00001D70                          1123                      
00001D70                          1124  * Finds Xn type
00001D70                          1125  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001D70                          1126  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D70  48E7 3000               1127  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D74  4A41                    1128                      TST.W     D1                    ; compares D1 to 0
00001D76  6700 000E               1129                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001D7A                          1130  
00001D7A  343C 0E00               1131  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001D7E  363C 0009               1132                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001D82  6000 000A               1133                      BRA       FINDTYPEXN            ; finds the type of Xn
00001D86                          1134  
00001D86  343C 0007               1135  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001D8A  363C 0000               1136                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001D8E                          1137                      
00001D8E  3200                    1138  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001D90  C242                    1139                      AND.W     D2,D1                 ; applies bitmask to D1
00001D92  E669                    1140                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001D94  4CDF 000C               1141                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001D98  4E75                    1142                      RTS                             ; returns from subroutine 
00001D9A                          1143                      
00001D9A                          1144  * Checks and gets the EA and Xn
00001D9A                          1145  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001D9A                          1146  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001D9A  3207                    1147  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001D9C  4EB8 1D46               1148                  JSR     GET_EA                  ; Gets EA
00001DA0  3401                    1149                  MOVE.W  D1,D2                   ; Stores EA in D2
00001DA2  3207                    1150                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001DA4  4EB8 1D70               1151                  JSR     GET_XN                  ; Gets Xn
00001DA8  3601                    1152                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001DAA  3202                    1153                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001DAC                          1154                  
00001DAC  4EB9 00001ED4           1155                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001DB2  B27C 0002               1156                  CMP.W   #2,D1                   ; checks if it is Xn
00001DB6  6700 0012               1157                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001DBA  B27C 0001               1158                  CMP.W   #1,D1                   ; Checks if it is invalid
00001DBE  6700 001C               1159                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001DC2                          1160                  
00001DC2                          1161                  
00001DC2  323C 0000               1162  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001DC6  6000 0018               1163                  BRA     END_CHECKGET
00001DCA                          1164        
00001DCA                          1165  ; need XN
00001DCA  2A4E                    1166  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001DCC  3203                    1167                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001DCE  4EB9 00001ED4           1168                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001DD4  4A41                    1169                  TST.W   D1                      ; checks if it is valid
00001DD6  67EA                    1170                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001DD8  6000 0002               1171                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001DDC                          1172   
00001DDC  323C 0001               1173  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001DE0                          1174  
00001DE0  4E75                    1175  END_CHECKGET    RTS          
00001DE2                          1176                                            
00001DE2                          1177                                            
00001DE2                          1178  * Gets the displacement and pritns it 
00001DE2                          1179  * Inputs: D2 = instruction word, A2 = address of next word
00001DE2                          1180  * Outputs: prints out displacement
00001DE2  48E7 4004               1181  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001DE6  3A4A                    1182                      MOVE.W    A2,A5                 ; copies A2 to A5
00001DE8  C47C 00FF               1183                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001DEC  6600 0004               1184                      BNE       PRINTADDRESS          ; prints address if not 0
00001DF0  341A                    1185                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001DF2                          1186                      
00001DF2  D44D                    1187  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001DF4  3202                    1188                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001DF6  183C 0000               1189                      MOVE.B    #0,D4                 ; marks address as word  length
00001DFA  4BF9 00002539           1190                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001E00  4EB9 000021CE           1191                      JSR       PRINTNULL             ; prints null
00001E06  4EB9 000020A8           1192                      JSR       PRINTSHORTLONGNUM     ; prints address
00001E0C                          1193                      
00001E0C  4CDF 2002               1194                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001E10                          1195                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001E10                          1196  
00001E10                          1197  * Gets the rotation value for ASd and LSd
00001E10                          1198  * Input: D2 = instruction word copy (of D0)                                    
00001E10                          1199  * Output: rotation  value in D2             
00001E10  C47C 0E00               1200  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001E14  E04A                    1201                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E16  E24A                    1202                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001E18  4E75                    1203                      RTS                             ; return from subroutine
00001E1A                          1204  
00001E1A                          1205  * Gets the direction value for ASd and LSd
00001E1A                          1206  * Input: D2 = instruction word copy (of D0)                                    
00001E1A                          1207  * Output: direction value in D2             
00001E1A  C47C 0100               1208  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001E1E  E04A                    1209                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E20  4E75                    1210                      RTS                             ; return from subroutine
00001E22                          1211  
00001E22                          1212  * Gets the rotation size value for ASd and LSd
00001E22                          1213  * Input: D2 = instruction word copy (of D0)                                    
00001E22                          1214  * Output: rotation size value in D2             
00001E22  C47C 00C0               1215  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001E26  EC4A                    1216                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E28  4E75                    1217                      RTS                             ; return from subroutine
00001E2A                          1218  
00001E2A                          1219  * Gets the rotation location  value for ASd and LSd
00001E2A                          1220  * Input: D2 = instruction word copy (of D0)                                    
00001E2A                          1221  * Output: rotation location value in D2             
00001E2A  C47C 0020               1222  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001E2E  EA4A                    1223                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E30  4E75                    1224                      RTS                             ; return from subroutine
00001E32                          1225  
00001E32                          1226  * Prints out registers for MOVEM
00001E32                          1227  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001E32                          1228  * Output: printed out registers
00001E32                          1229  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001E32  48E7 0706               1230  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001E36  3A3C 0000               1231                      MOVE.W     #0,D5                ; sets counter to 0
00001E3A  3E1A                    1232                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001E3C  B83C 0001               1233                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E40  6600 0010               1234                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001E44                          1235  
00001E44  3C3C 0000               1236  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001E48  4BF9 0000252B           1237                      LEA        MSG_DR,A5            ; loads D to A5
00001E4E  6000 000C               1238                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001E52                          1239                      
00001E52  3C3C 0007               1240  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001E56  4BF9 0000252D           1241                      LEA        MSG_AR,A5            ; loads A to A5
00001E5C                          1242                      
00001E5C  E34F                    1243  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001E5E  6500 0018               1244                      BCS        PRINTREG             ; if pushes out a 1
00001E62  DC44                    1245                      ADD.W      D4,D6                ; decrements or increments
00001E64  5245                    1246                      ADD.W      #1,D5                ; increments D5
00001E66  BA7C 0008               1247                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001E6A  66F0                    1248                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001E6C  B83C 0001               1249                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E70  6600 0052               1250                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001E74  6000 0042               1251                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001E78                          1252                      
00001E78  4EB9 000021CE           1253  PRINTREG            JSR        PRINTNULL
00001E7E  3206                    1254                      MOVE.W     D6,D1
00001E80  4EB9 00002084           1255                      JSR        PRINTNUM 
00001E86                          1256    
00001E86  BE7C 0000               1257  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001E8A  6600 0006               1258                      BNE        PRINTMORE            ; continue if there is more
00001E8E  6000 0040               1259                      BRA        DONEPRINTINGREG      ; exit case
00001E92                          1260  
00001E92  2C4D                    1261  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001E94  4BF9 0000253E           1262                      LEA        MSG_SLASH,A5         ; leads / into A5
00001E9A  4EB9 000021CE           1263                      JSR        PRINTNULL            ; prints the slash
00001EA0  2A4E                    1264                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001EA2  DC44                    1265                      ADD.W      D4,D6                ; decrements or increments
00001EA4  5245                    1266                      ADD.W      #1,D5                ; increments D5
00001EA6  BA7C 0008               1267                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001EAA  66B0                    1268                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001EAC  B83C 0001               1269                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EB0  6600 0012               1270                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001EB4  6000 0002               1271                      BRA        REGTOMEM2            ; loops
00001EB8                          1272  
00001EB8  3C3C 0000               1273  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001EBC  4BF9 0000252D           1274                      LEA        MSG_AR,A5            ; loads A to A5
00001EC2  6098                    1275                      BRA        PRINTREGISTERLOOP    ; loops
00001EC4                          1276  
00001EC4  3C3C 0007               1277  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001EC8  4BF9 0000252B           1278                      LEA        MSG_DR,A5            ; loads D to A5
00001ECE  608C                    1279                      BRA        PRINTREGISTERLOOP    ; loops
00001ED0                          1280  
00001ED0  4CDF 60E0               1281  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001ED4                          1282  
00001ED4                          1283                          
00001ED4                          1284  * Checks if EA or Xn is valid
00001ED4                          1285  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001ED4                          1286  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001ED4  2F02                    1287  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001ED6                          1288  
00001ED6  141D                    1289  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001ED8  B43C 00FF               1290                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001EDC  6700 000A               1291                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001EE0  B202                    1292                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001EE2  6700 000C               1293                     BEQ        VALIDEA               ; branches to valid EA
00001EE6  60EE                    1294                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001EE8                          1295                     
00001EE8  323C 0001               1296  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001EEC  6000 0016               1297                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001EF0                          1298                    
00001EF0  B43C 0007               1299  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001EF4  6700 000A               1300                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001EF8  323C 0000               1301                     MOVE.W     #$0,D1                ; marks that it is valid
00001EFC  6000 0006               1302                     BRA        CHECKEAEXIT           ; exits the subroutine
00001F00                          1303  
00001F00  323C 0002               1304  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001F04                          1305  
00001F04  241F                    1306  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001F06  4E75                    1307                     RTS                              ; returns from subroutine
00001F08                          1308  
00001F08                          1309  * Converts EA and Xn into a string                                
00001F08                          1310  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001F08                          1311  * Outputs: Prints out EA and Xn into a string
00001F08  48E7 C004               1312  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001F0C  B47C 0001               1313                     CMP.W    #An,D2                  ; checks if it is An
00001F10  6700 003A               1314                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001F14                          1315                     
00001F14  B47C 0002               1316                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001F18  6700 004A               1317                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001F1C                          1318                     
00001F1C  B47C 0003               1319                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001F20  6700 0072               1320                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001F24                          1321                     
00001F24  B47C 0004               1322                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001F28  6700 00A6               1323                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001F2C                          1324                     
00001F2C  B47C 0007               1325                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001F30  6700 00DA               1326                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001F34                          1327                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001F34                          1328  
00001F34                          1329  * data register, Dn
00001F34  4BF9 0000252B           1330  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001F3A  4EB9 000021CE           1331                     JSR      PRINTNULL               ; Prints D
00001F40  3203                    1332                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F42  4EB9 00002084           1333                     JSR      PRINTNUM                ; Prints the Xn
00001F48  6000 0134               1334                     BRA      EA_TO_STRING_EXIT       ; exits           
00001F4C                          1335  
00001F4C                          1336  
00001F4C                          1337  * address register
00001F4C  4BF9 0000252D           1338  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001F52  4EB9 000021CE           1339                     JSR      PRINTNULL               ; Prints A
00001F58  3203                    1340                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F5A  4EB9 00002084           1341                     JSR      PRINTNUM                ; Prints the Xn
00001F60  6000 011C               1342                     BRA      EA_TO_STRING_EXIT       ; exits
00001F64                          1343  
00001F64                          1344  * address register indirect
00001F64  4BF9 0000252F           1345  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001F6A  4EB9 000021CE           1346                     JSR      PRINTNULL               ; Prints (
00001F70  4BF9 0000252D           1347                     LEA      MSG_AR,A5               ; Loads A into A5
00001F76  4EB9 000021CE           1348                     JSR      PRINTNULL               ; Prints A
00001F7C  3203                    1349                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F7E  4EB9 00002084           1350                     JSR      PRINTNUM                ; Prints the Xn
00001F84  4BF9 00002531           1351                     LEA      MSG_RB,A5               ; Loads ) into A5
00001F8A  4EB9 000021CE           1352                     JSR      PRINTNULL               ; Prints )
00001F90  6000 00EC               1353                     BRA      EA_TO_STRING_EXIT       ; exits
00001F94                          1354  
00001F94                          1355  * address register indirect post increment
00001F94  4BF9 0000252F           1356  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001F9A  4EB9 000021CE           1357                     JSR      PRINTNULL               ; Prints (
00001FA0  4BF9 0000252D           1358                     LEA      MSG_AR,A5               ; Loads A into A5
00001FA6  4EB9 000021CE           1359                     JSR      PRINTNULL               ; Prints A
00001FAC  3203                    1360                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FAE  4EB9 00002084           1361                     JSR      PRINTNUM                ; Prints the Xn
00001FB4  4BF9 00002531           1362                     LEA      MSG_RB,A5               ; Loads ) into A5
00001FBA  4EB9 000021CE           1363                     JSR      PRINTNULL               ; Prints )
00001FC0  4BF9 00002533           1364                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001FC6  4EB9 000021CE           1365                     JSR      PRINTNULL               ; Prints +
00001FCC  6000 00B0               1366                     BRA      EA_TO_STRING_EXIT       ; exits
00001FD0                          1367  
00001FD0                          1368  
00001FD0                          1369  * address register indirect pre increment
00001FD0  4BF9 00002535           1370  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001FD6  4EB9 000021CE           1371                     JSR      PRINTNULL               ; Prints -
00001FDC  4BF9 0000252F           1372                     LEA      MSG_LB,A5               ; Loads ( into A5
00001FE2  4EB9 000021CE           1373                     JSR      PRINTNULL               ; Prints (
00001FE8  4BF9 0000252D           1374                     LEA      MSG_AR,A5               ; Loads A into A5
00001FEE  4EB9 000021CE           1375                     JSR      PRINTNULL               ; Prints A
00001FF4  3203                    1376                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FF6  4EB9 00002084           1377                     JSR      PRINTNUM                ; Prints the Xn
00001FFC  4BF9 00002531           1378                     LEA      MSG_RB,A5               ; Loads ) into A5
00002002  4EB9 000021CE           1379                     JSR      PRINTNULL               ; Prints )
00002008  6000 0074               1380                     BRA      EA_TO_STRING_EXIT       ; exits
0000200C                          1381  
0000200C                          1382  * other (long, short, immediate) with Xn yes
0000200C  301A                    1383  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
0000200E  B67C 0000               1384                     CMP.W    #ABSShort,D3            ; checks if it is a word
00002012  6700 002E               1385                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00002016                          1386                     
00002016  B67C 0001               1387                     CMP.W    #ABSLong,D3             ; checks if it is (An)
0000201A  6700 0042               1388                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
0000201E                          1389  
0000201E                          1390  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
0000201E                          1391  * immediate
0000201E  4BF9 00002537           1392  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00002024  4EB9 000021CE           1393                     JSR      PRINTNULL               ; Prints #  
0000202A  4BF9 00002539           1394                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002030  4EB9 000021CE           1395                     JSR      PRINTNULL               ; Prints $
00002036  3200                    1396                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002038  4EB9 00002094           1397                     JSR      PRINTHEXNUM 
0000203E  6000 003E               1398                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00002042                          1399                     
00002042                          1400  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00002042                          1401  
00002042                          1402  * word address
00002042                          1403  CASE_WORD          
00002042  4BF9 00002539           1404                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002048  4EB9 000021CE           1405                     JSR      PRINTNULL               ; Prints $
0000204E  3200                    1406                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002050  383C 0000               1407                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00002054  4EB9 000020A8           1408                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000205A  6000 0022               1409                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000205E                          1410  
0000205E                          1411  * long address 
0000205E                          1412  CASE_LONG          
0000205E  4BF9 00002539           1413                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002064  4EB9 000021CE           1414                     JSR      PRINTNULL               ; Prints $
0000206A  3200                    1415                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000206C  383C 0001               1416                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00002070  4EB9 000020A8           1417                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002076  321A                    1418                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002078  4EB9 00002084           1419                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
0000207E                          1420  
0000207E                          1421  
0000207E                          1422  * exits subroutine
0000207E  4CDF 2003               1423  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00002082  4E75                    1424                      RTS                              ; returns from subroutine
00002084                          1425  
00002084                          1426  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00002084                          1427  
00002084                          1428  * Prints out the content of D1 as a decimal number
00002084                          1429  * Input: number in D1 to be printed
00002084                          1430  * Output: contents of D1 printed
00002084  48E7 C000               1431  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00002088  103C 0003               1432                   MOVE.B      #3,D0               ; prints D1
0000208C  4E4F                    1433                   TRAP        #15                 ; is trap task 3
0000208E                          1434              
0000208E  4CDF 0003               1435                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00002092  4E75                    1436                   RTS                             ; returns from subroutine
00002094                          1437                   
00002094                          1438  * Prints out the content of D1 as a hex number
00002094                          1439  * Input: number in D1 to be printed
00002094                          1440  * Output: contents of D1 printed
00002094  48E7 C000               1441  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00002098  143C 0010               1442                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
0000209C  103C 000F               1443                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000020A0  4E4F                    1444                   TRAP        #15                 ; is trap task 15
000020A2  4CDF 0003               1445                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000020A6  4E75                    1446                   RTS                             ; returns from subroutine
000020A8                          1447                   
000020A8                          1448  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
000020A8                          1449  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
000020A8                          1450  * Output: contents of D1 printed
000020A8  48E7 E000               1451  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
000020AC  B83C 0001               1452                            CMP.B       #1,D4               ; checks size of number
000020B0  6700 0042               1453                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
000020B4                          1454  
000020B4  3401                    1455  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
000020B6  C47C F000               1456                            AND.W       #$F000,D2           ; gets the first digit
000020BA  B47C 0000               1457                            CMP.W       #0, D2              ; checks if it is 0
000020BE  6600 00DC               1458                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020C2  4EB9 000021AC           1459                            JSR         PRINTZERO           ; prints a zero
000020C8                          1460                            
000020C8  3401                    1461                            MOVE.W      D1,D2               ; copies number to D2
000020CA  C47C 0F00               1462                            AND.W       #$0F00,D2           ; gets the second digit
000020CE  B47C 0000               1463                            CMP.W       #0, D2              ; checks if it is 0
000020D2  6600 00C8               1464                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020D6  4EB9 000021AC           1465                            JSR         PRINTZERO           ; prints a zero
000020DC                          1466                            
000020DC  3401                    1467                            MOVE.W      D1,D2               ; copies number to D2
000020DE  C47C 00F0               1468                            AND.W       #$00F0,D2           ; gets the third digit
000020E2  B47C 0000               1469                            CMP.W       #0, D2              ; checks if it is 0
000020E6  6600 00B4               1470                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020EA  4EB9 000021AC           1471                            JSR         PRINTZERO           ; prints a zero
000020F0  6000 00AA               1472                            BRA         PRINTASHEX          ; prints last digit
000020F4                          1473                            
000020F4  2401                    1474  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
000020F6  C4BC F0000000           1475                            AND.L       #$F0000000,D2       ; gets the first digit
000020FC  B4BC 00000000           1476                            CMP.L       #0, D2              ; checks if it is 0
00002102  6600 0098               1477                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002106  4EB9 000021AC           1478                            JSR         PRINTZERO           ; prints a zero
0000210C                          1479                            
0000210C  2401                    1480                            MOVE.L      D1,D2               ; copies number to D2
0000210E  C4BC 0F000000           1481                            AND.L       #$0F000000,D2       ; gets the second digit
00002114  B4BC 00000000           1482                            CMP.L       #0, D2              ; checks if it is 0
0000211A  6600 0080               1483                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000211E  4EB9 000021AC           1484                            JSR         PRINTZERO           ; prints a zero
00002124                          1485                            
00002124  2401                    1486                            MOVE.L      D1,D2               ; copies number to D2
00002126  C4BC 00F00000           1487                            AND.L       #$00F00000,D2       ; gets the third digit
0000212C  B4BC 00000000           1488                            CMP.L       #0, D2              ; checks if it is 0
00002132  6600 0068               1489                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002136  4EB9 000021AC           1490                            JSR         PRINTZERO           ; prints a zero
0000213C                          1491                            
0000213C  2401                    1492                            MOVE.L      D1,D2               ; copies number to D2
0000213E  C4BC 000F0000           1493                            AND.L       #$000F0000,D2       ; gets the fourth digit
00002144  B4BC 00000000           1494                            CMP.L       #0, D2              ; checks if it is 0
0000214A  6600 0050               1495                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000214E  4EB9 000021AC           1496                            JSR         PRINTZERO           ; prints a zero
00002154                          1497                            
00002154  2401                    1498                            MOVE.L      D1,D2               ; copies number to D2
00002156  C4BC 0000F000           1499                            AND.L       #$0000F000,D2       ; gets the fith digit
0000215C  B4BC 00000000           1500                            CMP.L       #0, D2              ; checks if it is 0
00002162  6600 0038               1501                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002166  4EB9 000021AC           1502                            JSR         PRINTZERO           ; prints a zero
0000216C                          1503                            
0000216C  2401                    1504                            MOVE.L      D1,D2               ; copies number to D2
0000216E  C4BC 00000F00           1505                            AND.L       #$00000F00,D2       ; gets the sixth digit
00002174  B4BC 00000000           1506                            CMP.L       #0, D2              ; checks if it is 0
0000217A  6600 0020               1507                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000217E  4EB9 000021AC           1508                            JSR         PRINTZERO           ; prints a zero
00002184                          1509                            
00002184  2401                    1510                            MOVE.L      D1,D2               ; copies number to D2
00002186  C4BC 000000F0           1511                            AND.L       #$000000F0,D2       ; gets the seventh digit
0000218C  B4BC 00000000           1512                            CMP.L       #0, D2              ; checks if it is 0
00002192  6600 0008               1513                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002196  4EB9 000021AC           1514                            JSR         PRINTZERO           ; prints a zero
0000219C                          1515  
0000219C  143C 0010               1516  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000021A0  103C 000F               1517                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000021A4  4E4F                    1518                            TRAP        #15                 ; is trap task 15
000021A6  4CDF 0007               1519                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
000021AA  4E75                    1520                            RTS                             ; returns from subroutine    
000021AC                          1521  * Prints a zero
000021AC                          1522  * Input: nothing
000021AC                          1523  * Output: 0 printed out to the console
000021AC  2F01                    1524  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
000021AE  7200                    1525                            MOVE.L      #0,D1               ; moves 0 to D1
000021B0  4EB8 2084               1526                            JSR         PRINTNUM            ; prints the number
000021B4  221F                    1527                            MOVE.L      (SP)+,D1            ; restores D1
000021B6  4E75                    1528                            RTS                             ; returns from subroutine
000021B8                          1529              
000021B8                          1530  * Prints contents of things between a range
000021B8                          1531  * input: A5, A6 (the range)
000021B8                          1532  * output: prints memory contents from A5 to A6 as strings   
000021B8  48E7 C040               1533  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
000021BC  224D                    1534                  MOVEA.L     A5, A1           ; loads A5 into A1
000021BE  9DCD                    1535                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
000021C0  320E                    1536                  MOVE.W      A6, D1           ; move n into D1
000021C2  103C 0001               1537                  MOVE.B      #1, D0           ; display n characters of string at A1
000021C6  4E4F                    1538                  TRAP        #15              ; is trap task 1
000021C8  4CDF 0203               1539                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
000021CC  4E75                    1540                  RTS                          ; returns
000021CE                          1541      
000021CE                          1542  * Prints null terminated string
000021CE                          1543  * input: string pointed to by A5
000021CE                          1544  * output: prints out the null terminated string
000021CE  48E7 8040               1545  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
000021D2  224D                    1546                  MOVE.L      A5,A1           ; loads A5 into A1
000021D4  103C 000E               1547                  MOVE.B      #14,D0          ; prints null terminated string
000021D8  4E4F                    1548                  TRAP        #15             ; is trap task 10
000021DA  4CDF 0201               1549                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
000021DE  4E75                    1550                  RTS                         ; returns from subroutine
000021E0                          1551                  
000021E0  2F0D                    1552  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
000021E2  4BF9 0000246A           1553                  LEA         NEW_LINE,A5     ; Prints null
000021E8  4EB8 21CE               1554                  JSR         PRINTNULL       ; prints the new line
000021EC  2A5F                    1555                  MOVE.L      (SP)+,A5        ; returns A5
000021EE  4E75                    1556                  RTS
000021F0                          1557  
000021F0                          1558  * Prints the size of the MOVE or MOVEA operation  
000021F0                          1559  * input: D0
000021F0                          1560  * output: prints out the size of a MOVE or MOVEA operation        
000021F0  48E7 8004               1561  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
000021F4  3200                    1562                  MOVE.W  D0,D1               ; stores d0 in d1
000021F6  C07C 3000               1563                  AND.W   #$3000,D0           ; gets the size
000021FA  B07C 2000               1564                  CMP.W   #$2000,D0           ; checks if is long
000021FE  6700 001E               1565                  BEQ     MOVE_LONG
00002202  B07C 3000               1566                  CMP.W   #$3000,D0           ; checks if is word
00002206  6700 000C               1567                  BEQ     MOVE_WORD      
0000220A                          1568                  
0000220A  4BF9 00002562           1569  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00002210  6000 0012               1570                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002214                          1571  
00002214  4BF9 00002565           1572  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
0000221A  6000 0008               1573                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000221E                          1574  
0000221E  4BF9 00002568           1575  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00002224                          1576                  
00002224  4EB8 21CE               1577  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00002228  4CDF 2001               1578                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
0000222C  4E75                    1579                  RTS
0000222E                          1580  
0000222E  43F9 000023D9           1581  ERROR           LEA     ERROR_MSG,A1
00002234  103C 000E               1582                  MOVE.B  #14,D0
00002238  4E4F                    1583                  TRAP    #15 
0000223A                          1584         
0000223A                          1585  * DELETE THIS: Test                
0000223A  2661                    1586  DELETEME        MOVEA.L  -(A1),A3
0000223C  6700 0038               1587                  BEQ      DELETEMEAGAIN  
00002240  6F00 0034               1588                  BLE      DELETEMEAGAIN
00002244  6E00 0030               1589                  BGT      DELETEMEAGAIN
00002248                          1590  
00002248  E40A                    1591                  LSR.B      #2,D2
0000224A  E2E2                    1592                  LSR.W      -(A2)
0000224C  E2DA                    1593                  LSR.W      (A2)+
0000224E  E4AA                    1594                  LSR.L      D2,D2 
00002250  E50A                    1595                  LSL.B      #2,D2
00002252  E3E2                    1596                  LSL.W      -(A2)
00002254  E3DA                    1597                  LSL.W      (A2)+
00002256  E5AA                    1598                  LSL.L      D2,D2
00002258  E51A                    1599                  ROL.B      #2,D2
0000225A  E7E2                    1600                  ROL.W      -(A2)
0000225C  E7DA                    1601                  ROL.W      (A2)+
0000225E  E5BA                    1602                  ROL.L      D2,D2
00002260  E41A                    1603                  ROR.B      #2,D2
00002262  E6E2                    1604                  ROR.W      -(A2)
00002264  E6DA                    1605                  ROR.W      (A2)+
00002266  E4BA                    1606                  ROR.L      D2,D2
00002268                          1607                  
00002268  504D                    1608                  ADDQ.W      #8,A5
0000226A  D6C2                    1609                  ADDA.W      D2,A3
0000226C  9BCB                    1610                  SUB.L       A3,A5        
0000226E  8A43                    1611                  OR.W        D3,D5
00002270  4642                    1612                  NOT.W       D2
00002272                          1613                  
00002272  C5FC 0010               1614                  MULS.W    #$0010,D2
00002276                          1615                  
00002276                          1616  DELETEMEAGAIN                 
00002276                          1617            
00002276  FFFF FFFF               1618      SIMHALT             ; halt simulator
0000227A                          1619  
0000227A                          1620  * Put variables and constants here
0000227A                          1621  
0000227A  =0000000D               1622  CR                              EQU     $0D
0000227A  =0000000A               1623  LF                              EQU     $0A 
0000227A  =00000009               1624  TAB                             EQU     $09  
0000227A                          1625  
0000227A                          1626  * Addressing Modes
0000227A  =00000000               1627  Dn                              EQU     0
0000227A  =00000001               1628  An                              EQU     1
0000227A  =00000002               1629  AnIndirect                      EQU     2
0000227A  =00000003               1630  AnPost                          EQU     3
0000227A  =00000004               1631  AnPre                           EQU     4
0000227A  =00000007               1632  Other                           EQU     7           ; short, long, immediate
0000227A                          1633  
0000227A                          1634  * Xn
0000227A  =00000000               1635  ABSShort                        EQU     0
0000227A  =00000001               1636  ABSLong                         EQU     1
0000227A  =00000004               1637  XnImmediate                     EQU     4
0000227A                          1638  
0000227A                          1639  * Valid Addressing Modes
0000227A= 00 01 02 03 04 07 FF    1640  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00002281                          1641  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00002281= 00 02 03 04 07 FF       1642  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002287= 02 04 07 FF             1643  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
0000228B= 02 03 07 FF             1644  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000228F= 02 03 04 07 FF          1645  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002294= 00 02 03 04 07 FF       1646  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000229A= 01 07 FF                1647  VALIDEA_LEA                     DC.B    An,Other,-1
0000229D= 00 02 03 04 07 FF       1648  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022A3= 02 03 04 07 FF          1649  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022A8= 02 03 04 07 FF          1650  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
000022AD= 02 07 FF                1651  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
000022B0                          1652  
000022B0                          1653  * Valid Xn
000022B0= 00 01 04 FF             1654  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
000022B4                          1655  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
000022B4= 00 01 FF                1656  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
000022B7                          1657  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
000022B7                          1658  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
000022B7                          1659  
000022B7                          1660  * posible memory ASd/LSd rotation values
000022B7  =00000000               1661  ASd_MEM                         EQU     0   
000022B7  =00000001               1662  LSd_MEM                         EQU     1 
000022B7  =00000003               1663  ROd_MEM                         EQU     3
000022B7                          1664   
000022B7  =00000000               1665  ASd_REG                         EQU     0   
000022B7  =00000001               1666  LSd_REG                         EQU     1 
000022B7  =00000003               1667  ROd_REG                         EQU     3
000022B7                          1668  
000022B7                          1669  * Messages
000022B7= 57 65 6C 63 6F 6D ...   1670  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
000022DF= 46 6F 72 6D 61 74 ...   1671  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
0000232A= 4C 65 74 74 65 72 ...   1672  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
0000234A= 50 6C 65 61 73 65 ...   1673  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002381= 50 6C 65 61 73 65 ...   1674  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
000023B7= 49 6E 76 61 6C 69 ...   1675  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
000023D9= 45 72 72 6F 72 20 ...   1676  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
000023F5= 09 44 41 54 41 00       1677  INVALID_INSTR                   DC.B    TAB,'DATA',0
000023FB= 46 69 6E 69 73 68 ...   1678  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
0000243F= 0D 0A 50 72 65 73 ...   1679  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
0000246A= 0D 0A 00                1680  NEW_LINE                        DC.B    CR,LF,0
0000246D= 09 09 09 00             1681  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00002471                          1682  
00002471                          1683  * Opcode Messages
00002471= 09 4E 4F 50 00          1684  MSG_NOP                         DC.B    TAB,'NOP',0
00002476= 09 4D 4F 56 45 00       1685  MSG_MOVE                        DC.B    TAB,'MOVE',0  
0000247C= 09 4D 4F 56 45 41 00    1686  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00002483= 09 4D 4F 56 45 51 00    1687  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
0000248A= 09 4D 4F 56 45 4D 00    1688  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00002491= 09 41 44 44 00          1689  MSG_ADD                         DC.B    TAB,'ADD',0
00002496= 09 41 44 44 41 00       1690  MSG_ADDA                        DC.B    TAB,'ADDA',0
0000249C= 09 41 44 44 51 00       1691  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
000024A2= 09 53 55 42 00          1692  MSG_SUB                         DC.B    TAB,'SUB',0
000024A7= 09 4D 55 4C 53 00       1693  MSG_MULS                        DC.B    TAB,'MULS',0
000024AD= 09 44 49 56 55 00       1694  MSG_DIVU                        DC.B    TAB,'DIVU',0
000024B3= 09 4C 45 41 00          1695  MSG_LEA                         DC.B    TAB,'LEA',0
000024B8= 09 41 4E 44 00          1696  MSG_AND                         DC.B    TAB,'AND',0
000024BD= 09 4F 52 00             1697  MSG_OR                          DC.B    TAB,'OR',0
000024C1= 09 4E 4F 54 00          1698  MSG_NOT                         DC.B    TAB,'NOT',0
000024C6= 09 4C 53 00             1699  MSG_LSd                         DC.B    TAB,'LS',0
000024CA= 09 41 53 00             1700  MSG_ASd                         DC.B    TAB,'AS',0
000024CE= 09 52 4F 00             1701  MSG_ROd                         DC.B    TAB,'RO',0
000024D2= 09 42 43 43 00          1702  MSG_BCC                         DC.B    TAB,'BCC',0
000024D7= 09 42 43 53 00          1703  MSG_BCS                         DC.B    TAB,'BCS',0
000024DC= 09 42 45 51 00          1704  MSG_BEQ                         DC.B    TAB,'BEQ',0
000024E1= 09 42 4E 45 00          1705  MSG_BNE                         DC.B    TAB,'BNE',0
000024E6= 09 42 47 45 00          1706  MSG_BGE                         DC.B    TAB,'BGE',0
000024EB= 09 42 47 54 00          1707  MSG_BGT                         DC.B    TAB,'BGT',0
000024F0= 09 42 48 49 00          1708  MSG_BHI                         DC.B    TAB,'BHI',0
000024F5= 09 42 4C 45 00          1709  MSG_BLE                         DC.B    TAB,'BLE',0
000024FA= 09 42 4C 53 00          1710  MSG_BLS                         DC.B    TAB,'BLS',0
000024FF= 09 42 4C 54 00          1711  MSG_BLT                         DC.B    TAB,'BLT',0
00002504= 09 42 4D 49 00          1712  MSG_BMI                         DC.B    TAB,'BMI',0
00002509= 09 42 50 4C 00          1713  MSG_BPL                         DC.B    TAB,'BPL',0
0000250E= 09 42 56 43 00          1714  MSG_BVC                         DC.B    TAB,'BVC',0
00002513= 09 42 56 53 00          1715  MSG_BVS                         DC.B    TAB,'BVS',0
00002518= 09 4A 53 52 00          1716  MSG_JSR                         DC.B    TAB,'JSR',0
0000251D= 09 52 54 53 00          1717  MSG_RTS                         DC.B    TAB,'RTS',0
00002522= 09 42 52 41 00          1718  MSG_BRA                         DC.B    TAB,'BRA',0
00002527                          1719  
00002527                          1720  * Direction for LSd and ASd
00002527= 52 00                   1721  MSG_RIGHT                       DC.B    'R',0
00002529= 4C 00                   1722  MSG_LEFT                        DC.B    'L',0
0000252B                          1723  
0000252B                          1724  * Effective Addresses Messages
0000252B= 44 00                   1725  MSG_DR                          DC.B    'D',0
0000252D= 41 00                   1726  MSG_AR                          DC.B    'A',0
0000252F= 28 00                   1727  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002531= 29 00                   1728  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00002533= 2B 00                   1729  MSG_PLUS                        DC.B    '+',0
00002535= 2D 00                   1730  MSG_MINUS                       DC.B    '-',0
00002537= 23 00                   1731  MSG_POUND                       DC.B    '#',0 
00002539= 24 00                   1732  MSG_HEX                         DC.B    '$',0 
0000253B= 2C 20 00                1733  MSG_COMMA                       DC.B    ', ',0
0000253E= 2F 00                   1734  MSG_SLASH                       DC.B    '/',0  
00002540= 20 00                   1735  MSG_SPACE                       DC.B    ' ',0
00002542= 09 00                   1736  MSG_TAB                         DC.B    TAB,0
00002544= 20 20 20 00             1737  MSG_3SPACES                     DC.B    '   ',0
00002548= 20 20 20 20 00          1738  MSG_4SPACES                     DC.B    '    ',0
0000254D= 20 20 20 20 20 00       1739  MSG_5SPACES                     DC.B    '     ',0
00002553= 20 20 20 20 20 20 00    1740  MSG_6SPACES                     DC.B    '      ',0
0000255A= 20 20 20 20 20 20 ...   1741  MSG_7SPACES                     DC.B    '       ',0
00002562                          1742  
00002562                          1743  * Size Messages
00002562= 2E 42 00                1744  MSG_B                           DC.B    '.B',0
00002565= 2E 57 00                1745  MSG_W                           DC.B    '.W',0
00002568= 2E 4C 00                1746  MSG_L                           DC.B    '.L',0
0000256B                          1747  
0000256B                          1748  * Variables
0000256B  =00000100               1749  STARTING_ADDRESS                EQU     $100
0000256B  =00000150               1750  ENDING_ADDRESS                  EQU     $150
0000256B  =00000200               1751  CURRENT_INSTR                   EQU     $200
0000256B  =00000250               1752  REG_VAR                         EQU     $250 * Hold bits 11-9
0000256B  =00000300               1753  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
0000256B  =00000350               1754  EA_MODE                         EQU     $350 * Hold bits 5-3
0000256B  =00000400               1755  EA_REG                          EQU     $400 * Hold bits 2-0
0000256B= 00                      1756  LINE_COUNT                      DC.B     0
0000256C= 14                      1757  LINE_MAX                        DC.B     20
0000256D                          1758              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           163C
ADDQ_BYTE           16DA
ADDQ_LONG           1712
ADDQ_WORD           16F6
ADD_SUB_BYTE        156C
ADD_SUB_HELP        14E6
ADD_SUB_LONG        1588
ADD_SUB_OPERAND     159E
ADD_SUB_SIZE        1548
ADD_SUB_WORD        157A
AN                  1
AND_BYTE            18F8
AND_LONG            1930
AND_WORD            1914
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           23B7
CASE_ADD            14BE
CASE_ADDA           1604
CASE_ADDQ           1684
CASE_AND            18B2
CASE_AR             1F4C
CASE_ARI            1F64
CASE_ARIPOST        1F94
CASE_ARIPRE         1FD0
CASE_ASDMEM         1A98
CASE_ASDREG         1B6C
CASE_BCC            1CBC
CASE_BEQ            1CEE
CASE_BGT            1D02
CASE_BLE            1CF8
CASE_BRA            1C8C
CASE_DATA           1D3E
CASE_DR             1F34
CASE_EPICFAIL       1D44
CASE_IMMEDIATE      201E
CASE_JSR            1D28
CASE_LEA            1814
CASE_LEFTMEM        1ABE
CASE_LEFTREG        1B92
CASE_LONG           205E
CASE_LSDASDROD      1A58
CASE_LSDMEM         1A8E
CASE_LSDREG         1B62
CASE_MOVE           1286
CASE_MOVEM          134C
CASE_MOVEQ          145E
CASE_NOP            1270
CASE_NOT            19F4
CASE_OR             1994
CASE_OTHER          200C
CASE_RIGHTMEM       1AC8
CASE_RIGHTREG       1B9C
CASE_RODMEM         1AA2
CASE_RODREG         1B76
CASE_RTS            1D28
CASE_SHIFTMEM       1A76
CASE_SHIFTREG       1B48
CASE_SUB            177C
CASE_SUBA           17FE
CASE_WORD           2042
CHECKEAEXIT         1F04
CHECKEAMLOOP        1ED6
CHECKEAXN_IFVALID   1ED4
CHECKGET_EAXN       1D9A
CHECKMEMSOURE       1B08
CHECKMOREBITS       1E86
CHECKSHIFT_XN       1B32
CHECK_LENGTH        11BE
CHECK_LINE          1166
CHECK_ODD           1254
CHECK_ORDER         10AE
CHECK_XN            1DCA
CLEAR_SCREEN        119A
CONCAT              1206
CONTINUE            243F
CONVERT             11D0
CR                  D
CURRENT_INSTR       200
DELETEME            223A
DELETEMEAGAIN       2276
DESTEA              1D50
DESTXN              1D7A
DISASSEMBLE         10C4
DN                  0
DN_PLUS_EA          15D8
DONE                23FB
DONEPRINTINGREG     1ED0
EASHIFT_VALID       1B26
EAXN_INVALID        1DDC
EAXN_VALID          1DC2
EA_MODE             350
EA_REG              400
EA_TO_STRING        1F08
EA_TO_STRING_EXIT   207E
ENDING              2381
ENDING_ADDRESS      150
END_CHECKGET        1DE0
ERROR               222E
ERROR_MSG           23D9
FINDTYPEEA          1D64
FINDTYPEXN          1D8E
FINISHED            10E8
FINISHMOVE          2224
FINISH_ADD          1596
FINISH_ADDA         1658
FINISH_ADDQ         172E
FINISH_AND          194C
FINISH_SUB          17C4
FINISH_SUBA         17CA
FORMAT1             22DF
FORMAT2             232A
GETDIRECTION        1E1A
GETDISPLACEMENT     1DE2
GETMEMSOURCE        1AF0
GETROTATION         1E10
GETROTATIONLOCATION  1E2A
GETROTATIONSIZE     1E22
GET_EA              1D46
GET_XN              1D70
INPUT1              1020
INPUT2              1066
INSERTA             130C
INVALID             121E
INVALIDEA           1EE8
INVALID_INSTR       23F5
INV_INSTR           1956
ISNUMBER            11E6
LF                  A
LINE_COUNT          256B
LINE_MAX            256C
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         1422
MEM2REGWORD         1412
MEMTOREG1           1E52
MEMTOREG2           1EC4
MOVEM_MEM2REG       13DE
MOVEM_REG2MEM       136A
MOVE_BYTE           220A
MOVE_LONG           221E
MOVE_WORD           2214
MSG_3SPACES         2544
MSG_4SPACES         2548
MSG_5SPACES         254D
MSG_6SPACES         2553
MSG_7SPACES         255A
MSG_ADD             2491
MSG_ADDA            2496
MSG_ADDQ            249C
MSG_AND             24B8
MSG_AR              252D
MSG_ASD             24CA
MSG_B               2562
MSG_BCC             24D2
MSG_BCS             24D7
MSG_BEQ             24DC
MSG_BGE             24E6
MSG_BGT             24EB
MSG_BHI             24F0
MSG_BLE             24F5
MSG_BLS             24FA
MSG_BLT             24FF
MSG_BMI             2504
MSG_BNE             24E1
MSG_BPL             2509
MSG_BRA             2522
MSG_BVC             250E
MSG_BVS             2513
MSG_COMMA           253B
MSG_DIVU            24AD
MSG_DR              252B
MSG_HEX             2539
MSG_JSR             2518
MSG_L               2568
MSG_LB              252F
MSG_LEA             24B3
MSG_LEFT            2529
MSG_LSD             24C6
MSG_MINUS           2535
MSG_MOVE            2476
MSG_MOVEA           247C
MSG_MOVEM           248A
MSG_MOVEQ           2483
MSG_MULS            24A7
MSG_NOP             2471
MSG_NOT             24C1
MSG_OR              24BD
MSG_PLUS            2533
MSG_POUND           2537
MSG_RB              2531
MSG_RIGHT           2527
MSG_ROD             24CE
MSG_RTS             251D
MSG_SLASH           253E
MSG_SPACE           2540
MSG_SUB             24A2
MSG_TAB             2542
MSG_W               2565
NEW_LINE            246A
NEXT_SCREEN         117A
NOTNUMBER           11EE
OPCODE_DECODE       1268
OPMODE_VAR          300
OR_SIZE             19DC
OTHER               7
OTHEREA             1F00
PRINTADD            1524
PRINTADDRESS        1DF2
PRINTASHEX          219C
PRINTBCC            1D0C
PRINTENTER          21E0
PRINTHEXNUM         2094
PRINTLONGZERO       20F4
PRINTMEM2REG        142E
PRINTMORE           1E92
PRINTMOVE           132A
PRINTMOVESIZE       21F0
PRINTNULL           21CE
PRINTNUM            2084
PRINTRANGE          21B8
PRINTREG            1E78
PRINTREG2MEM        13AE
PRINTREGEA          1BDE
PRINTREGISTERLOOP   1E5C
PRINTREGISTERS      1E32
PRINTREGSIZE        1BAC
PRINTSHIFTMEM       1AA8
PRINTSHIFTREG       1B7C
PRINTSHORTLONGNUM   20A8
PRINTSHORTZERO      20B4
PRINTSUB            1792
PRINTZERO           21AC
PRINT_8             1770
PRINT_ADDQ_DATA     174C
PRINT_ADDR          125C
PRINT_MEMDIR        1ACE
PRINT_MOVEQ         1480
PRINT_REGDIR        1BA6
READ_KEY            118A
REG2MEMLONG         13A8
REG2MEMWORD         139E
REGTOMEM1           1E44
REGTOMEM2           1EB8
REG_BYTE            1BC4
REG_IMMEDIATE       1C00
REG_LONG            1BD8
REG_REGISTER        1C46
REG_VAR             250
REG_WORD            1BCE
RESET_INPUT         11B6
RESTART             1110
RETURN              121C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1D5C
SOURCEXN            1D86
START               1000
STARTING            234A
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          123C
THREE_TAB           246D
VALIDEA             1EF0
VALIDEA_ADDSUB_DESTOPERAND  228F
VALIDEA_ALL         227A
VALIDEA_ANDORNOT    229D
VALIDEA_ANDOR_DESTOPERAND  22A3
VALIDEA_JSR         22AD
VALIDEA_LEA         229A
VALIDEA_MOVEM_MEMTOREG  228B
VALIDEA_MOVEM_REGTOMEM  2287
VALIDEA_MOVEQ       2281
VALIDEA_MULSDIVU    2294
VALIDEA_SHIFT       22A8
VALIDXN_ALL         22B0
VALIDXN_SHORTLONG   22B4
WELCOME             22B7
XNIMMEDIATE         4
