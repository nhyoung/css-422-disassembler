00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/8/2020 7:39:00 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 000022E7             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 0000230F             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 0000235A             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 0000237A             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011B2             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011C4             36                  JSR     CONVERT
00001052  4EB9 00001230             37                  JSR     TEST_RANGE
00001058  4EB9 00001248             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 000023B1             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011B2             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011C4             55                  JSR     CONVERT
0000109A  4EB9 00001230             56                  JSR     TEST_RANGE
000010A0  4EB9 00001248             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 00F4                 64                  BLT     RESET_INPUT
000010B8                            65                                 
000010B8                            66  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010B8                            67                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010B8                            68                  ; JSR     PRINTSHORTLONGNUM   ; prints out address
000010B8                            69                  
000010B8  1439 000025A3             70                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010BE  5202                      71                  ADD.B   #1,D2               ; add 1 to counter
000010C0  13C2 000025A3             72                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010C6                            73                      
000010C6  4EB9 0000125C             74                  JSR     OPCODE_DECODE       ; decode the opcode
000010CC                            75                  
000010CC  4EB9 0000115A             76                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010D2                            77                  
000010D2  4EB9 00002210             78                  JSR     PRINTENTER          ; prints a new line
000010D8  B5CB                      79                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010DA  6FDC                      80                  BLE     DISASSEMBLE         ; if not, loop
000010DC                            81                  
000010DC                            82  
000010DC  4BF9 00002433             83  FINISHED        LEA     DONE,A5
000010E2  4EB9 000021FE             84                  JSR     PRINTNULL
000010E8  103C 0005                 85                  MOVE.B  #5,D0
000010EC  4E4F                      86                  TRAP    #15
000010EE                            87                  
000010EE  B23C 0052                 88                  CMP.B   #82,D1              ; Compare the key press with R
000010F2  6700 0010                 89                  BEQ     RESTART             ; it's R, restart
000010F6                            90                  
000010F6  B23C 0072                 91                  CMP.B   #114,D1              ; Compare the key press with r
000010FA  6700 0008                 92                  BEQ     RESTART             ; it's r, restart
000010FE                            93  
000010FE  103C 0009                 94                  MOVE.B  #9,D0
00001102  4E4F                      95                  TRAP    #15
00001104                            96                  
00001104  103C 000B                 97  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001108  323C FF00                 98                  MOVE.W  #$FF00, D1          Clear Screen
0000110C  4E4F                      99                  TRAP    #15                 Call Trap
0000110E                           100                  
0000110E  103C 000C                101                  MOVE.B  #12,D0              Keyboard echo
00001112  123C 0001                102                  MOVE.B  #1,D1               Visible
00001116  4E4F                     103                  TRAP    #15
00001118                           104                  
00001118  207C 00000000            105                  MOVE.L  #$0000000, A0       ; Reset A1
0000111E  227C 00000000            106                  MOVE.L  #$0000000, A1       ; Reset A1
00001124  247C 00000000            107                  MOVE.L  #$0000000, A2       ; Reset A2
0000112A  267C 00000000            108                  MOVE.L  #$0000000, A3       ; Reset A3
00001130  287C 00000000            109                  MOVE.L  #$0000000, A4       ; Reset A4
00001136  2A7C 00000000            110                  MOVE.L  #$0000000, A5       ; Reset A5
0000113C  2C7C 00000000            111                  MOVE.L  #$0000000, A6       ; Reset A6
00001142  2E7C 01000000            112                  MOVEA.L #$01000000,A7       ; Reset A7
00001148  4281                     113                  CLR.L   D1                  ; Reset D1
0000114A  4281                     114                  CLR.L   D1                  ; Reset D1
0000114C  4282                     115                  CLR.L   D2                  ; Reset D2
0000114E  4283                     116                  CLR.L   D3                  ; Reset D3
00001150  4284                     117                  CLR.L   D4                  ; Reset D4
00001152  4285                     118                  CLR.L   D5                  ; Reset D5
00001154  4286                     119                  CLR.L   D6                  ; Reset D6
00001156  6000 FEA8                120                  BRA     START               ; branch to start of program
0000115A                           121  
0000115A                           122  *--------------------SUBROUTINES------------------
0000115A  1439 000025A3            123  CHECK_LINE      MOVE.B  LINE_COUNT,D2
00001160  1639 000025A4            124                  MOVE.B  LINE_MAX,D3                
00001166  B602                     125                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001168  6F00 0004                126                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
0000116C  4E75                     127                  RTS
0000116E                           128  
0000116E  4BF9 00002477            129  NEXT_SCREEN     LEA     CONTINUE,A5
00001174  4EB9 000021FE            130                  JSR     PRINTNULL
0000117A  6000 0002                131                  BRA     READ_KEY
0000117E                           132                  
0000117E  103C 0005                133  READ_KEY        MOVE.B  #5,D0
00001182  4E4F                     134                  TRAP    #15
00001184                           135                  
00001184  B23C 000D                136                  CMP.B   #$D,D1              ; Compare the key press with ENTER
00001188  6700 0004                137                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
0000118C  60F0                     138                  BRA     READ_KEY
0000118E                           139                  
0000118E  103C 000B                140  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
00001192  323C FF00                141                  MOVE.W  #$FF00, D1          Clear Screen
00001196  4E4F                     142                  TRAP    #15                 Call Trap
00001198                           143                  
00001198                           144                  ; reset line counter
00001198  1439 000025A3            145                  MOVE.B  LINE_COUNT,D2
0000119E  143C 0000                146                  MOVE.B  #$0,D2
000011A2  13C2 000025A3            147                  MOVE.B  D2,LINE_COUNT
000011A8  4E75                     148                  RTS       
000011AA                           149      
000011AA                           150  
000011AA  143C 0001                151  RESET_INPUT     MOVE.B  #1,D2
000011AE  6000 0062                152                  BRA     INVALID            
000011B2                           153                  
000011B2  7800                     154  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011B4  B204                     155                  CMP.B   D4,D1               ; D1 stores length
000011B6  6700 005A                156                  BEQ     INVALID             ; input is null
000011BA  0C41 0008                157                  CMPI    #$8,D1              ; check if input is longer than a longword
000011BE  6600 0052                158                  BNE     INVALID             ; input is longer than a longword
000011C2  4E75                     159                  RTS
000011C4                           160                              
000011C4  4283                     161  CONVERT         CLR.L   D3
000011C6  4284                     162                  CLR.L   D4
000011C8  1619                     163                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011CA  B63C 0039                164                  CMP.B   #57,D3
000011CE  6E00 0012                165                  BGT     NOTNUMBER
000011D2                           166                  
000011D2  B63C 002F                167                  CMP.B   #47,D3
000011D6  6E00 0002                168                  BGT     ISNUMBER
000011DA                           169                  
000011DA  0603 00D0                170  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000011DE  6000 001A                171                  BRA     CONCAT
000011E2                           172              
000011E2  B63C 0041                173  NOTNUMBER       CMP.B   #65,D3
000011E6  6D00 002A                174                  BLT     INVALID
000011EA  B63C 0046                175                  CMP.B   #70,D3
000011EE  6E00 0022                176                  BGT     INVALID  
000011F2  0603 00C9                177                  ADD.B   #-55,D3             ; is letter             
000011F6  6000 0002                178                  BRA     CONCAT
000011FA                           179              
000011FA  BC3C 0000                180  CONCAT          CMP.B   #0,D6               ; D6 stores counter
000011FE  6D00 0010                181                  BLT     RETURN
00001202  1806                     182                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001204  E50C                     183                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001206  E9AB                     184                  LSL.L   D4,D3               ; moves current char to correct position  
00001208  DA83                     185                  ADD.L   D3,D5               ; D5 stores converted input so far
0000120A  0606 00FF                186                  ADD.B   #-1,D6  
0000120E  60B4                     187                  BRA     CONVERT             ; continue loop for remaining chars
00001210                           188                  
00001210  4E75                     189  RETURN          RTS
00001212                           190                  
00001212  227C 00000000            191  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001218  43F9 000023E7            192                  LEA     BAD_INPUT,A1        ; output invalid message
0000121E  103C 000E                193                  MOVE.B  #14,D0
00001222  4E4F                     194                  TRAP    #15
00001224  B47C 0001                195                  CMP     #1,D2
00001228  6700 FDF6                196                  BEQ     INPUT1
0000122C  6000 FE38                197                  BRA     INPUT2
00001230                           198  
00001230  4284                     199  TEST_RANGE      CLR.L      D4               ; D4 will store test results
00001232  223C 00001000            200                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001238  BA81                     201                  CMP.L      D1,D5            ; Compare minimum address with input
0000123A  6DD6                     202                  BLT        INVALID          ; input is too low. 
0000123C  223C 00FFFFFE            203                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
00001242  BA81                     204                  CMP.L      D1,D5            ; compare maximum address with input
00001244  6ECC                     205                  BGT        INVALID          ; input too large
00001246  4E75                     206                  RTS                         ; input is within range
00001248                           207             
00001248  0805 0000                208  CHECK_ODD       BTST       #0,D5            ; check if input is odd
0000124C  66C4                     209                  BNE        INVALID
0000124E  4E75                     210                  RTS
00001250                           211  
00001250                           212  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
00001250                           213  *                MOVE.L  A6,D1                   ; loads current address in D1
00001250                           214  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001250                           215  *                JSR     PRINTSHORTLONGNUM       ; prints out address
00001250                           216  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
00001250                           217  *                RTS
00001250  220E                     218                  MOVE.L  A6,D1                   ; loads current address in D1
00001252  7801                     219                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001254  4EB9 000020D8            220                  JSR     PRINTSHORTLONGNUM       ; prints out address
0000125A  4E75                     221                  RTS
0000125C                           222  
0000125C                           223  
0000125C                           224  
0000125C                           225  * Checks every single possible opcode we could have. Jump table
0000125C                           226  * Inputs: (A2) which is a pointer to intruction word to be translated
0000125C                           227  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
0000125C                           228  
0000125C  3C4A                     229  OPCODE_DECODE   MOVE.W  A2,A6
0000125E  301A                     230                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
00001260                           231                  
00001260                           232  
00001260                           233  *---------------NOP opcode----------------------                
00001260  B07C 4E71                234  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001264  6600 0014                235                  BNE     CASE_MOVE               ; checks the next case if not equal
00001268                           236                  
00001268  4EB8 1250                237                  JSR     PRINT_ADDR
0000126C  4BF9 000024A9            238                  LEA     MSG_NOP,A5              ; loads string pointer into A5
00001272  4EB9 000021FE            239                  JSR     PRINTNULL               ; prints NOP                
00001278  4E75                     240                  RTS                             ; returns from the subroutine
0000127A                           241  
0000127A                           242  *---------------MOVE opcode----------------------              
0000127A                           243                  * if first two bits are 00, next two are not 00
0000127A  3200                     244  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
0000127C  C27C C000                245                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
00001280  6600 00C2                246                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
00001284  B07C 0FFF                247                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
00001288  6F00 00BA                248                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
0000128C                           249                  
0000128C                           250                  ; Check source
0000128C  4BF9 000022AA            251                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001292  4DF9 000022E0            252                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001298  3E3C 0000                253                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000129C  4EB9 00001DCA            254                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012A2  B27C 0001                255                  CMP.W   #1,D1                    ; checks if invalid
000012A6  6700 0AC6                256                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012AA  3802                     257                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012AC  3A03                     258                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012AE                           259                  
000012AE                           260                  ; Check destination
000012AE  4BF9 000022AA            261                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012B4  4DF9 000022E4            262                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012BA  3E3C 0001                263                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012BE  4EB9 00001DCA            264                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012C4  B27C 0001                265                  CMP.W   #1,D1                    ; checks if invalid
000012C8  6700 0AA4                266                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012CC  3C02                     267                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012CE  3E03                     268                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012D0                           269                  
000012D0                           270                  ; Checking if it is MOVEA
000012D0  3200                     271                  MOVE.W  D0,D1                    ; stores d0 in d1
000012D2  C27C 01C0                272                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000012D6  B27C 0040                273                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000012DA  6700 0028                274                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000012DE                           275                  
000012DE  4EB8 1250                276                  JSR     PRINT_ADDR               ; print address
000012E2  4BF9 000024AE            277                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
000012E8  4EB9 000021FE            278                  JSR     PRINTNULL                ; prints out MOVE
000012EE  4EB9 00002220            279                  JSR     PRINTMOVESIZE            ; prints out the size 
000012F4  4BF9 00002580            280                  LEA     MSG_4SPACES,A5           ; loads spaces
000012FA  4EB9 000021FE            281                  JSR     PRINTNULL                ; prints out spaces
00001300  6000 0020                282                  BRA     PRINTMOVE                ; Branches to print move
00001304                           283                  
00001304  4BF9 000024B4            284  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
0000130A  4EB9 000021FE            285                  JSR     PRINTNULL                ; prints out MOVEA
00001310  4EB9 00002220            286                  JSR     PRINTMOVESIZE            ; prints out the size 
00001316  4BF9 0000257C            287                  LEA     MSG_3SPACES,A5           ; loads spaces
0000131C  4EB9 000021FE            288                  JSR     PRINTNULL                ; prints out spaces
00001322                           289   
00001322  3404                     290  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
00001324  3605                     291                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
00001326  4EB9 00001F38            292                  JSR     EA_TO_STRING             ; outputs it into a string
0000132C                           293                  
0000132C                           294                  ; prints a comma to seperate
0000132C  4BF9 00002573            295                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
00001332  4EB9 000021FE            296                  JSR     PRINTNULL                ; prints out MOVE
00001338                           297                  
00001338                           298                  ; print destination
00001338  3406                     299                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
0000133A  3607                     300                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
0000133C  4EB9 00001F38            301                  JSR     EA_TO_STRING             ; outputs it into a string
00001342  4E75                     302                  RTS                              ; exits subroutine                 
00001344                           303                
00001344                           304  *---------------MOVEM opcode----------------------                
00001344  3200                     305  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
00001346  C27C FB80                306                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
0000134A  B27C 4880                307                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
0000134E  6600 010E                308                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
00001352                           309                  
00001352                           310                  ; Check D
00001352  3200                     311                  MOVE.W  D0,D1                           ; copies instruction word to D1
00001354  C27C 0400                312                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001358  3E01                     313                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
0000135A  B27C 0400                314                  CMP.W   #$0400,D1                       ; checks if value is 1
0000135E  6700 007A                315                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
00001362                           316  
00001362                           317  MOVEM_REG2MEM   ; loads EA and XN
00001362  3E3C 0000                318                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001366  4BF9 000022B7            319                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
0000136C  4DF9 000022E4            320                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
00001372  4EB9 00001DCA            321                  JSR     CHECKGET_EAXN
00001378  B27C 0001                322                  CMP.W   #1,D1                           ; checks if D1 invalid
0000137C  6700 09F0                323                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001380  4EB8 1250                324                  JSR     PRINT_ADDR                      ; prints the address
00001384  4BF9 000024C2            325                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000138A  4EB9 000021FE            326                  JSR     PRINTNULL                       ; prints MOVEM
00001390                           327                  
00001390                           328                  ; finds and prints size
00001390  3200                     329                  MOVE.W  D0,D1                           ; copies D0
00001392  C27C 0040                330                  AND.W   #$0040,D1                       ; gets the size bit
00001396  6600 000C                331                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
0000139A                           332  
0000139A  4BF9 0000259D            333  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013A0  6000 0008                334                  BRA     PRINTREG2MEM                    ; prints the registers           
000013A4                           335                  
000013A4  4BF9 000025A0            336  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013AA                           337             
000013AA  4EB9 000021FE            338  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013B0  4BF9 0000257C            339                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013B6  4EB9 000021FE            340                  JSR     PRINTNULL                       ; prints out spaces
000013BC  383C 0001                341                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013C0  4EB9 00001E62            342                  JSR     PRINTREGISTERS                  ; prints registers
000013C6  4BF9 00002573            343                  LEA     MSG_COMMA,A5                    ; loads comma
000013CC  4EB9 000021FE            344                  JSR     PRINTNULL                       ; prints comma
000013D2  4EB9 00001F38            345                  JSR     EA_TO_STRING                    ; prints EA
000013D8  4E75                     346                  RTS
000013DA                           347  
000013DA                           348  MOVEM_MEM2REG  ; loads EA and XN
000013DA  3E3C 0000                349                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000013DE  4BF9 000022BB            350                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
000013E4  4DF9 000022E4            351                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000013EA  4EB9 00001DCA            352                  JSR     CHECKGET_EAXN
000013F0  B27C 0001                353                  CMP.W   #1,D1                           ; checks if D1 invalid
000013F4  6700 0978                354                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000013F8  4EB8 1250                355                  JSR     PRINT_ADDR                      ; prints the address
000013FC  4BF9 000024C2            356                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001402  4EB9 000021FE            357                  JSR     PRINTNULL                       ; prints MOVEM
00001408                           358                  
00001408                           359                  ; finds and prints size
00001408  3200                     360                  MOVE.W  D0,D1                           ; copies D0
0000140A  C27C 0040                361                  AND.W   #$0040,D1                       ; gets the size bit
0000140E  6600 0012                362                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001412                           363  
00001412  4BF9 0000259D            364  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001418  4EB9 000021FE            365                  JSR     PRINTNULL                       ; prints MOVEM
0000141E  6000 000E                366                  BRA     PRINTMEM2REG                    ; prints the registers           
00001422                           367                  
00001422  4BF9 000025A0            368  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001428  4EB9 000021FE            369                  JSR     PRINTNULL                       ; prints MOVEM 
0000142E                           370             
0000142E  4EB9 000021FE            371  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
00001434  4BF9 0000257C            372                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000143A  4EB9 000021FE            373                  JSR     PRINTNULL                       ; prints out spaces
00001440  4EB9 00001F38            374                  JSR     EA_TO_STRING                    ; prints EA
00001446  4BF9 00002573            375                  LEA     MSG_COMMA,A5                    ; loads comma
0000144C  4EB9 000021FE            376                  JSR     PRINTNULL                       ; prints comma
00001452  383C FFFF                377                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001456  4EB9 00001E62            378                  JSR     PRINTREGISTERS                  ; prints registers
0000145C  4E75                     379                  RTS
0000145E                           380                          
0000145E                           381  
0000145E                           382  *---------------MOVEQ opcode----------------------
0000145E  3200                     383  CASE_MOVEQ      MOVE.W  D0,D1
00001460  C27C F100                384                  AND.W   #$F100,D1
00001464  B27C 7000                385                  CMP.W   #$7000,D1
00001468  6600 0058                386                  BNE     CASE_ADD
0000146C                           387                  
0000146C                           388                  ;loads Register
0000146C  323C 0001                389                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001470  4EB9 00001DA0            390                  JSR     GET_XN                          ; gets XN and puts in D1
00001476  3401                     391                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
00001478                           392                  
00001478                           393                  ;loads DATA
00001478  3200                     394                  MOVE.W  D0,D1
0000147A  C27C 00FF                395                  AND.W   #$00FF,D1                       ;bit mask to get DATA
0000147E  3601                     396                  MOVE.W  D1,D3                          ;copy data into D3
00001480                           397                                                        ;must convert bits to hex
00001480                           398                                  
00001480  4EB8 1250                399  PRINT_MOVEQ     JSR     PRINT_ADDR                      ; print address
00001484                           400  
00001484  4BF9 000024BB            401                  LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
0000148A  4EB9 000021FE            402                  JSR     PRINTNULL  
00001490                           403                  
00001490  4BF9 0000257C            404                  LEA     MSG_3SPACES,A5                  ; loads spaces
00001496  4EB9 000021FE            405                  JSR     PRINTNULL                       ; prints out spaces
0000149C                           406                  
0000149C  4BF9 000025A0            407                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014A2  4EB9 000021FE            408                  JSR     PRINTNULL
000014A8                           409      
000014A8  4BF9 000024A5            410                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000014AE  4EB9 000021FE            411                  JSR     PRINTNULL
000014B4                           412                  
000014B4  4BF9 0000256F            413                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000014BA  4EB9 000021FE            414                  JSR     PRINTNULL
000014C0  4E75                     415                  RTS
000014C2                           416                  
000014C2                           417  *---------------ADD opcode----------------------                
000014C2                           418  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000014C2  3200                     419  CASE_ADD        MOVE.W  D0,D1
000014C4  C27C F000                420                  AND.W   #$F000,D1
000014C8  B27C D000                421                  CMP.W   #$D000,D1
000014CC  6600 01BE                422                  BNE     CASE_ADDQ
000014D0                           423   
000014D0  4EB8 1250                424                  JSR     PRINT_ADDR              ; print address
000014D4                           425                  
000014D4  4EB9 000014EE            426                  JSR     ADD_SUB_HELP
000014DA                           427                  
000014DA                           428                  ; bits 7-8 determine if it is ADDA or ADD
000014DA  3200                     429                  MOVE.W  D0,D1
000014DC  E149                     430                  LSL.W   #8,D1                   ; get rid of left 8 bits
000014DE  E049                     431                  LSR.W   #8,D1
000014E0  EC49                     432                  LSR.W   #6,D1                   ; get rid of right 6 bits
000014E2  B27C 0003                433                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000014E6  6700 0124                434                  BEQ     CASE_ADDA
000014EA                           435                  
000014EA  6000 0040                436                  BRA     PRINTADD                ; Branches to print add
000014EE                           437                  
000014EE                           438                  ; Check bits 0-5 
000014EE  4BF9 000022AA            439  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000014F4  4DF9 000022E0            440                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000014FA  3E3C 0000                441                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000014FE  4EB9 00001DCA            442                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001504  B27C 0001                443                  CMP.W       #1,D1                    ; checks if invalid
00001508  6700 0864                444                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000150C  3802                     445                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
0000150E  3A03                     446                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001510                           447                  
00001510                           448                  ; Check 6-11
00001510  4BF9 000022AA            449                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001516  4DF9 000022E4            450                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000151C  3E3C 0001                451                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001520  4EB9 00001DCA            452                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001526  3C02                     453                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001528  3E03                     454                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
0000152A                           455    
0000152A  4E75                     456                  RTS                
0000152C                           457                    
0000152C  4BF9 000024C9            458  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001532  4EB9 000021FE            459                  JSR         PRINTNULL               ; print ADD
00001538  3200                     460                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000153A  4EB9 00001550            461                  JSR         ADD_SUB_SIZE
00001540  4BF9 00002585            462                  LEA         MSG_5SPACES,A5          ; loads spaces
00001546  4EB9 000021FE            463                  JSR         PRINTNULL               ; prints out spaces
0000154C  6000 0050                464                  BRA         FINISH_ADD
00001550                           465                    
00001550  3200                     466  ADD_SUB_SIZE    MOVE.W      D0,D1
00001552  E149                     467                  LSL.W       #8,D1
00001554  E049                     468                  LSR.W       #8,D1
00001556  EC49                     469                  LSR.W       #6,D1                   ; gets bits 6-7
00001558                           470                    
00001558  B27C 0000                471                  CMP.W       #0,D1
0000155C  6700 0016                472                  BEQ         ADD_SUB_BYTE
00001560  B27C 0001                473                  CMP.W       #1,D1                   ; if 1, it is a word
00001564  6700 001C                474                  BEQ         ADD_SUB_WORD
00001568  B27C 0002                475                  CMP.W       #2,D1                   ; if 2, it is a long
0000156C  6700 0022                476                  BEQ         ADD_SUB_LONG
00001570  6000 029C                477                  BRA         CASE_SUBA               ; error
00001574                           478                    
00001574  4BF9 0000259A            479  ADD_SUB_BYTE    LEA         MSG_B,A5
0000157A  4EB9 000021FE            480                  JSR         PRINTNULL
00001580  4E75                     481                  RTS
00001582                           482                    
00001582  4BF9 0000259D            483  ADD_SUB_WORD    LEA         MSG_W,A5
00001588  4EB9 000021FE            484                  JSR         PRINTNULL
0000158E  4E75                     485                  RTS
00001590                           486    
00001590  4BF9 000025A0            487  ADD_SUB_LONG    LEA         MSG_L,A5
00001596  4EB9 000021FE            488                  JSR         PRINTNULL
0000159C  4E75                     489                  RTS
0000159E                           490        
0000159E  4EB9 000015A6            491  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015A4  4E75                     492                  RTS
000015A6                           493    
000015A6  EF49                     494  ADD_SUB_OPERAND LSL.W       #7,D1
000015A8  EE49                     495                  LSR.W       #7,D1
000015AA  E049                     496                  LSR.W       #8,D1
000015AC  B27C 0001                497                  CMP.W       #1,D1
000015B0  6600 002E                498                  BNE         Dn_PLUS_EA          
000015B4                           499                    
000015B4                           500                  ; print Data Register
000015B4  4BF9 00002563            501                  LEA         MSG_DR,A5
000015BA  4EB9 000021FE            502                  JSR         PRINTNULL
000015C0  3207                     503                  MOVE.W      D7,D1
000015C2  4EB9 000020B4            504                  JSR         PRINTNUM                
000015C8                           505                  
000015C8                           506                  ; prints a comma to seperate
000015C8  4BF9 00002573            507                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015CE  4EB9 000021FE            508                  JSR         PRINTNULL                ; prints out MOVE
000015D4                           509                 
000015D4                           510                  ; below is EA+Dn->Dn  
000015D4  3404                     511                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015D6  3605                     512                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015D8  4EB9 00001F38            513                  JSR         EA_TO_STRING             ; outputs it into a string
000015DE  4E75                     514                  RTS                                 ; exits subroutine 
000015E0                           515  
000015E0                           516  Dn_PLUS_EA      ; below is Dn+EA->EA  
000015E0  3404                     517                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015E2  3605                     518                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015E4  4EB9 00001F38            519                  JSR         EA_TO_STRING             ; outputs it into a string   
000015EA                           520                  
000015EA                           521                  ; prints a comma to seperate
000015EA  4BF9 00002573            522                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015F0  4EB9 000021FE            523                  JSR         PRINTNULL                ; prints out MOVE
000015F6                           524                  
000015F6                           525                  ; below is Dn+EA->EA
000015F6  4BF9 00002563            526                  LEA         MSG_DR,A5                ; print data register
000015FC  4EB9 000021FE            527                  JSR         PRINTNULL
00001602  3207                     528                  MOVE.W      D7,D1
00001604  4EB9 000020B4            529                  JSR         PRINTNUM             
0000160A  4E75                     530                  RTS                                  ; exits subroutine          
0000160C                           531                        
0000160C                           532  *---------------ADDA opcode----------------------
0000160C                           533  CASE_ADDA       ; gets bit 8 (size bit)
0000160C  3200                     534                  MOVE.W      D0,D1
0000160E  EF49                     535                  LSL.W       #7,D1
00001610  EE49                     536                  LSR.W       #7,D1
00001612  E049                     537                  LSR         #8,D1                   
00001614                           538                  
00001614  4BF9 000024CE            539                  LEA         MSG_ADDA,A5             ; print ADDA
0000161A  4EB9 000021FE            540                  JSR         PRINTNULL
00001620                           541                   
00001620  B27C 0001                542                  CMP.W       #1,D1
00001624  6700 001E                543                  BEQ         ADDA_LONG
00001628                           544                    
00001628  4BF9 0000259D            545                  LEA         MSG_W,A5
0000162E  4EB9 000021FE            546                  JSR         PRINTNULL
00001634  4BF9 00002580            547                  LEA         MSG_4SPACES,A5          ; loads spaces
0000163A  4EB9 000021FE            548                  JSR         PRINTNULL               ; prints out spaces
00001640  6000 001E                549                  BRA         FINISH_ADDA   
00001644                           550                    
00001644  4BF9 000025A0            551  ADDA_LONG       LEA         MSG_L,A5
0000164A  4EB9 000021FE            552                  JSR         PRINTNULL
00001650  4BF9 00002580            553                  LEA         MSG_4SPACES,A5          ; loads spaces
00001656  4EB9 000021FE            554                  JSR         PRINTNULL               ; prints out spaces
0000165C  6000 0002                555                  BRA         FINISH_ADDA
00001660                           556                    
00001660  3404                     557  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001662  3605                     558                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001664  4EB9 00001F38            559                  JSR         EA_TO_STRING             ; outputs it into a string
0000166A                           560                    
0000166A                           561                  ; prints a comma to seperate
0000166A  4BF9 00002573            562                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001670  4EB9 000021FE            563                  JSR         PRINTNULL                ; prints out MOVE
00001676                           564            
00001676  4BF9 00002565            565                  LEA         MSG_AR,A5                ; print address register
0000167C  4EB9 000021FE            566                  JSR         PRINTNULL
00001682  3207                     567                  MOVE.W      D7,D1
00001684  4EB9 000020B4            568                  JSR         PRINTNUM             
0000168A  4E75                     569                  RTS                              ; exits subroutine
0000168C                           570                  
0000168C                           571  *---------------ADDQ opcode----------------------                  
0000168C  3200                     572  CASE_ADDQ       MOVE.W      D0,D1
0000168E  C27C F000                573                  AND.W       #$F000,D1       
00001692  B27C 5000                574                  CMP.W       #$5000,D1
00001696  6600 00F0                575                  BNE         CASE_SUB
0000169A                           576                                                   
0000169A  4EB8 1250                577                  JSR         PRINT_ADDR              ; print address  
0000169E  4BF9 000024D4            578                  LEA         MSG_ADDQ,A5             ; print ADDQ
000016A4  4EB9 000021FE            579                  JSR         PRINTNULL
000016AA                           580                  
000016AA                           581                  ; get bits 6-7 (size bits)
000016AA  3200                     582                  MOVE.W      D0,D1
000016AC  E149                     583                  LSL.W       #8,D1
000016AE  E049                     584                  LSR.W       #8,D1
000016B0  EC49                     585                  LSR.W       #6,D1
000016B2  3401                     586                  MOVE.W      D1,D2
000016B4                           587                  
000016B4                           588                  ; Check bits 0-5 
000016B4  4BF9 000022AA            589                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016BA  4DF9 000022E0            590                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016C0  3E3C 0000                591                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016C4  4EB9 00001DCA            592                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000016CA  B27C 0001                593                  CMP.W       #1,D1                    ; checks if invalid
000016CE  6700 069E                594                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000016D2  3802                     595                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000016D4  3A03                     596                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000016D6                           597                  
000016D6  B47C 0001                598                  CMP.W       #1,D2
000016DA  6700 0026                599                  BEQ         ADDQ_WORD
000016DE  B47C 0002                600                  CMP.W       #2,D2
000016E2  6700 003A                601                  BEQ         ADDQ_LONG
000016E6                           602                    
000016E6  4BF9 0000259A            603  ADDQ_BYTE       LEA         MSG_B,A5
000016EC  4EB9 000021FE            604                  JSR         PRINTNULL
000016F2  4BF9 00002580            605                  LEA         MSG_4SPACES,A5          ; loads spaces
000016F8  4EB9 000021FE            606                  JSR         PRINTNULL               ; prints out spaces
000016FE  6000 003A                607                  BRA         FINISH_ADDQ  
00001702                           608   
00001702  4BF9 0000259D            609  ADDQ_WORD       LEA         MSG_W,A5
00001708  4EB9 000021FE            610                  JSR         PRINTNULL
0000170E  4BF9 00002580            611                  LEA         MSG_4SPACES,A5          ; loads spaces
00001714  4EB9 000021FE            612                  JSR         PRINTNULL               ; prints out spaces
0000171A  6000 001E                613                  BRA         FINISH_ADDQ                 
0000171E                           614    
0000171E  4BF9 000025A0            615  ADDQ_LONG       LEA         MSG_L,A5
00001724  4EB9 000021FE            616                  JSR         PRINTNULL
0000172A  4BF9 00002580            617                  LEA         MSG_4SPACES,A5          ; loads spaces
00001730  4EB9 000021FE            618                  JSR         PRINTNULL               ; prints out spaces
00001736  6000 0002                619                  BRA         FINISH_ADDQ                  
0000173A                           620                    
0000173A  4EB9 00001758            621  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001740                           622   
00001740                           623                  ; prints a comma to seperate
00001740  4BF9 00002573            624                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001746  4EB9 000021FE            625                  JSR         PRINTNULL                ; prints out MOVE
0000174C                           626                    
0000174C                           627                  ; prints destination
0000174C  3404                     628                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000174E  3605                     629                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001750  4EB9 00001F38            630                  JSR         EA_TO_STRING             ; outputs it into a string
00001756                           631                 
00001756  4E75                     632                  RTS
00001758                           633   
00001758  4BF9 0000256F            634  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
0000175E  4EB9 000021FE            635                  JSR         PRINTNULL
00001764                           636                  ; gets bits 9-11 (data bits)
00001764  E949                     637                  LSL.W       #4,D1
00001766  E849                     638                  LSR.W       #4,D1                               ; get rid of left 4 bits
00001768  E049                     639                  LSR.W       #8,D1
0000176A  E249                     640                  LSR.W       #1,D1                               ; get rid of right 9 bits
0000176C                           641                  
0000176C  B27C 0000                642                  CMP.W       #0,D1
00001770  6700 000A                643                  BEQ         PRINT_8
00001774  4EB9 000020B4            644                  JSR         PRINTNUM
0000177A  4E75                     645                  RTS 
0000177C                           646  
0000177C  123C 0008                647  PRINT_8         MOVE.B      #8,D1
00001780  4EB9 000020B4            648                  JSR         PRINTNUM
00001786  4E75                     649                  RTS   
00001788                           650         
00001788                           651  *---------------SUB opcode---------------------- 
00001788  3200                     652  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000178A  C27C F000                653                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000178E  B27C 9000                654                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001792  6600 0090                655                  BNE         CASE_LEA
00001796                           656                 
00001796  4EB8 14EE                657                  JSR         ADD_SUB_HELP
0000179A  4EB8 1250                658                  JSR         PRINT_ADDR                          ; print address                              
0000179E                           659                  
0000179E  6000 0002                660                  BRA         PRINTSUB                            ; Branches to print sub
000017A2                           661  
000017A2  4BF9 000024DA            662  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017A8  4EB9 000021FE            663                  JSR         PRINTNULL
000017AE  3200                     664                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017B0  4EB8 1550                665                  JSR         ADD_SUB_SIZE
000017B4  4BF9 00002585            666                  LEA         MSG_5SPACES,A5                      ; loads spaces
000017BA  4EB9 000021FE            667                  JSR         PRINTNULL                           ; prints out spaces
000017C0  3200                     668                  MOVE.W      D0,D1
000017C2  E149                     669                  LSL.W       #8,D1
000017C4  E049                     670                  LSR.W       #8,D1
000017C6  EC49                     671                  LSR.W       #6,D1
000017C8  B27C 0003                672                  CMP.W       #3,D1
000017CC  6600 0006                673                  BNE         FINISH_SUB
000017D0  6000 0008                674                  BRA         FINISH_SUBA                         ; same as ADDA
000017D4                           675                  
000017D4  4EB8 15A6                676  FINISH_SUB      JSR         ADD_SUB_OPERAND
000017D8  4E75                     677                  RTS
000017DA                           678                    
000017DA  3404                     679  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000017DC  3605                     680                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000017DE  4EB9 00001F38            681                  JSR         EA_TO_STRING             ; outputs it into a string
000017E4                           682                
000017E4                           683                  ; prints a comma to seperate
000017E4  4BF9 00002573            684                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000017EA  4EB9 000021FE            685                  JSR         PRINTNULL                ; prints out MOVE
000017F0                           686                  
000017F0  4BF9 00002565            687                  LEA         MSG_AR,A5                ; print address register
000017F6  4EB9 000021FE            688                  JSR         PRINTNULL
000017FC  3200                     689                  MOVE.W      D0,D1
000017FE  E949                     690                  LSL.W       #4,D1
00001800  E849                     691                  LSR.W       #4,D1
00001802  E049                     692                  LSR.W       #8,D1
00001804  E249                     693                  LSR.W       #1,D1
00001806  4EB9 000020B4            694                  JSR         PRINTNUM             
0000180C  4E75                     695                  RTS                              ; exits subroutine
0000180E                           696  
0000180E                           697  
0000180E                           698  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000180E  3200                     699  CASE_SUBA       MOVE.W      D0,D1
00001810  EF49                     700                  LSL.W       #7,D1
00001812  EE49                     701                  LSR.W       #7,D1
00001814  E049                     702                  LSR.W       #8,D1
00001816  B23C 0000                703                  CMP.B       #0,D1
0000181A  6700 FD66                704                  BEQ         ADD_SUB_WORD
0000181E  6000 FD70                705                  BRA         ADD_SUB_LONG
00001822  4E75                     706                  RTS         
00001824                           707                   
00001824  3200                     708  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001826  C27C F000                709                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000182A  B27C 4000                710                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000182E  6600 0092                711                  BNE.W   CASE_AND                             ; If its not, check AND
00001832  3200                     712                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001834  C27C 01C0                713                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001838  B27C 01C0                714                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000183C  6600 0084                715                  BNE.W   CASE_AND                             ; If its not, check AND
00001840                           716                  
00001840                           717                  ; Check source
00001840  4BF9 000022CA            718                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001846  4DF9 000022E4            719                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000184C  3E3C 0000                720                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001850  4EB9 00001DCA            721                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001856  3802                     722                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001858  3A03                     723                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000185A                           724                  
0000185A                           725                  ; Check destination
0000185A  4BF9 000022CA            726                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001860  4DF9 000022E4            727                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001866  3E3C 0001                728                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000186A  4EB9 00001DCA            729                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001870  3C02                     730                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001872  3E03                     731                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001874                           732  
00001874  4BF9 000024EB            733                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000187A  4EB9 000021FE            734                  JSR     PRINTNULL                            ; prints LEA
00001880  4BF9 00002592            735                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001886  4EB9 000021FE            736                  JSR     PRINTNULL                            ; prints out spaces
0000188C                           737                  
0000188C                           738                  ; print source
0000188C  3404                     739                  MOVE.W  D4,D2
0000188E  3605                     740                  MOVE.W  D5,D3
00001890  4EB9 00001F38            741                  JSR     EA_TO_STRING                         ; Prints out the EA
00001896                           742                  
00001896                           743                  ; comma
00001896  4BF9 00002573            744                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
0000189C  4EB9 000021FE            745                  JSR     PRINTNULL                       
000018A2                           746                   
000018A2                           747                  ; register
000018A2  4BF9 00002565            748                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018A8  4EB9 000021FE            749                  JSR     PRINTNULL 
000018AE  3401                     750                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018B0  323C 0001                751                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000018B4  4EB9 00001DA0            752                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000018BA  4EB9 000020B4            753                  JSR     PRINTNUM                             ; Prints the number in D1
000018C0  4E75                     754                  RTS
000018C2                           755  
000018C2                           756  *---------------AND opcode----------------------
000018C2  3200                     757  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018C4  C27C F000                758                  AND.W       #$F000,D1       
000018C8  B27C C000                759                  CMP.W       #$C000,D1
000018CC  6600 00DA                760                  BNE         CASE_OR
000018D0                           761                  
000018D0  3200                     762                  MOVE.W      D0,D1
000018D2  E149                     763                  LSL.W       #8,D1
000018D4  E049                     764                  LSR.W       #8,D1
000018D6  EC49                     765                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000018D8  3C01                     766                  MOVE.W      D1,D6
000018DA  BC7C 0003                767                  CMP.W       #3,D6
000018DE  6700 008A                768                  BEQ         INV_INSTR
000018E2                           769                  
000018E2  4EB8 1250                770                  JSR         PRINT_ADDR                      ; print address
000018E6  4BF9 000024F0            771                  LEA         MSG_AND,A5                      ; print AND
000018EC  4EB9 000021FE            772                  JSR         PRINTNULL
000018F2                           773                  
000018F2  3206                     774                  MOVE.W      D6,D1
000018F4  B27C 0000                775                  CMP.W       #0,D1
000018F8  6700 0012                776                  BEQ         AND_BYTE
000018FC  B27C 0001                777                  CMP.W       #1,D1                   ; if 1, it is a word
00001900  6700 0026                778                  BEQ         AND_WORD
00001904  B27C 0002                779                  CMP.W       #2,D1                   ; if 2, it is a long
00001908  6700 003A                780                  BEQ         AND_LONG
0000190C                           781                  
0000190C  4BF9 0000259A            782  AND_BYTE        LEA         MSG_B,A5
00001912  4EB9 000021FE            783                  JSR         PRINTNULL
00001918  4BF9 00002592            784                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000191E  4EB9 000021FE            785                  JSR         PRINTNULL                       ; prints out spaces
00001924  6000 003A                786                  BRA         FINISH_AND
00001928                           787                                    
00001928  4BF9 0000259D            788  AND_WORD        LEA         MSG_W,A5
0000192E  4EB9 000021FE            789                  JSR         PRINTNULL
00001934  4BF9 00002592            790                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000193A  4EB9 000021FE            791                  JSR         PRINTNULL                       ; prints out spaces
00001940  6000 001E                792                  BRA         FINISH_AND
00001944                           793    
00001944  4BF9 000025A0            794  AND_LONG        LEA         MSG_L,A5
0000194A  4EB9 000021FE            795                  JSR         PRINTNULL
00001950  4BF9 00002592            796                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001956  4EB9 000021FE            797                  JSR         PRINTNULL                       ; prints out spaces
0000195C  6000 0002                798                  BRA         FINISH_AND
00001960                           799        
00001960  4EB8 14EE                800  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001964  4EB8 15A6                801                  JSR         ADD_SUB_OPERAND
00001968  4E75                     802                  RTS
0000196A                           803                  
0000196A  4BF9 00002425            804  INV_INSTR       LEA         INVALID_INSTR,A5
00001970  4EB9 000021FE            805                  JSR         PRINTNULL
00001976  4BF9 0000258B            806                  LEA         MSG_6SPACES,A5
0000197C  4EB9 000021FE            807                  JSR         PRINTNULL
00001982  4BF9 00002571            808                  LEA         MSG_HEX,A5
00001988  4EB9 000021FE            809                  JSR         PRINTNULL
0000198E  2200                     810                  MOVE.L      D0,D1
00001990  383C 0000                811                  MOVE.W      #0,D4
00001994  4EB9 000020D8            812                  JSR         PRINTSHORTLONGNUM
0000199A  4BF9 000024A2            813                  LEA         NEW_LINE,A5
000019A0  4EB9 000021FE            814                  JSR         PRINTNULL
000019A6  4E75                     815                  RTS               
000019A8                           816                  
000019A8                           817  *---------------OR opcode----------------------            
000019A8  3200                     818  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019AA  C27C F000                819                  AND.W       #$F000,D1       
000019AE  B27C 8000                820                  CMP.W       #$8000,D1
000019B2  6600 0058                821                  BNE         CASE_NOT
000019B6                           822                                                
000019B6  3200                     823                  MOVE.W      D0,D1
000019B8  E149                     824                  LSL.W       #8,D1
000019BA  E049                     825                  LSR.W       #8,D1
000019BC  EC49                     826                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019BE  B27C 0003                827                  CMP.W       #3,D1
000019C2  3C01                     828                  MOVE.W      D1,D6
000019C4  67A4                     829                  BEQ         INV_INSTR
000019C6                           830                  
000019C6  4EB8 1250                831                  JSR         PRINT_ADDR                      ; print address
000019CA                           832                  
000019CA  4BF9 000024F5            833                  LEA         MSG_OR,A5
000019D0  4EB9 000021FE            834                  JSR         PRINTNULL                       ; print "OR"
000019D6                           835                  
000019D6  3206                     836                  MOVE.W      D6,D1
000019D8  4EB9 000019F4            837                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000019DE  4BF9 0000258B            838                  LEA         MSG_6SPACES,A5                  ; loads spaces
000019E4  4EB9 000021FE            839                  JSR         PRINTNULL                       ; prints out spaces
000019EA                           840  
000019EA  4EB8 14EE                841                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
000019EE  4EB8 15A6                842                  JSR         ADD_SUB_OPERAND                 ; print 
000019F2  4E75                     843                  RTS
000019F4                           844  
000019F4  B27C 0000                845  OR_SIZE         CMP.W       #0,D1
000019F8  6700 FB7A                846                  BEQ         ADD_SUB_BYTE
000019FC  B27C 0001                847                  CMP.W       #1,D1                   ; if 1, it is a word
00001A00  6700 FB80                848                  BEQ         ADD_SUB_WORD
00001A04  B27C 0002                849                  CMP.W       #2,D1                   ; if 2, it is a long
00001A08  6700 FB86                850                  BEQ         ADD_SUB_LONG
00001A0C                           851                  ; no need for rts, since ADD_SUB_ already has                
00001A0C                           852  
00001A0C                           853  *---------------NOT opcode----------------------
00001A0C  3200                     854  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A0E  C27C FF00                855                  AND.W       #$FF00,D1       
00001A12  B27C 4600                856                  CMP.W       #$4600,D1
00001A16  6600 005C                857                  BNE         CASE_LSDASDROD
00001A1A                           858                 
00001A1A                           859                  ; get bits 6-7 (size)
00001A1A  3200                     860                  MOVE.W      D0,D1
00001A1C  E149                     861                  LSL.W       #8,D1
00001A1E  E049                     862                  LSR.W       #8,D1
00001A20  EC49                     863                  LSR.W       #6,D1 
00001A22  3C01                     864                  MOVE.W      D1,D6                         
00001A24  BC7C 0003                865                  CMP.W       #3,D6
00001A28  6700 FF40                866                  BEQ         INV_INSTR
00001A2C                           867                  
00001A2C  4EB8 1250                868                  JSR         PRINT_ADDR
00001A30                           869                  
00001A30  4BF9 000024F9            870                  LEA         MSG_NOT,A5
00001A36  4EB9 000021FE            871                  JSR         PRINTNULL                       ; print "NOT"
00001A3C                           872                                 
00001A3C  3206                     873                  MOVE.W      D6,D1
00001A3E                           874  
00001A3E  4EB8 19F4                875                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A42  4BF9 00002585            876                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A48  4EB9 000021FE            877                  JSR         PRINTNULL                       ; prints out spaces
00001A4E                           878                  
00001A4E                           879                  ; get bits 0-5 
00001A4E  4BF9 000022AA            880                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A54  4DF9 000022E0            881                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A5A  3E3C 0000                882                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A5E  4EB9 00001DCA            883                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A64  B27C 0001                884                  CMP.W       #1,D1                    ; checks if invalid
00001A68  6700 0304                885                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001A6C  4EB9 00001F38            886                  JSR         EA_TO_STRING             ; outputs it into a string
00001A72                           887    
00001A72  4E75                     888                  RTS
00001A74                           889  
00001A74  3200                     890  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001A76  C27C F000                891                  AND.W       #$F000, D1                       ; gets first 4 bits
00001A7A  B27C E000                892                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001A7E  6600 0230                893                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001A82  3400                     894                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A84  4EB9 00001E52            895                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A8A  B47C 0003                896                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001A8E  6600 00D8                897                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001A92                           898                  
00001A92  3400                     899  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001A94  4EB9 00001E40            900                  JSR         GETROTATION                      ; gets rotation value of D2
00001A9A  B47C 0000                901                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001A9E  6700 0014                902                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001AA2  B47C 0003                903                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001AA6  6700 0016                904                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001AAA                           905                  
00001AAA  4BF9 000024FE            906  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001AB0  6000 0012                907                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AB4                           908  
00001AB4  4BF9 00002502            909  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001ABA  6000 0008                910                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001ABE                           911  
00001ABE  4BF9 00002506            912  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AC4                           913                  
00001AC4  4EB8 1250                914  PRINTSHIFTMEM   JSR         PRINT_ADDR                       ; prints address
00001AC8  4EB9 000021FE            915                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001ACE  3400                     916                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AD0  4EB9 00001E4A            917                  JSR         GETDIRECTION                     ; gets direction
00001AD6  B47C 0000                918                  CMP.W       #0,D2                            ; checking if its right
00001ADA  6700 000C                919                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001ADE                           920  
00001ADE  4BF9 00002561            921  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001AE4  6000 0008                922                  BRA         PRINT_MEMDIR                     ; branches for printing
00001AE8                           923          
00001AE8  4BF9 0000255F            924  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001AEE                           925  
00001AEE  4EB9 000021FE            926  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001AF4  4BF9 0000259D            927                  LEA         MSG_W,A5                         ; loads .W into A5
00001AFA  4EB9 000021FE            928                  JSR         PRINTNULL                        ; Prints .W
00001B00  4BF9 00002592            929                  LEA         MSG_7SPACES,A5                   ; loads spaces
00001B06  4EB9 000021FE            930                  JSR         PRINTNULL                        ; prints out spaces
00001B0C  6000 0002                931                  BRA         GETMEMSOURCE                     ; checks the source 
00001B10                           932                  
00001B10                           933  ; get source addressing mode       
00001B10                           934  GETMEMSOURCE                                                 
00001B10  323C 0000                935                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B14  4EB9 00001D76            936                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B1A  3801                     937                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B1C  323C 0000                938                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B20  4EB9 00001DA0            939                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B26  3A01                     940                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B28                           941  
00001B28  4BF9 000022D8            942  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B2E  3204                     943                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B30  4EB9 00001F04            944                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B36  B27C 0002                945                  CMP.W       #2,D1                            ; checks if it is Xn
00001B3A  6700 0016                946                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B3E  B27C 0001                947                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B42  6700 022A                948                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B46                           949  
00001B46  3404                     950  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B48  3605                     951                  MOVE.W      D5,D3                            ; moves EA to D3
00001B4A  4EB9 00001F38            952                  JSR         EA_TO_STRING                     ; prints out the EA
00001B50  4E75                     953                  RTS                
00001B52                           954                  
00001B52                           955                  
00001B52  4BF9 000022E4            956  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B58  3205                     957                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B5A  4EB9 00001F04            958                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B60  4A41                     959                  TST.W       D1                               ; checks if it is valid
00001B62  67E2                     960                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B64  6000 0208                961                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B68                           962  
00001B68                           963  
00001B68  3602                     964  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B6A  3200                     965                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B6C  C27C 0018                966                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001B70  E649                     967                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001B72  B27C 0000                968                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B76  6700 0014                969                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001B7A  B27C 0003                970                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B7E  6700 0016                971                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001B82                           972                  
00001B82  4BF9 000024FE            973  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001B88  6000 0012                974                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B8C                           975  
00001B8C  4BF9 00002502            976  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001B92  6000 0008                977                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B96                           978  
00001B96  4BF9 00002506            979  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001B9C                           980                  
00001B9C  4EB8 1250                981  PRINTSHIFTREG   JSR         PRINT_ADDR                       ; prints address
00001BA0  4EB9 000021FE            982                  JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001BA6  3400                     983                  MOVE.W      D0,D2                            ; copies D0 to D2
00001BA8  4EB9 00001E4A            984                  JSR         GETDIRECTION                     ; gets direction
00001BAE  B47C 0000                985                  CMP.W       #0,D2                            ; checking if its right
00001BB2  6700 000C                986                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BB6                           987  
00001BB6  4BF9 00002561            988  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BBC  6000 000C                989                  BRA         PRINT_REGDIR                     ; branches for printing
00001BC0                           990          
00001BC0  4BF9 0000255F            991  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BC6  6000 0002                992                  BRA         PRINT_REGDIR                     ; branches for printing
00001BCA                           993                  
00001BCA  4EB9 000021FE            994  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BD0                           995  
00001BD0  3400                     996  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BD2  4EB9 00001E52            997                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BD8  B47C 0001                998                  CMP.W       #1,D2                            ; Checks if it is word size
00001BDC  6700 0014                999                  BEQ         REG_WORD                         ; Prints .W
00001BE0  B47C 0002               1000                  CMP.W       #2,D2                            ; Checks if it is long size
00001BE4  6700 0016               1001                  BEQ         REG_LONG                         ; Prints .L
00001BE8                          1002  
00001BE8  4BF9 0000259A           1003  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001BEE  6000 0012               1004                  BRA         PRINTREGEA      
00001BF2                          1005  
00001BF2  4BF9 0000259D           1006  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001BF8  6000 0008               1007                  BRA         PRINTREGEA      
00001BFC                          1008                             
00001BFC  4BF9 000025A0           1009  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001C02                          1010  
00001C02  4EB9 000021FE           1011  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001C08  4BF9 00002585           1012                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001C0E  4EB9 000021FE           1013                  JSR         PRINTNULL                        ; prints out spaces
00001C14  3400                    1014                  MOVE.W      D0,D2                            ; copies D0 to D1
00001C16  4EB9 00001E5A           1015                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C1C  B27C 0001               1016                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001C20  6700 0048               1017                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001C24                          1018                                  
00001C24  3400                    1019  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C26  4EB9 00001E52           1020                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C2C  3202                    1021                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C2E  4BF9 0000256F           1022                  LEA         MSG_POUND, A5                    ; loads # into A5
00001C34  4EB9 000021FE           1023                  JSR         PRINTNULL                        ; prints #
00001C3A  4EB9 000020B4           1024                  JSR         PRINTNUM                         ; prints shift count
00001C40  4BF9 00002573           1025                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C46  4EB9 000021FE           1026                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C4C  4BF9 00002563           1027                  LEA         MSG_DR, A5                       ; loads D into A5
00001C52  4EB9 000021FE           1028                  JSR         PRINTNULL                        ; prints out D 
00001C58  323C 0000               1029                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C5C  4EB9 00001DA0           1030                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C62  4EB9 000020B4           1031                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C68  4E75                    1032                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C6A                          1033                  
00001C6A  3400                    1034  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001C6C  4EB9 00001E52           1035                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C72  3202                    1036                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C74  4BF9 00002563           1037                  LEA         MSG_DR, A5                       ; loads D into A5
00001C7A  4EB9 000021FE           1038                  JSR         PRINTNULL                        ; prints D
00001C80  4EB9 000020B4           1039                  JSR         PRINTNUM                         ; prints register number
00001C86  4BF9 00002573           1040                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C8C  4EB9 000021FE           1041                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C92  4BF9 00002563           1042                  LEA         MSG_DR, A5                       ; loads D into A5
00001C98  4EB9 000021FE           1043                  JSR         PRINTNULL                        ; prints out D 
00001C9E  323C 0000               1044                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CA2  4EB9 00001DA0           1045                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CA8  4EB9 000020B4           1046                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CAE  4E75                    1047                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CB0                          1048               
00001CB0  3200                    1049  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001CB2  C27C FF00               1050                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001CB6  B27C 6000               1051                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001CBA  6600 0028               1052                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001CBE                          1053                  
00001CBE  4EB8 1250               1054                  JSR     PRINT_ADDR
00001CC2  4BF9 0000255A           1055                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001CC8  4EB9 000021FE           1056                  JSR     PRINTNULL                            ; prints BRA
00001CCE  4BF9 00002592           1057                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001CD4  4EB9 000021FE           1058                  JSR     PRINTNULL                            ; prints out spaces
00001CDA                          1059  
00001CDA  3400                    1060                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001CDC  4EB9 00001E12           1061                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001CE2  4E75                    1062                  RTS
00001CE4                          1063                  
00001CE4                          1064  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001CE4                          1065  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001CE4  3200                    1066  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CE6  C27C F000               1067                  AND.W   #$F000,D1                            ; get top 4 bits
00001CEA  B27C 6000               1068                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001CEE  6600 0064               1069                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001CF2  3200                    1070                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CF4  C27C 0F00               1071                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001CF8  E049                    1072                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001CFA                          1073                  
00001CFA  B27C 000E               1074                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001CFE  6700 002A               1075                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001D02                          1076                  
00001D02  B27C 000F               1077                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001D06  6700 0018               1078                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001D0A                          1079                      
00001D0A  B27C 0007               1080                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001D0E  6700 0006               1081                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001D12  6000 005A               1082                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001D16                          1083     
00001D16  4BF9 00002514           1084  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D1C  6000 0016               1085                  BRA     PRINTBCC
00001D20                          1086  
00001D20  4BF9 0000252D           1087  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D26  6000 000C               1088                  BRA     PRINTBCC
00001D2A                          1089                  
00001D2A  4BF9 00002523           1090  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D30  6000 0002               1091                  BRA     PRINTBCC
00001D34                          1092  
00001D34  4EB8 1250               1093  PRINTBCC        JSR     PRINT_ADDR                           ; prints address
00001D38  4EB9 000021FE           1094                  JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D3E  4BF9 00002592           1095                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D44  4EB9 000021FE           1096                  JSR     PRINTNULL                            ; prints out spaces
00001D4A  3400                    1097                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D4C  4EB9 00001E12           1098                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D52  4E75                    1099                  RTS              
00001D54                          1100                  
00001D54                          1101  
00001D54                          1102  CASE_JSR       
00001D54                          1103  
00001D54  B07C 4E75               1104  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001D58  6600 0014               1105                  BNE     CASE_DATA           ; checks the next case if not equal
00001D5C  4EB8 1250               1106                  JSR     PRINT_ADDR          ; prints address
00001D60  4BF9 00002555           1107                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001D66  4EB9 000021FE           1108                  JSR     PRINTNULL           ; prints RTS                
00001D6C  4E75                    1109                  RTS                         ; returns from the subroutine
00001D6E                          1110  
00001D6E                          1111                  
00001D6E                          1112  
00001D6E  4EB8 196A               1113  CASE_DATA           JSR INV_INSTR  
00001D72  4E75                    1114                      RTS               
00001D74                          1115  
00001D74  4E75                    1116  CASE_EPICFAIL       RTS
00001D76                          1117  
00001D76                          1118  
00001D76                          1119  * Finds the EA type
00001D76                          1120  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001D76                          1121  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D76  48E7 3000               1122  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D7A  4A41                    1123                      TST.W     D1                    ; compares D1 to 0
00001D7C  6700 000E               1124                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001D80                          1125                      
00001D80  343C 01C0               1126  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001D84  363C 0006               1127                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001D88  6000 000A               1128                      BRA       FINDTYPEEA            
00001D8C                          1129  
00001D8C  343C 0038               1130  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001D90  363C 0003               1131                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001D94                          1132  
00001D94                          1133  
00001D94  3200                    1134  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001D96  C242                    1135                      AND.W     D2,D1                 ; applies bitmask to D1
00001D98  E669                    1136                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001D9A  4CDF 000C               1137                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001D9E  4E75                    1138                      RTS                             ; returns from subroutine    
00001DA0                          1139                      
00001DA0                          1140  * Finds Xn type
00001DA0                          1141  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001DA0                          1142  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001DA0  48E7 3000               1143  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001DA4  4A41                    1144                      TST.W     D1                    ; compares D1 to 0
00001DA6  6700 000E               1145                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001DAA                          1146  
00001DAA  343C 0E00               1147  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001DAE  363C 0009               1148                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001DB2  6000 000A               1149                      BRA       FINDTYPEXN            ; finds the type of Xn
00001DB6                          1150  
00001DB6  343C 0007               1151  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001DBA  363C 0000               1152                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001DBE                          1153                      
00001DBE  3200                    1154  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001DC0  C242                    1155                      AND.W     D2,D1                 ; applies bitmask to D1
00001DC2  E669                    1156                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001DC4  4CDF 000C               1157                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001DC8  4E75                    1158                      RTS                             ; returns from subroutine 
00001DCA                          1159                      
00001DCA                          1160  * Checks and gets the EA and Xn
00001DCA                          1161  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001DCA                          1162  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001DCA  3207                    1163  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001DCC  4EB8 1D76               1164                  JSR     GET_EA                  ; Gets EA
00001DD0  3401                    1165                  MOVE.W  D1,D2                   ; Stores EA in D2
00001DD2  3207                    1166                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001DD4  4EB8 1DA0               1167                  JSR     GET_XN                  ; Gets Xn
00001DD8  3601                    1168                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001DDA  3202                    1169                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001DDC                          1170                  
00001DDC  4EB9 00001F04           1171                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001DE2  B27C 0002               1172                  CMP.W   #2,D1                   ; checks if it is Xn
00001DE6  6700 0012               1173                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001DEA  B27C 0001               1174                  CMP.W   #1,D1                   ; Checks if it is invalid
00001DEE  6700 001C               1175                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001DF2                          1176                  
00001DF2                          1177                  
00001DF2  323C 0000               1178  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001DF6  6000 0018               1179                  BRA     END_CHECKGET
00001DFA                          1180        
00001DFA                          1181  ; need XN
00001DFA  2A4E                    1182  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001DFC  3203                    1183                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001DFE  4EB9 00001F04           1184                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001E04  4A41                    1185                  TST.W   D1                      ; checks if it is valid
00001E06  67EA                    1186                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001E08  6000 0002               1187                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001E0C                          1188   
00001E0C  323C 0001               1189  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001E10                          1190  
00001E10  4E75                    1191  END_CHECKGET    RTS          
00001E12                          1192                                            
00001E12                          1193                                            
00001E12                          1194  * Gets the displacement and pritns it 
00001E12                          1195  * Inputs: D2 = instruction word, A2 = address of next word
00001E12                          1196  * Outputs: prints out displacement
00001E12  48E7 4004               1197  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001E16  3A4A                    1198                      MOVE.W    A2,A5                 ; copies A2 to A5
00001E18  C47C 00FF               1199                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001E1C  6600 0004               1200                      BNE       PRINTADDRESS          ; prints address if not 0
00001E20  341A                    1201                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001E22                          1202                      
00001E22  D44D                    1203  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001E24  3202                    1204                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001E26  183C 0000               1205                      MOVE.B    #0,D4                 ; marks address as word  length
00001E2A  4BF9 00002571           1206                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001E30  4EB9 000021FE           1207                      JSR       PRINTNULL             ; prints null
00001E36  4EB9 000020D8           1208                      JSR       PRINTSHORTLONGNUM     ; prints address
00001E3C                          1209                      
00001E3C  4CDF 2002               1210                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001E40                          1211                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001E40                          1212  
00001E40                          1213  * Gets the rotation value for ASd and LSd
00001E40                          1214  * Input: D2 = instruction word copy (of D0)                                    
00001E40                          1215  * Output: rotation  value in D2             
00001E40  C47C 0E00               1216  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001E44  E04A                    1217                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E46  E24A                    1218                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001E48  4E75                    1219                      RTS                             ; return from subroutine
00001E4A                          1220  
00001E4A                          1221  * Gets the direction value for ASd and LSd
00001E4A                          1222  * Input: D2 = instruction word copy (of D0)                                    
00001E4A                          1223  * Output: direction value in D2             
00001E4A  C47C 0100               1224  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001E4E  E04A                    1225                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E50  4E75                    1226                      RTS                             ; return from subroutine
00001E52                          1227  
00001E52                          1228  * Gets the rotation size value for ASd and LSd
00001E52                          1229  * Input: D2 = instruction word copy (of D0)                                    
00001E52                          1230  * Output: rotation size value in D2             
00001E52  C47C 00C0               1231  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001E56  EC4A                    1232                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E58  4E75                    1233                      RTS                             ; return from subroutine
00001E5A                          1234  
00001E5A                          1235  * Gets the rotation location  value for ASd and LSd
00001E5A                          1236  * Input: D2 = instruction word copy (of D0)                                    
00001E5A                          1237  * Output: rotation location value in D2             
00001E5A  C47C 0020               1238  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001E5E  EA4A                    1239                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E60  4E75                    1240                      RTS                             ; return from subroutine
00001E62                          1241  
00001E62                          1242  * Prints out registers for MOVEM
00001E62                          1243  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001E62                          1244  * Output: printed out registers
00001E62                          1245  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001E62  48E7 0706               1246  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001E66  3A3C 0000               1247                      MOVE.W     #0,D5                ; sets counter to 0
00001E6A  3E1A                    1248                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001E6C  B83C 0001               1249                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E70  6600 0010               1250                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001E74                          1251  
00001E74  3C3C 0000               1252  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001E78  4BF9 00002563           1253                      LEA        MSG_DR,A5            ; loads D to A5
00001E7E  6000 000C               1254                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001E82                          1255                      
00001E82  3C3C 0007               1256  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001E86  4BF9 00002565           1257                      LEA        MSG_AR,A5            ; loads A to A5
00001E8C                          1258                      
00001E8C  E34F                    1259  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001E8E  6500 0018               1260                      BCS        PRINTREG             ; if pushes out a 1
00001E92  DC44                    1261                      ADD.W      D4,D6                ; decrements or increments
00001E94  5245                    1262                      ADD.W      #1,D5                ; increments D5
00001E96  BA7C 0008               1263                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001E9A  66F0                    1264                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001E9C  B83C 0001               1265                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EA0  6600 0052               1266                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001EA4  6000 0042               1267                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001EA8                          1268                      
00001EA8  4EB9 000021FE           1269  PRINTREG            JSR        PRINTNULL
00001EAE  3206                    1270                      MOVE.W     D6,D1
00001EB0  4EB9 000020B4           1271                      JSR        PRINTNUM 
00001EB6                          1272    
00001EB6  BE7C 0000               1273  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001EBA  6600 0006               1274                      BNE        PRINTMORE            ; continue if there is more
00001EBE  6000 0040               1275                      BRA        DONEPRINTINGREG      ; exit case
00001EC2                          1276  
00001EC2  2C4D                    1277  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001EC4  4BF9 00002576           1278                      LEA        MSG_SLASH,A5         ; leads / into A5
00001ECA  4EB9 000021FE           1279                      JSR        PRINTNULL            ; prints the slash
00001ED0  2A4E                    1280                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001ED2  DC44                    1281                      ADD.W      D4,D6                ; decrements or increments
00001ED4  5245                    1282                      ADD.W      #1,D5                ; increments D5
00001ED6  BA7C 0008               1283                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001EDA  66B0                    1284                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001EDC  B83C 0001               1285                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EE0  6600 0012               1286                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001EE4  6000 0002               1287                      BRA        REGTOMEM2            ; loops
00001EE8                          1288  
00001EE8  3C3C 0000               1289  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001EEC  4BF9 00002565           1290                      LEA        MSG_AR,A5            ; loads A to A5
00001EF2  6098                    1291                      BRA        PRINTREGISTERLOOP    ; loops
00001EF4                          1292  
00001EF4  3C3C 0007               1293  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001EF8  4BF9 00002563           1294                      LEA        MSG_DR,A5            ; loads D to A5
00001EFE  608C                    1295                      BRA        PRINTREGISTERLOOP    ; loops
00001F00                          1296  
00001F00  4CDF 60E0               1297  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001F04                          1298  
00001F04                          1299                          
00001F04                          1300  * Checks if EA or Xn is valid
00001F04                          1301  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001F04                          1302  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001F04  2F02                    1303  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001F06                          1304  
00001F06  141D                    1305  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001F08  B43C 00FF               1306                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001F0C  6700 000A               1307                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001F10  B202                    1308                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001F12  6700 000C               1309                     BEQ        VALIDEA               ; branches to valid EA
00001F16  60EE                    1310                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001F18                          1311                     
00001F18  323C 0001               1312  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001F1C  6000 0016               1313                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001F20                          1314                    
00001F20  B43C 0007               1315  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001F24  6700 000A               1316                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001F28  323C 0000               1317                     MOVE.W     #$0,D1                ; marks that it is valid
00001F2C  6000 0006               1318                     BRA        CHECKEAEXIT           ; exits the subroutine
00001F30                          1319  
00001F30  323C 0002               1320  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001F34                          1321  
00001F34  241F                    1322  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001F36  4E75                    1323                     RTS                              ; returns from subroutine
00001F38                          1324  
00001F38                          1325  * Converts EA and Xn into a string                                
00001F38                          1326  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001F38                          1327  * Outputs: Prints out EA and Xn into a string
00001F38  48E7 C004               1328  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001F3C  B47C 0001               1329                     CMP.W    #An,D2                  ; checks if it is An
00001F40  6700 003A               1330                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001F44                          1331                     
00001F44  B47C 0002               1332                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001F48  6700 004A               1333                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001F4C                          1334                     
00001F4C  B47C 0003               1335                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001F50  6700 0072               1336                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001F54                          1337                     
00001F54  B47C 0004               1338                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001F58  6700 00A6               1339                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001F5C                          1340                     
00001F5C  B47C 0007               1341                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001F60  6700 00DA               1342                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001F64                          1343                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001F64                          1344  
00001F64                          1345  * data register, Dn
00001F64  4BF9 00002563           1346  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001F6A  4EB9 000021FE           1347                     JSR      PRINTNULL               ; Prints D
00001F70  3203                    1348                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F72  4EB9 000020B4           1349                     JSR      PRINTNUM                ; Prints the Xn
00001F78  6000 0134               1350                     BRA      EA_TO_STRING_EXIT       ; exits           
00001F7C                          1351  
00001F7C                          1352  
00001F7C                          1353  * address register
00001F7C  4BF9 00002565           1354  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001F82  4EB9 000021FE           1355                     JSR      PRINTNULL               ; Prints A
00001F88  3203                    1356                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F8A  4EB9 000020B4           1357                     JSR      PRINTNUM                ; Prints the Xn
00001F90  6000 011C               1358                     BRA      EA_TO_STRING_EXIT       ; exits
00001F94                          1359  
00001F94                          1360  * address register indirect
00001F94  4BF9 00002567           1361  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001F9A  4EB9 000021FE           1362                     JSR      PRINTNULL               ; Prints (
00001FA0  4BF9 00002565           1363                     LEA      MSG_AR,A5               ; Loads A into A5
00001FA6  4EB9 000021FE           1364                     JSR      PRINTNULL               ; Prints A
00001FAC  3203                    1365                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FAE  4EB9 000020B4           1366                     JSR      PRINTNUM                ; Prints the Xn
00001FB4  4BF9 00002569           1367                     LEA      MSG_RB,A5               ; Loads ) into A5
00001FBA  4EB9 000021FE           1368                     JSR      PRINTNULL               ; Prints )
00001FC0  6000 00EC               1369                     BRA      EA_TO_STRING_EXIT       ; exits
00001FC4                          1370  
00001FC4                          1371  * address register indirect post increment
00001FC4  4BF9 00002567           1372  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001FCA  4EB9 000021FE           1373                     JSR      PRINTNULL               ; Prints (
00001FD0  4BF9 00002565           1374                     LEA      MSG_AR,A5               ; Loads A into A5
00001FD6  4EB9 000021FE           1375                     JSR      PRINTNULL               ; Prints A
00001FDC  3203                    1376                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FDE  4EB9 000020B4           1377                     JSR      PRINTNUM                ; Prints the Xn
00001FE4  4BF9 00002569           1378                     LEA      MSG_RB,A5               ; Loads ) into A5
00001FEA  4EB9 000021FE           1379                     JSR      PRINTNULL               ; Prints )
00001FF0  4BF9 0000256B           1380                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001FF6  4EB9 000021FE           1381                     JSR      PRINTNULL               ; Prints +
00001FFC  6000 00B0               1382                     BRA      EA_TO_STRING_EXIT       ; exits
00002000                          1383  
00002000                          1384  
00002000                          1385  * address register indirect pre increment
00002000  4BF9 0000256D           1386  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00002006  4EB9 000021FE           1387                     JSR      PRINTNULL               ; Prints -
0000200C  4BF9 00002567           1388                     LEA      MSG_LB,A5               ; Loads ( into A5
00002012  4EB9 000021FE           1389                     JSR      PRINTNULL               ; Prints (
00002018  4BF9 00002565           1390                     LEA      MSG_AR,A5               ; Loads A into A5
0000201E  4EB9 000021FE           1391                     JSR      PRINTNULL               ; Prints A
00002024  3203                    1392                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002026  4EB9 000020B4           1393                     JSR      PRINTNUM                ; Prints the Xn
0000202C  4BF9 00002569           1394                     LEA      MSG_RB,A5               ; Loads ) into A5
00002032  4EB9 000021FE           1395                     JSR      PRINTNULL               ; Prints )
00002038  6000 0074               1396                     BRA      EA_TO_STRING_EXIT       ; exits
0000203C                          1397  
0000203C                          1398  * other (long, short, immediate) with Xn yes
0000203C  301A                    1399  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
0000203E  B67C 0000               1400                     CMP.W    #ABSShort,D3            ; checks if it is a word
00002042  6700 002E               1401                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00002046                          1402                     
00002046  B67C 0001               1403                     CMP.W    #ABSLong,D3             ; checks if it is (An)
0000204A  6700 0042               1404                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
0000204E                          1405  
0000204E                          1406  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
0000204E                          1407  * immediate
0000204E  4BF9 0000256F           1408  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00002054  4EB9 000021FE           1409                     JSR      PRINTNULL               ; Prints #  
0000205A  4BF9 00002571           1410                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002060  4EB9 000021FE           1411                     JSR      PRINTNULL               ; Prints $
00002066  3200                    1412                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002068  4EB9 000020C4           1413                     JSR      PRINTHEXNUM 
0000206E  6000 003E               1414                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00002072                          1415                     
00002072                          1416  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00002072                          1417  
00002072                          1418  * word address
00002072                          1419  CASE_WORD          
00002072  4BF9 00002571           1420                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002078  4EB9 000021FE           1421                     JSR      PRINTNULL               ; Prints $
0000207E  3200                    1422                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002080  383C 0000               1423                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00002084  4EB9 000020D8           1424                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000208A  6000 0022               1425                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000208E                          1426  
0000208E                          1427  * long address 
0000208E                          1428  CASE_LONG          
0000208E  4BF9 00002571           1429                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002094  4EB9 000021FE           1430                     JSR      PRINTNULL               ; Prints $
0000209A  3200                    1431                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000209C  383C 0001               1432                     MOVE.W   #1, D4                  ; moves length size (long) into d4
000020A0  4EB9 000020D8           1433                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000020A6  321A                    1434                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
000020A8  4EB9 000020B4           1435                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
000020AE                          1436  
000020AE                          1437  
000020AE                          1438  * exits subroutine
000020AE  4CDF 2003               1439  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
000020B2  4E75                    1440                      RTS                              ; returns from subroutine
000020B4                          1441  
000020B4                          1442  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
000020B4                          1443  
000020B4                          1444  * Prints out the content of D1 as a decimal number
000020B4                          1445  * Input: number in D1 to be printed
000020B4                          1446  * Output: contents of D1 printed
000020B4  48E7 C000               1447  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000020B8  103C 0003               1448                   MOVE.B      #3,D0               ; prints D1
000020BC  4E4F                    1449                   TRAP        #15                 ; is trap task 3
000020BE                          1450              
000020BE  4CDF 0003               1451                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000020C2  4E75                    1452                   RTS                             ; returns from subroutine
000020C4                          1453                   
000020C4                          1454  * Prints out the content of D1 as a hex number
000020C4                          1455  * Input: number in D1 to be printed
000020C4                          1456  * Output: contents of D1 printed
000020C4  48E7 C000               1457  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000020C8  143C 0010               1458                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000020CC  103C 000F               1459                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000020D0  4E4F                    1460                   TRAP        #15                 ; is trap task 15
000020D2  4CDF 0003               1461                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000020D6  4E75                    1462                   RTS                             ; returns from subroutine
000020D8                          1463                   
000020D8                          1464  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
000020D8                          1465  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
000020D8                          1466  * Output: contents of D1 printed
000020D8  48E7 E000               1467  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
000020DC  B83C 0001               1468                            CMP.B       #1,D4               ; checks size of number
000020E0  6700 0042               1469                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
000020E4                          1470  
000020E4  3401                    1471  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
000020E6  C47C F000               1472                            AND.W       #$F000,D2           ; gets the first digit
000020EA  B47C 0000               1473                            CMP.W       #0, D2              ; checks if it is 0
000020EE  6600 00DC               1474                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020F2  4EB9 000021DC           1475                            JSR         PRINTZERO           ; prints a zero
000020F8                          1476                            
000020F8  3401                    1477                            MOVE.W      D1,D2               ; copies number to D2
000020FA  C47C 0F00               1478                            AND.W       #$0F00,D2           ; gets the second digit
000020FE  B47C 0000               1479                            CMP.W       #0, D2              ; checks if it is 0
00002102  6600 00C8               1480                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002106  4EB9 000021DC           1481                            JSR         PRINTZERO           ; prints a zero
0000210C                          1482                            
0000210C  3401                    1483                            MOVE.W      D1,D2               ; copies number to D2
0000210E  C47C 00F0               1484                            AND.W       #$00F0,D2           ; gets the third digit
00002112  B47C 0000               1485                            CMP.W       #0, D2              ; checks if it is 0
00002116  6600 00B4               1486                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000211A  4EB9 000021DC           1487                            JSR         PRINTZERO           ; prints a zero
00002120  6000 00AA               1488                            BRA         PRINTASHEX          ; prints last digit
00002124                          1489                            
00002124  2401                    1490  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00002126  C4BC F0000000           1491                            AND.L       #$F0000000,D2       ; gets the first digit
0000212C  B4BC 00000000           1492                            CMP.L       #0, D2              ; checks if it is 0
00002132  6600 0098               1493                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002136  4EB9 000021DC           1494                            JSR         PRINTZERO           ; prints a zero
0000213C                          1495                            
0000213C  2401                    1496                            MOVE.L      D1,D2               ; copies number to D2
0000213E  C4BC 0F000000           1497                            AND.L       #$0F000000,D2       ; gets the second digit
00002144  B4BC 00000000           1498                            CMP.L       #0, D2              ; checks if it is 0
0000214A  6600 0080               1499                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000214E  4EB9 000021DC           1500                            JSR         PRINTZERO           ; prints a zero
00002154                          1501                            
00002154  2401                    1502                            MOVE.L      D1,D2               ; copies number to D2
00002156  C4BC 00F00000           1503                            AND.L       #$00F00000,D2       ; gets the third digit
0000215C  B4BC 00000000           1504                            CMP.L       #0, D2              ; checks if it is 0
00002162  6600 0068               1505                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002166  4EB9 000021DC           1506                            JSR         PRINTZERO           ; prints a zero
0000216C                          1507                            
0000216C  2401                    1508                            MOVE.L      D1,D2               ; copies number to D2
0000216E  C4BC 000F0000           1509                            AND.L       #$000F0000,D2       ; gets the fourth digit
00002174  B4BC 00000000           1510                            CMP.L       #0, D2              ; checks if it is 0
0000217A  6600 0050               1511                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000217E  4EB9 000021DC           1512                            JSR         PRINTZERO           ; prints a zero
00002184                          1513                            
00002184  2401                    1514                            MOVE.L      D1,D2               ; copies number to D2
00002186  C4BC 0000F000           1515                            AND.L       #$0000F000,D2       ; gets the fith digit
0000218C  B4BC 00000000           1516                            CMP.L       #0, D2              ; checks if it is 0
00002192  6600 0038               1517                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002196  4EB9 000021DC           1518                            JSR         PRINTZERO           ; prints a zero
0000219C                          1519                            
0000219C  2401                    1520                            MOVE.L      D1,D2               ; copies number to D2
0000219E  C4BC 00000F00           1521                            AND.L       #$00000F00,D2       ; gets the sixth digit
000021A4  B4BC 00000000           1522                            CMP.L       #0, D2              ; checks if it is 0
000021AA  6600 0020               1523                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021AE  4EB9 000021DC           1524                            JSR         PRINTZERO           ; prints a zero
000021B4                          1525                            
000021B4  2401                    1526                            MOVE.L      D1,D2               ; copies number to D2
000021B6  C4BC 000000F0           1527                            AND.L       #$000000F0,D2       ; gets the seventh digit
000021BC  B4BC 00000000           1528                            CMP.L       #0, D2              ; checks if it is 0
000021C2  6600 0008               1529                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021C6  4EB9 000021DC           1530                            JSR         PRINTZERO           ; prints a zero
000021CC                          1531  
000021CC  143C 0010               1532  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000021D0  103C 000F               1533                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000021D4  4E4F                    1534                            TRAP        #15                 ; is trap task 15
000021D6  4CDF 0007               1535                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
000021DA  4E75                    1536                            RTS                             ; returns from subroutine    
000021DC                          1537  * Prints a zero
000021DC                          1538  * Input: nothing
000021DC                          1539  * Output: 0 printed out to the console
000021DC  2F01                    1540  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
000021DE  7200                    1541                            MOVE.L      #0,D1               ; moves 0 to D1
000021E0  4EB8 20B4               1542                            JSR         PRINTNUM            ; prints the number
000021E4  221F                    1543                            MOVE.L      (SP)+,D1            ; restores D1
000021E6  4E75                    1544                            RTS                             ; returns from subroutine
000021E8                          1545              
000021E8                          1546  * Prints contents of things between a range
000021E8                          1547  * input: A5, A6 (the range)
000021E8                          1548  * output: prints memory contents from A5 to A6 as strings   
000021E8  48E7 C040               1549  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
000021EC  224D                    1550                  MOVEA.L     A5, A1           ; loads A5 into A1
000021EE  9DCD                    1551                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
000021F0  320E                    1552                  MOVE.W      A6, D1           ; move n into D1
000021F2  103C 0001               1553                  MOVE.B      #1, D0           ; display n characters of string at A1
000021F6  4E4F                    1554                  TRAP        #15              ; is trap task 1
000021F8  4CDF 0203               1555                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
000021FC  4E75                    1556                  RTS                          ; returns
000021FE                          1557      
000021FE                          1558  * Prints null terminated string
000021FE                          1559  * input: string pointed to by A5
000021FE                          1560  * output: prints out the null terminated string
000021FE  48E7 8040               1561  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002202  224D                    1562                  MOVE.L      A5,A1           ; loads A5 into A1
00002204  103C 000E               1563                  MOVE.B      #14,D0          ; prints null terminated string
00002208  4E4F                    1564                  TRAP        #15             ; is trap task 10
0000220A  4CDF 0201               1565                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
0000220E  4E75                    1566                  RTS                         ; returns from subroutine
00002210                          1567                  
00002210  2F0D                    1568  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002212  4BF9 000024A2           1569                  LEA         NEW_LINE,A5     ; Prints null
00002218  4EB8 21FE               1570                  JSR         PRINTNULL       ; prints the new line
0000221C  2A5F                    1571                  MOVE.L      (SP)+,A5        ; returns A5
0000221E  4E75                    1572                  RTS
00002220                          1573  
00002220                          1574  * Prints the size of the MOVE or MOVEA operation  
00002220                          1575  * input: D0
00002220                          1576  * output: prints out the size of a MOVE or MOVEA operation        
00002220  48E7 8004               1577  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00002224  3200                    1578                  MOVE.W  D0,D1               ; stores d0 in d1
00002226  C07C 3000               1579                  AND.W   #$3000,D0           ; gets the size
0000222A  B07C 2000               1580                  CMP.W   #$2000,D0           ; checks if is long
0000222E  6700 001E               1581                  BEQ     MOVE_LONG
00002232  B07C 3000               1582                  CMP.W   #$3000,D0           ; checks if is word
00002236  6700 000C               1583                  BEQ     MOVE_WORD      
0000223A                          1584                  
0000223A  4BF9 0000259A           1585  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00002240  6000 0012               1586                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002244                          1587  
00002244  4BF9 0000259D           1588  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
0000224A  6000 0008               1589                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000224E                          1590  
0000224E  4BF9 000025A0           1591  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00002254                          1592                  
00002254  4EB8 21FE               1593  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00002258  4CDF 2001               1594                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
0000225C  4E75                    1595                  RTS
0000225E                          1596  
0000225E  43F9 00002409           1597  ERROR           LEA     ERROR_MSG,A1
00002264  103C 000E               1598                  MOVE.B  #14,D0
00002268  4E4F                    1599                  TRAP    #15 
0000226A                          1600         
0000226A                          1601  * DELETE THIS: Test                
0000226A  2661                    1602  DELETEME        MOVEA.L  -(A1),A3
0000226C  6700 0038               1603                  BEQ      DELETEMEAGAIN  
00002270  6F00 0034               1604                  BLE      DELETEMEAGAIN
00002274  6E00 0030               1605                  BGT      DELETEMEAGAIN
00002278                          1606  
00002278  E40A                    1607                  LSR.B      #2,D2
0000227A  E2E2                    1608                  LSR.W      -(A2)
0000227C  E2DA                    1609                  LSR.W      (A2)+
0000227E  E4AA                    1610                  LSR.L      D2,D2 
00002280  E50A                    1611                  LSL.B      #2,D2
00002282  E3E2                    1612                  LSL.W      -(A2)
00002284  E3DA                    1613                  LSL.W      (A2)+
00002286  E5AA                    1614                  LSL.L      D2,D2
00002288  E51A                    1615                  ROL.B      #2,D2
0000228A  E7E2                    1616                  ROL.W      -(A2)
0000228C  E7DA                    1617                  ROL.W      (A2)+
0000228E  E5BA                    1618                  ROL.L      D2,D2
00002290  E41A                    1619                  ROR.B      #2,D2
00002292  E6E2                    1620                  ROR.W      -(A2)
00002294  E6DA                    1621                  ROR.W      (A2)+
00002296  E4BA                    1622                  ROR.L      D2,D2
00002298                          1623                  
00002298  504D                    1624                  ADDQ.W      #8,A5
0000229A  D6C2                    1625                  ADDA.W      D2,A3
0000229C  9BCB                    1626                  SUB.L       A3,A5        
0000229E  8A43                    1627                  OR.W        D3,D5
000022A0  4642                    1628                  NOT.W       D2
000022A2                          1629                  
000022A2  C5FC 0010               1630                  MULS.W    #$0010,D2
000022A6                          1631                  
000022A6                          1632  DELETEMEAGAIN                 
000022A6                          1633            
000022A6  FFFF FFFF               1634      SIMHALT             ; halt simulator
000022AA                          1635  
000022AA                          1636  * Put variables and constants here
000022AA                          1637  
000022AA  =0000000D               1638  CR                              EQU     $0D
000022AA  =0000000A               1639  LF                              EQU     $0A 
000022AA  =00000009               1640  TAB                             EQU     $09  
000022AA                          1641  
000022AA                          1642  * Addressing Modes
000022AA  =00000000               1643  Dn                              EQU     0
000022AA  =00000001               1644  An                              EQU     1
000022AA  =00000002               1645  AnIndirect                      EQU     2
000022AA  =00000003               1646  AnPost                          EQU     3
000022AA  =00000004               1647  AnPre                           EQU     4
000022AA  =00000007               1648  Other                           EQU     7           ; short, long, immediate
000022AA                          1649  
000022AA                          1650  * Xn
000022AA  =00000000               1651  ABSShort                        EQU     0
000022AA  =00000001               1652  ABSLong                         EQU     1
000022AA  =00000004               1653  XnImmediate                     EQU     4
000022AA                          1654  
000022AA                          1655  * Valid Addressing Modes
000022AA= 00 01 02 03 04 07 FF    1656  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
000022B1                          1657  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
000022B1= 00 02 03 04 07 FF       1658  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022B7= 02 04 07 FF             1659  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
000022BB= 02 03 07 FF             1660  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
000022BF= 02 03 04 07 FF          1661  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022C4= 00 02 03 04 07 FF       1662  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022CA= 01 07 FF                1663  VALIDEA_LEA                     DC.B    An,Other,-1
000022CD= 00 02 03 04 07 FF       1664  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022D3= 02 03 04 07 FF          1665  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022D8= 02 03 04 07 FF          1666  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
000022DD= 02 07 FF                1667  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
000022E0                          1668  
000022E0                          1669  * Valid Xn
000022E0= 00 01 04 FF             1670  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
000022E4                          1671  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
000022E4= 00 01 FF                1672  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
000022E7                          1673  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
000022E7                          1674  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
000022E7                          1675  
000022E7                          1676  * posible memory ASd/LSd rotation values
000022E7  =00000000               1677  ASd_MEM                         EQU     0   
000022E7  =00000001               1678  LSd_MEM                         EQU     1 
000022E7  =00000003               1679  ROd_MEM                         EQU     3
000022E7                          1680   
000022E7  =00000000               1681  ASd_REG                         EQU     0   
000022E7  =00000001               1682  LSd_REG                         EQU     1 
000022E7  =00000003               1683  ROd_REG                         EQU     3
000022E7                          1684  
000022E7                          1685  * Messages
000022E7= 57 65 6C 63 6F 6D ...   1686  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
0000230F= 46 6F 72 6D 61 74 ...   1687  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
0000235A= 4C 65 74 74 65 72 ...   1688  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
0000237A= 50 6C 65 61 73 65 ...   1689  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
000023B1= 50 6C 65 61 73 65 ...   1690  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
000023E7= 49 6E 76 61 6C 69 ...   1691  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002409= 45 72 72 6F 72 20 ...   1692  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00002425= 31 30 30 30 20 20 ...   1693  INVALID_INSTR                   DC.B    '1000    ',TAB,'DATA',0
00002433= 46 69 6E 69 73 68 ...   1694  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
00002477= 0D 0A 50 72 65 73 ...   1695  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
000024A2= 0D 0A 00                1696  NEW_LINE                        DC.B    CR,LF,0
000024A5= 09 09 09 00             1697  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000024A9                          1698  
000024A9                          1699  * Opcode Messages
000024A9= 09 4E 4F 50 00          1700  MSG_NOP                         DC.B    TAB,'NOP',0
000024AE= 09 4D 4F 56 45 00       1701  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000024B4= 09 4D 4F 56 45 41 00    1702  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000024BB= 09 4D 4F 56 45 51 00    1703  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000024C2= 09 4D 4F 56 45 4D 00    1704  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000024C9= 09 41 44 44 00          1705  MSG_ADD                         DC.B    TAB,'ADD',0
000024CE= 09 41 44 44 41 00       1706  MSG_ADDA                        DC.B    TAB,'ADDA',0
000024D4= 09 41 44 44 51 00       1707  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
000024DA= 09 53 55 42 00          1708  MSG_SUB                         DC.B    TAB,'SUB',0
000024DF= 09 4D 55 4C 53 00       1709  MSG_MULS                        DC.B    TAB,'MULS',0
000024E5= 09 44 49 56 55 00       1710  MSG_DIVU                        DC.B    TAB,'DIVU',0
000024EB= 09 4C 45 41 00          1711  MSG_LEA                         DC.B    TAB,'LEA',0
000024F0= 09 41 4E 44 00          1712  MSG_AND                         DC.B    TAB,'AND',0
000024F5= 09 4F 52 00             1713  MSG_OR                          DC.B    TAB,'OR',0
000024F9= 09 4E 4F 54 00          1714  MSG_NOT                         DC.B    TAB,'NOT',0
000024FE= 09 4C 53 00             1715  MSG_LSd                         DC.B    TAB,'LS',0
00002502= 09 41 53 00             1716  MSG_ASd                         DC.B    TAB,'AS',0
00002506= 09 52 4F 00             1717  MSG_ROd                         DC.B    TAB,'RO',0
0000250A= 09 42 43 43 00          1718  MSG_BCC                         DC.B    TAB,'BCC',0
0000250F= 09 42 43 53 00          1719  MSG_BCS                         DC.B    TAB,'BCS',0
00002514= 09 42 45 51 00          1720  MSG_BEQ                         DC.B    TAB,'BEQ',0
00002519= 09 42 4E 45 00          1721  MSG_BNE                         DC.B    TAB,'BNE',0
0000251E= 09 42 47 45 00          1722  MSG_BGE                         DC.B    TAB,'BGE',0
00002523= 09 42 47 54 00          1723  MSG_BGT                         DC.B    TAB,'BGT',0
00002528= 09 42 48 49 00          1724  MSG_BHI                         DC.B    TAB,'BHI',0
0000252D= 09 42 4C 45 00          1725  MSG_BLE                         DC.B    TAB,'BLE',0
00002532= 09 42 4C 53 00          1726  MSG_BLS                         DC.B    TAB,'BLS',0
00002537= 09 42 4C 54 00          1727  MSG_BLT                         DC.B    TAB,'BLT',0
0000253C= 09 42 4D 49 00          1728  MSG_BMI                         DC.B    TAB,'BMI',0
00002541= 09 42 50 4C 00          1729  MSG_BPL                         DC.B    TAB,'BPL',0
00002546= 09 42 56 43 00          1730  MSG_BVC                         DC.B    TAB,'BVC',0
0000254B= 09 42 56 53 00          1731  MSG_BVS                         DC.B    TAB,'BVS',0
00002550= 09 4A 53 52 00          1732  MSG_JSR                         DC.B    TAB,'JSR',0
00002555= 09 52 54 53 00          1733  MSG_RTS                         DC.B    TAB,'RTS',0
0000255A= 09 42 52 41 00          1734  MSG_BRA                         DC.B    TAB,'BRA',0
0000255F                          1735  
0000255F                          1736  * Direction for LSd and ASd
0000255F= 52 00                   1737  MSG_RIGHT                       DC.B    'R',0
00002561= 4C 00                   1738  MSG_LEFT                        DC.B    'L',0
00002563                          1739  
00002563                          1740  * Effective Addresses Messages
00002563= 44 00                   1741  MSG_DR                          DC.B    'D',0
00002565= 41 00                   1742  MSG_AR                          DC.B    'A',0
00002567= 28 00                   1743  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002569= 29 00                   1744  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
0000256B= 2B 00                   1745  MSG_PLUS                        DC.B    '+',0
0000256D= 2D 00                   1746  MSG_MINUS                       DC.B    '-',0
0000256F= 23 00                   1747  MSG_POUND                       DC.B    '#',0 
00002571= 24 00                   1748  MSG_HEX                         DC.B    '$',0 
00002573= 2C 20 00                1749  MSG_COMMA                       DC.B    ', ',0
00002576= 2F 00                   1750  MSG_SLASH                       DC.B    '/',0  
00002578= 20 00                   1751  MSG_SPACE                       DC.B    ' ',0
0000257A= 09 00                   1752  MSG_TAB                         DC.B    TAB,0
0000257C= 20 20 20 00             1753  MSG_3SPACES                     DC.B    '   ',0
00002580= 20 20 20 20 00          1754  MSG_4SPACES                     DC.B    '    ',0
00002585= 20 20 20 20 20 00       1755  MSG_5SPACES                     DC.B    '     ',0
0000258B= 20 20 20 20 20 20 00    1756  MSG_6SPACES                     DC.B    '      ',0
00002592= 20 20 20 20 20 20 ...   1757  MSG_7SPACES                     DC.B    '       ',0
0000259A                          1758  
0000259A                          1759  * Size Messages
0000259A= 2E 42 00                1760  MSG_B                           DC.B    '.B',0
0000259D= 2E 57 00                1761  MSG_W                           DC.B    '.W',0
000025A0= 2E 4C 00                1762  MSG_L                           DC.B    '.L',0
000025A3                          1763  
000025A3                          1764  * Variables
000025A3  =00000100               1765  STARTING_ADDRESS                EQU     $100
000025A3  =00000150               1766  ENDING_ADDRESS                  EQU     $150
000025A3  =00000200               1767  CURRENT_INSTR                   EQU     $200
000025A3  =00000250               1768  REG_VAR                         EQU     $250 * Hold bits 11-9
000025A3  =00000300               1769  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000025A3  =00000350               1770  EA_MODE                         EQU     $350 * Hold bits 5-3
000025A3  =00000400               1771  EA_REG                          EQU     $400 * Hold bits 2-0
000025A3= 00                      1772  LINE_COUNT                      DC.B     0
000025A4= 0F                      1773  LINE_MAX                        DC.B     15
000025A5                          1774              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1644
ADDQ_BYTE           16E6
ADDQ_LONG           171E
ADDQ_WORD           1702
ADD_SUB_BYTE        1574
ADD_SUB_HELP        14EE
ADD_SUB_LONG        1590
ADD_SUB_OPERAND     15A6
ADD_SUB_SIZE        1550
ADD_SUB_WORD        1582
AN                  1
AND_BYTE            190C
AND_LONG            1944
AND_WORD            1928
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           23E7
CASE_ADD            14C2
CASE_ADDA           160C
CASE_ADDQ           168C
CASE_AND            18C2
CASE_AR             1F7C
CASE_ARI            1F94
CASE_ARIPOST        1FC4
CASE_ARIPRE         2000
CASE_ASDMEM         1AB4
CASE_ASDREG         1B8C
CASE_BCC            1CE4
CASE_BEQ            1D16
CASE_BGT            1D2A
CASE_BLE            1D20
CASE_BRA            1CB0
CASE_DATA           1D6E
CASE_DR             1F64
CASE_EPICFAIL       1D74
CASE_IMMEDIATE      204E
CASE_JSR            1D54
CASE_LEA            1824
CASE_LEFTMEM        1ADE
CASE_LEFTREG        1BB6
CASE_LONG           208E
CASE_LSDASDROD      1A74
CASE_LSDMEM         1AAA
CASE_LSDREG         1B82
CASE_MOVE           127A
CASE_MOVEM          1344
CASE_MOVEQ          145E
CASE_NOP            1260
CASE_NOT            1A0C
CASE_OR             19A8
CASE_OTHER          203C
CASE_RIGHTMEM       1AE8
CASE_RIGHTREG       1BC0
CASE_RODMEM         1ABE
CASE_RODREG         1B96
CASE_RTS            1D54
CASE_SHIFTMEM       1A92
CASE_SHIFTREG       1B68
CASE_SUB            1788
CASE_SUBA           180E
CASE_WORD           2072
CHECKEAEXIT         1F34
CHECKEAMLOOP        1F06
CHECKEAXN_IFVALID   1F04
CHECKGET_EAXN       1DCA
CHECKMEMSOURE       1B28
CHECKMOREBITS       1EB6
CHECKSHIFT_XN       1B52
CHECK_LENGTH        11B2
CHECK_LINE          115A
CHECK_ODD           1248
CHECK_ORDER         10AE
CHECK_XN            1DFA
CLEAR_SCREEN        118E
CONCAT              11FA
CONTINUE            2477
CONVERT             11C4
CR                  D
CURRENT_INSTR       200
DELETEME            226A
DELETEMEAGAIN       22A6
DESTEA              1D80
DESTXN              1DAA
DISASSEMBLE         10B8
DN                  0
DN_PLUS_EA          15E0
DONE                2433
DONEPRINTINGREG     1F00
EASHIFT_VALID       1B46
EAXN_INVALID        1E0C
EAXN_VALID          1DF2
EA_MODE             350
EA_REG              400
EA_TO_STRING        1F38
EA_TO_STRING_EXIT   20AE
ENDING              23B1
ENDING_ADDRESS      150
END_CHECKGET        1E10
ERROR               225E
ERROR_MSG           2409
FINDTYPEEA          1D94
FINDTYPEXN          1DBE
FINISHED            10DC
FINISHMOVE          2254
FINISH_ADD          159E
FINISH_ADDA         1660
FINISH_ADDQ         173A
FINISH_AND          1960
FINISH_SUB          17D4
FINISH_SUBA         17DA
FORMAT1             230F
FORMAT2             235A
GETDIRECTION        1E4A
GETDISPLACEMENT     1E12
GETMEMSOURCE        1B10
GETROTATION         1E40
GETROTATIONLOCATION  1E5A
GETROTATIONSIZE     1E52
GET_EA              1D76
GET_XN              1DA0
INPUT1              1020
INPUT2              1066
INSERTA             1304
INVALID             1212
INVALIDEA           1F18
INVALID_INSTR       2425
INV_INSTR           196A
ISNUMBER            11DA
LF                  A
LINE_COUNT          25A3
LINE_MAX            25A4
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         1422
MEM2REGWORD         1412
MEMTOREG1           1E82
MEMTOREG2           1EF4
MOVEM_MEM2REG       13DA
MOVEM_REG2MEM       1362
MOVE_BYTE           223A
MOVE_LONG           224E
MOVE_WORD           2244
MSG_3SPACES         257C
MSG_4SPACES         2580
MSG_5SPACES         2585
MSG_6SPACES         258B
MSG_7SPACES         2592
MSG_ADD             24C9
MSG_ADDA            24CE
MSG_ADDQ            24D4
MSG_AND             24F0
MSG_AR              2565
MSG_ASD             2502
MSG_B               259A
MSG_BCC             250A
MSG_BCS             250F
MSG_BEQ             2514
MSG_BGE             251E
MSG_BGT             2523
MSG_BHI             2528
MSG_BLE             252D
MSG_BLS             2532
MSG_BLT             2537
MSG_BMI             253C
MSG_BNE             2519
MSG_BPL             2541
MSG_BRA             255A
MSG_BVC             2546
MSG_BVS             254B
MSG_COMMA           2573
MSG_DIVU            24E5
MSG_DR              2563
MSG_HEX             2571
MSG_JSR             2550
MSG_L               25A0
MSG_LB              2567
MSG_LEA             24EB
MSG_LEFT            2561
MSG_LSD             24FE
MSG_MINUS           256D
MSG_MOVE            24AE
MSG_MOVEA           24B4
MSG_MOVEM           24C2
MSG_MOVEQ           24BB
MSG_MULS            24DF
MSG_NOP             24A9
MSG_NOT             24F9
MSG_OR              24F5
MSG_PLUS            256B
MSG_POUND           256F
MSG_RB              2569
MSG_RIGHT           255F
MSG_ROD             2506
MSG_RTS             2555
MSG_SLASH           2576
MSG_SPACE           2578
MSG_SUB             24DA
MSG_TAB             257A
MSG_W               259D
NEW_LINE            24A2
NEXT_SCREEN         116E
NOTNUMBER           11E2
OPCODE_DECODE       125C
OPMODE_VAR          300
OR_SIZE             19F4
OTHER               7
OTHEREA             1F30
PRINTADD            152C
PRINTADDRESS        1E22
PRINTASHEX          21CC
PRINTBCC            1D34
PRINTENTER          2210
PRINTHEXNUM         20C4
PRINTLONGZERO       2124
PRINTMEM2REG        142E
PRINTMORE           1EC2
PRINTMOVE           1322
PRINTMOVESIZE       2220
PRINTNULL           21FE
PRINTNUM            20B4
PRINTRANGE          21E8
PRINTREG            1EA8
PRINTREG2MEM        13AA
PRINTREGEA          1C02
PRINTREGISTERLOOP   1E8C
PRINTREGISTERS      1E62
PRINTREGSIZE        1BD0
PRINTSHIFTMEM       1AC4
PRINTSHIFTREG       1B9C
PRINTSHORTLONGNUM   20D8
PRINTSHORTZERO      20E4
PRINTSUB            17A2
PRINTZERO           21DC
PRINT_8             177C
PRINT_ADDQ_DATA     1758
PRINT_ADDR          1250
PRINT_MEMDIR        1AEE
PRINT_MOVEQ         1480
PRINT_REGDIR        1BCA
READ_KEY            117E
REG2MEMLONG         13A4
REG2MEMWORD         139A
REGTOMEM1           1E74
REGTOMEM2           1EE8
REG_BYTE            1BE8
REG_IMMEDIATE       1C24
REG_LONG            1BFC
REG_REGISTER        1C6A
REG_VAR             250
REG_WORD            1BF2
RESET_INPUT         11AA
RESTART             1104
RETURN              1210
ROD_MEM             3
ROD_REG             3
SOURCEEA            1D8C
SOURCEXN            1DB6
START               1000
STARTING            237A
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          1230
THREE_TAB           24A5
VALIDEA             1F20
VALIDEA_ADDSUB_DESTOPERAND  22BF
VALIDEA_ALL         22AA
VALIDEA_ANDORNOT    22CD
VALIDEA_ANDOR_DESTOPERAND  22D3
VALIDEA_JSR         22DD
VALIDEA_LEA         22CA
VALIDEA_MOVEM_MEMTOREG  22BB
VALIDEA_MOVEM_REGTOMEM  22B7
VALIDEA_MOVEQ       22B1
VALIDEA_MULSDIVU    22C4
VALIDEA_SHIFT       22D8
VALIDXN_ALL         22E0
VALIDXN_SHORTLONG   22E4
WELCOME             22E7
XNIMMEDIATE         4
