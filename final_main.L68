00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/9/2020 7:59:30 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/5/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 000022C7             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 000022EF             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 0000233A             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 0000235A             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011CE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011E0             36                  JSR     CONVERT
00001052  4EB9 0000124C             37                  JSR     TEST_RANGE
00001058  4EB9 00001264             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 00002391             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011CE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011E0             55                  JSR     CONVERT
0000109A  4EB9 0000124C             56                  JSR     TEST_RANGE
000010A0  4EB9 00001264             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0110                 64                  BLT     RESET_INPUT
000010B8  4BF9 0000247A             65                  LEA     NEW_LINE,A5
000010BE  4EB9 000021DE             66                  JSR     PRINTNULL
000010C4                            67                                 
000010C4                            68  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010C4                            69                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010C4                            70                  ; JSR     PRINTSHORTLONGNUM   ; prints out address
000010C4                            71                  
000010C4  1439 0000257B             72                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010CC  13C2 0000257B             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010D2                            75                  
000010D2  4EB9 00001278             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010D8                            77                  
000010D8  4EB9 00001176             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010DE                            79                  
000010DE  4EB9 000021F0             80                  JSR     PRINTENTER          ; prints a new line
000010E4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010E6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010E8                            83                  
000010E8                            84  
000010E8  4BF9 0000240B             85  FINISHED        LEA     DONE,A5
000010EE  4EB9 000021DE             86                  JSR     PRINTNULL
000010F4  103C 0005                 87                  MOVE.B  #5,D0
000010F8  4E4F                      88                  TRAP    #15
000010FA                            89                  
000010FA  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
000010FE  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001102                            92                  
00001102  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001106  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000110A                            95  
0000110A  103C 0009                 96                  MOVE.B  #9,D0
0000110E  4E4F                      97                  TRAP    #15
00001110                            98                  
00001110  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001114  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001118  4E4F                     101                  TRAP    #15                 Call Trap
0000111A                           102                  
0000111A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000111E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001122  4E4F                     105                  TRAP    #15
00001124                           106                  
00001124  1439 0000257B            107                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
0000112A  143C 0000                108                  MOVE.B  #0,D2               ; set variable to 0
0000112E  13C2 0000257B            109                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
00001134                           110   
00001134  207C 00000000            111                  MOVE.L  #$0000000, A0       ; Reset A1
0000113A  227C 00000000            112                  MOVE.L  #$0000000, A1       ; Reset A1
00001140  247C 00000000            113                  MOVE.L  #$0000000, A2       ; Reset A2
00001146  267C 00000000            114                  MOVE.L  #$0000000, A3       ; Reset A3
0000114C  287C 00000000            115                  MOVE.L  #$0000000, A4       ; Reset A4
00001152  2A7C 00000000            116                  MOVE.L  #$0000000, A5       ; Reset A5
00001158  2C7C 00000000            117                  MOVE.L  #$0000000, A6       ; Reset A6
0000115E  2E7C 01000000            118                  MOVEA.L #$01000000,A7       ; Reset A7
00001164  4281                     119                  CLR.L   D1                  ; Reset D1
00001166  4281                     120                  CLR.L   D1                  ; Reset D1
00001168  4282                     121                  CLR.L   D2                  ; Reset D2
0000116A  4283                     122                  CLR.L   D3                  ; Reset D3
0000116C  4284                     123                  CLR.L   D4                  ; Reset D4
0000116E  4285                     124                  CLR.L   D5                  ; Reset D5
00001170  4286                     125                  CLR.L   D6                  ; Reset D6
00001172  6000 FE8C                126                  BRA     START               ; branch to start of program
00001176                           127  
00001176                           128  *--------------------SUBROUTINES------------------
00001176  1439 0000257B            129  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000117C  1639 0000257C            130                  MOVE.B  LINE_MAX,D3                
00001182  B602                     131                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001184  6F00 0004                132                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001188  4E75                     133                  RTS
0000118A                           134  
0000118A  4BF9 0000244F            135  NEXT_SCREEN     LEA     CONTINUE,A5
00001190  4EB9 000021DE            136                  JSR     PRINTNULL
00001196  6000 0002                137                  BRA     READ_KEY
0000119A                           138                  
0000119A  103C 0005                139  READ_KEY        MOVE.B  #5,D0
0000119E  4E4F                     140                  TRAP    #15
000011A0                           141                  
000011A0  B23C 000D                142                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000011A4  6700 0004                143                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
000011A8  60F0                     144                  BRA     READ_KEY
000011AA                           145                  
000011AA  103C 000B                146  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
000011AE  323C FF00                147                  MOVE.W  #$FF00, D1          Clear Screen
000011B2  4E4F                     148                  TRAP    #15                 Call Trap
000011B4                           149                  
000011B4                           150                  ; reset line counter
000011B4  1439 0000257B            151                  MOVE.B  LINE_COUNT,D2
000011BA  143C 0000                152                  MOVE.B  #$0,D2
000011BE  13C2 0000257B            153                  MOVE.B  D2,LINE_COUNT
000011C4  4E75                     154                  RTS       
000011C6                           155      
000011C6                           156  
000011C6  143C 0001                157  RESET_INPUT     MOVE.B  #1,D2
000011CA  6000 0062                158                  BRA     INVALID            
000011CE                           159                  
000011CE  7800                     160  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011D0  B204                     161                  CMP.B   D4,D1               ; D1 stores length
000011D2  6700 005A                162                  BEQ     INVALID             ; input is null
000011D6  0C41 0008                163                  CMPI    #$8,D1              ; check if input is longer than a longword
000011DA  6600 0052                164                  BNE     INVALID             ; input is longer than a longword
000011DE  4E75                     165                  RTS
000011E0                           166                              
000011E0  4283                     167  CONVERT         CLR.L   D3
000011E2  4284                     168                  CLR.L   D4
000011E4  1619                     169                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011E6  B63C 0039                170                  CMP.B   #57,D3
000011EA  6E00 0012                171                  BGT     NOTNUMBER
000011EE                           172                  
000011EE  B63C 002F                173                  CMP.B   #47,D3
000011F2  6E00 0002                174                  BGT     ISNUMBER
000011F6                           175                  
000011F6  0603 00D0                176  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000011FA  6000 001A                177                  BRA     CONCAT
000011FE                           178              
000011FE  B63C 0041                179  NOTNUMBER       CMP.B   #65,D3
00001202  6D00 002A                180                  BLT     INVALID
00001206  B63C 0046                181                  CMP.B   #70,D3
0000120A  6E00 0022                182                  BGT     INVALID  
0000120E  0603 00C9                183                  ADD.B   #-55,D3             ; is letter             
00001212  6000 0002                184                  BRA     CONCAT
00001216                           185              
00001216  BC3C 0000                186  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000121A  6D00 0010                187                  BLT     RETURN
0000121E  1806                     188                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001220  E50C                     189                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001222  E9AB                     190                  LSL.L   D4,D3               ; moves current char to correct position  
00001224  DA83                     191                  ADD.L   D3,D5               ; D5 stores converted input so far
00001226  0606 00FF                192                  ADD.B   #-1,D6  
0000122A  60B4                     193                  BRA     CONVERT             ; continue loop for remaining chars
0000122C                           194                  
0000122C  4E75                     195  RETURN          RTS
0000122E                           196                  
0000122E  227C 00000000            197  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001234  43F9 000023C7            198                  LEA     BAD_INPUT,A1        ; output invalid message
0000123A  103C 000E                199                  MOVE.B  #14,D0
0000123E  4E4F                     200                  TRAP    #15
00001240  B47C 0001                201                  CMP     #1,D2
00001244  6700 FDDA                202                  BEQ     INPUT1
00001248  6000 FE1C                203                  BRA     INPUT2
0000124C                           204  
0000124C  4284                     205  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000124E  223C 00001000            206                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001254  BA81                     207                  CMP.L      D1,D5            ; Compare minimum address with input
00001256  6DD6                     208                  BLT        INVALID          ; input is too low. 
00001258  223C 00FFFFFE            209                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000125E  BA81                     210                  CMP.L      D1,D5            ; compare maximum address with input
00001260  6ECC                     211                  BGT        INVALID          ; input too large
00001262  4E75                     212                  RTS                         ; input is within range
00001264                           213             
00001264  0805 0000                214  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001268  66C4                     215                  BNE        INVALID
0000126A  4E75                     216                  RTS
0000126C                           217  
0000126C                           218  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
0000126C                           219  *                MOVE.L  A6,D1                   ; loads current address in D1
0000126C                           220  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
0000126C                           221  *                JSR     PRINTSHORTLONGNUM       ; prints out address
0000126C                           222  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
0000126C                           223  *                RTS
0000126C  220E                     224                  MOVE.L  A6,D1                   ; loads current address in D1
0000126E  7801                     225                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001270  4EB9 000020B8            226                  JSR     PRINTSHORTLONGNUM       ; prints out address
00001276  4E75                     227                  RTS
00001278                           228  
00001278                           229  
00001278                           230  
00001278                           231  * Checks every single possible opcode we could have. Jump table
00001278                           232  * Inputs: (A2) which is a pointer to intruction word to be translated
00001278                           233  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001278                           234  
00001278  3C4A                     235  OPCODE_DECODE   MOVE.W  A2,A6
0000127A  301A                     236                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000127C  4EB8 126C                237                  JSR     PRINT_ADDR
00001280                           238                  
00001280                           239  
00001280                           240  *---------------NOP opcode----------------------                
00001280  B07C 4E71                241  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001284  6600 0010                242                  BNE     CASE_MOVE               ; checks the next case if not equal
00001288                           243                  
00001288  4BF9 00002481            244                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000128E  4EB9 000021DE            245                  JSR     PRINTNULL               ; prints NOP                
00001294  4E75                     246                  RTS                             ; returns from the subroutine
00001296                           247  
00001296                           248  *---------------MOVE opcode----------------------              
00001296                           249                  * if first two bits are 00, next two are not 00
00001296  3200                     250  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001298  C27C C000                251                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000129C  6600 00BE                252                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
000012A0  B07C 0FFF                253                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000012A4  6F00 00B6                254                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
000012A8                           255                  
000012A8                           256                  ; Check source
000012A8  4BF9 0000228A            257                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012AE  4DF9 000022C0            258                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012B4  3E3C 0000                259                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012B8  4EB9 00001DAA            260                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012BE  B27C 0001                261                  CMP.W   #1,D1                    ; checks if invalid
000012C2  6700 0A8A                262                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012C6  3802                     263                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012C8  3A03                     264                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012CA                           265                  
000012CA                           266                  ; Check destination
000012CA  4BF9 0000228A            267                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012D0  4DF9 000022C4            268                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012D6  3E3C 0001                269                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012DA  4EB9 00001DAA            270                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012E0  B27C 0001                271                  CMP.W   #1,D1                    ; checks if invalid
000012E4  6700 0A68                272                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012E8  3C02                     273                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012EA  3E03                     274                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012EC                           275                  
000012EC                           276                  ; Checking if it is MOVEA
000012EC  3200                     277                  MOVE.W  D0,D1                    ; stores d0 in d1
000012EE  C27C 01C0                278                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000012F2  B27C 0040                279                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000012F6  6700 0024                280                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000012FA                           281                  
000012FA  4BF9 00002486            282                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001300  4EB9 000021DE            283                  JSR     PRINTNULL                ; prints out MOVE
00001306  4EB9 00002200            284                  JSR     PRINTMOVESIZE            ; prints out the size 
0000130C  4BF9 00002558            285                  LEA     MSG_4SPACES,A5           ; loads spaces
00001312  4EB9 000021DE            286                  JSR     PRINTNULL                ; prints out spaces
00001318  6000 0020                287                  BRA     PRINTMOVE                ; Branches to print move
0000131C                           288                  
0000131C  4BF9 0000248C            289  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001322  4EB9 000021DE            290                  JSR     PRINTNULL                ; prints out MOVEA
00001328  4EB9 00002200            291                  JSR     PRINTMOVESIZE            ; prints out the size 
0000132E  4BF9 00002554            292                  LEA     MSG_3SPACES,A5           ; loads spaces
00001334  4EB9 000021DE            293                  JSR     PRINTNULL                ; prints out spaces
0000133A                           294   
0000133A  3404                     295  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000133C  3605                     296                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000133E  4EB9 00001F18            297                  JSR     EA_TO_STRING             ; outputs it into a string
00001344                           298                  
00001344                           299                  ; prints a comma to seperate
00001344  4BF9 0000254B            300                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000134A  4EB9 000021DE            301                  JSR     PRINTNULL                ; prints out MOVE
00001350                           302                  
00001350                           303                  ; print destination
00001350  3406                     304                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001352  3607                     305                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001354  4EB9 00001F18            306                  JSR     EA_TO_STRING             ; outputs it into a string
0000135A  4E75                     307                  RTS                              ; exits subroutine                 
0000135C                           308                
0000135C                           309  *---------------MOVEM opcode----------------------                
0000135C  3200                     310  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000135E  C27C FB80                311                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001362  B27C 4880                312                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001366  6600 0106                313                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000136A                           314                  
0000136A                           315                  ; Check D
0000136A  3200                     316                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000136C  C27C 0400                317                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001370  3E01                     318                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001372  B27C 0400                319                  CMP.W   #$0400,D1                       ; checks if value is 1
00001376  6700 0076                320                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000137A                           321  
0000137A                           322  MOVEM_REG2MEM   ; loads EA and XN
0000137A  3E3C 0000                323                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000137E  4BF9 00002297            324                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001384  4DF9 000022C4            325                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000138A  4EB9 00001DAA            326                  JSR     CHECKGET_EAXN
00001390  B27C 0001                327                  CMP.W   #1,D1                           ; checks if D1 invalid
00001394  6700 09B8                328                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001398  4BF9 0000249A            329                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000139E  4EB9 000021DE            330                  JSR     PRINTNULL                       ; prints MOVEM
000013A4                           331                  
000013A4                           332                  ; finds and prints size
000013A4  3200                     333                  MOVE.W  D0,D1                           ; copies D0
000013A6  C27C 0040                334                  AND.W   #$0040,D1                       ; gets the size bit
000013AA  6600 000C                335                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000013AE                           336  
000013AE  4BF9 00002575            337  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013B4  6000 0008                338                  BRA     PRINTREG2MEM                    ; prints the registers           
000013B8                           339                  
000013B8  4BF9 00002578            340  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013BE                           341             
000013BE  4EB9 000021DE            342  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013C4  4BF9 00002554            343                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013CA  4EB9 000021DE            344                  JSR     PRINTNULL                       ; prints out spaces
000013D0  383C 0001                345                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013D4  4EB9 00001E42            346                  JSR     PRINTREGISTERS                  ; prints registers
000013DA  4BF9 0000254B            347                  LEA     MSG_COMMA,A5                    ; loads comma
000013E0  4EB9 000021DE            348                  JSR     PRINTNULL                       ; prints comma
000013E6  4EB9 00001F18            349                  JSR     EA_TO_STRING                    ; prints EA
000013EC  4E75                     350                  RTS
000013EE                           351  
000013EE                           352  MOVEM_MEM2REG  ; loads EA and XN
000013EE  3E3C 0000                353                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000013F2  4BF9 0000229B            354                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
000013F8  4DF9 000022C4            355                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000013FE  4EB9 00001DAA            356                  JSR     CHECKGET_EAXN
00001404  B27C 0001                357                  CMP.W   #1,D1                           ; checks if D1 invalid
00001408  6700 0944                358                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000140C  4BF9 0000249A            359                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001412  4EB9 000021DE            360                  JSR     PRINTNULL                       ; prints MOVEM
00001418                           361                  
00001418                           362                  ; finds and prints size
00001418  3200                     363                  MOVE.W  D0,D1                           ; copies D0
0000141A  C27C 0040                364                  AND.W   #$0040,D1                       ; gets the size bit
0000141E  6600 0012                365                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001422                           366  
00001422  4BF9 00002575            367  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001428  4EB9 000021DE            368                  JSR     PRINTNULL                       ; prints MOVEM
0000142E  6000 000E                369                  BRA     PRINTMEM2REG                    ; prints the registers           
00001432                           370                  
00001432  4BF9 00002578            371  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001438  4EB9 000021DE            372                  JSR     PRINTNULL                       ; prints MOVEM 
0000143E                           373             
0000143E  4EB9 000021DE            374  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
00001444  4BF9 00002554            375                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000144A  4EB9 000021DE            376                  JSR     PRINTNULL                       ; prints out spaces
00001450  4EB9 00001F18            377                  JSR     EA_TO_STRING                    ; prints EA
00001456  4BF9 0000254B            378                  LEA     MSG_COMMA,A5                    ; loads comma
0000145C  4EB9 000021DE            379                  JSR     PRINTNULL                       ; prints comma
00001462  383C FFFF                380                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001466  4EB9 00001E42            381                  JSR     PRINTREGISTERS                  ; prints registers
0000146C  4E75                     382                  RTS
0000146E                           383                          
0000146E                           384  
0000146E                           385  *---------------MOVEQ opcode----------------------
0000146E  3200                     386  CASE_MOVEQ      MOVE.W  D0,D1
00001470  C27C F100                387                  AND.W   #$F100,D1
00001474  B27C 7000                388                  CMP.W   #$7000,D1
00001478  6600 0054                389                  BNE     CASE_ADD
0000147C                           390                  
0000147C                           391                  ;loads Register
0000147C  323C 0001                392                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001480  4EB9 00001D80            393                  JSR     GET_XN                          ; gets XN and puts in D1
00001486  3401                     394                  MOVE.W  D1,D2                           ; copies Xn to D2 so it won't be overwritten
00001488                           395                  
00001488                           396                  ;loads DATA
00001488  3200                     397                  MOVE.W  D0,D1
0000148A  C27C 00FF                398                  AND.W   #$00FF,D1                       ;bit mask to get DATA
0000148E  3601                     399                  MOVE.W  D1,D3                          ;copy data into D3
00001490                           400                                                        ;must convert bits to hex
00001490                           401                                  
00001490  4BF9 00002493            402  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
00001496  4EB9 000021DE            403                  JSR     PRINTNULL  
0000149C                           404                  
0000149C  4BF9 00002554            405                  LEA     MSG_3SPACES,A5                  ; loads spaces
000014A2  4EB9 000021DE            406                  JSR     PRINTNULL                       ; prints out spaces
000014A8                           407                  
000014A8  4BF9 00002578            408                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014AE  4EB9 000021DE            409                  JSR     PRINTNULL
000014B4                           410      
000014B4  4BF9 0000247D            411                  LEA     THREE_TAB,A5                    ;PRINT THREE TABS
000014BA  4EB9 000021DE            412                  JSR     PRINTNULL
000014C0                           413                  
000014C0  4BF9 00002547            414                  LEA     MSG_POUND, A5                     ;PRINT HASHTAG
000014C6  4EB9 000021DE            415                  JSR     PRINTNULL
000014CC  4E75                     416                  RTS
000014CE                           417                  
000014CE                           418  *---------------ADD opcode----------------------                
000014CE                           419  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000014CE  3200                     420  CASE_ADD        MOVE.W  D0,D1
000014D0  C27C F000                421                  AND.W   #$F000,D1
000014D4  B27C D000                422                  CMP.W   #$D000,D1
000014D8  6600 01BA                423                  BNE     CASE_ADDQ
000014DC                           424                   
000014DC  4EB9 000014F6            425                  JSR     ADD_SUB_HELP
000014E2                           426                  
000014E2                           427                  ; bits 7-8 determine if it is ADDA or ADD
000014E2  3200                     428                  MOVE.W  D0,D1
000014E4  E149                     429                  LSL.W   #8,D1                   ; get rid of left 8 bits
000014E6  E049                     430                  LSR.W   #8,D1
000014E8  EC49                     431                  LSR.W   #6,D1                   ; get rid of right 6 bits
000014EA  B27C 0003                432                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
000014EE  6700 0124                433                  BEQ     CASE_ADDA
000014F2                           434                  
000014F2  6000 0040                435                  BRA     PRINTADD                ; Branches to print add
000014F6                           436                  
000014F6                           437                  ; Check bits 0-5 
000014F6  4BF9 0000228A            438  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000014FC  4DF9 000022C0            439                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001502  3E3C 0000                440                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001506  4EB9 00001DAA            441                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000150C  B27C 0001                442                  CMP.W       #1,D1                    ; checks if invalid
00001510  6700 083C                443                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001514  3802                     444                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001516  3A03                     445                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001518                           446                  
00001518                           447                  ; Check 6-11
00001518  4BF9 0000228A            448                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000151E  4DF9 000022C4            449                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001524  3E3C 0001                450                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001528  4EB9 00001DAA            451                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000152E  3C02                     452                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001530  3E03                     453                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
00001532                           454    
00001532  4E75                     455                  RTS                
00001534                           456                    
00001534  4BF9 000024A1            457  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
0000153A  4EB9 000021DE            458                  JSR         PRINTNULL               ; print ADD
00001540  3200                     459                  MOVE.W      D0,D1                   ; bits 7-8 contain size
00001542  4EB9 00001558            460                  JSR         ADD_SUB_SIZE
00001548  4BF9 0000255D            461                  LEA         MSG_5SPACES,A5          ; loads spaces
0000154E  4EB9 000021DE            462                  JSR         PRINTNULL               ; prints out spaces
00001554  6000 0050                463                  BRA         FINISH_ADD
00001558                           464                    
00001558  3200                     465  ADD_SUB_SIZE    MOVE.W      D0,D1
0000155A  E149                     466                  LSL.W       #8,D1
0000155C  E049                     467                  LSR.W       #8,D1
0000155E  EC49                     468                  LSR.W       #6,D1                   ; gets bits 6-7
00001560                           469                    
00001560  B27C 0000                470                  CMP.W       #0,D1
00001564  6700 0016                471                  BEQ         ADD_SUB_BYTE
00001568  B27C 0001                472                  CMP.W       #1,D1                   ; if 1, it is a word
0000156C  6700 001C                473                  BEQ         ADD_SUB_WORD
00001570  B27C 0002                474                  CMP.W       #2,D1                   ; if 2, it is a long
00001574  6700 0022                475                  BEQ         ADD_SUB_LONG
00001578  6000 0294                476                  BRA         CASE_SUBA               ; error
0000157C                           477                    
0000157C  4BF9 00002572            478  ADD_SUB_BYTE    LEA         MSG_B,A5
00001582  4EB9 000021DE            479                  JSR         PRINTNULL
00001588  4E75                     480                  RTS
0000158A                           481                    
0000158A  4BF9 00002575            482  ADD_SUB_WORD    LEA         MSG_W,A5
00001590  4EB9 000021DE            483                  JSR         PRINTNULL
00001596  4E75                     484                  RTS
00001598                           485    
00001598  4BF9 00002578            486  ADD_SUB_LONG    LEA         MSG_L,A5
0000159E  4EB9 000021DE            487                  JSR         PRINTNULL
000015A4  4E75                     488                  RTS
000015A6                           489        
000015A6  4EB9 000015AE            490  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015AC  4E75                     491                  RTS
000015AE                           492    
000015AE  EF49                     493  ADD_SUB_OPERAND LSL.W       #7,D1
000015B0  EE49                     494                  LSR.W       #7,D1
000015B2  E049                     495                  LSR.W       #8,D1
000015B4  B27C 0001                496                  CMP.W       #1,D1
000015B8  6600 002E                497                  BNE         Dn_PLUS_EA          
000015BC                           498                    
000015BC                           499                  ; print Data Register
000015BC  4BF9 0000253B            500                  LEA         MSG_DR,A5
000015C2  4EB9 000021DE            501                  JSR         PRINTNULL
000015C8  3207                     502                  MOVE.W      D7,D1
000015CA  4EB9 00002094            503                  JSR         PRINTNUM                
000015D0                           504                  
000015D0                           505                  ; prints a comma to seperate
000015D0  4BF9 0000254B            506                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015D6  4EB9 000021DE            507                  JSR         PRINTNULL                ; prints out MOVE
000015DC                           508                 
000015DC                           509                  ; below is EA+Dn->Dn  
000015DC  3404                     510                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015DE  3605                     511                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015E0  4EB9 00001F18            512                  JSR         EA_TO_STRING             ; outputs it into a string
000015E6  4E75                     513                  RTS                                 ; exits subroutine 
000015E8                           514  
000015E8                           515  Dn_PLUS_EA      ; below is Dn+EA->EA  
000015E8  3404                     516                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000015EA  3605                     517                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000015EC  4EB9 00001F18            518                  JSR         EA_TO_STRING             ; outputs it into a string   
000015F2                           519                  
000015F2                           520                  ; prints a comma to seperate
000015F2  4BF9 0000254B            521                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015F8  4EB9 000021DE            522                  JSR         PRINTNULL                ; prints out MOVE
000015FE                           523                  
000015FE                           524                  ; below is Dn+EA->EA
000015FE  4BF9 0000253B            525                  LEA         MSG_DR,A5                ; print data register
00001604  4EB9 000021DE            526                  JSR         PRINTNULL
0000160A  3207                     527                  MOVE.W      D7,D1
0000160C  4EB9 00002094            528                  JSR         PRINTNUM             
00001612  4E75                     529                  RTS                                  ; exits subroutine          
00001614                           530                        
00001614                           531  *---------------ADDA opcode----------------------
00001614                           532  CASE_ADDA       ; gets bit 8 (size bit)
00001614  3200                     533                  MOVE.W      D0,D1
00001616  EF49                     534                  LSL.W       #7,D1
00001618  EE49                     535                  LSR.W       #7,D1
0000161A  E049                     536                  LSR         #8,D1                   
0000161C                           537                  
0000161C  4BF9 000024A6            538                  LEA         MSG_ADDA,A5             ; print ADDA
00001622  4EB9 000021DE            539                  JSR         PRINTNULL
00001628                           540                   
00001628  B27C 0001                541                  CMP.W       #1,D1
0000162C  6700 001E                542                  BEQ         ADDA_LONG
00001630                           543                    
00001630  4BF9 00002575            544                  LEA         MSG_W,A5
00001636  4EB9 000021DE            545                  JSR         PRINTNULL
0000163C  4BF9 00002558            546                  LEA         MSG_4SPACES,A5          ; loads spaces
00001642  4EB9 000021DE            547                  JSR         PRINTNULL               ; prints out spaces
00001648  6000 001E                548                  BRA         FINISH_ADDA   
0000164C                           549                    
0000164C  4BF9 00002578            550  ADDA_LONG       LEA         MSG_L,A5
00001652  4EB9 000021DE            551                  JSR         PRINTNULL
00001658  4BF9 00002558            552                  LEA         MSG_4SPACES,A5          ; loads spaces
0000165E  4EB9 000021DE            553                  JSR         PRINTNULL               ; prints out spaces
00001664  6000 0002                554                  BRA         FINISH_ADDA
00001668                           555                    
00001668  3404                     556  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000166A  3605                     557                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000166C  4EB9 00001F18            558                  JSR         EA_TO_STRING             ; outputs it into a string
00001672                           559                    
00001672                           560                  ; prints a comma to seperate
00001672  4BF9 0000254B            561                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001678  4EB9 000021DE            562                  JSR         PRINTNULL                ; prints out MOVE
0000167E                           563            
0000167E  4BF9 0000253D            564                  LEA         MSG_AR,A5                ; print address register
00001684  4EB9 000021DE            565                  JSR         PRINTNULL
0000168A  3207                     566                  MOVE.W      D7,D1
0000168C  4EB9 00002094            567                  JSR         PRINTNUM             
00001692  4E75                     568                  RTS                              ; exits subroutine
00001694                           569                  
00001694                           570  *---------------ADDQ opcode----------------------                  
00001694  3200                     571  CASE_ADDQ       MOVE.W      D0,D1
00001696  C27C F000                572                  AND.W       #$F000,D1       
0000169A  B27C 5000                573                  CMP.W       #$5000,D1
0000169E  6600 00EC                574                  BNE         CASE_SUB
000016A2                           575                                                   
000016A2  4BF9 000024AC            576                  LEA         MSG_ADDQ,A5             ; print ADDQ
000016A8  4EB9 000021DE            577                  JSR         PRINTNULL
000016AE                           578                  
000016AE                           579                  ; get bits 6-7 (size bits)
000016AE  3200                     580                  MOVE.W      D0,D1
000016B0  E149                     581                  LSL.W       #8,D1
000016B2  E049                     582                  LSR.W       #8,D1
000016B4  EC49                     583                  LSR.W       #6,D1
000016B6  3401                     584                  MOVE.W      D1,D2
000016B8                           585                  
000016B8                           586                  ; Check bits 0-5 
000016B8  4BF9 0000228A            587                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016BE  4DF9 000022C0            588                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016C4  3E3C 0000                589                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016C8  4EB9 00001DAA            590                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000016CE  B27C 0001                591                  CMP.W       #1,D1                    ; checks if invalid
000016D2  6700 067A                592                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000016D6  3802                     593                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
000016D8  3A03                     594                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
000016DA                           595                  
000016DA  B47C 0001                596                  CMP.W       #1,D2
000016DE  6700 0026                597                  BEQ         ADDQ_WORD
000016E2  B47C 0002                598                  CMP.W       #2,D2
000016E6  6700 003A                599                  BEQ         ADDQ_LONG
000016EA                           600                    
000016EA  4BF9 00002572            601  ADDQ_BYTE       LEA         MSG_B,A5
000016F0  4EB9 000021DE            602                  JSR         PRINTNULL
000016F6  4BF9 00002558            603                  LEA         MSG_4SPACES,A5          ; loads spaces
000016FC  4EB9 000021DE            604                  JSR         PRINTNULL               ; prints out spaces
00001702  6000 003A                605                  BRA         FINISH_ADDQ  
00001706                           606   
00001706  4BF9 00002575            607  ADDQ_WORD       LEA         MSG_W,A5
0000170C  4EB9 000021DE            608                  JSR         PRINTNULL
00001712  4BF9 00002558            609                  LEA         MSG_4SPACES,A5          ; loads spaces
00001718  4EB9 000021DE            610                  JSR         PRINTNULL               ; prints out spaces
0000171E  6000 001E                611                  BRA         FINISH_ADDQ                 
00001722                           612    
00001722  4BF9 00002578            613  ADDQ_LONG       LEA         MSG_L,A5
00001728  4EB9 000021DE            614                  JSR         PRINTNULL
0000172E  4BF9 00002558            615                  LEA         MSG_4SPACES,A5          ; loads spaces
00001734  4EB9 000021DE            616                  JSR         PRINTNULL               ; prints out spaces
0000173A  6000 0002                617                  BRA         FINISH_ADDQ                  
0000173E                           618                    
0000173E  4EB9 0000175C            619  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001744                           620   
00001744                           621                  ; prints a comma to seperate
00001744  4BF9 0000254B            622                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000174A  4EB9 000021DE            623                  JSR         PRINTNULL                ; prints out MOVE
00001750                           624                    
00001750                           625                  ; prints destination
00001750  3404                     626                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001752  3605                     627                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001754  4EB9 00001F18            628                  JSR         EA_TO_STRING             ; outputs it into a string
0000175A                           629                 
0000175A  4E75                     630                  RTS
0000175C                           631   
0000175C  4BF9 00002547            632  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
00001762  4EB9 000021DE            633                  JSR         PRINTNULL
00001768                           634                  ; gets bits 9-11 (data bits)
00001768  E949                     635                  LSL.W       #4,D1
0000176A  E849                     636                  LSR.W       #4,D1                               ; get rid of left 4 bits
0000176C  E049                     637                  LSR.W       #8,D1
0000176E  E249                     638                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001770                           639                  
00001770  B27C 0000                640                  CMP.W       #0,D1
00001774  6700 000A                641                  BEQ         PRINT_8
00001778  4EB9 00002094            642                  JSR         PRINTNUM
0000177E  4E75                     643                  RTS 
00001780                           644  
00001780  123C 0008                645  PRINT_8         MOVE.B      #8,D1
00001784  4EB9 00002094            646                  JSR         PRINTNUM
0000178A  4E75                     647                  RTS   
0000178C                           648         
0000178C                           649  *---------------SUB opcode---------------------- 
0000178C  3200                     650  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
0000178E  C27C F000                651                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001792  B27C 9000                652                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001796  6600 008C                653                  BNE         CASE_LEA
0000179A                           654                 
0000179A  4EB8 14F6                655                  JSR         ADD_SUB_HELP
0000179E                           656                  
0000179E  6000 0002                657                  BRA         PRINTSUB                            ; Branches to print sub
000017A2                           658  
000017A2  4BF9 000024B2            659  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017A8  4EB9 000021DE            660                  JSR         PRINTNULL
000017AE  3200                     661                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017B0  4EB8 1558                662                  JSR         ADD_SUB_SIZE
000017B4  4BF9 0000255D            663                  LEA         MSG_5SPACES,A5                      ; loads spaces
000017BA  4EB9 000021DE            664                  JSR         PRINTNULL                           ; prints out spaces
000017C0  3200                     665                  MOVE.W      D0,D1
000017C2  E149                     666                  LSL.W       #8,D1
000017C4  E049                     667                  LSR.W       #8,D1
000017C6  EC49                     668                  LSR.W       #6,D1
000017C8  B27C 0003                669                  CMP.W       #3,D1
000017CC  6600 0006                670                  BNE         FINISH_SUB
000017D0  6000 0008                671                  BRA         FINISH_SUBA                         ; same as ADDA
000017D4                           672                  
000017D4  4EB8 15AE                673  FINISH_SUB      JSR         ADD_SUB_OPERAND
000017D8  4E75                     674                  RTS
000017DA                           675                    
000017DA  3404                     676  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000017DC  3605                     677                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000017DE  4EB9 00001F18            678                  JSR         EA_TO_STRING             ; outputs it into a string
000017E4                           679                
000017E4                           680                  ; prints a comma to seperate
000017E4  4BF9 0000254B            681                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000017EA  4EB9 000021DE            682                  JSR         PRINTNULL                ; prints out MOVE
000017F0                           683                  
000017F0  4BF9 0000253D            684                  LEA         MSG_AR,A5                ; print address register
000017F6  4EB9 000021DE            685                  JSR         PRINTNULL
000017FC  3200                     686                  MOVE.W      D0,D1
000017FE  E949                     687                  LSL.W       #4,D1
00001800  E849                     688                  LSR.W       #4,D1
00001802  E049                     689                  LSR.W       #8,D1
00001804  E249                     690                  LSR.W       #1,D1
00001806  4EB9 00002094            691                  JSR         PRINTNUM             
0000180C  4E75                     692                  RTS                              ; exits subroutine
0000180E                           693  
0000180E                           694  
0000180E                           695  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
0000180E  3200                     696  CASE_SUBA       MOVE.W      D0,D1
00001810  EF49                     697                  LSL.W       #7,D1
00001812  EE49                     698                  LSR.W       #7,D1
00001814  E049                     699                  LSR.W       #8,D1
00001816  B23C 0000                700                  CMP.B       #0,D1
0000181A  6700 FD6E                701                  BEQ         ADD_SUB_WORD
0000181E  6000 FD78                702                  BRA         ADD_SUB_LONG
00001822  4E75                     703                  RTS         
00001824                           704                   
00001824  3200                     705  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001826  C27C F000                706                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
0000182A  B27C 4000                707                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
0000182E  6600 0092                708                  BNE.W   CASE_AND                             ; If its not, check AND
00001832  3200                     709                  MOVE.W  D0,D1                                ; Copies instruction word to D1
00001834  C27C 01C0                710                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001838  B27C 01C0                711                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
0000183C  6600 0084                712                  BNE.W   CASE_AND                             ; If its not, check AND
00001840                           713                  
00001840                           714                  ; Check source
00001840  4BF9 000022AA            715                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001846  4DF9 000022C4            716                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000184C  3E3C 0000                717                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001850  4EB9 00001DAA            718                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001856  3802                     719                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001858  3A03                     720                  MOVE.W  D3,D5                                ; Saves D2 in D4
0000185A                           721                  
0000185A                           722                  ; Check destination
0000185A  4BF9 000022AA            723                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001860  4DF9 000022C4            724                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001866  3E3C 0001                725                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
0000186A  4EB9 00001DAA            726                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001870  3C02                     727                  MOVE.W  D2,D6                                ; Saves D2 in D4
00001872  3E03                     728                  MOVE.W  D3,D7                                ; Saves D2 in D4
00001874                           729  
00001874  4BF9 000024C3            730                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
0000187A  4EB9 000021DE            731                  JSR     PRINTNULL                            ; prints LEA
00001880  4BF9 0000256A            732                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001886  4EB9 000021DE            733                  JSR     PRINTNULL                            ; prints out spaces
0000188C                           734                  
0000188C                           735                  ; print source
0000188C  3404                     736                  MOVE.W  D4,D2
0000188E  3605                     737                  MOVE.W  D5,D3
00001890  4EB9 00001F18            738                  JSR     EA_TO_STRING                         ; Prints out the EA
00001896                           739                  
00001896                           740                  ; comma
00001896  4BF9 0000254B            741                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
0000189C  4EB9 000021DE            742                  JSR     PRINTNULL                       
000018A2                           743                   
000018A2                           744                  ; register
000018A2  4BF9 0000253D            745                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018A8  4EB9 000021DE            746                  JSR     PRINTNULL 
000018AE  3401                     747                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018B0  323C 0001                748                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000018B4  4EB9 00001D80            749                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000018BA  4EB9 00002094            750                  JSR     PRINTNUM                             ; Prints the number in D1
000018C0  4E75                     751                  RTS
000018C2                           752  
000018C2                           753  *---------------AND opcode----------------------
000018C2  3200                     754  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018C4  C27C F000                755                  AND.W       #$F000,D1       
000018C8  B27C C000                756                  CMP.W       #$C000,D1
000018CC  6600 00D6                757                  BNE         CASE_OR
000018D0                           758                  
000018D0  3200                     759                  MOVE.W      D0,D1
000018D2  E149                     760                  LSL.W       #8,D1
000018D4  E049                     761                  LSR.W       #8,D1
000018D6  EC49                     762                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000018D8  3C01                     763                  MOVE.W      D1,D6
000018DA  BC7C 0003                764                  CMP.W       #3,D6
000018DE  6700 0086                765                  BEQ         INV_INSTR
000018E2                           766                  
000018E2  4BF9 000024C8            767                  LEA         MSG_AND,A5                      ; print AND
000018E8  4EB9 000021DE            768                  JSR         PRINTNULL
000018EE                           769                  
000018EE  3206                     770                  MOVE.W      D6,D1
000018F0  B27C 0000                771                  CMP.W       #0,D1
000018F4  6700 0012                772                  BEQ         AND_BYTE
000018F8  B27C 0001                773                  CMP.W       #1,D1                   ; if 1, it is a word
000018FC  6700 0026                774                  BEQ         AND_WORD
00001900  B27C 0002                775                  CMP.W       #2,D1                   ; if 2, it is a long
00001904  6700 003A                776                  BEQ         AND_LONG
00001908                           777                  
00001908  4BF9 00002572            778  AND_BYTE        LEA         MSG_B,A5
0000190E  4EB9 000021DE            779                  JSR         PRINTNULL
00001914  4BF9 0000256A            780                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000191A  4EB9 000021DE            781                  JSR         PRINTNULL                       ; prints out spaces
00001920  6000 003A                782                  BRA         FINISH_AND
00001924                           783                                    
00001924  4BF9 00002575            784  AND_WORD        LEA         MSG_W,A5
0000192A  4EB9 000021DE            785                  JSR         PRINTNULL
00001930  4BF9 0000256A            786                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001936  4EB9 000021DE            787                  JSR         PRINTNULL                       ; prints out spaces
0000193C  6000 001E                788                  BRA         FINISH_AND
00001940                           789    
00001940  4BF9 00002578            790  AND_LONG        LEA         MSG_L,A5
00001946  4EB9 000021DE            791                  JSR         PRINTNULL
0000194C  4BF9 0000256A            792                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001952  4EB9 000021DE            793                  JSR         PRINTNULL                       ; prints out spaces
00001958  6000 0002                794                  BRA         FINISH_AND
0000195C                           795        
0000195C  4EB8 14F6                796  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001960  4EB8 15AE                797                  JSR         ADD_SUB_OPERAND
00001964  4E75                     798                  RTS
00001966                           799                  
00001966  4BF9 00002405            800  INV_INSTR       LEA         INVALID_INSTR,A5
0000196C  4EB9 000021DE            801                  JSR         PRINTNULL
00001972  4BF9 00002563            802                  LEA         MSG_6SPACES,A5
00001978  4EB9 000021DE            803                  JSR         PRINTNULL
0000197E  4BF9 00002549            804                  LEA         MSG_HEX,A5
00001984  4EB9 000021DE            805                  JSR         PRINTNULL
0000198A  2200                     806                  MOVE.L      D0,D1
0000198C  383C 0000                807                  MOVE.W      #0,D4
00001990  4EB9 000020B8            808                  JSR         PRINTSHORTLONGNUM
00001996  4BF9 0000247A            809                  LEA         NEW_LINE,A5
0000199C  4EB9 000021DE            810                  JSR         PRINTNULL
000019A2  4E75                     811                  RTS               
000019A4                           812                  
000019A4                           813  *---------------OR opcode----------------------            
000019A4  3200                     814  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019A6  C27C F000                815                  AND.W       #$F000,D1       
000019AA  B27C 8000                816                  CMP.W       #$8000,D1
000019AE  6600 0054                817                  BNE         CASE_NOT
000019B2                           818                                                
000019B2  3200                     819                  MOVE.W      D0,D1
000019B4  E149                     820                  LSL.W       #8,D1
000019B6  E049                     821                  LSR.W       #8,D1
000019B8  EC49                     822                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019BA  B27C 0003                823                  CMP.W       #3,D1
000019BE  3C01                     824                  MOVE.W      D1,D6
000019C0  67A4                     825                  BEQ         INV_INSTR
000019C2                           826                  
000019C2                           827                  
000019C2  4BF9 000024CD            828                  LEA         MSG_OR,A5
000019C8  4EB9 000021DE            829                  JSR         PRINTNULL                       ; print "OR"
000019CE                           830                  
000019CE  3206                     831                  MOVE.W      D6,D1
000019D0  4EB9 000019EC            832                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000019D6  4BF9 00002563            833                  LEA         MSG_6SPACES,A5                  ; loads spaces
000019DC  4EB9 000021DE            834                  JSR         PRINTNULL                       ; prints out spaces
000019E2                           835  
000019E2  4EB8 14F6                836                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
000019E6  4EB8 15AE                837                  JSR         ADD_SUB_OPERAND                 ; print 
000019EA  4E75                     838                  RTS
000019EC                           839  
000019EC  B27C 0000                840  OR_SIZE         CMP.W       #0,D1
000019F0  6700 FB8A                841                  BEQ         ADD_SUB_BYTE
000019F4  B27C 0001                842                  CMP.W       #1,D1                   ; if 1, it is a word
000019F8  6700 FB90                843                  BEQ         ADD_SUB_WORD
000019FC  B27C 0002                844                  CMP.W       #2,D1                   ; if 2, it is a long
00001A00  6700 FB96                845                  BEQ         ADD_SUB_LONG
00001A04                           846                  ; no need for rts, since ADD_SUB_ already has                
00001A04                           847  
00001A04                           848  *---------------NOT opcode----------------------
00001A04  3200                     849  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A06  C27C FF00                850                  AND.W       #$FF00,D1       
00001A0A  B27C 4600                851                  CMP.W       #$4600,D1
00001A0E  6600 0058                852                  BNE         CASE_LSDASDROD
00001A12                           853                 
00001A12                           854                  ; get bits 6-7 (size)
00001A12  3200                     855                  MOVE.W      D0,D1
00001A14  E149                     856                  LSL.W       #8,D1
00001A16  E049                     857                  LSR.W       #8,D1
00001A18  EC49                     858                  LSR.W       #6,D1 
00001A1A  3C01                     859                  MOVE.W      D1,D6                         
00001A1C  BC7C 0003                860                  CMP.W       #3,D6
00001A20  6700 FF44                861                  BEQ         INV_INSTR
00001A24                           862                                  
00001A24  4BF9 000024D1            863                  LEA         MSG_NOT,A5
00001A2A  4EB9 000021DE            864                  JSR         PRINTNULL                       ; print "NOT"
00001A30                           865                                 
00001A30  3206                     866                  MOVE.W      D6,D1
00001A32                           867  
00001A32  4EB8 19EC                868                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A36  4BF9 0000255D            869                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A3C  4EB9 000021DE            870                  JSR         PRINTNULL                       ; prints out spaces
00001A42                           871                  
00001A42                           872                  ; get bits 0-5 
00001A42  4BF9 0000228A            873                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A48  4DF9 000022C0            874                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A4E  3E3C 0000                875                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A52  4EB9 00001DAA            876                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A58  B27C 0001                877                  CMP.W       #1,D1                    ; checks if invalid
00001A5C  6700 02F0                878                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001A60  4EB9 00001F18            879                  JSR         EA_TO_STRING             ; outputs it into a string
00001A66                           880    
00001A66  4E75                     881                  RTS
00001A68                           882  
00001A68  3200                     883  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001A6A  C27C F000                884                  AND.W       #$F000, D1                       ; gets first 4 bits
00001A6E  B27C E000                885                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001A72  6600 0228                886                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001A76  3400                     887                  MOVE.W      D0,D2                            ; copies D0 to D2
00001A78  4EB9 00001E32            888                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001A7E  B47C 0003                889                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001A82  6600 00D4                890                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001A86                           891                  
00001A86  3400                     892  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001A88  4EB9 00001E20            893                  JSR         GETROTATION                      ; gets rotation value of D2
00001A8E  B47C 0000                894                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001A92  6700 0014                895                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001A96  B47C 0003                896                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001A9A  6700 0016                897                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001A9E                           898                  
00001A9E  4BF9 000024D6            899  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001AA4  6000 0012                900                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AA8                           901  
00001AA8  4BF9 000024DA            902  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001AAE  6000 0008                903                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AB2                           904  
00001AB2  4BF9 000024DE            905  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AB8                           906                  
00001AB8  4EB9 000021DE            907  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001ABE  3400                     908                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AC0  4EB9 00001E2A            909                  JSR         GETDIRECTION                     ; gets direction
00001AC6  B47C 0000                910                  CMP.W       #0,D2                            ; checking if its right
00001ACA  6700 000C                911                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001ACE                           912  
00001ACE  4BF9 00002539            913  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001AD4  6000 0008                914                  BRA         PRINT_MEMDIR                     ; branches for printing
00001AD8                           915          
00001AD8  4BF9 00002537            916  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001ADE                           917  
00001ADE  4EB9 000021DE            918  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001AE4  4BF9 00002575            919                  LEA         MSG_W,A5                         ; loads .W into A5
00001AEA  4EB9 000021DE            920                  JSR         PRINTNULL                        ; Prints .W
00001AF0  4BF9 0000256A            921                  LEA         MSG_7SPACES,A5                   ; loads spaces
00001AF6  4EB9 000021DE            922                  JSR         PRINTNULL                        ; prints out spaces
00001AFC  6000 0002                923                  BRA         GETMEMSOURCE                     ; checks the source 
00001B00                           924                  
00001B00                           925  ; get source addressing mode       
00001B00                           926  GETMEMSOURCE                                                 
00001B00  323C 0000                927                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B04  4EB9 00001D56            928                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B0A  3801                     929                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B0C  323C 0000                930                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B10  4EB9 00001D80            931                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B16  3A01                     932                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B18                           933  
00001B18  4BF9 000022B8            934  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B1E  3204                     935                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B20  4EB9 00001EE4            936                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B26  B27C 0002                937                  CMP.W       #2,D1                            ; checks if it is Xn
00001B2A  6700 0016                938                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B2E  B27C 0001                939                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B32  6700 021A                940                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B36                           941  
00001B36  3404                     942  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B38  3605                     943                  MOVE.W      D5,D3                            ; moves EA to D3
00001B3A  4EB9 00001F18            944                  JSR         EA_TO_STRING                     ; prints out the EA
00001B40  4E75                     945                  RTS                
00001B42                           946                  
00001B42                           947                  
00001B42  4BF9 000022C4            948  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B48  3205                     949                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B4A  4EB9 00001EE4            950                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B50  4A41                     951                  TST.W       D1                               ; checks if it is valid
00001B52  67E2                     952                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B54  6000 01F8                953                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B58                           954  
00001B58                           955  
00001B58  3602                     956  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B5A  3200                     957                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B5C  C27C 0018                958                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001B60  E649                     959                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001B62  B27C 0000                960                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B66  6700 0014                961                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001B6A  B27C 0003                962                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B6E  6700 0016                963                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001B72                           964                  
00001B72  4BF9 000024D6            965  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001B78  6000 0012                966                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B7C                           967  
00001B7C  4BF9 000024DA            968  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001B82  6000 0008                969                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001B86                           970  
00001B86  4BF9 000024DE            971  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001B8C                           972                  
00001B8C  4EB9 000021DE            973  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001B92  3400                     974                  MOVE.W      D0,D2                            ; copies D0 to D2
00001B94  4EB9 00001E2A            975                  JSR         GETDIRECTION                     ; gets direction
00001B9A  B47C 0000                976                  CMP.W       #0,D2                            ; checking if its right
00001B9E  6700 000C                977                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BA2                           978  
00001BA2  4BF9 00002539            979  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BA8  6000 000C                980                  BRA         PRINT_REGDIR                     ; branches for printing
00001BAC                           981          
00001BAC  4BF9 00002537            982  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BB2  6000 0002                983                  BRA         PRINT_REGDIR                     ; branches for printing
00001BB6                           984                  
00001BB6  4EB9 000021DE            985  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BBC                           986  
00001BBC  3400                     987  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BBE  4EB9 00001E32            988                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BC4  B47C 0001                989                  CMP.W       #1,D2                            ; Checks if it is word size
00001BC8  6700 0014                990                  BEQ         REG_WORD                         ; Prints .W
00001BCC  B47C 0002                991                  CMP.W       #2,D2                            ; Checks if it is long size
00001BD0  6700 0016                992                  BEQ         REG_LONG                         ; Prints .L
00001BD4                           993  
00001BD4  4BF9 00002572            994  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001BDA  6000 0012                995                  BRA         PRINTREGEA      
00001BDE                           996  
00001BDE  4BF9 00002575            997  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001BE4  6000 0008                998                  BRA         PRINTREGEA      
00001BE8                           999                             
00001BE8  4BF9 00002578           1000  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001BEE                          1001  
00001BEE  4EB9 000021DE           1002  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001BF4  4BF9 0000255D           1003                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001BFA  4EB9 000021DE           1004                  JSR         PRINTNULL                        ; prints out spaces
00001C00  3400                    1005                  MOVE.W      D0,D2                            ; copies D0 to D1
00001C02  4EB9 00001E3A           1006                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C08  B27C 0001               1007                  CMP.W       #$1,D1                           ; Compares D1 to 0, if it is 0, it is a data register
00001C0C  6700 0048               1008                  BEQ         REG_REGISTER                     ; goes to ASd case if so
00001C10                          1009                                  
00001C10  3400                    1010  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C12  4EB9 00001E32           1011                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C18  3202                    1012                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C1A  4BF9 00002547           1013                  LEA         MSG_POUND, A5                    ; loads # into A5
00001C20  4EB9 000021DE           1014                  JSR         PRINTNULL                        ; prints #
00001C26  4EB9 00002094           1015                  JSR         PRINTNUM                         ; prints shift count
00001C2C  4BF9 0000254B           1016                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C32  4EB9 000021DE           1017                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C38  4BF9 0000253B           1018                  LEA         MSG_DR, A5                       ; loads D into A5
00001C3E  4EB9 000021DE           1019                  JSR         PRINTNULL                        ; prints out D 
00001C44  323C 0000               1020                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C48  4EB9 00001D80           1021                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C4E  4EB9 00002094           1022                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C54  4E75                    1023                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C56                          1024                  
00001C56  3400                    1025  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001C58  4EB9 00001E32           1026                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C5E  3202                    1027                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C60  4BF9 0000253B           1028                  LEA         MSG_DR, A5                       ; loads D into A5
00001C66  4EB9 000021DE           1029                  JSR         PRINTNULL                        ; prints D
00001C6C  4EB9 00002094           1030                  JSR         PRINTNUM                         ; prints register number
00001C72  4BF9 0000254B           1031                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C78  4EB9 000021DE           1032                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C7E  4BF9 0000253B           1033                  LEA         MSG_DR, A5                       ; loads D into A5
00001C84  4EB9 000021DE           1034                  JSR         PRINTNULL                        ; prints out D 
00001C8A  323C 0000               1035                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C8E  4EB9 00001D80           1036                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C94  4EB9 00002094           1037                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C9A  4E75                    1038                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C9C                          1039               
00001C9C  3200                    1040  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001C9E  C27C FF00               1041                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001CA2  B27C 6000               1042                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001CA6  6600 0024               1043                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001CAA                          1044                  
00001CAA  4BF9 00002532           1045                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001CB0  4EB9 000021DE           1046                  JSR     PRINTNULL                            ; prints BRA
00001CB6  4BF9 0000256A           1047                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001CBC  4EB9 000021DE           1048                  JSR     PRINTNULL                            ; prints out spaces
00001CC2                          1049  
00001CC2  3400                    1050                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001CC4  4EB9 00001DF2           1051                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001CCA  4E75                    1052                  RTS
00001CCC                          1053                  
00001CCC                          1054  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001CCC                          1055  ; DELETE THIS NOTE: NEED TO FIX LSL/LSR SHIFT TO ENSURE THE BCC CODES GET PRINTED 
00001CCC  3200                    1056  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CCE  C27C F000               1057                  AND.W   #$F000,D1                            ; get top 4 bits
00001CD2  B27C 6000               1058                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001CD6  6600 0060               1059                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001CDA  3200                    1060                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001CDC  C27C 0F00               1061                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001CE0  E049                    1062                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001CE2                          1063                  
00001CE2  B27C 000E               1064                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001CE6  6700 002A               1065                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001CEA                          1066                  
00001CEA  B27C 000F               1067                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001CEE  6700 0018               1068                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001CF2                          1069                      
00001CF2  B27C 0007               1070                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001CF6  6700 0006               1071                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001CFA  6000 0052               1072                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001CFE                          1073     
00001CFE  4BF9 000024EC           1074  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D04  6000 0016               1075                  BRA     PRINTBCC
00001D08                          1076  
00001D08  4BF9 00002505           1077  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D0E  6000 000C               1078                  BRA     PRINTBCC
00001D12                          1079                  
00001D12  4BF9 000024FB           1080  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D18  6000 0002               1081                  BRA     PRINTBCC
00001D1C                          1082  
00001D1C  4EB9 000021DE           1083  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D22  4BF9 0000256A           1084                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D28  4EB9 000021DE           1085                  JSR     PRINTNULL                            ; prints out spaces
00001D2E  3400                    1086                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D30  4EB9 00001DF2           1087                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D36  4E75                    1088                  RTS              
00001D38                          1089                  
00001D38                          1090  
00001D38                          1091  CASE_JSR       
00001D38                          1092  
00001D38  B07C 4E75               1093  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001D3C  6600 0010               1094                  BNE     CASE_DATA           ; checks the next case if not equal
00001D40  4BF9 0000252D           1095                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001D46  4EB9 000021DE           1096                  JSR     PRINTNULL           ; prints RTS                
00001D4C  4E75                    1097                  RTS                         ; returns from the subroutine
00001D4E                          1098  
00001D4E                          1099                  
00001D4E                          1100  
00001D4E  4EB8 1966               1101  CASE_DATA           JSR INV_INSTR  
00001D52  4E75                    1102                      RTS               
00001D54                          1103  
00001D54  4E75                    1104  CASE_EPICFAIL       RTS
00001D56                          1105  
00001D56                          1106  
00001D56                          1107  * Finds the EA type
00001D56                          1108  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001D56                          1109  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D56  48E7 3000               1110  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D5A  4A41                    1111                      TST.W     D1                    ; compares D1 to 0
00001D5C  6700 000E               1112                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001D60                          1113                      
00001D60  343C 01C0               1114  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001D64  363C 0006               1115                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001D68  6000 000A               1116                      BRA       FINDTYPEEA            
00001D6C                          1117  
00001D6C  343C 0038               1118  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001D70  363C 0003               1119                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001D74                          1120  
00001D74                          1121  
00001D74  3200                    1122  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001D76  C242                    1123                      AND.W     D2,D1                 ; applies bitmask to D1
00001D78  E669                    1124                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001D7A  4CDF 000C               1125                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001D7E  4E75                    1126                      RTS                             ; returns from subroutine    
00001D80                          1127                      
00001D80                          1128  * Finds Xn type
00001D80                          1129  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001D80                          1130  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001D80  48E7 3000               1131  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001D84  4A41                    1132                      TST.W     D1                    ; compares D1 to 0
00001D86  6700 000E               1133                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001D8A                          1134  
00001D8A  343C 0E00               1135  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001D8E  363C 0009               1136                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001D92  6000 000A               1137                      BRA       FINDTYPEXN            ; finds the type of Xn
00001D96                          1138  
00001D96  343C 0007               1139  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001D9A  363C 0000               1140                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001D9E                          1141                      
00001D9E  3200                    1142  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001DA0  C242                    1143                      AND.W     D2,D1                 ; applies bitmask to D1
00001DA2  E669                    1144                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001DA4  4CDF 000C               1145                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001DA8  4E75                    1146                      RTS                             ; returns from subroutine 
00001DAA                          1147                      
00001DAA                          1148  * Checks and gets the EA and Xn
00001DAA                          1149  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001DAA                          1150  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001DAA  3207                    1151  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001DAC  4EB8 1D56               1152                  JSR     GET_EA                  ; Gets EA
00001DB0  3401                    1153                  MOVE.W  D1,D2                   ; Stores EA in D2
00001DB2  3207                    1154                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001DB4  4EB8 1D80               1155                  JSR     GET_XN                  ; Gets Xn
00001DB8  3601                    1156                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001DBA  3202                    1157                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001DBC                          1158                  
00001DBC  4EB9 00001EE4           1159                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001DC2  B27C 0002               1160                  CMP.W   #2,D1                   ; checks if it is Xn
00001DC6  6700 0012               1161                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001DCA  B27C 0001               1162                  CMP.W   #1,D1                   ; Checks if it is invalid
00001DCE  6700 001C               1163                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001DD2                          1164                  
00001DD2                          1165                  
00001DD2  323C 0000               1166  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001DD6  6000 0018               1167                  BRA     END_CHECKGET
00001DDA                          1168        
00001DDA                          1169  ; need XN
00001DDA  2A4E                    1170  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001DDC  3203                    1171                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001DDE  4EB9 00001EE4           1172                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001DE4  4A41                    1173                  TST.W   D1                      ; checks if it is valid
00001DE6  67EA                    1174                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001DE8  6000 0002               1175                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001DEC                          1176   
00001DEC  323C 0001               1177  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001DF0                          1178  
00001DF0  4E75                    1179  END_CHECKGET    RTS          
00001DF2                          1180                                            
00001DF2                          1181                                            
00001DF2                          1182  * Gets the displacement and pritns it 
00001DF2                          1183  * Inputs: D2 = instruction word, A2 = address of next word
00001DF2                          1184  * Outputs: prints out displacement
00001DF2  48E7 4004               1185  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001DF6  3A4A                    1186                      MOVE.W    A2,A5                 ; copies A2 to A5
00001DF8  C47C 00FF               1187                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001DFC  6600 0004               1188                      BNE       PRINTADDRESS          ; prints address if not 0
00001E00  341A                    1189                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001E02                          1190                      
00001E02  D44D                    1191  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001E04  3202                    1192                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001E06  183C 0000               1193                      MOVE.B    #0,D4                 ; marks address as word  length
00001E0A  4BF9 00002549           1194                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001E10  4EB9 000021DE           1195                      JSR       PRINTNULL             ; prints null
00001E16  4EB9 000020B8           1196                      JSR       PRINTSHORTLONGNUM     ; prints address
00001E1C                          1197                      
00001E1C  4CDF 2002               1198                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001E20                          1199                      ; DELETE LATER. NOTE: WE DONT HAVE HEX YET, PRINT HEX SIGN BEFORE NUM, BUT WILL NEED TO ADD THIS LATER
00001E20                          1200  
00001E20                          1201  * Gets the rotation value for ASd and LSd
00001E20                          1202  * Input: D2 = instruction word copy (of D0)                                    
00001E20                          1203  * Output: rotation  value in D2             
00001E20  C47C 0E00               1204  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001E24  E04A                    1205                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E26  E24A                    1206                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001E28  4E75                    1207                      RTS                             ; return from subroutine
00001E2A                          1208  
00001E2A                          1209  * Gets the direction value for ASd and LSd
00001E2A                          1210  * Input: D2 = instruction word copy (of D0)                                    
00001E2A                          1211  * Output: direction value in D2             
00001E2A  C47C 0100               1212  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001E2E  E04A                    1213                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001E30  4E75                    1214                      RTS                             ; return from subroutine
00001E32                          1215  
00001E32                          1216  * Gets the rotation size value for ASd and LSd
00001E32                          1217  * Input: D2 = instruction word copy (of D0)                                    
00001E32                          1218  * Output: rotation size value in D2             
00001E32  C47C 00C0               1219  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001E36  EC4A                    1220                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E38  4E75                    1221                      RTS                             ; return from subroutine
00001E3A                          1222  
00001E3A                          1223  * Gets the rotation location  value for ASd and LSd
00001E3A                          1224  * Input: D2 = instruction word copy (of D0)                                    
00001E3A                          1225  * Output: rotation location value in D2             
00001E3A  C47C 0020               1226  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001E3E  EA4A                    1227                      LSR.W      #5,D2                ; shifts 6 bits to the right to only have the rotation bits
00001E40  4E75                    1228                      RTS                             ; return from subroutine
00001E42                          1229  
00001E42                          1230  * Prints out registers for MOVEM
00001E42                          1231  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001E42                          1232  * Output: printed out registers
00001E42                          1233  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001E42  48E7 0706               1234  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001E46  3A3C 0000               1235                      MOVE.W     #0,D5                ; sets counter to 0
00001E4A  3E1A                    1236                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001E4C  B83C 0001               1237                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E50  6600 0010               1238                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001E54                          1239  
00001E54  3C3C 0000               1240  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001E58  4BF9 0000253B           1241                      LEA        MSG_DR,A5            ; loads D to A5
00001E5E  6000 000C               1242                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001E62                          1243                      
00001E62  3C3C 0007               1244  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001E66  4BF9 0000253D           1245                      LEA        MSG_AR,A5            ; loads A to A5
00001E6C                          1246                      
00001E6C  E34F                    1247  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001E6E  6500 0018               1248                      BCS        PRINTREG             ; if pushes out a 1
00001E72  DC44                    1249                      ADD.W      D4,D6                ; decrements or increments
00001E74  5245                    1250                      ADD.W      #1,D5                ; increments D5
00001E76  BA7C 0008               1251                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001E7A  66F0                    1252                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001E7C  B83C 0001               1253                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001E80  6600 0052               1254                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001E84  6000 0042               1255                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001E88                          1256                      
00001E88  4EB9 000021DE           1257  PRINTREG            JSR        PRINTNULL
00001E8E  3206                    1258                      MOVE.W     D6,D1
00001E90  4EB9 00002094           1259                      JSR        PRINTNUM 
00001E96                          1260    
00001E96  BE7C 0000               1261  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001E9A  6600 0006               1262                      BNE        PRINTMORE            ; continue if there is more
00001E9E  6000 0040               1263                      BRA        DONEPRINTINGREG      ; exit case
00001EA2                          1264  
00001EA2  2C4D                    1265  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001EA4  4BF9 0000254E           1266                      LEA        MSG_SLASH,A5         ; leads / into A5
00001EAA  4EB9 000021DE           1267                      JSR        PRINTNULL            ; prints the slash
00001EB0  2A4E                    1268                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001EB2  DC44                    1269                      ADD.W      D4,D6                ; decrements or increments
00001EB4  5245                    1270                      ADD.W      #1,D5                ; increments D5
00001EB6  BA7C 0008               1271                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001EBA  66B0                    1272                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001EBC  B83C 0001               1273                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EC0  6600 0012               1274                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001EC4  6000 0002               1275                      BRA        REGTOMEM2            ; loops
00001EC8                          1276  
00001EC8  3C3C 0000               1277  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001ECC  4BF9 0000253D           1278                      LEA        MSG_AR,A5            ; loads A to A5
00001ED2  6098                    1279                      BRA        PRINTREGISTERLOOP    ; loops
00001ED4                          1280  
00001ED4  3C3C 0007               1281  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001ED8  4BF9 0000253B           1282                      LEA        MSG_DR,A5            ; loads D to A5
00001EDE  608C                    1283                      BRA        PRINTREGISTERLOOP    ; loops
00001EE0                          1284  
00001EE0  4CDF 60E0               1285  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001EE4                          1286  
00001EE4                          1287                          
00001EE4                          1288  * Checks if EA or Xn is valid
00001EE4                          1289  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001EE4                          1290  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001EE4  2F02                    1291  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001EE6                          1292  
00001EE6  141D                    1293  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001EE8  B43C 00FF               1294                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001EEC  6700 000A               1295                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001EF0  B202                    1296                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001EF2  6700 000C               1297                     BEQ        VALIDEA               ; branches to valid EA
00001EF6  60EE                    1298                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001EF8                          1299                     
00001EF8  323C 0001               1300  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001EFC  6000 0016               1301                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001F00                          1302                    
00001F00  B43C 0007               1303  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001F04  6700 000A               1304                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001F08  323C 0000               1305                     MOVE.W     #$0,D1                ; marks that it is valid
00001F0C  6000 0006               1306                     BRA        CHECKEAEXIT           ; exits the subroutine
00001F10                          1307  
00001F10  323C 0002               1308  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001F14                          1309  
00001F14  241F                    1310  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001F16  4E75                    1311                     RTS                              ; returns from subroutine
00001F18                          1312  
00001F18                          1313  * Converts EA and Xn into a string                                
00001F18                          1314  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001F18                          1315  * Outputs: Prints out EA and Xn into a string
00001F18  48E7 C004               1316  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001F1C  B47C 0001               1317                     CMP.W    #An,D2                  ; checks if it is An
00001F20  6700 003A               1318                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001F24                          1319                     
00001F24  B47C 0002               1320                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001F28  6700 004A               1321                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001F2C                          1322                     
00001F2C  B47C 0003               1323                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001F30  6700 0072               1324                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001F34                          1325                     
00001F34  B47C 0004               1326                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001F38  6700 00A6               1327                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001F3C                          1328                     
00001F3C  B47C 0007               1329                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001F40  6700 00DA               1330                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001F44                          1331                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001F44                          1332  
00001F44                          1333  * data register, Dn
00001F44  4BF9 0000253B           1334  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001F4A  4EB9 000021DE           1335                     JSR      PRINTNULL               ; Prints D
00001F50  3203                    1336                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F52  4EB9 00002094           1337                     JSR      PRINTNUM                ; Prints the Xn
00001F58  6000 0134               1338                     BRA      EA_TO_STRING_EXIT       ; exits           
00001F5C                          1339  
00001F5C                          1340  
00001F5C                          1341  * address register
00001F5C  4BF9 0000253D           1342  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001F62  4EB9 000021DE           1343                     JSR      PRINTNULL               ; Prints A
00001F68  3203                    1344                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F6A  4EB9 00002094           1345                     JSR      PRINTNUM                ; Prints the Xn
00001F70  6000 011C               1346                     BRA      EA_TO_STRING_EXIT       ; exits
00001F74                          1347  
00001F74                          1348  * address register indirect
00001F74  4BF9 0000253F           1349  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00001F7A  4EB9 000021DE           1350                     JSR      PRINTNULL               ; Prints (
00001F80  4BF9 0000253D           1351                     LEA      MSG_AR,A5               ; Loads A into A5
00001F86  4EB9 000021DE           1352                     JSR      PRINTNULL               ; Prints A
00001F8C  3203                    1353                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001F8E  4EB9 00002094           1354                     JSR      PRINTNUM                ; Prints the Xn
00001F94  4BF9 00002541           1355                     LEA      MSG_RB,A5               ; Loads ) into A5
00001F9A  4EB9 000021DE           1356                     JSR      PRINTNULL               ; Prints )
00001FA0  6000 00EC               1357                     BRA      EA_TO_STRING_EXIT       ; exits
00001FA4                          1358  
00001FA4                          1359  * address register indirect post increment
00001FA4  4BF9 0000253F           1360  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00001FAA  4EB9 000021DE           1361                     JSR      PRINTNULL               ; Prints (
00001FB0  4BF9 0000253D           1362                     LEA      MSG_AR,A5               ; Loads A into A5
00001FB6  4EB9 000021DE           1363                     JSR      PRINTNULL               ; Prints A
00001FBC  3203                    1364                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FBE  4EB9 00002094           1365                     JSR      PRINTNUM                ; Prints the Xn
00001FC4  4BF9 00002541           1366                     LEA      MSG_RB,A5               ; Loads ) into A5
00001FCA  4EB9 000021DE           1367                     JSR      PRINTNULL               ; Prints )
00001FD0  4BF9 00002543           1368                     LEA      MSG_PLUS,A5             ; Loads + into A5
00001FD6  4EB9 000021DE           1369                     JSR      PRINTNULL               ; Prints +
00001FDC  6000 00B0               1370                     BRA      EA_TO_STRING_EXIT       ; exits
00001FE0                          1371  
00001FE0                          1372  
00001FE0                          1373  * address register indirect pre increment
00001FE0  4BF9 00002545           1374  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00001FE6  4EB9 000021DE           1375                     JSR      PRINTNULL               ; Prints -
00001FEC  4BF9 0000253F           1376                     LEA      MSG_LB,A5               ; Loads ( into A5
00001FF2  4EB9 000021DE           1377                     JSR      PRINTNULL               ; Prints (
00001FF8  4BF9 0000253D           1378                     LEA      MSG_AR,A5               ; Loads A into A5
00001FFE  4EB9 000021DE           1379                     JSR      PRINTNULL               ; Prints A
00002004  3203                    1380                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002006  4EB9 00002094           1381                     JSR      PRINTNUM                ; Prints the Xn
0000200C  4BF9 00002541           1382                     LEA      MSG_RB,A5               ; Loads ) into A5
00002012  4EB9 000021DE           1383                     JSR      PRINTNULL               ; Prints )
00002018  6000 0074               1384                     BRA      EA_TO_STRING_EXIT       ; exits
0000201C                          1385  
0000201C                          1386  * other (long, short, immediate) with Xn yes
0000201C  301A                    1387  CASE_OTHER         MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
0000201E  B67C 0000               1388                     CMP.W    #ABSShort,D3            ; checks if it is a word
00002022  6700 002E               1389                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
00002026                          1390                     
00002026  B67C 0001               1391                     CMP.W    #ABSLong,D3             ; checks if it is (An)
0000202A  6700 0042               1392                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
0000202E                          1393  
0000202E                          1394  * NOTE DELETE LATER: update to print num as HEX and add NEGATIVE NUMBER CHECK
0000202E                          1395  * immediate
0000202E  4BF9 00002547           1396  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
00002034  4EB9 000021DE           1397                     JSR      PRINTNULL               ; Prints #  
0000203A  4BF9 00002549           1398                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002040  4EB9 000021DE           1399                     JSR      PRINTNULL               ; Prints $
00002046  3200                    1400                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002048  4EB9 000020A4           1401                     JSR      PRINTHEXNUM 
0000204E  6000 003E               1402                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
00002052                          1403                     
00002052                          1404  ; DELETE LATER: convert to hex andwrite code to make them print out a total of 4 and 8 characters, add 0's                      
00002052                          1405  
00002052                          1406  * word address
00002052                          1407  CASE_WORD          
00002052  4BF9 00002549           1408                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002058  4EB9 000021DE           1409                     JSR      PRINTNULL               ; Prints $
0000205E  3200                    1410                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002060  383C 0000               1411                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00002064  4EB9 000020B8           1412                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000206A  6000 0022               1413                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
0000206E                          1414  
0000206E                          1415  * long address 
0000206E                          1416  CASE_LONG          
0000206E  4BF9 00002549           1417                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002074  4EB9 000021DE           1418                     JSR      PRINTNULL               ; Prints $
0000207A  3200                    1419                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000207C  383C 0001               1420                     MOVE.W   #1, D4                  ; moves length size (long) into d4
00002080  4EB9 000020B8           1421                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002086  321A                    1422                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002088  4EB9 00002094           1423                     JSR      PRINTNUM                ; reformats the number to the proper length and prints out the number
0000208E                          1424  
0000208E                          1425  
0000208E                          1426  * exits subroutine
0000208E  4CDF 2003               1427  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00002092  4E75                    1428                      RTS                              ; returns from subroutine
00002094                          1429  
00002094                          1430  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00002094                          1431  
00002094                          1432  * Prints out the content of D1 as a decimal number
00002094                          1433  * Input: number in D1 to be printed
00002094                          1434  * Output: contents of D1 printed
00002094  48E7 C000               1435  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00002098  103C 0003               1436                   MOVE.B      #3,D0               ; prints D1
0000209C  4E4F                    1437                   TRAP        #15                 ; is trap task 3
0000209E                          1438              
0000209E  4CDF 0003               1439                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000020A2  4E75                    1440                   RTS                             ; returns from subroutine
000020A4                          1441                   
000020A4                          1442  * Prints out the content of D1 as a hex number
000020A4                          1443  * Input: number in D1 to be printed
000020A4                          1444  * Output: contents of D1 printed
000020A4  48E7 C000               1445  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
000020A8  143C 0010               1446                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000020AC  103C 000F               1447                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000020B0  4E4F                    1448                   TRAP        #15                 ; is trap task 15
000020B2  4CDF 0003               1449                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
000020B6  4E75                    1450                   RTS                             ; returns from subroutine
000020B8                          1451                   
000020B8                          1452  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
000020B8                          1453  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
000020B8                          1454  * Output: contents of D1 printed
000020B8  48E7 E000               1455  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
000020BC  B83C 0001               1456                            CMP.B       #1,D4               ; checks size of number
000020C0  6700 0042               1457                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
000020C4                          1458  
000020C4  3401                    1459  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
000020C6  C47C F000               1460                            AND.W       #$F000,D2           ; gets the first digit
000020CA  B47C 0000               1461                            CMP.W       #0, D2              ; checks if it is 0
000020CE  6600 00DC               1462                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020D2  4EB9 000021BC           1463                            JSR         PRINTZERO           ; prints a zero
000020D8                          1464                            
000020D8  3401                    1465                            MOVE.W      D1,D2               ; copies number to D2
000020DA  C47C 0F00               1466                            AND.W       #$0F00,D2           ; gets the second digit
000020DE  B47C 0000               1467                            CMP.W       #0, D2              ; checks if it is 0
000020E2  6600 00C8               1468                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020E6  4EB9 000021BC           1469                            JSR         PRINTZERO           ; prints a zero
000020EC                          1470                            
000020EC  3401                    1471                            MOVE.W      D1,D2               ; copies number to D2
000020EE  C47C 00F0               1472                            AND.W       #$00F0,D2           ; gets the third digit
000020F2  B47C 0000               1473                            CMP.W       #0, D2              ; checks if it is 0
000020F6  6600 00B4               1474                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000020FA  4EB9 000021BC           1475                            JSR         PRINTZERO           ; prints a zero
00002100  6000 00AA               1476                            BRA         PRINTASHEX          ; prints last digit
00002104                          1477                            
00002104  2401                    1478  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
00002106  C4BC F0000000           1479                            AND.L       #$F0000000,D2       ; gets the first digit
0000210C  B4BC 00000000           1480                            CMP.L       #0, D2              ; checks if it is 0
00002112  6600 0098               1481                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002116  4EB9 000021BC           1482                            JSR         PRINTZERO           ; prints a zero
0000211C                          1483                            
0000211C  2401                    1484                            MOVE.L      D1,D2               ; copies number to D2
0000211E  C4BC 0F000000           1485                            AND.L       #$0F000000,D2       ; gets the second digit
00002124  B4BC 00000000           1486                            CMP.L       #0, D2              ; checks if it is 0
0000212A  6600 0080               1487                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000212E  4EB9 000021BC           1488                            JSR         PRINTZERO           ; prints a zero
00002134                          1489                            
00002134  2401                    1490                            MOVE.L      D1,D2               ; copies number to D2
00002136  C4BC 00F00000           1491                            AND.L       #$00F00000,D2       ; gets the third digit
0000213C  B4BC 00000000           1492                            CMP.L       #0, D2              ; checks if it is 0
00002142  6600 0068               1493                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002146  4EB9 000021BC           1494                            JSR         PRINTZERO           ; prints a zero
0000214C                          1495                            
0000214C  2401                    1496                            MOVE.L      D1,D2               ; copies number to D2
0000214E  C4BC 000F0000           1497                            AND.L       #$000F0000,D2       ; gets the fourth digit
00002154  B4BC 00000000           1498                            CMP.L       #0, D2              ; checks if it is 0
0000215A  6600 0050               1499                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000215E  4EB9 000021BC           1500                            JSR         PRINTZERO           ; prints a zero
00002164                          1501                            
00002164  2401                    1502                            MOVE.L      D1,D2               ; copies number to D2
00002166  C4BC 0000F000           1503                            AND.L       #$0000F000,D2       ; gets the fith digit
0000216C  B4BC 00000000           1504                            CMP.L       #0, D2              ; checks if it is 0
00002172  6600 0038               1505                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002176  4EB9 000021BC           1506                            JSR         PRINTZERO           ; prints a zero
0000217C                          1507                            
0000217C  2401                    1508                            MOVE.L      D1,D2               ; copies number to D2
0000217E  C4BC 00000F00           1509                            AND.L       #$00000F00,D2       ; gets the sixth digit
00002184  B4BC 00000000           1510                            CMP.L       #0, D2              ; checks if it is 0
0000218A  6600 0020               1511                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000218E  4EB9 000021BC           1512                            JSR         PRINTZERO           ; prints a zero
00002194                          1513                            
00002194  2401                    1514                            MOVE.L      D1,D2               ; copies number to D2
00002196  C4BC 000000F0           1515                            AND.L       #$000000F0,D2       ; gets the seventh digit
0000219C  B4BC 00000000           1516                            CMP.L       #0, D2              ; checks if it is 0
000021A2  6600 0008               1517                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021A6  4EB9 000021BC           1518                            JSR         PRINTZERO           ; prints a zero
000021AC                          1519  
000021AC  143C 0010               1520  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
000021B0  103C 000F               1521                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
000021B4  4E4F                    1522                            TRAP        #15                 ; is trap task 15
000021B6  4CDF 0007               1523                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
000021BA  4E75                    1524                            RTS                             ; returns from subroutine    
000021BC                          1525  * Prints a zero
000021BC                          1526  * Input: nothing
000021BC                          1527  * Output: 0 printed out to the console
000021BC  2F01                    1528  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
000021BE  7200                    1529                            MOVE.L      #0,D1               ; moves 0 to D1
000021C0  4EB8 2094               1530                            JSR         PRINTNUM            ; prints the number
000021C4  221F                    1531                            MOVE.L      (SP)+,D1            ; restores D1
000021C6  4E75                    1532                            RTS                             ; returns from subroutine
000021C8                          1533              
000021C8                          1534  * Prints contents of things between a range
000021C8                          1535  * input: A5, A6 (the range)
000021C8                          1536  * output: prints memory contents from A5 to A6 as strings   
000021C8  48E7 C040               1537  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
000021CC  224D                    1538                  MOVEA.L     A5, A1           ; loads A5 into A1
000021CE  9DCD                    1539                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
000021D0  320E                    1540                  MOVE.W      A6, D1           ; move n into D1
000021D2  103C 0001               1541                  MOVE.B      #1, D0           ; display n characters of string at A1
000021D6  4E4F                    1542                  TRAP        #15              ; is trap task 1
000021D8  4CDF 0203               1543                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
000021DC  4E75                    1544                  RTS                          ; returns
000021DE                          1545      
000021DE                          1546  * Prints null terminated string
000021DE                          1547  * input: string pointed to by A5
000021DE                          1548  * output: prints out the null terminated string
000021DE  48E7 8040               1549  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
000021E2  224D                    1550                  MOVE.L      A5,A1           ; loads A5 into A1
000021E4  103C 000E               1551                  MOVE.B      #14,D0          ; prints null terminated string
000021E8  4E4F                    1552                  TRAP        #15             ; is trap task 10
000021EA  4CDF 0201               1553                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
000021EE  4E75                    1554                  RTS                         ; returns from subroutine
000021F0                          1555                  
000021F0  2F0D                    1556  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
000021F2  4BF9 0000247A           1557                  LEA         NEW_LINE,A5     ; Prints null
000021F8  4EB8 21DE               1558                  JSR         PRINTNULL       ; prints the new line
000021FC  2A5F                    1559                  MOVE.L      (SP)+,A5        ; returns A5
000021FE  4E75                    1560                  RTS
00002200                          1561  
00002200                          1562  * Prints the size of the MOVE or MOVEA operation  
00002200                          1563  * input: D0
00002200                          1564  * output: prints out the size of a MOVE or MOVEA operation        
00002200  48E7 8004               1565  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00002204  3200                    1566                  MOVE.W  D0,D1               ; stores d0 in d1
00002206  C07C 3000               1567                  AND.W   #$3000,D0           ; gets the size
0000220A  B07C 2000               1568                  CMP.W   #$2000,D0           ; checks if is long
0000220E  6700 001E               1569                  BEQ     MOVE_LONG
00002212  B07C 3000               1570                  CMP.W   #$3000,D0           ; checks if is word
00002216  6700 000C               1571                  BEQ     MOVE_WORD      
0000221A                          1572                  
0000221A  4BF9 00002572           1573  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00002220  6000 0012               1574                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00002224                          1575  
00002224  4BF9 00002575           1576  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
0000222A  6000 0008               1577                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000222E                          1578  
0000222E  4BF9 00002578           1579  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
00002234                          1580                  
00002234  4EB8 21DE               1581  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00002238  4CDF 2001               1582                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
0000223C  4E75                    1583                  RTS
0000223E                          1584  
0000223E  43F9 000023E9           1585  ERROR           LEA     ERROR_MSG,A1
00002244  103C 000E               1586                  MOVE.B  #14,D0
00002248  4E4F                    1587                  TRAP    #15 
0000224A                          1588         
0000224A                          1589  * DELETE THIS: Test                
0000224A  2661                    1590  DELETEME        MOVEA.L  -(A1),A3
0000224C  6700 0038               1591                  BEQ      DELETEMEAGAIN  
00002250  6F00 0034               1592                  BLE      DELETEMEAGAIN
00002254  6E00 0030               1593                  BGT      DELETEMEAGAIN
00002258                          1594  
00002258  E40A                    1595                  LSR.B      #2,D2
0000225A  E2E2                    1596                  LSR.W      -(A2)
0000225C  E2DA                    1597                  LSR.W      (A2)+
0000225E  E4AA                    1598                  LSR.L      D2,D2 
00002260  E50A                    1599                  LSL.B      #2,D2
00002262  E3E2                    1600                  LSL.W      -(A2)
00002264  E3DA                    1601                  LSL.W      (A2)+
00002266  E5AA                    1602                  LSL.L      D2,D2
00002268  E51A                    1603                  ROL.B      #2,D2
0000226A  E7E2                    1604                  ROL.W      -(A2)
0000226C  E7DA                    1605                  ROL.W      (A2)+
0000226E  E5BA                    1606                  ROL.L      D2,D2
00002270  E41A                    1607                  ROR.B      #2,D2
00002272  E6E2                    1608                  ROR.W      -(A2)
00002274  E6DA                    1609                  ROR.W      (A2)+
00002276  E4BA                    1610                  ROR.L      D2,D2
00002278                          1611                  
00002278  504D                    1612                  ADDQ.W      #8,A5
0000227A  D6C2                    1613                  ADDA.W      D2,A3
0000227C  9BCB                    1614                  SUB.L       A3,A5        
0000227E  8A43                    1615                  OR.W        D3,D5
00002280  4642                    1616                  NOT.W       D2
00002282                          1617                  
00002282  C5FC 0010               1618                  MULS.W    #$0010,D2
00002286                          1619                  
00002286                          1620  DELETEMEAGAIN                 
00002286                          1621            
00002286  FFFF FFFF               1622      SIMHALT             ; halt simulator
0000228A                          1623  
0000228A                          1624  * Put variables and constants here
0000228A                          1625  
0000228A  =0000000D               1626  CR                              EQU     $0D
0000228A  =0000000A               1627  LF                              EQU     $0A 
0000228A  =00000009               1628  TAB                             EQU     $09  
0000228A                          1629  
0000228A                          1630  * Addressing Modes
0000228A  =00000000               1631  Dn                              EQU     0
0000228A  =00000001               1632  An                              EQU     1
0000228A  =00000002               1633  AnIndirect                      EQU     2
0000228A  =00000003               1634  AnPost                          EQU     3
0000228A  =00000004               1635  AnPre                           EQU     4
0000228A  =00000007               1636  Other                           EQU     7           ; short, long, immediate
0000228A                          1637  
0000228A                          1638  * Xn
0000228A  =00000000               1639  ABSShort                        EQU     0
0000228A  =00000001               1640  ABSLong                         EQU     1
0000228A  =00000004               1641  XnImmediate                     EQU     4
0000228A                          1642  
0000228A                          1643  * Valid Addressing Modes
0000228A= 00 01 02 03 04 07 FF    1644  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00002291                          1645  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00002291= 00 02 03 04 07 FF       1646  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002297= 02 04 07 FF             1647  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
0000229B= 02 03 07 FF             1648  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
0000229F= 02 03 04 07 FF          1649  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022A4= 00 02 03 04 07 FF       1650  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022AA= 01 07 FF                1651  VALIDEA_LEA                     DC.B    An,Other,-1
000022AD= 00 02 03 04 07 FF       1652  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022B3= 02 03 04 07 FF          1653  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022B8= 02 03 04 07 FF          1654  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
000022BD= 02 07 FF                1655  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
000022C0                          1656  
000022C0                          1657  * Valid Xn
000022C0= 00 01 04 FF             1658  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
000022C4                          1659  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
000022C4= 00 01 FF                1660  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
000022C7                          1661  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
000022C7                          1662  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
000022C7                          1663  
000022C7                          1664  * posible memory ASd/LSd rotation values
000022C7  =00000000               1665  ASd_MEM                         EQU     0   
000022C7  =00000001               1666  LSd_MEM                         EQU     1 
000022C7  =00000003               1667  ROd_MEM                         EQU     3
000022C7                          1668   
000022C7  =00000000               1669  ASd_REG                         EQU     0   
000022C7  =00000001               1670  LSd_REG                         EQU     1 
000022C7  =00000003               1671  ROd_REG                         EQU     3
000022C7                          1672  
000022C7                          1673  * Messages
000022C7= 57 65 6C 63 6F 6D ...   1674  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
000022EF= 46 6F 72 6D 61 74 ...   1675  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
0000233A= 4C 65 74 74 65 72 ...   1676  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
0000235A= 50 6C 65 61 73 65 ...   1677  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002391= 50 6C 65 61 73 65 ...   1678  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
000023C7= 49 6E 76 61 6C 69 ...   1679  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
000023E9= 45 72 72 6F 72 20 ...   1680  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00002405= 09 44 41 54 41 00       1681  INVALID_INSTR                   DC.B    TAB,'DATA',0
0000240B= 46 69 6E 69 73 68 ...   1682  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
0000244F= 0D 0A 50 72 65 73 ...   1683  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
0000247A= 0D 0A 00                1684  NEW_LINE                        DC.B    CR,LF,0
0000247D= 09 09 09 00             1685  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00002481                          1686  
00002481                          1687  * Opcode Messages
00002481= 09 4E 4F 50 00          1688  MSG_NOP                         DC.B    TAB,'NOP',0
00002486= 09 4D 4F 56 45 00       1689  MSG_MOVE                        DC.B    TAB,'MOVE',0  
0000248C= 09 4D 4F 56 45 41 00    1690  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00002493= 09 4D 4F 56 45 51 00    1691  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
0000249A= 09 4D 4F 56 45 4D 00    1692  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000024A1= 09 41 44 44 00          1693  MSG_ADD                         DC.B    TAB,'ADD',0
000024A6= 09 41 44 44 41 00       1694  MSG_ADDA                        DC.B    TAB,'ADDA',0
000024AC= 09 41 44 44 51 00       1695  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
000024B2= 09 53 55 42 00          1696  MSG_SUB                         DC.B    TAB,'SUB',0
000024B7= 09 4D 55 4C 53 00       1697  MSG_MULS                        DC.B    TAB,'MULS',0
000024BD= 09 44 49 56 55 00       1698  MSG_DIVU                        DC.B    TAB,'DIVU',0
000024C3= 09 4C 45 41 00          1699  MSG_LEA                         DC.B    TAB,'LEA',0
000024C8= 09 41 4E 44 00          1700  MSG_AND                         DC.B    TAB,'AND',0
000024CD= 09 4F 52 00             1701  MSG_OR                          DC.B    TAB,'OR',0
000024D1= 09 4E 4F 54 00          1702  MSG_NOT                         DC.B    TAB,'NOT',0
000024D6= 09 4C 53 00             1703  MSG_LSd                         DC.B    TAB,'LS',0
000024DA= 09 41 53 00             1704  MSG_ASd                         DC.B    TAB,'AS',0
000024DE= 09 52 4F 00             1705  MSG_ROd                         DC.B    TAB,'RO',0
000024E2= 09 42 43 43 00          1706  MSG_BCC                         DC.B    TAB,'BCC',0
000024E7= 09 42 43 53 00          1707  MSG_BCS                         DC.B    TAB,'BCS',0
000024EC= 09 42 45 51 00          1708  MSG_BEQ                         DC.B    TAB,'BEQ',0
000024F1= 09 42 4E 45 00          1709  MSG_BNE                         DC.B    TAB,'BNE',0
000024F6= 09 42 47 45 00          1710  MSG_BGE                         DC.B    TAB,'BGE',0
000024FB= 09 42 47 54 00          1711  MSG_BGT                         DC.B    TAB,'BGT',0
00002500= 09 42 48 49 00          1712  MSG_BHI                         DC.B    TAB,'BHI',0
00002505= 09 42 4C 45 00          1713  MSG_BLE                         DC.B    TAB,'BLE',0
0000250A= 09 42 4C 53 00          1714  MSG_BLS                         DC.B    TAB,'BLS',0
0000250F= 09 42 4C 54 00          1715  MSG_BLT                         DC.B    TAB,'BLT',0
00002514= 09 42 4D 49 00          1716  MSG_BMI                         DC.B    TAB,'BMI',0
00002519= 09 42 50 4C 00          1717  MSG_BPL                         DC.B    TAB,'BPL',0
0000251E= 09 42 56 43 00          1718  MSG_BVC                         DC.B    TAB,'BVC',0
00002523= 09 42 56 53 00          1719  MSG_BVS                         DC.B    TAB,'BVS',0
00002528= 09 4A 53 52 00          1720  MSG_JSR                         DC.B    TAB,'JSR',0
0000252D= 09 52 54 53 00          1721  MSG_RTS                         DC.B    TAB,'RTS',0
00002532= 09 42 52 41 00          1722  MSG_BRA                         DC.B    TAB,'BRA',0
00002537                          1723  
00002537                          1724  * Direction for LSd and ASd
00002537= 52 00                   1725  MSG_RIGHT                       DC.B    'R',0
00002539= 4C 00                   1726  MSG_LEFT                        DC.B    'L',0
0000253B                          1727  
0000253B                          1728  * Effective Addresses Messages
0000253B= 44 00                   1729  MSG_DR                          DC.B    'D',0
0000253D= 41 00                   1730  MSG_AR                          DC.B    'A',0
0000253F= 28 00                   1731  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002541= 29 00                   1732  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
00002543= 2B 00                   1733  MSG_PLUS                        DC.B    '+',0
00002545= 2D 00                   1734  MSG_MINUS                       DC.B    '-',0
00002547= 23 00                   1735  MSG_POUND                       DC.B    '#',0 
00002549= 24 00                   1736  MSG_HEX                         DC.B    '$',0 
0000254B= 2C 20 00                1737  MSG_COMMA                       DC.B    ', ',0
0000254E= 2F 00                   1738  MSG_SLASH                       DC.B    '/',0  
00002550= 20 00                   1739  MSG_SPACE                       DC.B    ' ',0
00002552= 09 00                   1740  MSG_TAB                         DC.B    TAB,0
00002554= 20 20 20 00             1741  MSG_3SPACES                     DC.B    '   ',0
00002558= 20 20 20 20 00          1742  MSG_4SPACES                     DC.B    '    ',0
0000255D= 20 20 20 20 20 00       1743  MSG_5SPACES                     DC.B    '     ',0
00002563= 20 20 20 20 20 20 00    1744  MSG_6SPACES                     DC.B    '      ',0
0000256A= 20 20 20 20 20 20 ...   1745  MSG_7SPACES                     DC.B    '       ',0
00002572                          1746  
00002572                          1747  * Size Messages
00002572= 2E 42 00                1748  MSG_B                           DC.B    '.B',0
00002575= 2E 57 00                1749  MSG_W                           DC.B    '.W',0
00002578= 2E 4C 00                1750  MSG_L                           DC.B    '.L',0
0000257B                          1751  
0000257B                          1752  * Variables
0000257B  =00000100               1753  STARTING_ADDRESS                EQU     $100
0000257B  =00000150               1754  ENDING_ADDRESS                  EQU     $150
0000257B  =00000200               1755  CURRENT_INSTR                   EQU     $200
0000257B  =00000250               1756  REG_VAR                         EQU     $250 * Hold bits 11-9
0000257B  =00000300               1757  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
0000257B  =00000350               1758  EA_MODE                         EQU     $350 * Hold bits 5-3
0000257B  =00000400               1759  EA_REG                          EQU     $400 * Hold bits 2-0
0000257B= 00                      1760  LINE_COUNT                      DC.B     0
0000257C= 14                      1761  LINE_MAX                        DC.B     20
0000257D                          1762              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           164C
ADDQ_BYTE           16EA
ADDQ_LONG           1722
ADDQ_WORD           1706
ADD_SUB_BYTE        157C
ADD_SUB_HELP        14F6
ADD_SUB_LONG        1598
ADD_SUB_OPERAND     15AE
ADD_SUB_SIZE        1558
ADD_SUB_WORD        158A
AN                  1
AND_BYTE            1908
AND_LONG            1940
AND_WORD            1924
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           23C7
CASE_ADD            14CE
CASE_ADDA           1614
CASE_ADDQ           1694
CASE_AND            18C2
CASE_AR             1F5C
CASE_ARI            1F74
CASE_ARIPOST        1FA4
CASE_ARIPRE         1FE0
CASE_ASDMEM         1AA8
CASE_ASDREG         1B7C
CASE_BCC            1CCC
CASE_BEQ            1CFE
CASE_BGT            1D12
CASE_BLE            1D08
CASE_BRA            1C9C
CASE_DATA           1D4E
CASE_DR             1F44
CASE_EPICFAIL       1D54
CASE_IMMEDIATE      202E
CASE_JSR            1D38
CASE_LEA            1824
CASE_LEFTMEM        1ACE
CASE_LEFTREG        1BA2
CASE_LONG           206E
CASE_LSDASDROD      1A68
CASE_LSDMEM         1A9E
CASE_LSDREG         1B72
CASE_MOVE           1296
CASE_MOVEM          135C
CASE_MOVEQ          146E
CASE_NOP            1280
CASE_NOT            1A04
CASE_OR             19A4
CASE_OTHER          201C
CASE_RIGHTMEM       1AD8
CASE_RIGHTREG       1BAC
CASE_RODMEM         1AB2
CASE_RODREG         1B86
CASE_RTS            1D38
CASE_SHIFTMEM       1A86
CASE_SHIFTREG       1B58
CASE_SUB            178C
CASE_SUBA           180E
CASE_WORD           2052
CHECKEAEXIT         1F14
CHECKEAMLOOP        1EE6
CHECKEAXN_IFVALID   1EE4
CHECKGET_EAXN       1DAA
CHECKMEMSOURE       1B18
CHECKMOREBITS       1E96
CHECKSHIFT_XN       1B42
CHECK_LENGTH        11CE
CHECK_LINE          1176
CHECK_ODD           1264
CHECK_ORDER         10AE
CHECK_XN            1DDA
CLEAR_SCREEN        11AA
CONCAT              1216
CONTINUE            244F
CONVERT             11E0
CR                  D
CURRENT_INSTR       200
DELETEME            224A
DELETEMEAGAIN       2286
DESTEA              1D60
DESTXN              1D8A
DISASSEMBLE         10C4
DN                  0
DN_PLUS_EA          15E8
DONE                240B
DONEPRINTINGREG     1EE0
EASHIFT_VALID       1B36
EAXN_INVALID        1DEC
EAXN_VALID          1DD2
EA_MODE             350
EA_REG              400
EA_TO_STRING        1F18
EA_TO_STRING_EXIT   208E
ENDING              2391
ENDING_ADDRESS      150
END_CHECKGET        1DF0
ERROR               223E
ERROR_MSG           23E9
FINDTYPEEA          1D74
FINDTYPEXN          1D9E
FINISHED            10E8
FINISHMOVE          2234
FINISH_ADD          15A6
FINISH_ADDA         1668
FINISH_ADDQ         173E
FINISH_AND          195C
FINISH_SUB          17D4
FINISH_SUBA         17DA
FORMAT1             22EF
FORMAT2             233A
GETDIRECTION        1E2A
GETDISPLACEMENT     1DF2
GETMEMSOURCE        1B00
GETROTATION         1E20
GETROTATIONLOCATION  1E3A
GETROTATIONSIZE     1E32
GET_EA              1D56
GET_XN              1D80
INPUT1              1020
INPUT2              1066
INSERTA             131C
INVALID             122E
INVALIDEA           1EF8
INVALID_INSTR       2405
INV_INSTR           1966
ISNUMBER            11F6
LF                  A
LINE_COUNT          257B
LINE_MAX            257C
LSD_MEM             1
LSD_REG             1
MEM2REGLONG         1432
MEM2REGWORD         1422
MEMTOREG1           1E62
MEMTOREG2           1ED4
MOVEM_MEM2REG       13EE
MOVEM_REG2MEM       137A
MOVE_BYTE           221A
MOVE_LONG           222E
MOVE_WORD           2224
MSG_3SPACES         2554
MSG_4SPACES         2558
MSG_5SPACES         255D
MSG_6SPACES         2563
MSG_7SPACES         256A
MSG_ADD             24A1
MSG_ADDA            24A6
MSG_ADDQ            24AC
MSG_AND             24C8
MSG_AR              253D
MSG_ASD             24DA
MSG_B               2572
MSG_BCC             24E2
MSG_BCS             24E7
MSG_BEQ             24EC
MSG_BGE             24F6
MSG_BGT             24FB
MSG_BHI             2500
MSG_BLE             2505
MSG_BLS             250A
MSG_BLT             250F
MSG_BMI             2514
MSG_BNE             24F1
MSG_BPL             2519
MSG_BRA             2532
MSG_BVC             251E
MSG_BVS             2523
MSG_COMMA           254B
MSG_DIVU            24BD
MSG_DR              253B
MSG_HEX             2549
MSG_JSR             2528
MSG_L               2578
MSG_LB              253F
MSG_LEA             24C3
MSG_LEFT            2539
MSG_LSD             24D6
MSG_MINUS           2545
MSG_MOVE            2486
MSG_MOVEA           248C
MSG_MOVEM           249A
MSG_MOVEQ           2493
MSG_MULS            24B7
MSG_NOP             2481
MSG_NOT             24D1
MSG_OR              24CD
MSG_PLUS            2543
MSG_POUND           2547
MSG_RB              2541
MSG_RIGHT           2537
MSG_ROD             24DE
MSG_RTS             252D
MSG_SLASH           254E
MSG_SPACE           2550
MSG_SUB             24B2
MSG_TAB             2552
MSG_W               2575
NEW_LINE            247A
NEXT_SCREEN         118A
NOTNUMBER           11FE
OPCODE_DECODE       1278
OPMODE_VAR          300
OR_SIZE             19EC
OTHER               7
OTHEREA             1F10
PRINTADD            1534
PRINTADDRESS        1E02
PRINTASHEX          21AC
PRINTBCC            1D1C
PRINTENTER          21F0
PRINTHEXNUM         20A4
PRINTLONGZERO       2104
PRINTMEM2REG        143E
PRINTMORE           1EA2
PRINTMOVE           133A
PRINTMOVESIZE       2200
PRINTNULL           21DE
PRINTNUM            2094
PRINTRANGE          21C8
PRINTREG            1E88
PRINTREG2MEM        13BE
PRINTREGEA          1BEE
PRINTREGISTERLOOP   1E6C
PRINTREGISTERS      1E42
PRINTREGSIZE        1BBC
PRINTSHIFTMEM       1AB8
PRINTSHIFTREG       1B8C
PRINTSHORTLONGNUM   20B8
PRINTSHORTZERO      20C4
PRINTSUB            17A2
PRINTZERO           21BC
PRINT_8             1780
PRINT_ADDQ_DATA     175C
PRINT_ADDR          126C
PRINT_MEMDIR        1ADE
PRINT_MOVEQ         1490
PRINT_REGDIR        1BB6
READ_KEY            119A
REG2MEMLONG         13B8
REG2MEMWORD         13AE
REGTOMEM1           1E54
REGTOMEM2           1EC8
REG_BYTE            1BD4
REG_IMMEDIATE       1C10
REG_LONG            1BE8
REG_REGISTER        1C56
REG_VAR             250
REG_WORD            1BDE
RESET_INPUT         11C6
RESTART             1110
RETURN              122C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1D6C
SOURCEXN            1D96
START               1000
STARTING            235A
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          124C
THREE_TAB           247D
VALIDEA             1F00
VALIDEA_ADDSUB_DESTOPERAND  229F
VALIDEA_ALL         228A
VALIDEA_ANDORNOT    22AD
VALIDEA_ANDOR_DESTOPERAND  22B3
VALIDEA_JSR         22BD
VALIDEA_LEA         22AA
VALIDEA_MOVEM_MEMTOREG  229B
VALIDEA_MOVEM_REGTOMEM  2297
VALIDEA_MOVEQ       2291
VALIDEA_MULSDIVU    22A4
VALIDEA_SHIFT       22B8
VALIDXN_ALL         22C0
VALIDXN_SHORTLONG   22C4
WELCOME             22C7
XNIMMEDIATE         4
