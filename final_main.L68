00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 2:14:52 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/10/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 0000231F             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 00002347             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 00002392             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000023B2             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1       ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011CE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011E0             36                  JSR     CONVERT
00001052  4EB9 0000124C             37                  JSR     TEST_RANGE
00001058  4EB9 00001264             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 000023E9             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011CE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011E0             55                  JSR     CONVERT
0000109A  4EB9 0000124C             56                  JSR     TEST_RANGE
000010A0  4EB9 00001264             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0110                 64                  BLT     RESET_INPUT
000010B8  4BF9 000024D2             65                  LEA     NEW_LINE,A5
000010BE  4EB9 00002272             66                  JSR     PRINTNULL
000010C4                            67                                 
000010C4                            68  DISASSEMBLE     ;MOVE.L  A2,A6               ; loads current address in D1
000010C4                            69                  ; MOVE.L  #1,D4               ; tells subroutine we want to make the address print as a long
000010C4                            70                  ; JSR     PRINTSHORTLONGNUM   ; prints out address
000010C4                            71                  
000010C4  1439 000025D3             72                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010CC  13C2 000025D3             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010D2                            75                  
000010D2  4EB9 00001278             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010D8                            77                  
000010D8  4EB9 00001176             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010DE                            79                  
000010DE  4EB9 00002284             80                  JSR     PRINTENTER          ; prints a new line
000010E4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010E6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010E8                            83                  
000010E8                            84  
000010E8  4BF9 00002463             85  FINISHED        LEA     DONE,A5
000010EE  4EB9 00002272             86                  JSR     PRINTNULL
000010F4  103C 0005                 87                  MOVE.B  #5,D0
000010F8  4E4F                      88                  TRAP    #15
000010FA                            89                  
000010FA  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
000010FE  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001102                            92                  
00001102  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001106  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000110A                            95  
0000110A  103C 0009                 96                  MOVE.B  #9,D0
0000110E  4E4F                      97                  TRAP    #15
00001110                            98                  
00001110  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001114  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001118  4E4F                     101                  TRAP    #15                 Call Trap
0000111A                           102                  
0000111A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000111E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001122  4E4F                     105                  TRAP    #15
00001124                           106                  
00001124  1439 000025D3            107                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
0000112A  143C 0000                108                  MOVE.B  #0,D2               ; set variable to 0
0000112E  13C2 000025D3            109                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
00001134                           110   
00001134  207C 00000000            111                  MOVE.L  #$0000000, A0       ; Reset A1
0000113A  227C 00000000            112                  MOVE.L  #$0000000, A1       ; Reset A1
00001140  247C 00000000            113                  MOVE.L  #$0000000, A2       ; Reset A2
00001146  267C 00000000            114                  MOVE.L  #$0000000, A3       ; Reset A3
0000114C  287C 00000000            115                  MOVE.L  #$0000000, A4       ; Reset A4
00001152  2A7C 00000000            116                  MOVE.L  #$0000000, A5       ; Reset A5
00001158  2C7C 00000000            117                  MOVE.L  #$0000000, A6       ; Reset A6
0000115E  2E7C 01000000            118                  MOVEA.L #$01000000,A7       ; Reset A7
00001164  4281                     119                  CLR.L   D1                  ; Reset D1
00001166  4281                     120                  CLR.L   D1                  ; Reset D1
00001168  4282                     121                  CLR.L   D2                  ; Reset D2
0000116A  4283                     122                  CLR.L   D3                  ; Reset D3
0000116C  4284                     123                  CLR.L   D4                  ; Reset D4
0000116E  4285                     124                  CLR.L   D5                  ; Reset D5
00001170  4286                     125                  CLR.L   D6                  ; Reset D6
00001172  6000 FE8C                126                  BRA     START               ; branch to start of program
00001176                           127  
00001176                           128  *--------------------SUBROUTINES------------------
00001176  1439 000025D3            129  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000117C  1639 000025D4            130                  MOVE.B  LINE_MAX,D3                
00001182  B602                     131                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001184  6F00 0004                132                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001188  4E75                     133                  RTS
0000118A                           134  
0000118A  4BF9 000024A7            135  NEXT_SCREEN     LEA     CONTINUE,A5
00001190  4EB9 00002272            136                  JSR     PRINTNULL
00001196  6000 0002                137                  BRA     READ_KEY
0000119A                           138                  
0000119A  103C 0005                139  READ_KEY        MOVE.B  #5,D0
0000119E  4E4F                     140                  TRAP    #15
000011A0                           141                  
000011A0  B23C 000D                142                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000011A4  6700 0004                143                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
000011A8  60F0                     144                  BRA     READ_KEY
000011AA                           145                  
000011AA  103C 000B                146  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
000011AE  323C FF00                147                  MOVE.W  #$FF00, D1          Clear Screen
000011B2  4E4F                     148                  TRAP    #15                 Call Trap
000011B4                           149                  
000011B4                           150                  ; reset line counter
000011B4  1439 000025D3            151                  MOVE.B  LINE_COUNT,D2
000011BA  143C 0000                152                  MOVE.B  #$0,D2
000011BE  13C2 000025D3            153                  MOVE.B  D2,LINE_COUNT
000011C4  4E75                     154                  RTS       
000011C6                           155      
000011C6                           156  
000011C6  143C 0001                157  RESET_INPUT     MOVE.B  #1,D2
000011CA  6000 0062                158                  BRA     INVALID            
000011CE                           159                  
000011CE  7800                     160  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011D0  B204                     161                  CMP.B   D4,D1               ; D1 stores length
000011D2  6700 005A                162                  BEQ     INVALID             ; input is null
000011D6  0C41 0008                163                  CMPI    #$8,D1              ; check if input is longer than a longword
000011DA  6600 0052                164                  BNE     INVALID             ; input is longer than a longword
000011DE  4E75                     165                  RTS
000011E0                           166                              
000011E0  4283                     167  CONVERT         CLR.L   D3
000011E2  4284                     168                  CLR.L   D4
000011E4  1619                     169                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011E6  B63C 0039                170                  CMP.B   #57,D3
000011EA  6E00 0012                171                  BGT     NOTNUMBER
000011EE                           172                  
000011EE  B63C 002F                173                  CMP.B   #47,D3
000011F2  6E00 0002                174                  BGT     ISNUMBER
000011F6                           175                  
000011F6  0603 00D0                176  ISNUMBER        ADD.B   #-48,D3             ; current char is number
000011FA  6000 001A                177                  BRA     CONCAT
000011FE                           178              
000011FE  B63C 0041                179  NOTNUMBER       CMP.B   #65,D3
00001202  6D00 002A                180                  BLT     INVALID
00001206  B63C 0046                181                  CMP.B   #70,D3
0000120A  6E00 0022                182                  BGT     INVALID  
0000120E  0603 00C9                183                  ADD.B   #-55,D3             ; is letter             
00001212  6000 0002                184                  BRA     CONCAT
00001216                           185              
00001216  BC3C 0000                186  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000121A  6D00 0010                187                  BLT     RETURN
0000121E  1806                     188                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001220  E50C                     189                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001222  E9AB                     190                  LSL.L   D4,D3               ; moves current char to correct position  
00001224  DA83                     191                  ADD.L   D3,D5               ; D5 stores converted input so far
00001226  0606 00FF                192                  ADD.B   #-1,D6  
0000122A  60B4                     193                  BRA     CONVERT             ; continue loop for remaining chars
0000122C                           194                  
0000122C  4E75                     195  RETURN          RTS
0000122E                           196                  
0000122E  227C 00000000            197  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001234  43F9 0000241F            198                  LEA     BAD_INPUT,A1        ; output invalid message
0000123A  103C 000E                199                  MOVE.B  #14,D0
0000123E  4E4F                     200                  TRAP    #15
00001240  B47C 0001                201                  CMP     #1,D2
00001244  6700 FDDA                202                  BEQ     INPUT1
00001248  6000 FE1C                203                  BRA     INPUT2
0000124C                           204  
0000124C  4284                     205  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000124E  223C 00001000            206                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001254  BA81                     207                  CMP.L      D1,D5            ; Compare minimum address with input
00001256  6DD6                     208                  BLT        INVALID          ; input is too low. 
00001258  223C 00FFFFFE            209                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000125E  BA81                     210                  CMP.L      D1,D5            ; compare maximum address with input
00001260  6ECC                     211                  BGT        INVALID          ; input too large
00001262  4E75                     212                  RTS                         ; input is within range
00001264                           213             
00001264  0805 0000                214  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001268  66C4                     215                  BNE        INVALID
0000126A  4E75                     216                  RTS
0000126C                           217  
0000126C                           218  PRINT_ADDR      ;MOVEM.L D1/D4,-(SP)             ; saves D1 and D4
0000126C                           219  *                MOVE.L  A6,D1                   ; loads current address in D1
0000126C                           220  *                MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
0000126C                           221  *                JSR     PRINTSHORTLONGNUM       ; prints out address
0000126C                           222  *                MOVEM.L (SP)+, D1/D4            ; restores D1 and D4
0000126C                           223  *                RTS
0000126C  220E                     224                  MOVE.L  A6,D1                   ; loads current address in D1
0000126E  7801                     225                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001270  4EB9 0000214C            226                  JSR     PRINTSHORTLONGNUM       ; prints out address
00001276  4E75                     227                  RTS
00001278                           228  
00001278                           229  
00001278                           230  
00001278                           231  * Checks every single possible opcode we could have. Jump table
00001278                           232  * Inputs: (A2) which is a pointer to intruction word to be translated
00001278                           233  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001278                           234  
00001278  3C4A                     235  OPCODE_DECODE   MOVE.W  A2,A6
0000127A  301A                     236                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000127C  4EB8 126C                237                  JSR     PRINT_ADDR
00001280                           238                  
00001280                           239  
00001280                           240  *---------------NOP opcode----------------------                
00001280  B07C 4E71                241  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001284  6600 0010                242                  BNE     CASE_MOVE               ; checks the next case if not equal
00001288                           243                  
00001288  4BF9 000024D9            244                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000128E  4EB9 00002272            245                  JSR     PRINTNULL               ; prints NOP                
00001294  4E75                     246                  RTS                             ; returns from the subroutine
00001296                           247  
00001296                           248  *---------------MOVE opcode----------------------              
00001296                           249                  * if first two bits are 00, next two are not 00
00001296  3200                     250  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
00001298  C27C C000                251                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
0000129C  6600 00BE                252                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
000012A0  B07C 0FFF                253                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000012A4  6F00 00B6                254                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
000012A8                           255                  
000012A8                           256                  ; Check source
000012A8  4BF9 000022E2            257                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012AE  4DF9 00002318            258                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012B4  3E3C 0000                259                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012B8  4EB9 00001E36            260                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012BE  B27C 0001                261                  CMP.W   #1,D1                    ; checks if invalid
000012C2  6700 0B16                262                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012C6  3802                     263                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012C8  3A03                     264                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012CA                           265                  
000012CA                           266                  ; Check destination
000012CA  4BF9 000022E2            267                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012D0  4DF9 0000231C            268                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012D6  3E3C 0001                269                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012DA  4EB9 00001E36            270                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012E0  B27C 0001                271                  CMP.W   #1,D1                    ; checks if invalid
000012E4  6700 0AF4                272                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012E8  3C02                     273                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012EA  3E03                     274                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012EC                           275                  
000012EC                           276                  ; Checking if it is MOVEA
000012EC  3200                     277                  MOVE.W  D0,D1                    ; stores d0 in d1
000012EE  C27C 01C0                278                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
000012F2  B27C 0040                279                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
000012F6  6700 0024                280                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
000012FA                           281                  
000012FA  4BF9 000024DE            282                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001300  4EB9 00002272            283                  JSR     PRINTNULL                ; prints out MOVE
00001306  4EB9 00002294            284                  JSR     PRINTMOVESIZE            ; prints out the size 
0000130C  4BF9 000025B0            285                  LEA     MSG_4SPACES,A5           ; loads spaces
00001312  4EB9 00002272            286                  JSR     PRINTNULL                ; prints out spaces
00001318  6000 0020                287                  BRA     PRINTMOVE                ; Branches to print move
0000131C                           288                  
0000131C  4BF9 000024E4            289  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001322  4EB9 00002272            290                  JSR     PRINTNULL                ; prints out MOVEA
00001328  4EB9 00002294            291                  JSR     PRINTMOVESIZE            ; prints out the size 
0000132E  4BF9 000025AC            292                  LEA     MSG_3SPACES,A5           ; loads spaces
00001334  4EB9 00002272            293                  JSR     PRINTNULL                ; prints out spaces
0000133A                           294   
0000133A  3404                     295  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000133C  3605                     296                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000133E  4EB9 00001FA4            297                  JSR     EA_TO_STRING             ; outputs it into a string
00001344                           298                  
00001344                           299                  ; prints a comma to seperate
00001344  4BF9 000025A3            300                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000134A  4EB9 00002272            301                  JSR     PRINTNULL                ; prints out MOVE
00001350                           302                  
00001350                           303                  ; print destination
00001350  3406                     304                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001352  3607                     305                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001354  4EB9 00001FA4            306                  JSR     EA_TO_STRING             ; outputs it into a string
0000135A  4E75                     307                  RTS                              ; exits subroutine                 
0000135C                           308                
0000135C                           309  *---------------MOVEM opcode----------------------                
0000135C  3200                     310  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000135E  C27C FB80                311                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001362  B27C 4880                312                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001366  6600 0106                313                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000136A                           314                  
0000136A                           315                  ; Check D
0000136A  3200                     316                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000136C  C27C 0400                317                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001370  3E01                     318                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001372  B27C 0400                319                  CMP.W   #$0400,D1                       ; checks if value is 1
00001376  6700 0076                320                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000137A                           321  
0000137A                           322  MOVEM_REG2MEM   ; loads EA and XN
0000137A  3E3C 0000                323                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000137E  4BF9 000022EF            324                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001384  4DF9 0000231C            325                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000138A  4EB9 00001E36            326                  JSR     CHECKGET_EAXN
00001390  B27C 0001                327                  CMP.W   #1,D1                           ; checks if D1 invalid
00001394  6700 0A44                328                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
00001398  4BF9 000024F2            329                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
0000139E  4EB9 00002272            330                  JSR     PRINTNULL                       ; prints MOVEM
000013A4                           331                  
000013A4                           332                  ; finds and prints size
000013A4  3200                     333                  MOVE.W  D0,D1                           ; copies D0
000013A6  C27C 0040                334                  AND.W   #$0040,D1                       ; gets the size bit
000013AA  6600 000C                335                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000013AE                           336  
000013AE  4BF9 000025CD            337  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013B4  6000 0008                338                  BRA     PRINTREG2MEM                    ; prints the registers           
000013B8                           339                  
000013B8  4BF9 000025D0            340  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013BE                           341             
000013BE  4EB9 00002272            342  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013C4  4BF9 000025AC            343                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013CA  4EB9 00002272            344                  JSR     PRINTNULL                       ; prints out spaces
000013D0  383C 0001                345                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013D4  4EB9 00001ECE            346                  JSR     PRINTREGISTERS                  ; prints registers
000013DA  4BF9 000025A3            347                  LEA     MSG_COMMA,A5                    ; loads comma
000013E0  4EB9 00002272            348                  JSR     PRINTNULL                       ; prints comma
000013E6  4EB9 00001FA4            349                  JSR     EA_TO_STRING                    ; prints EA
000013EC  4E75                     350                  RTS
000013EE                           351  
000013EE                           352  MOVEM_MEM2REG  ; loads EA and XN
000013EE  3E3C 0000                353                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
000013F2  4BF9 000022F3            354                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
000013F8  4DF9 0000231C            355                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
000013FE  4EB9 00001E36            356                  JSR     CHECKGET_EAXN
00001404  B27C 0001                357                  CMP.W   #1,D1                           ; checks if D1 invalid
00001408  6700 09D0                358                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000140C  4BF9 000024F2            359                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001412  4EB9 00002272            360                  JSR     PRINTNULL                       ; prints MOVEM
00001418                           361                  
00001418                           362                  ; finds and prints size
00001418  3200                     363                  MOVE.W  D0,D1                           ; copies D0
0000141A  C27C 0040                364                  AND.W   #$0040,D1                       ; gets the size bit
0000141E  6600 0012                365                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001422                           366  
00001422  4BF9 000025CD            367  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001428  4EB9 00002272            368                  JSR     PRINTNULL                       ; prints MOVEM
0000142E  6000 000E                369                  BRA     PRINTMEM2REG                    ; prints the registers           
00001432                           370                  
00001432  4BF9 000025D0            371  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001438  4EB9 00002272            372                  JSR     PRINTNULL                       ; prints MOVEM 
0000143E                           373             
0000143E  4EB9 00002272            374  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
00001444  4BF9 000025AC            375                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000144A  4EB9 00002272            376                  JSR     PRINTNULL                       ; prints out spaces
00001450  4EB9 00001FA4            377                  JSR     EA_TO_STRING                    ; prints EA
00001456  4BF9 000025A3            378                  LEA     MSG_COMMA,A5                    ; loads comma
0000145C  4EB9 00002272            379                  JSR     PRINTNULL                       ; prints comma
00001462  383C FFFF                380                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
00001466  4EB9 00001ECE            381                  JSR     PRINTREGISTERS                  ; prints registers
0000146C  4E75                     382                  RTS
0000146E                           383                          
0000146E                           384  
0000146E                           385  *---------------MOVEQ opcode----------------------
0000146E  3200                     386  CASE_MOVEQ      MOVE.W  D0,D1
00001470  C27C F100                387                  AND.W   #$F100,D1
00001474  B27C 7000                388                  CMP.W   #$7000,D1
00001478  6600 007C                389                  BNE     CASE_ADD
0000147C                           390                  
0000147C                           391                  ;loads Register
0000147C  323C 0001                392                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001480  4EB9 00001E0C            393                  JSR     GET_XN                          ; gets XN and puts in D1
00001486  3601                     394                  MOVE.W  D1,D3                           ; copies Xn to D3 so it won't be overwritten
00001488                           395                  
00001488                           396                  ;loads DATA
00001488  3200                     397                  MOVE.W  D0,D1
0000148A  C27C 00FF                398                  AND.W   #$00FF,D1                       ;bit mask to get DATA
0000148E  3801                     399                  MOVE.W  D1,D4                           ;copy data into D4
00001490                           400                                                          ;must convert bits to hex
00001490                           401                                  
00001490  4BF9 000024EB            402  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
00001496  4EB9 00002272            403                  JSR     PRINTNULL  
0000149C                           404                                  
0000149C  4BF9 000025D0            405                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014A2  4EB9 00002272            406                  JSR     PRINTNULL
000014A8                           407      
000014A8  4BF9 000025AC            408                  LEA     MSG_3SPACES,A5                  ;PRINT THREE TABS
000014AE  4EB9 00002272            409                  JSR     PRINTNULL
000014B4                           410                  
000014B4  4BF9 0000259F            411                  LEA     MSG_POUND, A5                   ;PRINT HASHTAG
000014BA  4EB9 00002272            412                  JSR     PRINTNULL
000014C0                           413                  
000014C0  4BF9 000025A1            414                  LEA     MSG_HEX, A5                     ;PRINT DOLLAR SIGN
000014C6  4EB9 00002272            415                  JSR     PRINTNULL
000014CC                           416                  
000014CC  3204                     417                  MOVE.W  D4,D1                           ;PRINT DATA
000014CE  4EB9 00002138            418                  JSR     PRINTHEXNUM                           
000014D4                           419                  
000014D4  4BF9 000025A3            420                  LEA     MSG_COMMA, A5                   ;PRINT COMMA
000014DA  4EB9 00002272            421                  JSR     PRINTNULL
000014E0                           422                  
000014E0  4BF9 00002593            423                  LEA     MSG_DR,A5                       ;PRINT D
000014E6  4EB9 00002272            424                  JSR     PRINTNULL
000014EC                           425            
000014EC  3203                     426                  MOVE.W  D3,D1                           ;PRINT REGISTER NUMBER
000014EE  4EB9 00002128            427                  JSR     PRINTNUM                         
000014F4                           428                  
000014F4  4E75                     429                  RTS
000014F6                           430                  
000014F6                           431  *---------------ADD opcode----------------------                
000014F6                           432  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000014F6  3200                     433  CASE_ADD        MOVE.W  D0,D1
000014F8  C27C F000                434                  AND.W   #$F000,D1
000014FC  B27C D000                435                  CMP.W   #$D000,D1
00001500  6600 01BA                436                  BNE     CASE_ADDQ
00001504                           437                   
00001504  4EB9 0000151E            438                  JSR     ADD_SUB_HELP
0000150A                           439                  
0000150A                           440                  ; bits 7-8 determine if it is ADDA or ADD
0000150A  3200                     441                  MOVE.W  D0,D1
0000150C  E149                     442                  LSL.W   #8,D1                   ; get rid of left 8 bits
0000150E  E049                     443                  LSR.W   #8,D1
00001510  EC49                     444                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001512  B27C 0003                445                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
00001516  6700 0124                446                  BEQ     CASE_ADDA
0000151A                           447                  
0000151A  6000 0040                448                  BRA     PRINTADD                ; Branches to print add
0000151E                           449                  
0000151E                           450                  ; Check bits 0-5 
0000151E  4BF9 000022E2            451  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001524  4DF9 00002318            452                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000152A  3E3C 0000                453                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
0000152E  4EB9 00001E36            454                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001534  B27C 0001                455                  CMP.W       #1,D1                    ; checks if invalid
00001538  6700 08A0                456                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
0000153C  3802                     457                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
0000153E  3A03                     458                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001540                           459                  
00001540                           460                  ; Check 6-11
00001540  4BF9 000022E2            461                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001546  4DF9 0000231C            462                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
0000154C  3E3C 0001                463                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001550  4EB9 00001E36            464                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001556  3C02                     465                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
00001558  3E03                     466                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
0000155A                           467    
0000155A  4E75                     468                  RTS                
0000155C                           469                    
0000155C  4BF9 000024F9            470  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001562  4EB9 00002272            471                  JSR         PRINTNULL               ; print ADD
00001568  3200                     472                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000156A  4EB9 00001580            473                  JSR         ADD_SUB_SIZE
00001570  4BF9 000025B5            474                  LEA         MSG_5SPACES,A5          ; loads spaces
00001576  4EB9 00002272            475                  JSR         PRINTNULL               ; prints out spaces
0000157C  6000 0050                476                  BRA         FINISH_ADD
00001580                           477                    
00001580  3200                     478  ADD_SUB_SIZE    MOVE.W      D0,D1
00001582  E149                     479                  LSL.W       #8,D1
00001584  E049                     480                  LSR.W       #8,D1
00001586  EC49                     481                  LSR.W       #6,D1                   ; gets bits 6-7
00001588                           482                    
00001588  B27C 0000                483                  CMP.W       #0,D1
0000158C  6700 0016                484                  BEQ         ADD_SUB_BYTE
00001590  B27C 0001                485                  CMP.W       #1,D1                   ; if 1, it is a word
00001594  6700 001C                486                  BEQ         ADD_SUB_WORD
00001598  B27C 0002                487                  CMP.W       #2,D1                   ; if 2, it is a long
0000159C  6700 0022                488                  BEQ         ADD_SUB_LONG
000015A0  6000 0294                489                  BRA         CASE_SUBA               ; error
000015A4                           490                    
000015A4  4BF9 000025CA            491  ADD_SUB_BYTE    LEA         MSG_B,A5
000015AA  4EB9 00002272            492                  JSR         PRINTNULL
000015B0  4E75                     493                  RTS
000015B2                           494                    
000015B2  4BF9 000025CD            495  ADD_SUB_WORD    LEA         MSG_W,A5
000015B8  4EB9 00002272            496                  JSR         PRINTNULL
000015BE  4E75                     497                  RTS
000015C0                           498    
000015C0  4BF9 000025D0            499  ADD_SUB_LONG    LEA         MSG_L,A5
000015C6  4EB9 00002272            500                  JSR         PRINTNULL
000015CC  4E75                     501                  RTS
000015CE                           502        
000015CE  4EB9 000015D6            503  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015D4  4E75                     504                  RTS
000015D6                           505    
000015D6  EF49                     506  ADD_SUB_OPERAND LSL.W       #7,D1
000015D8  EE49                     507                  LSR.W       #7,D1
000015DA  E049                     508                  LSR.W       #8,D1
000015DC  B27C 0001                509                  CMP.W       #1,D1
000015E0  6600 002E                510                  BNE         Dn_PLUS_EA          
000015E4                           511                    
000015E4                           512                  ; print Data Register
000015E4  4BF9 00002593            513                  LEA         MSG_DR,A5
000015EA  4EB9 00002272            514                  JSR         PRINTNULL
000015F0  3207                     515                  MOVE.W      D7,D1
000015F2  4EB9 00002128            516                  JSR         PRINTNUM                
000015F8                           517                  
000015F8                           518                  ; prints a comma to seperate
000015F8  4BF9 000025A3            519                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000015FE  4EB9 00002272            520                  JSR         PRINTNULL                ; prints out MOVE
00001604                           521                 
00001604                           522                  ; below is EA+Dn->Dn  
00001604  3404                     523                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001606  3605                     524                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001608  4EB9 00001FA4            525                  JSR         EA_TO_STRING             ; outputs it into a string
0000160E  4E75                     526                  RTS                                 ; exits subroutine 
00001610                           527  
00001610                           528  Dn_PLUS_EA      ; below is Dn+EA->EA  
00001610  3404                     529                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001612  3605                     530                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001614  4EB9 00001FA4            531                  JSR         EA_TO_STRING             ; outputs it into a string   
0000161A                           532                  
0000161A                           533                  ; prints a comma to seperate
0000161A  4BF9 000025A3            534                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001620  4EB9 00002272            535                  JSR         PRINTNULL                ; prints out MOVE
00001626                           536                  
00001626                           537                  ; below is Dn+EA->EA
00001626  4BF9 00002593            538                  LEA         MSG_DR,A5                ; print data register
0000162C  4EB9 00002272            539                  JSR         PRINTNULL
00001632  3207                     540                  MOVE.W      D7,D1
00001634  4EB9 00002128            541                  JSR         PRINTNUM             
0000163A  4E75                     542                  RTS                                  ; exits subroutine          
0000163C                           543                        
0000163C                           544  *---------------ADDA opcode----------------------
0000163C                           545  CASE_ADDA       ; gets bit 8 (size bit)
0000163C  3200                     546                  MOVE.W      D0,D1
0000163E  EF49                     547                  LSL.W       #7,D1
00001640  EE49                     548                  LSR.W       #7,D1
00001642  E049                     549                  LSR         #8,D1                   
00001644                           550                  
00001644  4BF9 000024FE            551                  LEA         MSG_ADDA,A5             ; print ADDA
0000164A  4EB9 00002272            552                  JSR         PRINTNULL
00001650                           553                   
00001650  B27C 0001                554                  CMP.W       #1,D1
00001654  6700 001E                555                  BEQ         ADDA_LONG
00001658                           556                    
00001658  4BF9 000025CD            557                  LEA         MSG_W,A5
0000165E  4EB9 00002272            558                  JSR         PRINTNULL
00001664  4BF9 000025B0            559                  LEA         MSG_4SPACES,A5          ; loads spaces
0000166A  4EB9 00002272            560                  JSR         PRINTNULL               ; prints out spaces
00001670  6000 001E                561                  BRA         FINISH_ADDA   
00001674                           562                    
00001674  4BF9 000025D0            563  ADDA_LONG       LEA         MSG_L,A5
0000167A  4EB9 00002272            564                  JSR         PRINTNULL
00001680  4BF9 000025B0            565                  LEA         MSG_4SPACES,A5          ; loads spaces
00001686  4EB9 00002272            566                  JSR         PRINTNULL               ; prints out spaces
0000168C  6000 0002                567                  BRA         FINISH_ADDA
00001690                           568                    
00001690  3404                     569  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001692  3605                     570                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001694  4EB9 00001FA4            571                  JSR         EA_TO_STRING             ; outputs it into a string
0000169A                           572                    
0000169A                           573                  ; prints a comma to seperate
0000169A  4BF9 000025A3            574                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016A0  4EB9 00002272            575                  JSR         PRINTNULL                ; prints out MOVE
000016A6                           576            
000016A6  4BF9 00002595            577                  LEA         MSG_AR,A5                ; print address register
000016AC  4EB9 00002272            578                  JSR         PRINTNULL
000016B2  3207                     579                  MOVE.W      D7,D1
000016B4  4EB9 00002128            580                  JSR         PRINTNUM             
000016BA  4E75                     581                  RTS                              ; exits subroutine
000016BC                           582                  
000016BC                           583  *---------------ADDQ opcode----------------------                  
000016BC  3200                     584  CASE_ADDQ       MOVE.W      D0,D1
000016BE  C27C F000                585                  AND.W       #$F000,D1       
000016C2  B27C 5000                586                  CMP.W       #$5000,D1
000016C6  6600 00EC                587                  BNE         CASE_SUB
000016CA                           588                                                   
000016CA  4BF9 00002504            589                  LEA         MSG_ADDQ,A5             ; print ADDQ
000016D0  4EB9 00002272            590                  JSR         PRINTNULL
000016D6                           591                  
000016D6                           592                  ; get bits 6-7 (size bits)
000016D6  3200                     593                  MOVE.W      D0,D1
000016D8  E149                     594                  LSL.W       #8,D1
000016DA  E049                     595                  LSR.W       #8,D1
000016DC  EC49                     596                  LSR.W       #6,D1
000016DE  3401                     597                  MOVE.W      D1,D2
000016E0                           598                  
000016E0                           599                  ; Check bits 0-5 
000016E0  4BF9 000022E2            600                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016E6  4DF9 00002318            601                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016EC  3E3C 0000                602                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016F0  4EB9 00001E36            603                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000016F6  B27C 0001                604                  CMP.W       #1,D1                    ; checks if invalid
000016FA  6700 06DE                605                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
000016FE  3802                     606                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001700  3A03                     607                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001702                           608                  
00001702  B47C 0001                609                  CMP.W       #1,D2
00001706  6700 0026                610                  BEQ         ADDQ_WORD
0000170A  B47C 0002                611                  CMP.W       #2,D2
0000170E  6700 003A                612                  BEQ         ADDQ_LONG
00001712                           613                    
00001712  4BF9 000025CA            614  ADDQ_BYTE       LEA         MSG_B,A5
00001718  4EB9 00002272            615                  JSR         PRINTNULL
0000171E  4BF9 000025B0            616                  LEA         MSG_4SPACES,A5          ; loads spaces
00001724  4EB9 00002272            617                  JSR         PRINTNULL               ; prints out spaces
0000172A  6000 003A                618                  BRA         FINISH_ADDQ  
0000172E                           619   
0000172E  4BF9 000025CD            620  ADDQ_WORD       LEA         MSG_W,A5
00001734  4EB9 00002272            621                  JSR         PRINTNULL
0000173A  4BF9 000025B0            622                  LEA         MSG_4SPACES,A5          ; loads spaces
00001740  4EB9 00002272            623                  JSR         PRINTNULL               ; prints out spaces
00001746  6000 001E                624                  BRA         FINISH_ADDQ                 
0000174A                           625    
0000174A  4BF9 000025D0            626  ADDQ_LONG       LEA         MSG_L,A5
00001750  4EB9 00002272            627                  JSR         PRINTNULL
00001756  4BF9 000025B0            628                  LEA         MSG_4SPACES,A5          ; loads spaces
0000175C  4EB9 00002272            629                  JSR         PRINTNULL               ; prints out spaces
00001762  6000 0002                630                  BRA         FINISH_ADDQ                  
00001766                           631                    
00001766  4EB9 00001784            632  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
0000176C                           633   
0000176C                           634                  ; prints a comma to seperate
0000176C  4BF9 000025A3            635                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001772  4EB9 00002272            636                  JSR         PRINTNULL                ; prints out MOVE
00001778                           637                    
00001778                           638                  ; prints destination
00001778  3404                     639                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000177A  3605                     640                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
0000177C  4EB9 00001FA4            641                  JSR         EA_TO_STRING             ; outputs it into a string
00001782                           642                 
00001782  4E75                     643                  RTS
00001784                           644   
00001784  4BF9 0000259F            645  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
0000178A  4EB9 00002272            646                  JSR         PRINTNULL
00001790                           647                  ; gets bits 9-11 (data bits)
00001790  E949                     648                  LSL.W       #4,D1
00001792  E849                     649                  LSR.W       #4,D1                               ; get rid of left 4 bits
00001794  E049                     650                  LSR.W       #8,D1
00001796  E249                     651                  LSR.W       #1,D1                               ; get rid of right 9 bits
00001798                           652                  
00001798  B27C 0000                653                  CMP.W       #0,D1
0000179C  6700 000A                654                  BEQ         PRINT_8
000017A0  4EB9 00002128            655                  JSR         PRINTNUM
000017A6  4E75                     656                  RTS 
000017A8                           657  
000017A8  123C 0008                658  PRINT_8         MOVE.B      #8,D1
000017AC  4EB9 00002128            659                  JSR         PRINTNUM
000017B2  4E75                     660                  RTS   
000017B4                           661         
000017B4                           662  *---------------SUB opcode---------------------- 
000017B4  3200                     663  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
000017B6  C27C F000                664                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000017BA  B27C 9000                665                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
000017BE  6600 008C                666                  BNE         CASE_LEA
000017C2                           667                 
000017C2  4EB8 151E                668                  JSR         ADD_SUB_HELP
000017C6                           669                  
000017C6  6000 0002                670                  BRA         PRINTSUB                            ; Branches to print sub
000017CA                           671  
000017CA  4BF9 0000250A            672  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017D0  4EB9 00002272            673                  JSR         PRINTNULL
000017D6  3200                     674                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017D8  4EB8 1580                675                  JSR         ADD_SUB_SIZE
000017DC  4BF9 000025B5            676                  LEA         MSG_5SPACES,A5                      ; loads spaces
000017E2  4EB9 00002272            677                  JSR         PRINTNULL                           ; prints out spaces
000017E8  3200                     678                  MOVE.W      D0,D1
000017EA  E149                     679                  LSL.W       #8,D1
000017EC  E049                     680                  LSR.W       #8,D1
000017EE  EC49                     681                  LSR.W       #6,D1
000017F0  B27C 0003                682                  CMP.W       #3,D1
000017F4  6600 0006                683                  BNE         FINISH_SUB
000017F8  6000 0008                684                  BRA         FINISH_SUBA                         ; same as ADDA
000017FC                           685                  
000017FC  4EB8 15D6                686  FINISH_SUB      JSR         ADD_SUB_OPERAND
00001800  4E75                     687                  RTS
00001802                           688                    
00001802  3404                     689  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001804  3605                     690                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001806  4EB9 00001FA4            691                  JSR         EA_TO_STRING             ; outputs it into a string
0000180C                           692                
0000180C                           693                  ; prints a comma to seperate
0000180C  4BF9 000025A3            694                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001812  4EB9 00002272            695                  JSR         PRINTNULL                ; prints out MOVE
00001818                           696                  
00001818  4BF9 00002595            697                  LEA         MSG_AR,A5                ; print address register
0000181E  4EB9 00002272            698                  JSR         PRINTNULL
00001824  3200                     699                  MOVE.W      D0,D1
00001826  E949                     700                  LSL.W       #4,D1
00001828  E849                     701                  LSR.W       #4,D1
0000182A  E049                     702                  LSR.W       #8,D1
0000182C  E249                     703                  LSR.W       #1,D1
0000182E  4EB9 00002128            704                  JSR         PRINTNUM             
00001834  4E75                     705                  RTS                              ; exits subroutine
00001836                           706  
00001836                           707  
00001836                           708  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
00001836  3200                     709  CASE_SUBA       MOVE.W      D0,D1
00001838  EF49                     710                  LSL.W       #7,D1
0000183A  EE49                     711                  LSR.W       #7,D1
0000183C  E049                     712                  LSR.W       #8,D1
0000183E  B23C 0000                713                  CMP.B       #0,D1
00001842  6700 FD6E                714                  BEQ         ADD_SUB_WORD
00001846  6000 FD78                715                  BRA         ADD_SUB_LONG
0000184A  4E75                     716                  RTS         
0000184C                           717                   
0000184C  3200                     718  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000184E  C27C F000                719                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001852  B27C 4000                720                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001856  6600 0092                721                  BNE.W   CASE_AND                             ; If its not, check AND
0000185A  3200                     722                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000185C  C27C 01C0                723                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
00001860  B27C 01C0                724                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001864  6600 0084                725                  BNE.W   CASE_AND                             ; If its not, check AND
00001868                           726                  
00001868                           727                  ; Check source
00001868  4BF9 00002302            728                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000186E  4DF9 0000231C            729                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001874  3E3C 0000                730                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001878  4EB9 00001E36            731                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000187E  3802                     732                  MOVE.W  D2,D4                                ; Saves D2 in D4
00001880  3A03                     733                  MOVE.W  D3,D5                                ; Saves D2 in D4
00001882                           734                  
00001882                           735                  ; Check destination
00001882  4BF9 00002302            736                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
00001888  4DF9 0000231C            737                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
0000188E  3E3C 0001                738                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
00001892  4EB9 00001E36            739                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
00001898  3C02                     740                  MOVE.W  D2,D6                                ; Saves D2 in D4
0000189A  3E03                     741                  MOVE.W  D3,D7                                ; Saves D2 in D4
0000189C                           742  
0000189C  4BF9 0000251B            743                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000018A2  4EB9 00002272            744                  JSR     PRINTNULL                            ; prints LEA
000018A8  4BF9 000025C2            745                  LEA     MSG_7SPACES,A5                       ; loads spaces
000018AE  4EB9 00002272            746                  JSR     PRINTNULL                            ; prints out spaces
000018B4                           747                  
000018B4                           748                  ; print source
000018B4  3404                     749                  MOVE.W  D4,D2
000018B6  3605                     750                  MOVE.W  D5,D3
000018B8  4EB9 00001FA4            751                  JSR     EA_TO_STRING                         ; Prints out the EA
000018BE                           752                  
000018BE                           753                  ; comma
000018BE  4BF9 000025A3            754                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000018C4  4EB9 00002272            755                  JSR     PRINTNULL                       
000018CA                           756                   
000018CA                           757                  ; register
000018CA  4BF9 00002595            758                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018D0  4EB9 00002272            759                  JSR     PRINTNULL 
000018D6  3401                     760                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018D8  323C 0001                761                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000018DC  4EB9 00001E0C            762                  JSR     GET_XN                               ; Gets Xn, puts it into D1
000018E2  4EB9 00002128            763                  JSR     PRINTNUM                             ; Prints the number in D1
000018E8  4E75                     764                  RTS
000018EA                           765  
000018EA                           766  *---------------AND opcode----------------------
000018EA  3200                     767  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
000018EC  C27C F000                768                  AND.W       #$F000,D1       
000018F0  B27C C000                769                  CMP.W       #$C000,D1
000018F4  6600 00D6                770                  BNE         CASE_OR
000018F8                           771                  
000018F8  3200                     772                  MOVE.W      D0,D1
000018FA  E149                     773                  LSL.W       #8,D1
000018FC  E049                     774                  LSR.W       #8,D1
000018FE  EC49                     775                  LSR.W       #6,D1                           ; get bits 6-7 (size)
00001900  3C01                     776                  MOVE.W      D1,D6
00001902  BC7C 0003                777                  CMP.W       #3,D6
00001906  6700 0086                778                  BEQ         INV_INSTR
0000190A                           779                  
0000190A  4BF9 00002520            780                  LEA         MSG_AND,A5                      ; print AND
00001910  4EB9 00002272            781                  JSR         PRINTNULL
00001916                           782                  
00001916  3206                     783                  MOVE.W      D6,D1
00001918  B27C 0000                784                  CMP.W       #0,D1
0000191C  6700 0012                785                  BEQ         AND_BYTE
00001920  B27C 0001                786                  CMP.W       #1,D1                   ; if 1, it is a word
00001924  6700 0026                787                  BEQ         AND_WORD
00001928  B27C 0002                788                  CMP.W       #2,D1                   ; if 2, it is a long
0000192C  6700 003A                789                  BEQ         AND_LONG
00001930                           790                  
00001930  4BF9 000025CA            791  AND_BYTE        LEA         MSG_B,A5
00001936  4EB9 00002272            792                  JSR         PRINTNULL
0000193C  4BF9 000025C2            793                  LEA         MSG_7SPACES,A5                  ; loads spaces
00001942  4EB9 00002272            794                  JSR         PRINTNULL                       ; prints out spaces
00001948  6000 003A                795                  BRA         FINISH_AND
0000194C                           796                                    
0000194C  4BF9 000025CD            797  AND_WORD        LEA         MSG_W,A5
00001952  4EB9 00002272            798                  JSR         PRINTNULL
00001958  4BF9 000025C2            799                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000195E  4EB9 00002272            800                  JSR         PRINTNULL                       ; prints out spaces
00001964  6000 001E                801                  BRA         FINISH_AND
00001968                           802    
00001968  4BF9 000025D0            803  AND_LONG        LEA         MSG_L,A5
0000196E  4EB9 00002272            804                  JSR         PRINTNULL
00001974  4BF9 000025C2            805                  LEA         MSG_7SPACES,A5                  ; loads spaces
0000197A  4EB9 00002272            806                  JSR         PRINTNULL                       ; prints out spaces
00001980  6000 0002                807                  BRA         FINISH_AND
00001984                           808        
00001984  4EB8 151E                809  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
00001988  4EB8 15D6                810                  JSR         ADD_SUB_OPERAND
0000198C  4E75                     811                  RTS
0000198E                           812                  
0000198E  4BF9 0000245D            813  INV_INSTR       LEA         INVALID_INSTR,A5
00001994  4EB9 00002272            814                  JSR         PRINTNULL
0000199A  4BF9 000025BB            815                  LEA         MSG_6SPACES,A5
000019A0  4EB9 00002272            816                  JSR         PRINTNULL
000019A6  4BF9 000025A1            817                  LEA         MSG_HEX,A5
000019AC  4EB9 00002272            818                  JSR         PRINTNULL
000019B2  2200                     819                  MOVE.L      D0,D1
000019B4  383C 0000                820                  MOVE.W      #0,D4
000019B8  4EB9 0000214C            821                  JSR         PRINTSHORTLONGNUM
000019BE  4BF9 000024D2            822                  LEA         NEW_LINE,A5
000019C4  4EB9 00002272            823                  JSR         PRINTNULL
000019CA  4E75                     824                  RTS               
000019CC                           825                  
000019CC                           826  *---------------OR opcode----------------------            
000019CC  3200                     827  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019CE  C27C F000                828                  AND.W       #$F000,D1       
000019D2  B27C 8000                829                  CMP.W       #$8000,D1
000019D6  6600 0054                830                  BNE         CASE_NOT
000019DA                           831                                                
000019DA  3200                     832                  MOVE.W      D0,D1
000019DC  E149                     833                  LSL.W       #8,D1
000019DE  E049                     834                  LSR.W       #8,D1
000019E0  EC49                     835                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019E2  B27C 0003                836                  CMP.W       #3,D1
000019E6  3C01                     837                  MOVE.W      D1,D6
000019E8  67A4                     838                  BEQ         INV_INSTR
000019EA                           839                  
000019EA                           840                  
000019EA  4BF9 00002525            841                  LEA         MSG_OR,A5
000019F0  4EB9 00002272            842                  JSR         PRINTNULL                       ; print "OR"
000019F6                           843                  
000019F6  3206                     844                  MOVE.W      D6,D1
000019F8  4EB9 00001A14            845                  JSR         OR_SIZE                         ; print ".B",".W",".L"
000019FE  4BF9 000025BB            846                  LEA         MSG_6SPACES,A5                  ; loads spaces
00001A04  4EB9 00002272            847                  JSR         PRINTNULL                       ; prints out spaces
00001A0A                           848  
00001A0A  4EB8 151E                849                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001A0E  4EB8 15D6                850                  JSR         ADD_SUB_OPERAND                 ; print 
00001A12  4E75                     851                  RTS
00001A14                           852  
00001A14  B27C 0000                853  OR_SIZE         CMP.W       #0,D1
00001A18  6700 FB8A                854                  BEQ         ADD_SUB_BYTE
00001A1C  B27C 0001                855                  CMP.W       #1,D1                   ; if 1, it is a word
00001A20  6700 FB90                856                  BEQ         ADD_SUB_WORD
00001A24  B27C 0002                857                  CMP.W       #2,D1                   ; if 2, it is a long
00001A28  6700 FB96                858                  BEQ         ADD_SUB_LONG
00001A2C                           859                  ; no need for rts, since ADD_SUB_ already has                
00001A2C                           860  
00001A2C                           861  *---------------NOT opcode----------------------
00001A2C  3200                     862  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A2E  C27C FF00                863                  AND.W       #$FF00,D1       
00001A32  B27C 4600                864                  CMP.W       #$4600,D1
00001A36  6600 0058                865                  BNE         CASE_LSDASDROD
00001A3A                           866                 
00001A3A                           867                  ; get bits 6-7 (size)
00001A3A  3200                     868                  MOVE.W      D0,D1
00001A3C  E149                     869                  LSL.W       #8,D1
00001A3E  E049                     870                  LSR.W       #8,D1
00001A40  EC49                     871                  LSR.W       #6,D1 
00001A42  3C01                     872                  MOVE.W      D1,D6                         
00001A44  BC7C 0003                873                  CMP.W       #3,D6
00001A48  6700 FF44                874                  BEQ         INV_INSTR
00001A4C                           875                                  
00001A4C  4BF9 00002529            876                  LEA         MSG_NOT,A5
00001A52  4EB9 00002272            877                  JSR         PRINTNULL                       ; print "NOT"
00001A58                           878                                 
00001A58  3206                     879                  MOVE.W      D6,D1
00001A5A                           880  
00001A5A  4EB8 1A14                881                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A5E  4BF9 000025B5            882                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A64  4EB9 00002272            883                  JSR         PRINTNULL                       ; prints out spaces
00001A6A                           884                  
00001A6A                           885                  ; get bits 0-5 
00001A6A  4BF9 000022E2            886                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A70  4DF9 00002318            887                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A76  3E3C 0000                888                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A7A  4EB9 00001E36            889                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A80  B27C 0001                890                  CMP.W       #1,D1                    ; checks if invalid
00001A84  6700 0354                891                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001A88  4EB9 00001FA4            892                  JSR         EA_TO_STRING             ; outputs it into a string
00001A8E                           893    
00001A8E  4E75                     894                  RTS
00001A90                           895  
00001A90  3200                     896  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001A92  C27C F000                897                  AND.W       #$F000, D1                       ; gets first 4 bits
00001A96  B27C E000                898                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001A9A  6600 0240                899                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001A9E  3400                     900                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AA0  4EB9 00001EBE            901                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AA6  B47C 0003                902                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001AAA  6600 00D4                903                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001AAE                           904                  
00001AAE  3400                     905  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001AB0  4EB9 00001EAC            906                  JSR         GETROTATION                      ; gets rotation value of D2
00001AB6  B47C 0000                907                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001ABA  6700 0014                908                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001ABE  B47C 0003                909                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001AC2  6700 0016                910                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001AC6                           911                  
00001AC6  4BF9 0000252E            912  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001ACC  6000 0012                913                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AD0                           914  
00001AD0  4BF9 00002532            915  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001AD6  6000 0008                916                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001ADA                           917  
00001ADA  4BF9 00002536            918  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AE0                           919                  
00001AE0  4EB9 00002272            920  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001AE6  3400                     921                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AE8  4EB9 00001EB6            922                  JSR         GETDIRECTION                     ; gets direction
00001AEE  B47C 0000                923                  CMP.W       #0,D2                            ; checking if its right
00001AF2  6700 000C                924                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001AF6                           925  
00001AF6  4BF9 00002591            926  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001AFC  6000 0008                927                  BRA         PRINT_MEMDIR                     ; branches for printing
00001B00                           928          
00001B00  4BF9 0000258F            929  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001B06                           930  
00001B06  4EB9 00002272            931  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001B0C  4BF9 000025CD            932                  LEA         MSG_W,A5                         ; loads .W into A5
00001B12  4EB9 00002272            933                  JSR         PRINTNULL                        ; Prints .W
00001B18  4BF9 000025B5            934                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001B1E  4EB9 00002272            935                  JSR         PRINTNULL                        ; prints out spaces
00001B24  6000 0002                936                  BRA         GETMEMSOURCE                     ; checks the source 
00001B28                           937                  
00001B28                           938  ; get source addressing mode       
00001B28                           939  GETMEMSOURCE                                                 
00001B28  323C 0000                940                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B2C  4EB9 00001DE2            941                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B32  3801                     942                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B34  323C 0000                943                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B38  4EB9 00001E0C            944                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B3E  3A01                     945                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B40                           946  
00001B40  4BF9 00002310            947  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B46  3204                     948                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B48  4EB9 00001F70            949                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B4E  B27C 0002                950                  CMP.W       #2,D1                            ; checks if it is Xn
00001B52  6700 0016                951                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B56  B27C 0001                952                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B5A  6700 027E                953                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B5E                           954  
00001B5E  3404                     955  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B60  3605                     956                  MOVE.W      D5,D3                            ; moves EA to D3
00001B62  4EB9 00001FA4            957                  JSR         EA_TO_STRING                     ; prints out the EA
00001B68  4E75                     958                  RTS                
00001B6A                           959                  
00001B6A                           960                  
00001B6A  4BF9 0000231C            961  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B70  3205                     962                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B72  4EB9 00001F70            963                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B78  4A41                     964                  TST.W       D1                               ; checks if it is valid
00001B7A  67E2                     965                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B7C  6000 025C                966                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B80                           967  
00001B80                           968  
00001B80  3602                     969  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B82  3200                     970                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B84  C27C 0018                971                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001B88  E649                     972                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001B8A  B27C 0000                973                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B8E  6700 0014                974                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001B92  B27C 0003                975                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001B96  6700 0016                976                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001B9A                           977                  
00001B9A  4BF9 0000252E            978  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001BA0  6000 0012                979                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BA4                           980  
00001BA4  4BF9 00002532            981  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001BAA  6000 0008                982                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BAE                           983  
00001BAE  4BF9 00002536            984  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001BB4                           985                  
00001BB4  4EB9 00002272            986  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001BBA  3400                     987                  MOVE.W      D0,D2                            ; copies D0 to D2
00001BBC  4EB9 00001EB6            988                  JSR         GETDIRECTION                     ; gets direction
00001BC2  B47C 0000                989                  CMP.W       #0,D2                            ; checking if its right
00001BC6  6700 000C                990                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BCA                           991  
00001BCA  4BF9 00002591            992  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BD0  6000 000C                993                  BRA         PRINT_REGDIR                     ; branches for printing
00001BD4                           994          
00001BD4  4BF9 0000258F            995  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BDA  6000 0002                996                  BRA         PRINT_REGDIR                     ; branches for printing
00001BDE                           997                  
00001BDE  4EB9 00002272            998  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BE4                           999  
00001BE4  3400                    1000  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BE6  4EB9 00001EBE           1001                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BEC  B47C 0001               1002                  CMP.W       #1,D2                            ; Checks if it is word size
00001BF0  6700 0014               1003                  BEQ         REG_WORD                         ; Prints .W
00001BF4  B47C 0002               1004                  CMP.W       #2,D2                            ; Checks if it is long size
00001BF8  6700 0016               1005                  BEQ         REG_LONG                         ; Prints .L
00001BFC                          1006  
00001BFC  4BF9 000025CA           1007  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001C02  6000 0012               1008                  BRA         PRINTREGEA      
00001C06                          1009  
00001C06  4BF9 000025CD           1010  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001C0C  6000 0008               1011                  BRA         PRINTREGEA      
00001C10                          1012                             
00001C10  4BF9 000025D0           1013  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001C16                          1014  
00001C16  4EB9 00002272           1015  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001C1C  4BF9 000025B5           1016                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001C22  4EB9 00002272           1017                  JSR         PRINTNULL                        ; prints out spaces
00001C28  3400                    1018                  MOVE.W      D0,D2                            ; copies D0 to D2
00001C2A  4EB9 00001EC6           1019                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C30  B47C 0001               1020                  CMP.W       #$1,D2                           ; Compares D1 to 1, if it is 1, it is a data register
00001C34  6700 0060               1021                  BEQ         REG_REGISTER                     ; goes to register case if so
00001C38                          1022                                  
00001C38  3400                    1023  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C3A  4EB9 00001EAC           1024                  JSR         GETROTATION                      ; gets the rotation size
00001C40  B47C 0000               1025                  CMP.W       #0,D2                            ; checks if D2 is 0 (shift count of 8)
00001C44  6600 0006               1026                  BNE         COMPLETE_REGIM                   ; if not shigt count of 8, then branch to start printing
00001C48                          1027                  
00001C48  343C 0008               1028  MAKESHIFT8      MOVE.W      #8,D2                            ; sets shift cound to 8 (shift count of 8 is 000 in the opcode)
00001C4C                          1029                  
00001C4C  4BF9 0000259F           1030  COMPLETE_REGIM  LEA         MSG_POUND, A5                    ; loads # into A5
00001C52  4EB9 00002272           1031                  JSR         PRINTNULL                        ; prints #
00001C58  4BF9 000025A1           1032                  LEA         MSG_HEX, A5                      ; loads $ into A5
00001C5E  4EB9 00002272           1033                  JSR         PRINTNULL                        ; prints $
00001C64  3202                    1034                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C66  4EB9 00002138           1035                  JSR         PRINTHEXNUM                      ; prints shift count
00001C6C  4BF9 000025A3           1036                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C72  4EB9 00002272           1037                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C78  4BF9 00002593           1038                  LEA         MSG_DR, A5                       ; loads D into A5
00001C7E  4EB9 00002272           1039                  JSR         PRINTNULL                        ; prints out D 
00001C84  323C 0000               1040                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C88  4EB9 00001E0C           1041                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001C8E  4EB9 00002128           1042                  JSR         PRINTNUM                         ; prints data register number in D1          
00001C94  4E75                    1043                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001C96                          1044                  
00001C96  3400                    1045  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001C98  4EB9 00001EBE           1046                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001C9E  3202                    1047                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001CA0  4BF9 00002593           1048                  LEA         MSG_DR, A5                       ; loads D into A5
00001CA6  4EB9 00002272           1049                  JSR         PRINTNULL                        ; prints D
00001CAC  4EB9 00002128           1050                  JSR         PRINTNUM                         ; prints register number
00001CB2  4BF9 000025A3           1051                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001CB8  4EB9 00002272           1052                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001CBE  4BF9 00002593           1053                  LEA         MSG_DR, A5                       ; loads D into A5
00001CC4  4EB9 00002272           1054                  JSR         PRINTNULL                        ; prints out D 
00001CCA  323C 0000               1055                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CCE  4EB9 00001E0C           1056                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CD4  4EB9 00002128           1057                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CDA  4E75                    1058                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CDC                          1059               
00001CDC  3200                    1060  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001CDE  C27C FF00               1061                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001CE2  B27C 6000               1062                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001CE6  6600 0024               1063                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001CEA                          1064                  
00001CEA  4BF9 0000258A           1065                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001CF0  4EB9 00002272           1066                  JSR     PRINTNULL                            ; prints BRA
00001CF6  4BF9 000025C2           1067                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001CFC  4EB9 00002272           1068                  JSR     PRINTNULL                            ; prints out spaces
00001D02                          1069  
00001D02  3400                    1070                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D04  4EB9 00001E7E           1071                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D0A  4E75                    1072                  RTS
00001D0C                          1073                  
00001D0C                          1074  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001D0C  3200                    1075  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D0E  C27C F000               1076                  AND.W   #$F000,D1                            ; get top 4 bits
00001D12  B27C 6000               1077                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001D16  6600 0060               1078                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001D1A  3200                    1079                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D1C  C27C 0F00               1080                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001D20  E049                    1081                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001D22                          1082                  
00001D22  B27C 000E               1083                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001D26  6700 002A               1084                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001D2A                          1085                  
00001D2A  B27C 000F               1086                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001D2E  6700 0018               1087                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001D32                          1088                      
00001D32  B27C 0007               1089                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001D36  6700 0006               1090                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001D3A  6000 009E               1091                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001D3E                          1092     
00001D3E  4BF9 00002544           1093  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D44  6000 0016               1094                  BRA     PRINTBCC
00001D48                          1095  
00001D48  4BF9 0000255D           1096  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D4E  6000 000C               1097                  BRA     PRINTBCC
00001D52                          1098                  
00001D52  4BF9 00002553           1099  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D58  6000 0002               1100                  BRA     PRINTBCC
00001D5C                          1101  
00001D5C  4EB9 00002272           1102  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D62  4BF9 000025C2           1103                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D68  4EB9 00002272           1104                  JSR     PRINTNULL                            ; prints out spaces
00001D6E  3400                    1105                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D70  4EB9 00001E7E           1106                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D76  4E75                    1107                  RTS              
00001D78                          1108                  
00001D78                          1109  
00001D78  3200                    1110  CASE_JSR        MOVE.W  D0,D1                                ; check if JSR mandatory bits exist
00001D7A  C27C FFC0               1111                  AND.W   #$FFC0,D1
00001D7E  B27C 4E80               1112                  CMP.W   #$4E80,D1
00001D82  6600 0040               1113                  BNE     CASE_RTS
00001D86                          1114                  
00001D86  1E3C 0000               1115                  MOVE.B  #0,D7
00001D8A  4BF9 00002315           1116                  LEA     VALIDEA_JSR,A5                       ; loads string of valid addresses
00001D90  4DF9 0000231C           1117                  LEA     VALIDXN_SHORTLONG,A6                 ; loads string of valid addresses
00001D96  4EB9 00001E36           1118                  JSR     CHECKGET_EAXN                        ; checks if has valid effective address
00001D9C  B27C 0001               1119                  CMP     #1,D1
00001DA0  6700 0038               1120                  BEQ     CASE_DATA                            ; goes to case data if EA is invalid
00001DA4                          1121                  
00001DA4                          1122  PRINT_JSR       ;print JSR
00001DA4  4BF9 00002580           1123                  LEA     MSG_JSR,A5
00001DAA  4EB9 00002272           1124                  JSR     PRINTNULL
00001DB0                          1125                  
00001DB0                          1126                  ;print spaces
00001DB0  4BF9 000025C2           1127                  LEA     MSG_7SPACES,A5
00001DB6  4EB9 00002272           1128                  JSR     PRINTNULL
00001DBC                          1129                                  
00001DBC                          1130                  ;print address
00001DBC  4EB9 00001FA4           1131                  JSR     EA_TO_STRING
00001DC2  4E75                    1132                  RTS     
00001DC4                          1133  
00001DC4  B07C 4E75               1134  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001DC8  6600 0010               1135                  BNE     CASE_DATA           ; checks the next case if not equal
00001DCC  4BF9 00002585           1136                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001DD2  4EB9 00002272           1137                  JSR     PRINTNULL           ; prints RTS                
00001DD8  4E75                    1138                  RTS                         ; returns from the subroutine
00001DDA                          1139  
00001DDA  4EB8 198E               1140  CASE_DATA       JSR INV_INSTR  
00001DDE  4E75                    1141                  RTS               
00001DE0                          1142  
00001DE0  4E75                    1143  CASE_EPICFAIL   RTS
00001DE2                          1144  
00001DE2                          1145  
00001DE2                          1146  * Finds the EA type
00001DE2                          1147  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001DE2                          1148  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001DE2  48E7 3000               1149  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001DE6  4A41                    1150                      TST.W     D1                    ; compares D1 to 0
00001DE8  6700 000E               1151                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001DEC                          1152                      
00001DEC  343C 01C0               1153  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001DF0  363C 0006               1154                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001DF4  6000 000A               1155                      BRA       FINDTYPEEA            
00001DF8                          1156  
00001DF8  343C 0038               1157  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001DFC  363C 0003               1158                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001E00                          1159  
00001E00                          1160  
00001E00  3200                    1161  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001E02  C242                    1162                      AND.W     D2,D1                 ; applies bitmask to D1
00001E04  E669                    1163                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E06  4CDF 000C               1164                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E0A  4E75                    1165                      RTS                             ; returns from subroutine    
00001E0C                          1166                      
00001E0C                          1167  * Finds Xn type
00001E0C                          1168  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001E0C                          1169  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001E0C  48E7 3000               1170  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001E10  4A41                    1171                      TST.W     D1                    ; compares D1 to 0
00001E12  6700 000E               1172                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001E16                          1173  
00001E16  343C 0E00               1174  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001E1A  363C 0009               1175                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001E1E  6000 000A               1176                      BRA       FINDTYPEXN            ; finds the type of Xn
00001E22                          1177  
00001E22  343C 0007               1178  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001E26  363C 0000               1179                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001E2A                          1180                      
00001E2A  3200                    1181  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001E2C  C242                    1182                      AND.W     D2,D1                 ; applies bitmask to D1
00001E2E  E669                    1183                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E30  4CDF 000C               1184                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E34  4E75                    1185                      RTS                             ; returns from subroutine 
00001E36                          1186                      
00001E36                          1187  * Checks and gets the EA and Xn
00001E36                          1188  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001E36                          1189  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001E36  3207                    1190  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001E38  4EB8 1DE2               1191                  JSR     GET_EA                  ; Gets EA
00001E3C  3401                    1192                  MOVE.W  D1,D2                   ; Stores EA in D2
00001E3E  3207                    1193                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001E40  4EB8 1E0C               1194                  JSR     GET_XN                  ; Gets Xn
00001E44  3601                    1195                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001E46  3202                    1196                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001E48                          1197                  
00001E48  4EB9 00001F70           1198                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001E4E  B27C 0002               1199                  CMP.W   #2,D1                   ; checks if it is Xn
00001E52  6700 0012               1200                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001E56  B27C 0001               1201                  CMP.W   #1,D1                   ; Checks if it is invalid
00001E5A  6700 001C               1202                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001E5E                          1203                  
00001E5E                          1204                  
00001E5E  323C 0000               1205  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001E62  6000 0018               1206                  BRA     END_CHECKGET
00001E66                          1207        
00001E66                          1208  ; need XN
00001E66  2A4E                    1209  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001E68  3203                    1210                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001E6A  4EB9 00001F70           1211                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001E70  4A41                    1212                  TST.W   D1                      ; checks if it is valid
00001E72  67EA                    1213                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001E74  6000 0002               1214                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001E78                          1215   
00001E78  323C 0001               1216  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001E7C                          1217  
00001E7C  4E75                    1218  END_CHECKGET    RTS          
00001E7E                          1219                                            
00001E7E                          1220                                            
00001E7E                          1221  * Gets the displacement and pritns it 
00001E7E                          1222  * Inputs: D2 = instruction word, A2 = address of next word
00001E7E                          1223  * Outputs: prints out displacement
00001E7E  48E7 4004               1224  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001E82  3A4A                    1225                      MOVE.W    A2,A5                 ; copies A2 to A5
00001E84  C47C 00FF               1226                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001E88  6600 0004               1227                      BNE       PRINTADDRESS          ; prints address if not 0
00001E8C  341A                    1228                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001E8E                          1229                      
00001E8E  D44D                    1230  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001E90  3202                    1231                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001E92  183C 0000               1232                      MOVE.B    #0,D4                 ; marks address as word length
00001E96  4BF9 000025A1           1233                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001E9C  4EB9 00002272           1234                      JSR       PRINTNULL             ; prints null
00001EA2  4EB9 0000214C           1235                      JSR       PRINTSHORTLONGNUM     ; prints address
00001EA8                          1236                      
00001EA8  4CDF 2002               1237                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001EAC                          1238                      
00001EAC                          1239  
00001EAC                          1240  * Gets the rotation value for ASd and LSd
00001EAC                          1241  * Input: D2 = instruction word copy (of D0)                                    
00001EAC                          1242  * Output: rotation  value in D2             
00001EAC  C47C 0E00               1243  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001EB0  E04A                    1244                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001EB2  E24A                    1245                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001EB4  4E75                    1246                      RTS                             ; return from subroutine
00001EB6                          1247  
00001EB6                          1248  * Gets the direction value for ASd and LSd
00001EB6                          1249  * Input: D2 = instruction word copy (of D0)                                    
00001EB6                          1250  * Output: direction value in D2             
00001EB6  C47C 0100               1251  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001EBA  E04A                    1252                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001EBC  4E75                    1253                      RTS                             ; return from subroutine
00001EBE                          1254  
00001EBE                          1255  * Gets the rotation size value for ASd and LSd
00001EBE                          1256  * Input: D2 = instruction word copy (of D0)                                    
00001EBE                          1257  * Output: rotation size value in D2             
00001EBE  C47C 00C0               1258  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001EC2  EC4A                    1259                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001EC4  4E75                    1260                      RTS                             ; return from subroutine
00001EC6                          1261  
00001EC6                          1262  * Gets the rotation location  value for ASd and LSd
00001EC6                          1263  * Input: D2 = instruction word copy (of D0)                                    
00001EC6                          1264  * Output: rotation location value in D2             
00001EC6  C47C 0020               1265  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001ECA  EA4A                    1266                      LSR.W      #5,D2                ; shifts 5 bits to the right to only have the rotation bits
00001ECC  4E75                    1267                      RTS                             ; return from subroutine
00001ECE                          1268  
00001ECE                          1269  * Prints out registers for MOVEM
00001ECE                          1270  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001ECE                          1271  * Output: printed out registers
00001ECE                          1272  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001ECE  48E7 0706               1273  PRINTREGISTERS      MOVEM.L    D5-D7/A5-A6,-(SP)    ; saves D5-D7/A5-A6
00001ED2  3A3C 0000               1274                      MOVE.W     #0,D5                ; sets counter to 0
00001ED6  3E1A                    1275                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001ED8  B83C 0001               1276                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EDC  6600 0010               1277                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001EE0                          1278  
00001EE0  3C3C 0000               1279  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001EE4  4BF9 00002593           1280                      LEA        MSG_DR,A5            ; loads D to A5
00001EEA  6000 000C               1281                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001EEE                          1282                      
00001EEE  3C3C 0007               1283  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001EF2  4BF9 00002595           1284                      LEA        MSG_AR,A5            ; loads A to A5
00001EF8                          1285                      
00001EF8  E34F                    1286  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001EFA  6500 0018               1287                      BCS        PRINTREG             ; if pushes out a 1
00001EFE  DC44                    1288                      ADD.W      D4,D6                ; decrements or increments
00001F00  5245                    1289                      ADD.W      #1,D5                ; increments D5
00001F02  BA7C 0008               1290                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F06  66F0                    1291                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F08  B83C 0001               1292                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F0C  6600 0052               1293                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F10  6000 0042               1294                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001F14                          1295                      
00001F14  4EB9 00002272           1296  PRINTREG            JSR        PRINTNULL
00001F1A  3206                    1297                      MOVE.W     D6,D1
00001F1C  4EB9 00002128           1298                      JSR        PRINTNUM 
00001F22                          1299    
00001F22  BE7C 0000               1300  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001F26  6600 0006               1301                      BNE        PRINTMORE            ; continue if there is more
00001F2A  6000 0040               1302                      BRA        DONEPRINTINGREG      ; exit case
00001F2E                          1303  
00001F2E  2C4D                    1304  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001F30  4BF9 000025A6           1305                      LEA        MSG_SLASH,A5         ; leads / into A5
00001F36  4EB9 00002272           1306                      JSR        PRINTNULL            ; prints the slash
00001F3C  2A4E                    1307                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001F3E  DC44                    1308                      ADD.W      D4,D6                ; decrements or increments
00001F40  5245                    1309                      ADD.W      #1,D5                ; increments D5
00001F42  BA7C 0008               1310                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F46  66B0                    1311                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F48  B83C 0001               1312                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F4C  6600 0012               1313                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F50  6000 0002               1314                      BRA        REGTOMEM2            ; loops
00001F54                          1315  
00001F54  3C3C 0000               1316  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001F58  4BF9 00002595           1317                      LEA        MSG_AR,A5            ; loads A to A5
00001F5E  6098                    1318                      BRA        PRINTREGISTERLOOP    ; loops
00001F60                          1319  
00001F60  3C3C 0007               1320  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001F64  4BF9 00002593           1321                      LEA        MSG_DR,A5            ; loads D to A5
00001F6A  608C                    1322                      BRA        PRINTREGISTERLOOP    ; loops
00001F6C                          1323  
00001F6C  4CDF 60E0               1324  DONEPRINTINGREG     MOVEM.L    (SP)+,D5-D7/A5-A6    ; saves D5-D7/A5-A6
00001F70                          1325  
00001F70                          1326                          
00001F70                          1327  * Checks if EA or Xn is valid
00001F70                          1328  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001F70                          1329  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001F70  2F02                    1330  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001F72                          1331  
00001F72  141D                    1332  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001F74  B43C 00FF               1333                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001F78  6700 000A               1334                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001F7C  B202                    1335                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001F7E  6700 000C               1336                     BEQ        VALIDEA               ; branches to valid EA
00001F82  60EE                    1337                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001F84                          1338                     
00001F84  323C 0001               1339  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001F88  6000 0016               1340                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001F8C                          1341                    
00001F8C  B43C 0007               1342  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001F90  6700 000A               1343                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001F94  323C 0000               1344                     MOVE.W     #$0,D1                ; marks that it is valid
00001F98  6000 0006               1345                     BRA        CHECKEAEXIT           ; exits the subroutine
00001F9C                          1346  
00001F9C  323C 0002               1347  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001FA0                          1348  
00001FA0  241F                    1349  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001FA2  4E75                    1350                     RTS                              ; returns from subroutine
00001FA4                          1351  
00001FA4                          1352  * Converts EA and Xn into a string                                
00001FA4                          1353  * Inputs: D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001FA4                          1354  * Outputs: Prints out EA and Xn into a string
00001FA4  48E7 C004               1355  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001FA8  B47C 0001               1356                     CMP.W    #An,D2                  ; checks if it is An
00001FAC  6700 003A               1357                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001FB0                          1358                     
00001FB0  B47C 0002               1359                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001FB4  6700 004A               1360                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001FB8                          1361                     
00001FB8  B47C 0003               1362                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001FBC  6700 0072               1363                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001FC0                          1364                     
00001FC0  B47C 0004               1365                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001FC4  6700 00A6               1366                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001FC8                          1367                     
00001FC8  B47C 0007               1368                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001FCC  6700 00DA               1369                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001FD0                          1370                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001FD0                          1371  
00001FD0                          1372  * data register, Dn
00001FD0  4BF9 00002593           1373  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001FD6  4EB9 00002272           1374                     JSR      PRINTNULL               ; Prints D
00001FDC  3203                    1375                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FDE  4EB9 00002128           1376                     JSR      PRINTNUM                ; Prints the Xn
00001FE4  6000 013C               1377                     BRA      EA_TO_STRING_EXIT       ; exits           
00001FE8                          1378  
00001FE8                          1379  
00001FE8                          1380  * address register
00001FE8  4BF9 00002595           1381  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00001FEE  4EB9 00002272           1382                     JSR      PRINTNULL               ; Prints A
00001FF4  3203                    1383                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FF6  4EB9 00002128           1384                     JSR      PRINTNUM                ; Prints the Xn
00001FFC  6000 0124               1385                     BRA      EA_TO_STRING_EXIT       ; exits
00002000                          1386  
00002000                          1387  * address register indirect
00002000  4BF9 00002597           1388  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00002006  4EB9 00002272           1389                     JSR      PRINTNULL               ; Prints (
0000200C  4BF9 00002595           1390                     LEA      MSG_AR,A5               ; Loads A into A5
00002012  4EB9 00002272           1391                     JSR      PRINTNULL               ; Prints A
00002018  3203                    1392                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000201A  4EB9 00002128           1393                     JSR      PRINTNUM                ; Prints the Xn
00002020  4BF9 00002599           1394                     LEA      MSG_RB,A5               ; Loads ) into A5
00002026  4EB9 00002272           1395                     JSR      PRINTNULL               ; Prints )
0000202C  6000 00F4               1396                     BRA      EA_TO_STRING_EXIT       ; exits
00002030                          1397  
00002030                          1398  * address register indirect post increment
00002030  4BF9 00002597           1399  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00002036  4EB9 00002272           1400                     JSR      PRINTNULL               ; Prints (
0000203C  4BF9 00002595           1401                     LEA      MSG_AR,A5               ; Loads A into A5
00002042  4EB9 00002272           1402                     JSR      PRINTNULL               ; Prints A
00002048  3203                    1403                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000204A  4EB9 00002128           1404                     JSR      PRINTNUM                ; Prints the Xn
00002050  4BF9 00002599           1405                     LEA      MSG_RB,A5               ; Loads ) into A5
00002056  4EB9 00002272           1406                     JSR      PRINTNULL               ; Prints )
0000205C  4BF9 0000259B           1407                     LEA      MSG_PLUS,A5             ; Loads + into A5
00002062  4EB9 00002272           1408                     JSR      PRINTNULL               ; Prints +
00002068  6000 00B8               1409                     BRA      EA_TO_STRING_EXIT       ; exits
0000206C                          1410  
0000206C                          1411  
0000206C                          1412  * address register indirect pre increment
0000206C  4BF9 0000259D           1413  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00002072  4EB9 00002272           1414                     JSR      PRINTNULL               ; Prints -
00002078  4BF9 00002597           1415                     LEA      MSG_LB,A5               ; Loads ( into A5
0000207E  4EB9 00002272           1416                     JSR      PRINTNULL               ; Prints (
00002084  4BF9 00002595           1417                     LEA      MSG_AR,A5               ; Loads A into A5
0000208A  4EB9 00002272           1418                     JSR      PRINTNULL               ; Prints A
00002090  3203                    1419                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002092  4EB9 00002128           1420                     JSR      PRINTNUM                ; Prints the Xn
00002098  4BF9 00002599           1421                     LEA      MSG_RB,A5               ; Loads ) into A5
0000209E  4EB9 00002272           1422                     JSR      PRINTNULL               ; Prints )
000020A4  6000 007C               1423                     BRA      EA_TO_STRING_EXIT       ; exits
000020A8                          1424  
000020A8                          1425  * other (long, short, immediate) with Xn yes
000020A8  301A                    1426  CASE_OTHER         MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000020AA  B67C 0000               1427                     CMP.W    #ABSShort,D3            ; checks if it is a word
000020AE  6700 002E               1428                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000020B2                          1429                     
000020B2  B67C 0001               1430                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000020B6  6700 0042               1431                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000020BA                          1432  
000020BA                          1433  * immediate
000020BA  4BF9 0000259F           1434  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000020C0  4EB9 00002272           1435                     JSR      PRINTNULL               ; Prints #  
000020C6  4BF9 000025A1           1436                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020CC  4EB9 00002272           1437                     JSR      PRINTNULL               ; Prints $
000020D2  3200                    1438                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020D4  4EB9 00002138           1439                     JSR      PRINTHEXNUM 
000020DA  6000 0046               1440                     BRA      EA_TO_STRING_EXIT       ; exits subroutine                  
000020DE                          1441                     
000020DE                          1442  * word address
000020DE                          1443  CASE_WORD          
000020DE  4BF9 000025A1           1444                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020E4  4EB9 00002272           1445                     JSR      PRINTNULL               ; Prints $
000020EA  3200                    1446                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020EC  383C 0000               1447                     MOVE.W   #0, D4                  ; moves length size (word) into d4
000020F0  4EB9 0000214C           1448                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
000020F6  6000 002A               1449                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
000020FA                          1450  
000020FA                          1451  * long address 
000020FA                          1452  CASE_LONG          
000020FA  4BF9 000025A1           1453                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002100  4EB9 00002272           1454                     JSR      PRINTNULL               ; Prints $
00002106  3200                    1455                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002108  383C 0000               1456                     MOVE.W   #0, D4                  ; moves word size (long) into d4
0000210C  4EB9 0000214C           1457                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002112  301A                    1458                     MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002114  3200                    1459                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002116  383C 0000               1460                     MOVE.W   #0, D4                  ; moves word size (long) into d4
0000211A  4EB9 0000214C           1461                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002120  321A                    1462                     MOVE     (A2)+, D1               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002122                          1463                     
00002122                          1464  * exits subroutine
00002122  4CDF 2003               1465  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
00002126  4E75                    1466                      RTS                              ; returns from subroutine
00002128                          1467  
00002128                          1468  * Prints out the content of D1 as a decimal number
00002128                          1469  * Input: number in D1 to be printed
00002128                          1470  * Output: contents of D1 printed
00002128  48E7 C000               1471  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000212C  103C 0003               1472                   MOVE.B      #3,D0               ; prints D1
00002130  4E4F                    1473                   TRAP        #15                 ; is trap task 3
00002132                          1474              
00002132  4CDF 0003               1475                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00002136  4E75                    1476                   RTS                             ; returns from subroutine
00002138                          1477                   
00002138                          1478  * Prints out the content of D1 as a hex number
00002138                          1479  * Input: number in D1 to be printed
00002138                          1480  * Output: contents of D1 printed
00002138  48E7 C000               1481  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000213C  143C 0010               1482                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002140  103C 000F               1483                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002144  4E4F                    1484                   TRAP        #15                 ; is trap task 15
00002146  4CDF 0003               1485                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000214A  4E75                    1486                   RTS                             ; returns from subroutine
0000214C                          1487                   
0000214C                          1488  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
0000214C                          1489  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
0000214C                          1490  * Output: contents of D1 printed
0000214C  48E7 E000               1491  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00002150  B83C 0001               1492                            CMP.B       #1,D4               ; checks size of number
00002154  6700 0042               1493                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
00002158                          1494  
00002158  3401                    1495  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
0000215A  C47C F000               1496                            AND.W       #$F000,D2           ; gets the first digit
0000215E  B47C 0000               1497                            CMP.W       #0, D2              ; checks if it is 0
00002162  6600 00DC               1498                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002166  4EB9 00002250           1499                            JSR         PRINTZERO           ; prints a zero
0000216C                          1500                            
0000216C  3401                    1501                            MOVE.W      D1,D2               ; copies number to D2
0000216E  C47C 0F00               1502                            AND.W       #$0F00,D2           ; gets the second digit
00002172  B47C 0000               1503                            CMP.W       #0, D2              ; checks if it is 0
00002176  6600 00C8               1504                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000217A  4EB9 00002250           1505                            JSR         PRINTZERO           ; prints a zero
00002180                          1506                            
00002180  3401                    1507                            MOVE.W      D1,D2               ; copies number to D2
00002182  C47C 00F0               1508                            AND.W       #$00F0,D2           ; gets the third digit
00002186  B47C 0000               1509                            CMP.W       #0, D2              ; checks if it is 0
0000218A  6600 00B4               1510                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000218E  4EB9 00002250           1511                            JSR         PRINTZERO           ; prints a zero
00002194  6000 00AA               1512                            BRA         PRINTASHEX          ; prints last digit
00002198                          1513                            
00002198  2401                    1514  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
0000219A  C4BC F0000000           1515                            AND.L       #$F0000000,D2       ; gets the first digit
000021A0  B4BC 00000000           1516                            CMP.L       #0, D2              ; checks if it is 0
000021A6  6600 0098               1517                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021AA  4EB9 00002250           1518                            JSR         PRINTZERO           ; prints a zero
000021B0                          1519                            
000021B0  2401                    1520                            MOVE.L      D1,D2               ; copies number to D2
000021B2  C4BC 0F000000           1521                            AND.L       #$0F000000,D2       ; gets the second digit
000021B8  B4BC 00000000           1522                            CMP.L       #0, D2              ; checks if it is 0
000021BE  6600 0080               1523                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021C2  4EB9 00002250           1524                            JSR         PRINTZERO           ; prints a zero
000021C8                          1525                            
000021C8  2401                    1526                            MOVE.L      D1,D2               ; copies number to D2
000021CA  C4BC 00F00000           1527                            AND.L       #$00F00000,D2       ; gets the third digit
000021D0  B4BC 00000000           1528                            CMP.L       #0, D2              ; checks if it is 0
000021D6  6600 0068               1529                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021DA  4EB9 00002250           1530                            JSR         PRINTZERO           ; prints a zero
000021E0                          1531                            
000021E0  2401                    1532                            MOVE.L      D1,D2               ; copies number to D2
000021E2  C4BC 000F0000           1533                            AND.L       #$000F0000,D2       ; gets the fourth digit
000021E8  B4BC 00000000           1534                            CMP.L       #0, D2              ; checks if it is 0
000021EE  6600 0050               1535                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021F2  4EB9 00002250           1536                            JSR         PRINTZERO           ; prints a zero
000021F8                          1537                            
000021F8  2401                    1538                            MOVE.L      D1,D2               ; copies number to D2
000021FA  C4BC 0000F000           1539                            AND.L       #$0000F000,D2       ; gets the fith digit
00002200  B4BC 00000000           1540                            CMP.L       #0, D2              ; checks if it is 0
00002206  6600 0038               1541                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000220A  4EB9 00002250           1542                            JSR         PRINTZERO           ; prints a zero
00002210                          1543                            
00002210  2401                    1544                            MOVE.L      D1,D2               ; copies number to D2
00002212  C4BC 00000F00           1545                            AND.L       #$00000F00,D2       ; gets the sixth digit
00002218  B4BC 00000000           1546                            CMP.L       #0, D2              ; checks if it is 0
0000221E  6600 0020               1547                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002222  4EB9 00002250           1548                            JSR         PRINTZERO           ; prints a zero
00002228                          1549                            
00002228  2401                    1550                            MOVE.L      D1,D2               ; copies number to D2
0000222A  C4BC 000000F0           1551                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002230  B4BC 00000000           1552                            CMP.L       #0, D2              ; checks if it is 0
00002236  6600 0008               1553                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000223A  4EB9 00002250           1554                            JSR         PRINTZERO           ; prints a zero
00002240                          1555  
00002240  143C 0010               1556  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002244  103C 000F               1557                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
00002248  4E4F                    1558                            TRAP        #15                 ; is trap task 15
0000224A  4CDF 0007               1559                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
0000224E  4E75                    1560                            RTS                             ; returns from subroutine    
00002250                          1561  * Prints a zero
00002250                          1562  * Input: nothing
00002250                          1563  * Output: 0 printed out to the console
00002250  2F01                    1564  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002252  7200                    1565                            MOVE.L      #0,D1               ; moves 0 to D1
00002254  4EB8 2128               1566                            JSR         PRINTNUM            ; prints the number
00002258  221F                    1567                            MOVE.L      (SP)+,D1            ; restores D1
0000225A  4E75                    1568                            RTS                             ; returns from subroutine
0000225C                          1569              
0000225C                          1570  * Prints contents of things between a range
0000225C                          1571  * input: A5, A6 (the range)
0000225C                          1572  * output: prints memory contents from A5 to A6 as strings   
0000225C  48E7 C040               1573  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00002260  224D                    1574                  MOVEA.L     A5, A1           ; loads A5 into A1
00002262  9DCD                    1575                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00002264  320E                    1576                  MOVE.W      A6, D1           ; move n into D1
00002266  103C 0001               1577                  MOVE.B      #1, D0           ; display n characters of string at A1
0000226A  4E4F                    1578                  TRAP        #15              ; is trap task 1
0000226C  4CDF 0203               1579                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
00002270  4E75                    1580                  RTS                          ; returns
00002272                          1581      
00002272                          1582  * Prints null terminated string
00002272                          1583  * input: string pointed to by A5
00002272                          1584  * output: prints out the null terminated string
00002272  48E7 8040               1585  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00002276  224D                    1586                  MOVE.L      A5,A1           ; loads A5 into A1
00002278  103C 000E               1587                  MOVE.B      #14,D0          ; prints null terminated string
0000227C  4E4F                    1588                  TRAP        #15             ; is trap task 10
0000227E  4CDF 0201               1589                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
00002282  4E75                    1590                  RTS                         ; returns from subroutine
00002284                          1591                  
00002284  2F0D                    1592  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
00002286  4BF9 000024D2           1593                  LEA         NEW_LINE,A5     ; Prints null
0000228C  4EB8 2272               1594                  JSR         PRINTNULL       ; prints the new line
00002290  2A5F                    1595                  MOVE.L      (SP)+,A5        ; returns A5
00002292  4E75                    1596                  RTS
00002294                          1597  
00002294                          1598  * Prints the size of the MOVE or MOVEA operation  
00002294                          1599  * input: D0
00002294                          1600  * output: prints out the size of a MOVE or MOVEA operation        
00002294  48E7 8004               1601  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00002298  3200                    1602                  MOVE.W  D0,D1               ; stores d0 in d1
0000229A  C07C 3000               1603                  AND.W   #$3000,D0           ; gets the size
0000229E  B07C 2000               1604                  CMP.W   #$2000,D0           ; checks if is long
000022A2  6700 001E               1605                  BEQ     MOVE_LONG
000022A6  B07C 3000               1606                  CMP.W   #$3000,D0           ; checks if is word
000022AA  6700 000C               1607                  BEQ     MOVE_WORD      
000022AE                          1608                  
000022AE  4BF9 000025CA           1609  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000022B4  6000 0012               1610                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000022B8                          1611  
000022B8  4BF9 000025CD           1612  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000022BE  6000 0008               1613                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000022C2                          1614  
000022C2  4BF9 000025D0           1615  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000022C8                          1616                  
000022C8  4EB8 2272               1617  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000022CC  4CDF 2001               1618                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000022D0  4E75                    1619                  RTS
000022D2                          1620  
000022D2  43F9 00002441           1621  ERROR           LEA     ERROR_MSG,A1
000022D8  103C 000E               1622                  MOVE.B  #14,D0
000022DC  4E4F                    1623                  TRAP    #15 
000022DE                          1624            
000022DE  FFFF FFFF               1625      SIMHALT             ; halt simulator
000022E2                          1626  
000022E2                          1627  * Put variables and constants here
000022E2                          1628  
000022E2  =0000000D               1629  CR                              EQU     $0D
000022E2  =0000000A               1630  LF                              EQU     $0A 
000022E2  =00000009               1631  TAB                             EQU     $09  
000022E2                          1632  
000022E2                          1633  * Addressing Modes
000022E2  =00000000               1634  Dn                              EQU     0
000022E2  =00000001               1635  An                              EQU     1
000022E2  =00000002               1636  AnIndirect                      EQU     2
000022E2  =00000003               1637  AnPost                          EQU     3
000022E2  =00000004               1638  AnPre                           EQU     4
000022E2  =00000007               1639  Other                           EQU     7           ; short, long, immediate
000022E2                          1640  
000022E2                          1641  * Xn
000022E2  =00000000               1642  ABSShort                        EQU     0
000022E2  =00000001               1643  ABSLong                         EQU     1
000022E2  =00000004               1644  XnImmediate                     EQU     4
000022E2                          1645  
000022E2                          1646  * Valid Addressing Modes
000022E2= 00 01 02 03 04 07 FF    1647  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
000022E9                          1648  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
000022E9= 00 02 03 04 07 FF       1649  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
000022EF= 02 04 07 FF             1650  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
000022F3= 02 03 07 FF             1651  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
000022F7= 02 03 04 07 FF          1652  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
000022FC= 00 02 03 04 07 FF       1653  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002302= 01 07 FF                1654  VALIDEA_LEA                     DC.B    An,Other,-1
00002305= 00 02 03 04 07 FF       1655  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000230B= 02 03 04 07 FF          1656  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002310= 02 03 04 07 FF          1657  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
00002315= 02 07 FF                1658  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00002318                          1659  
00002318                          1660  * Valid Xn
00002318= 00 01 04 FF             1661  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
0000231C                          1662  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
0000231C= 00 01 FF                1663  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
0000231F                          1664  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
0000231F                          1665  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
0000231F                          1666  
0000231F                          1667  * posible memory ASd/LSd rotation values
0000231F  =00000000               1668  ASd_MEM                         EQU     0   
0000231F  =00000001               1669  LSd_MEM                         EQU     1 
0000231F  =00000003               1670  ROd_MEM                         EQU     3
0000231F                          1671   
0000231F  =00000000               1672  ASd_REG                         EQU     0   
0000231F  =00000001               1673  LSd_REG                         EQU     1 
0000231F  =00000003               1674  ROd_REG                         EQU     3
0000231F                          1675  
0000231F                          1676  * Messages
0000231F= 57 65 6C 63 6F 6D ...   1677  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
00002347= 46 6F 72 6D 61 74 ...   1678  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
00002392= 4C 65 74 74 65 72 ...   1679  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000023B2= 50 6C 65 61 73 65 ...   1680  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
000023E9= 50 6C 65 61 73 65 ...   1681  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
0000241F= 49 6E 76 61 6C 69 ...   1682  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
00002441= 45 72 72 6F 72 20 ...   1683  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
0000245D= 09 44 41 54 41 00       1684  INVALID_INSTR                   DC.B    TAB,'DATA',0
00002463= 46 69 6E 69 73 68 ...   1685  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
000024A7= 0D 0A 50 72 65 73 ...   1686  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
000024D2= 0D 0A 00                1687  NEW_LINE                        DC.B    CR,LF,0
000024D5= 09 09 09 00             1688  THREE_TAB                       DC.B    TAB,TAB,TAB,0
000024D9                          1689  
000024D9                          1690  * Opcode Messages
000024D9= 09 4E 4F 50 00          1691  MSG_NOP                         DC.B    TAB,'NOP',0
000024DE= 09 4D 4F 56 45 00       1692  MSG_MOVE                        DC.B    TAB,'MOVE',0  
000024E4= 09 4D 4F 56 45 41 00    1693  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
000024EB= 09 4D 4F 56 45 51 00    1694  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
000024F2= 09 4D 4F 56 45 4D 00    1695  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
000024F9= 09 41 44 44 00          1696  MSG_ADD                         DC.B    TAB,'ADD',0
000024FE= 09 41 44 44 41 00       1697  MSG_ADDA                        DC.B    TAB,'ADDA',0
00002504= 09 41 44 44 51 00       1698  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
0000250A= 09 53 55 42 00          1699  MSG_SUB                         DC.B    TAB,'SUB',0
0000250F= 09 4D 55 4C 53 00       1700  MSG_MULS                        DC.B    TAB,'MULS',0
00002515= 09 44 49 56 55 00       1701  MSG_DIVU                        DC.B    TAB,'DIVU',0
0000251B= 09 4C 45 41 00          1702  MSG_LEA                         DC.B    TAB,'LEA',0
00002520= 09 41 4E 44 00          1703  MSG_AND                         DC.B    TAB,'AND',0
00002525= 09 4F 52 00             1704  MSG_OR                          DC.B    TAB,'OR',0
00002529= 09 4E 4F 54 00          1705  MSG_NOT                         DC.B    TAB,'NOT',0
0000252E= 09 4C 53 00             1706  MSG_LSd                         DC.B    TAB,'LS',0
00002532= 09 41 53 00             1707  MSG_ASd                         DC.B    TAB,'AS',0
00002536= 09 52 4F 00             1708  MSG_ROd                         DC.B    TAB,'RO',0
0000253A= 09 42 43 43 00          1709  MSG_BCC                         DC.B    TAB,'BCC',0
0000253F= 09 42 43 53 00          1710  MSG_BCS                         DC.B    TAB,'BCS',0
00002544= 09 42 45 51 00          1711  MSG_BEQ                         DC.B    TAB,'BEQ',0
00002549= 09 42 4E 45 00          1712  MSG_BNE                         DC.B    TAB,'BNE',0
0000254E= 09 42 47 45 00          1713  MSG_BGE                         DC.B    TAB,'BGE',0
00002553= 09 42 47 54 00          1714  MSG_BGT                         DC.B    TAB,'BGT',0
00002558= 09 42 48 49 00          1715  MSG_BHI                         DC.B    TAB,'BHI',0
0000255D= 09 42 4C 45 00          1716  MSG_BLE                         DC.B    TAB,'BLE',0
00002562= 09 42 4C 53 00          1717  MSG_BLS                         DC.B    TAB,'BLS',0
00002567= 09 42 4C 54 00          1718  MSG_BLT                         DC.B    TAB,'BLT',0
0000256C= 09 42 4D 49 00          1719  MSG_BMI                         DC.B    TAB,'BMI',0
00002571= 09 42 50 4C 00          1720  MSG_BPL                         DC.B    TAB,'BPL',0
00002576= 09 42 56 43 00          1721  MSG_BVC                         DC.B    TAB,'BVC',0
0000257B= 09 42 56 53 00          1722  MSG_BVS                         DC.B    TAB,'BVS',0
00002580= 09 4A 53 52 00          1723  MSG_JSR                         DC.B    TAB,'JSR',0
00002585= 09 52 54 53 00          1724  MSG_RTS                         DC.B    TAB,'RTS',0
0000258A= 09 42 52 41 00          1725  MSG_BRA                         DC.B    TAB,'BRA',0
0000258F                          1726  
0000258F                          1727  * Direction for LSd and ASd
0000258F= 52 00                   1728  MSG_RIGHT                       DC.B    'R',0
00002591= 4C 00                   1729  MSG_LEFT                        DC.B    'L',0
00002593                          1730  
00002593                          1731  * Effective Addresses Messages
00002593= 44 00                   1732  MSG_DR                          DC.B    'D',0
00002595= 41 00                   1733  MSG_AR                          DC.B    'A',0
00002597= 28 00                   1734  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
00002599= 29 00                   1735  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
0000259B= 2B 00                   1736  MSG_PLUS                        DC.B    '+',0
0000259D= 2D 00                   1737  MSG_MINUS                       DC.B    '-',0
0000259F= 23 00                   1738  MSG_POUND                       DC.B    '#',0 
000025A1= 24 00                   1739  MSG_HEX                         DC.B    '$',0 
000025A3= 2C 20 00                1740  MSG_COMMA                       DC.B    ', ',0
000025A6= 2F 00                   1741  MSG_SLASH                       DC.B    '/',0  
000025A8= 20 00                   1742  MSG_SPACE                       DC.B    ' ',0
000025AA= 09 00                   1743  MSG_TAB                         DC.B    TAB,0
000025AC= 20 20 20 00             1744  MSG_3SPACES                     DC.B    '   ',0
000025B0= 20 20 20 20 00          1745  MSG_4SPACES                     DC.B    '    ',0
000025B5= 20 20 20 20 20 00       1746  MSG_5SPACES                     DC.B    '     ',0
000025BB= 20 20 20 20 20 20 00    1747  MSG_6SPACES                     DC.B    '      ',0
000025C2= 20 20 20 20 20 20 ...   1748  MSG_7SPACES                     DC.B    '       ',0
000025CA                          1749  
000025CA                          1750  * Size Messages
000025CA= 2E 42 00                1751  MSG_B                           DC.B    '.B',0
000025CD= 2E 57 00                1752  MSG_W                           DC.B    '.W',0
000025D0= 2E 4C 00                1753  MSG_L                           DC.B    '.L',0
000025D3                          1754  
000025D3                          1755  * Variables
000025D3  =00000100               1756  STARTING_ADDRESS                EQU     $100
000025D3  =00000150               1757  ENDING_ADDRESS                  EQU     $150
000025D3  =00000200               1758  CURRENT_INSTR                   EQU     $200
000025D3  =00000250               1759  REG_VAR                         EQU     $250 * Hold bits 11-9
000025D3  =00000300               1760  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
000025D3  =00000350               1761  EA_MODE                         EQU     $350 * Hold bits 5-3
000025D3  =00000400               1762  EA_REG                          EQU     $400 * Hold bits 2-0
000025D3= 00                      1763  LINE_COUNT                      DC.B     0
000025D4= 14                      1764  LINE_MAX                        DC.B     20
000025D5                          1765              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           1674
ADDQ_BYTE           1712
ADDQ_LONG           174A
ADDQ_WORD           172E
ADD_SUB_BYTE        15A4
ADD_SUB_HELP        151E
ADD_SUB_LONG        15C0
ADD_SUB_OPERAND     15D6
ADD_SUB_SIZE        1580
ADD_SUB_WORD        15B2
AN                  1
AND_BYTE            1930
AND_LONG            1968
AND_WORD            194C
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           241F
CASE_ADD            14F6
CASE_ADDA           163C
CASE_ADDQ           16BC
CASE_AND            18EA
CASE_AR             1FE8
CASE_ARI            2000
CASE_ARIPOST        2030
CASE_ARIPRE         206C
CASE_ASDMEM         1AD0
CASE_ASDREG         1BA4
CASE_BCC            1D0C
CASE_BEQ            1D3E
CASE_BGT            1D52
CASE_BLE            1D48
CASE_BRA            1CDC
CASE_DATA           1DDA
CASE_DR             1FD0
CASE_EPICFAIL       1DE0
CASE_IMMEDIATE      20BA
CASE_JSR            1D78
CASE_LEA            184C
CASE_LEFTMEM        1AF6
CASE_LEFTREG        1BCA
CASE_LONG           20FA
CASE_LSDASDROD      1A90
CASE_LSDMEM         1AC6
CASE_LSDREG         1B9A
CASE_MOVE           1296
CASE_MOVEM          135C
CASE_MOVEQ          146E
CASE_NOP            1280
CASE_NOT            1A2C
CASE_OR             19CC
CASE_OTHER          20A8
CASE_RIGHTMEM       1B00
CASE_RIGHTREG       1BD4
CASE_RODMEM         1ADA
CASE_RODREG         1BAE
CASE_RTS            1DC4
CASE_SHIFTMEM       1AAE
CASE_SHIFTREG       1B80
CASE_SUB            17B4
CASE_SUBA           1836
CASE_WORD           20DE
CHECKEAEXIT         1FA0
CHECKEAMLOOP        1F72
CHECKEAXN_IFVALID   1F70
CHECKGET_EAXN       1E36
CHECKMEMSOURE       1B40
CHECKMOREBITS       1F22
CHECKSHIFT_XN       1B6A
CHECK_LENGTH        11CE
CHECK_LINE          1176
CHECK_ODD           1264
CHECK_ORDER         10AE
CHECK_XN            1E66
CLEAR_SCREEN        11AA
COMPLETE_REGIM      1C4C
CONCAT              1216
CONTINUE            24A7
CONVERT             11E0
CR                  D
CURRENT_INSTR       200
DESTEA              1DEC
DESTXN              1E16
DISASSEMBLE         10C4
DN                  0
DN_PLUS_EA          1610
DONE                2463
DONEPRINTINGREG     1F6C
EASHIFT_VALID       1B5E
EAXN_INVALID        1E78
EAXN_VALID          1E5E
EA_MODE             350
EA_REG              400
EA_TO_STRING        1FA4
EA_TO_STRING_EXIT   2122
ENDING              23E9
ENDING_ADDRESS      150
END_CHECKGET        1E7C
ERROR               22D2
ERROR_MSG           2441
FINDTYPEEA          1E00
FINDTYPEXN          1E2A
FINISHED            10E8
FINISHMOVE          22C8
FINISH_ADD          15CE
FINISH_ADDA         1690
FINISH_ADDQ         1766
FINISH_AND          1984
FINISH_SUB          17FC
FINISH_SUBA         1802
FORMAT1             2347
FORMAT2             2392
GETDIRECTION        1EB6
GETDISPLACEMENT     1E7E
GETMEMSOURCE        1B28
GETROTATION         1EAC
GETROTATIONLOCATION  1EC6
GETROTATIONSIZE     1EBE
GET_EA              1DE2
GET_XN              1E0C
INPUT1              1020
INPUT2              1066
INSERTA             131C
INVALID             122E
INVALIDEA           1F84
INVALID_INSTR       245D
INV_INSTR           198E
ISNUMBER            11F6
LF                  A
LINE_COUNT          25D3
LINE_MAX            25D4
LSD_MEM             1
LSD_REG             1
MAKESHIFT8          1C48
MEM2REGLONG         1432
MEM2REGWORD         1422
MEMTOREG1           1EEE
MEMTOREG2           1F60
MOVEM_MEM2REG       13EE
MOVEM_REG2MEM       137A
MOVE_BYTE           22AE
MOVE_LONG           22C2
MOVE_WORD           22B8
MSG_3SPACES         25AC
MSG_4SPACES         25B0
MSG_5SPACES         25B5
MSG_6SPACES         25BB
MSG_7SPACES         25C2
MSG_ADD             24F9
MSG_ADDA            24FE
MSG_ADDQ            2504
MSG_AND             2520
MSG_AR              2595
MSG_ASD             2532
MSG_B               25CA
MSG_BCC             253A
MSG_BCS             253F
MSG_BEQ             2544
MSG_BGE             254E
MSG_BGT             2553
MSG_BHI             2558
MSG_BLE             255D
MSG_BLS             2562
MSG_BLT             2567
MSG_BMI             256C
MSG_BNE             2549
MSG_BPL             2571
MSG_BRA             258A
MSG_BVC             2576
MSG_BVS             257B
MSG_COMMA           25A3
MSG_DIVU            2515
MSG_DR              2593
MSG_HEX             25A1
MSG_JSR             2580
MSG_L               25D0
MSG_LB              2597
MSG_LEA             251B
MSG_LEFT            2591
MSG_LSD             252E
MSG_MINUS           259D
MSG_MOVE            24DE
MSG_MOVEA           24E4
MSG_MOVEM           24F2
MSG_MOVEQ           24EB
MSG_MULS            250F
MSG_NOP             24D9
MSG_NOT             2529
MSG_OR              2525
MSG_PLUS            259B
MSG_POUND           259F
MSG_RB              2599
MSG_RIGHT           258F
MSG_ROD             2536
MSG_RTS             2585
MSG_SLASH           25A6
MSG_SPACE           25A8
MSG_SUB             250A
MSG_TAB             25AA
MSG_W               25CD
NEW_LINE            24D2
NEXT_SCREEN         118A
NOTNUMBER           11FE
OPCODE_DECODE       1278
OPMODE_VAR          300
OR_SIZE             1A14
OTHER               7
OTHEREA             1F9C
PRINTADD            155C
PRINTADDRESS        1E8E
PRINTASHEX          2240
PRINTBCC            1D5C
PRINTENTER          2284
PRINTHEXNUM         2138
PRINTLONGZERO       2198
PRINTMEM2REG        143E
PRINTMORE           1F2E
PRINTMOVE           133A
PRINTMOVESIZE       2294
PRINTNULL           2272
PRINTNUM            2128
PRINTRANGE          225C
PRINTREG            1F14
PRINTREG2MEM        13BE
PRINTREGEA          1C16
PRINTREGISTERLOOP   1EF8
PRINTREGISTERS      1ECE
PRINTREGSIZE        1BE4
PRINTSHIFTMEM       1AE0
PRINTSHIFTREG       1BB4
PRINTSHORTLONGNUM   214C
PRINTSHORTZERO      2158
PRINTSUB            17CA
PRINTZERO           2250
PRINT_8             17A8
PRINT_ADDQ_DATA     1784
PRINT_ADDR          126C
PRINT_JSR           1DA4
PRINT_MEMDIR        1B06
PRINT_MOVEQ         1490
PRINT_REGDIR        1BDE
READ_KEY            119A
REG2MEMLONG         13B8
REG2MEMWORD         13AE
REGTOMEM1           1EE0
REGTOMEM2           1F54
REG_BYTE            1BFC
REG_IMMEDIATE       1C38
REG_LONG            1C10
REG_REGISTER        1C96
REG_VAR             250
REG_WORD            1C06
RESET_INPUT         11C6
RESTART             1110
RETURN              122C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1DF8
SOURCEXN            1E22
START               1000
STARTING            23B2
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          124C
THREE_TAB           24D5
VALIDEA             1F8C
VALIDEA_ADDSUB_DESTOPERAND  22F7
VALIDEA_ALL         22E2
VALIDEA_ANDORNOT    2305
VALIDEA_ANDOR_DESTOPERAND  230B
VALIDEA_JSR         2315
VALIDEA_LEA         2302
VALIDEA_MOVEM_MEMTOREG  22F3
VALIDEA_MOVEM_REGTOMEM  22EF
VALIDEA_MOVEQ       22E9
VALIDEA_MULSDIVU    22FC
VALIDEA_SHIFT       2310
VALIDXN_ALL         2318
VALIDXN_SHORTLONG   231C
WELCOME             231F
XNIMMEDIATE         4
