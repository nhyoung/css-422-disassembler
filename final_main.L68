00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 6:11:24 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 6/10/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 00002359             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15                  
0000100C  43F9 00002381             16                  LEA     FORMAT1,A1
00001012  700E                      17                  MOVE.L  #14,D0
00001014  4E4F                      18                  TRAP    #15
00001016                            19                  
00001016  43F9 000023CC             20                  LEA     FORMAT2,A1
0000101C  700E                      21                  MOVE.L  #14,D0
0000101E  4E4F                      22                  TRAP    #15
00001020                            23              
00001020  227C 00000000             24  INPUT1          MOVE.L  #$0000000, A1       ;clear A1
00001026  43F9 000023EC             25                  LEA     STARTING,A1         ; output starting address message
0000102C  103C 000E                 26                  MOVE.B  #14,D0
00001030  4E4F                      27                  TRAP    #15
00001032                            28              
00001032  227C 00000000             29                  MOVE.L  #$0000000, A1        ;clear A1
00001038  103C 0002                 30                  MOVE.B  #2,D0                   
0000103C  4E4F                      31                  TRAP    #15                 ; take input from user
0000103E  143C 0001                 32                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001042                            33  
00001042  4EB9 000011DE             34                  JSR     CHECK_LENGTH
00001048  1C3C 0007                 35                  MOVE.B  #7,D6               ; D6 stores counter               
0000104C  4EB9 000011F0             36                  JSR     CONVERT
00001052  4EB9 0000125C             37                  JSR     TEST_RANGE
00001058  4EB9 00001274             38                  JSR     CHECK_ODD
0000105E  23C5 00000100             39                  MOVE.L  D5,STARTING_ADDRESS
00001064  2445                      40                  MOVEA.L D5,A2               ; store first input in A2
00001066                            41    
00001066  143C 0002                 42  INPUT2          MOVE.B  #2,D2
0000106A  227C 00000000             43                  MOVE.L  #$0000000, A1       ;clear A1
00001070  43F9 00002423             44                  LEA     ENDING,A1           ; output ending address message
00001076  103C 000E                 45                  MOVE.B  #14,D0
0000107A  4E4F                      46                  TRAP    #15         
0000107C                            47  
0000107C  227C 00000000             48                  MOVE.L  #$0000000, A1       ;clear A1
00001082  103C 0002                 49                  MOVE.B  #2,D0
00001086  4E4F                      50                  TRAP    #15
00001088                            51                  
00001088  4EB9 000011DE             52                  JSR     CHECK_LENGTH
0000108E  1C3C 0007                 53                  MOVE.B  #7,D6               ; D6 stores counter
00001092  4285                      54                  CLR.L   D5
00001094  4EB9 000011F0             55                  JSR     CONVERT
0000109A  4EB9 0000125C             56                  JSR     TEST_RANGE
000010A0  4EB9 00001274             57                  JSR     CHECK_ODD
000010A6  23C5 00000150             58                  MOVE.L  D5,ENDING_ADDRESS
000010AC  2645                      59                  MOVEA.L D5,A3               ; store second input in A3
000010AE                            60        
000010AE  260A                      61  CHECK_ORDER     MOVE.L  A2,D3
000010B0  280B                      62                  MOVE.L  A3,D4
000010B2  B883                      63                  CMP.L   D3,D4               ; make sure first input is less than second input
000010B4  6D00 0120                 64                  BLT     RESET_INPUT
000010B8  4BF9 0000250C             65                  LEA     NEW_LINE,A5
000010BE  4EB9 000022A8             66                  JSR     PRINTNULL
000010C4                            67                  
000010C4  1439 0000260D             68                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010CA  143C 0007                 69                  MOVE.B  #7,D2               ; set variable to 0
000010CE  13C2 0000260D             70                  MOVE.B  D2,LINE_COUNT       ; store back in the variabl
000010D4                            71                                 
000010D4  1439 0000260D             72  DISASSEMBLE     MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
000010DA  5202                      73                  ADD.B   #1,D2               ; add 1 to counter
000010DC  13C2 0000260D             74                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
000010E2                            75                  
000010E2  4EB9 00001288             76                  JSR     OPCODE_DECODE       ; decode the opcode
000010E8                            77                  
000010E8  4EB9 00001186             78                  JSR     CHECK_LINE          ; check if max number of lines on screen has been reached
000010EE                            79                  
000010EE  4EB9 000022BA             80                  JSR     PRINTENTER          ; prints a new line
000010F4  B5CB                      81                  CMP.L   A3, A2              ; checks if A2 has reached A3
000010F6  6FDC                      82                  BLE     DISASSEMBLE         ; if not, loop
000010F8                            83                  
000010F8                            84  
000010F8  4BF9 0000249D             85  FINISHED        LEA     DONE,A5
000010FE  4EB9 000022A8             86                  JSR     PRINTNULL
00001104  103C 0005                 87                  MOVE.B  #5,D0
00001108  4E4F                      88                  TRAP    #15
0000110A                            89                  
0000110A  B23C 0052                 90                  CMP.B   #82,D1              ; Compare the key press with R
0000110E  6700 0010                 91                  BEQ     RESTART             ; it's R, restart
00001112                            92                  
00001112  B23C 0072                 93                  CMP.B   #114,D1              ; Compare the key press with r
00001116  6700 0008                 94                  BEQ     RESTART             ; it's r, restart
0000111A                            95  
0000111A  103C 0009                 96                  MOVE.B  #9,D0
0000111E  4E4F                      97                  TRAP    #15
00001120                            98                  
00001120  103C 000B                 99  RESTART         MOVE.B  #11, D0             Task 11 - Clear screen
00001124  323C FF00                100                  MOVE.W  #$FF00, D1          Clear Screen
00001128  4E4F                     101                  TRAP    #15                 Call Trap
0000112A                           102                  
0000112A  103C 000C                103                  MOVE.B  #12,D0              Keyboard echo
0000112E  123C 0001                104                  MOVE.B  #1,D1               Visible
00001132  4E4F                     105                  TRAP    #15
00001134                           106                  
00001134  1439 0000260D            107                  MOVE.B  LINE_COUNT,D2       ; move to D2 for editing
0000113A  143C 0000                108                  MOVE.B  #0,D2               ; set variable to 0
0000113E  13C2 0000260D            109                  MOVE.B  D2,LINE_COUNT       ; store back in the variable
00001144                           110   
00001144  207C 00000000            111                  MOVE.L  #$0000000, A0       ; Reset A1
0000114A  227C 00000000            112                  MOVE.L  #$0000000, A1       ; Reset A1
00001150  247C 00000000            113                  MOVE.L  #$0000000, A2       ; Reset A2
00001156  267C 00000000            114                  MOVE.L  #$0000000, A3       ; Reset A3
0000115C  287C 00000000            115                  MOVE.L  #$0000000, A4       ; Reset A4
00001162  2A7C 00000000            116                  MOVE.L  #$0000000, A5       ; Reset A5
00001168  2C7C 00000000            117                  MOVE.L  #$0000000, A6       ; Reset A6
0000116E  2E7C 01000000            118                  MOVEA.L #$01000000,A7       ; Reset A7
00001174  4281                     119                  CLR.L   D1                  ; Reset D1
00001176  4281                     120                  CLR.L   D1                  ; Reset D1
00001178  4282                     121                  CLR.L   D2                  ; Reset D2
0000117A  4283                     122                  CLR.L   D3                  ; Reset D3
0000117C  4284                     123                  CLR.L   D4                  ; Reset D4
0000117E  4285                     124                  CLR.L   D5                  ; Reset D5
00001180  4286                     125                  CLR.L   D6                  ; Reset D6
00001182  6000 FE7C                126                  BRA     START               ; branch to start of program
00001186                           127  
00001186                           128  *--------------------SUBROUTINES------------------
00001186  1439 0000260D            129  CHECK_LINE      MOVE.B  LINE_COUNT,D2
0000118C  1639 0000260E            130                  MOVE.B  LINE_MAX,D3                
00001192  B602                     131                  CMP.B   D2,D3 ; compare number of lines on screen with maximum
00001194  6F00 0004                132                  BLE     NEXT_SCREEN         ; if max line count has been reached go to next screen
00001198  4E75                     133                  RTS
0000119A                           134  
0000119A  4BF9 000024E1            135  NEXT_SCREEN     LEA     CONTINUE,A5
000011A0  4EB9 000022A8            136                  JSR     PRINTNULL
000011A6  6000 0002                137                  BRA     READ_KEY
000011AA                           138                  
000011AA  103C 0005                139  READ_KEY        MOVE.B  #5,D0
000011AE  4E4F                     140                  TRAP    #15
000011B0                           141                  
000011B0  B23C 000D                142                  CMP.B   #$D,D1              ; Compare the key press with ENTER
000011B4  6700 0004                143                  BEQ     CLEAR_SCREEN             ; it's Enter, restart
000011B8  60F0                     144                  BRA     READ_KEY
000011BA                           145                  
000011BA  103C 000B                146  CLEAR_SCREEN    MOVE.B  #11, D0             Task 11 - Clear screen
000011BE  323C FF00                147                  MOVE.W  #$FF00, D1          Clear Screen
000011C2  4E4F                     148                  TRAP    #15                 Call Trap
000011C4                           149                  
000011C4                           150                  ; reset line counter
000011C4  1439 0000260D            151                  MOVE.B  LINE_COUNT,D2
000011CA  143C 0000                152                  MOVE.B  #$0,D2
000011CE  13C2 0000260D            153                  MOVE.B  D2,LINE_COUNT
000011D4  4E75                     154                  RTS       
000011D6                           155      
000011D6                           156  
000011D6  143C 0001                157  RESET_INPUT     MOVE.B  #1,D2
000011DA  6000 0062                158                  BRA     INVALID            
000011DE                           159                  
000011DE  7800                     160  CHECK_LENGTH    MOVEQ   #$0,D4              ; check if input is null    
000011E0  B204                     161                  CMP.B   D4,D1               ; D1 stores length
000011E2  6700 005A                162                  BEQ     INVALID             ; input is null
000011E6  0C41 0008                163                  CMPI    #$8,D1              ; check if input is longer than a longword
000011EA  6600 0052                164                  BNE     INVALID             ; input is longer than a longword
000011EE  4E75                     165                  RTS
000011F0                           166                              
000011F0  4283                     167  CONVERT         CLR.L   D3
000011F2  4284                     168                  CLR.L   D4
000011F4  1619                     169                  MOVE.B  (A1)+,D3            ; D3 stores current char
000011F6  B63C 0039                170                  CMP.B   #57,D3
000011FA  6E00 0012                171                  BGT     NOTNUMBER
000011FE                           172                  
000011FE  B63C 002F                173                  CMP.B   #47,D3
00001202  6E00 0002                174                  BGT     ISNUMBER
00001206                           175                  
00001206  0603 00D0                176  ISNUMBER        ADD.B   #-48,D3             ; current char is number
0000120A  6000 001A                177                  BRA     CONCAT
0000120E                           178              
0000120E  B63C 0041                179  NOTNUMBER       CMP.B   #65,D3
00001212  6D00 002A                180                  BLT     INVALID
00001216  B63C 0046                181                  CMP.B   #70,D3
0000121A  6E00 0022                182                  BGT     INVALID  
0000121E  0603 00C9                183                  ADD.B   #-55,D3             ; is letter             
00001222  6000 0002                184                  BRA     CONCAT
00001226                           185              
00001226  BC3C 0000                186  CONCAT          CMP.B   #0,D6               ; D6 stores counter
0000122A  6D00 0010                187                  BLT     RETURN
0000122E  1806                     188                  MOVE.B  D6,D4               ; D4 stores modified counter 
00001230  E50C                     189                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
00001232  E9AB                     190                  LSL.L   D4,D3               ; moves current char to correct position  
00001234  DA83                     191                  ADD.L   D3,D5               ; D5 stores converted input so far
00001236  0606 00FF                192                  ADD.B   #-1,D6  
0000123A  60B4                     193                  BRA     CONVERT             ; continue loop for remaining chars
0000123C                           194                  
0000123C  4E75                     195  RETURN          RTS
0000123E                           196                  
0000123E  227C 00000000            197  INVALID         MOVEA.L #$0000000, A1       ; clear A1
00001244  43F9 00002459            198                  LEA     BAD_INPUT,A1        ; output invalid message
0000124A  103C 000E                199                  MOVE.B  #14,D0
0000124E  4E4F                     200                  TRAP    #15
00001250  B47C 0001                201                  CMP     #1,D2
00001254  6700 FDCA                202                  BEQ     INPUT1
00001258  6000 FE0C                203                  BRA     INPUT2
0000125C                           204  
0000125C  4284                     205  TEST_RANGE      CLR.L      D4               ; D4 will store test results
0000125E  223C 00001000            206                  MOVE.L     #$1000,D1        ; D1 stores minimum address
00001264  BA81                     207                  CMP.L      D1,D5            ; Compare minimum address with input
00001266  6DD6                     208                  BLT        INVALID          ; input is too low. 
00001268  223C 00FFFFFE            209                  MOVE.L     #$00FFFFFE,D1    ; D1 now stores maximum address
0000126E  BA81                     210                  CMP.L      D1,D5            ; compare maximum address with input
00001270  6ECC                     211                  BGT        INVALID          ; input too large
00001272  4E75                     212                  RTS                         ; input is within range
00001274                           213             
00001274  0805 0000                214  CHECK_ODD       BTST       #0,D5            ; check if input is odd
00001278  66C4                     215                  BNE        INVALID
0000127A  4E75                     216                  RTS
0000127C                           217  
0000127C  220E                     218  PRINT_ADDR      MOVE.L  A6,D1                   ; loads current address in D1
0000127E  7801                     219                  MOVE.L  #1,D4                   ; tells subroutine we want to make the address print as a long
00001280  4EB9 00002182            220                  JSR     PRINTSHORTLONGNUM       ; prints out address
00001286  4E75                     221                  RTS
00001288                           222  
00001288                           223  
00001288                           224  
00001288                           225  * Checks every single possible opcode we could have. Jump table
00001288                           226  * Inputs: (A2) which is a pointer to intruction word to be translated
00001288                           227  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
00001288                           228  
00001288  2C4A                     229  OPCODE_DECODE   MOVE.L  A2,A6
0000128A  301A                     230                  MOVE.W  (A2)+,D0                ; load instruction word from memory, store in D0
0000128C  4EB8 127C                231                  JSR     PRINT_ADDR
00001290                           232                  
00001290                           233  
00001290                           234  *---------------NOP opcode----------------------                
00001290  B07C 4E71                235  CASE_NOP        CMP.W   #$4E71,D0               ; compares to NOP opcode in hex
00001294  6600 0010                236                  BNE     CASE_MOVE               ; checks the next case if not equal
00001298                           237                  
00001298  4BF9 00002513            238                  LEA     MSG_NOP,A5              ; loads string pointer into A5
0000129E  4EB9 000022A8            239                  JSR     PRINTNULL               ; prints NOP                
000012A4  4E75                     240                  RTS                             ; returns from the subroutine
000012A6                           241  
000012A6                           242  *---------------MOVE opcode----------------------              
000012A6                           243                  * if first two bits are 00, next two are not 00
000012A6  3200                     244  CASE_MOVE       MOVE.W  D0,D1                   ; stores d0 in d1
000012A8  C27C C000                245                  AND.W   #$C000, D1              ; applies a bitmask to get 4 bits, want 00XX
000012AC  6600 00BE                246                  BNE     CASE_MOVEM              ; if not 0, not a  move instruction
000012B0  B07C 0FFF                247                  CMP.W   #$0FFF, D0              ; checks if it exceeds 0FFF
000012B4  6F00 00B6                248                  BLE     CASE_MOVEM              ; if less than or equal to, not a move             
000012B8                           249                  
000012B8                           250                  ; Check source
000012B8  4BF9 0000231C            251                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012BE  4DF9 00002352            252                  LEA     VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000012C4  3E3C 0000                253                  MOVE.W  #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012C8  4EB9 00001E48            254                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012CE  B27C 0001                255                  CMP.W   #1,D1                    ; checks if invalid
000012D2  6700 0B18                256                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012D6  3802                     257                  MOVE.W  D2,D4                    ; Moves D2 (source effective address) to D4
000012D8  3A03                     258                  MOVE.W  D3,D5                    ; Moves D3 (source Xn if applicable) to D5
000012DA                           259                  
000012DA                           260                  ; Check destination
000012DA  4BF9 0000231C            261                  LEA     VALIDEA_ALL,A5           ; Loads valid EA types in A5
000012E0  4DF9 00002356            262                  LEA     VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
000012E6  3E3C 0001                263                  MOVE.W  #1,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000012EA  4EB9 00001E48            264                  JSR     CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000012F0  B27C 0001                265                  CMP.W   #1,D1                    ; checks if invalid
000012F4  6700 0AF6                266                  BEQ     CASE_DATA                ; branches to CASE_DATA if invalid
000012F8  3C02                     267                  MOVE.W  D2,D6                    ; Moves D2 (source effective address) to D6
000012FA  3E03                     268                  MOVE.W  D3,D7                    ; Moves D3 (source Xn if applicable) to D7
000012FC                           269                  
000012FC                           270                  ; Checking if it is MOVEA
000012FC  3200                     271                  MOVE.W  D0,D1                    ; stores d0 in d1
000012FE  C27C 01C0                272                  AND.W   #$01C0, D1               ; appplies a bitmask to get 3 bits, check if its 001
00001302  B27C 0040                273                  CMP.W   #$0040, D1               ; confirms if it is a MOVEA
00001306  6700 0024                274                  BEQ     INSERTA                  ; branches to MOVEA, otherwise it is a normal MOVE
0000130A                           275                  
0000130A  4BF9 00002518            276                  LEA     MSG_MOVE,A5              ; loads string pointer for MOVE into A5
00001310  4EB9 000022A8            277                  JSR     PRINTNULL                ; prints out MOVE
00001316  4EB9 000022CA            278                  JSR     PRINTMOVESIZE            ; prints out the size 
0000131C  4BF9 000025EA            279                  LEA     MSG_4SPACES,A5           ; loads spaces
00001322  4EB9 000022A8            280                  JSR     PRINTNULL                ; prints out spaces
00001328  6000 0020                281                  BRA     PRINTMOVE                ; Branches to print move
0000132C                           282                  
0000132C  4BF9 0000251E            283  INSERTA         LEA     MSG_MOVEA,A5             ; loads string pointer for MOVEA into A5
00001332  4EB9 000022A8            284                  JSR     PRINTNULL                ; prints out MOVEA
00001338  4EB9 000022CA            285                  JSR     PRINTMOVESIZE            ; prints out the size 
0000133E  4BF9 000025E6            286                  LEA     MSG_3SPACES,A5           ; loads spaces
00001344  4EB9 000022A8            287                  JSR     PRINTNULL                ; prints out spaces
0000134A                           288   
0000134A  3404                     289  PRINTMOVE       MOVE.W  D4,D2                    ; Moves D4 (source effective address) to D2
0000134C  3605                     290                  MOVE.W  D5,D3                    ; Moves D5 (source Xn) to D3 
0000134E  4EB9 00001FB6            291                  JSR     EA_TO_STRING             ; outputs it into a string
00001354                           292                  
00001354                           293                  ; prints a comma to seperate
00001354  4BF9 000025DD            294                  LEA     MSG_COMMA,A5             ; loads string pointer into A5
0000135A  4EB9 000022A8            295                  JSR     PRINTNULL                ; prints out MOVE
00001360                           296                  
00001360                           297                  ; print destination
00001360  3406                     298                  MOVE.W  D6,D2                    ; Moves D6 (dest effective address) to D2
00001362  3607                     299                  MOVE.W  D7,D3                    ; Moves D7 (dest Xn if applicable) to D3 
00001364  4EB9 00001FB6            300                  JSR     EA_TO_STRING             ; outputs it into a string
0000136A  4E75                     301                  RTS                              ; exits subroutine                 
0000136C                           302                
0000136C                           303  *---------------MOVEM opcode----------------------                
0000136C  3200                     304  CASE_MOVEM      MOVE.W  D0,D1                           ; copies instruction word to D1
0000136E  C27C FB80                305                  AND.W   #$FB80,D1                       ; check bitmask for MOVEM (1111 1011 1000 0000)
00001372  B27C 4880                306                  CMP.W   #$4880,D1                       ; sees if it matches MOVEM (0100 1000 1000 0000)
00001376  6600 00FA                307                  BNE     CASE_MOVEQ                      ; checks MOVEQ if its not MOVEM
0000137A                           308                  
0000137A                           309                  ; Check D
0000137A  3200                     310                  MOVE.W  D0,D1                           ; copies instruction word to D1
0000137C  C27C 0400                311                  AND.W   #$0400,D1                       ; check bitmask for D in MOVEM (0000 0100 0000 0000)
00001380  3E01                     312                  MOVE.W  D1,D7                           ; stores D1 in D7 so it doesn't get overwritten
00001382  B27C 0400                313                  CMP.W   #$0400,D1                       ; checks if value is 1
00001386  6700 0076                314                  BEQ     MOVEM_MEM2REG                   ; if value is 1, then it is Memory to Register   
0000138A                           315  
0000138A                           316  MOVEM_REG2MEM   ; loads EA and XN
0000138A  3E3C 0000                317                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
0000138E  4BF9 00002329            318                  LEA     VALIDEA_MOVEM_REGTOMEM,A5       ; loads list of valid EA
00001394  4DF9 00002356            319                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000139A  4EB9 00001E48            320                  JSR     CHECKGET_EAXN
000013A0  B27C 0001                321                  CMP.W   #1,D1                           ; checks if D1 invalid
000013A4  6700 0A46                322                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
000013A8  4BF9 0000252C            323                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
000013AE  4EB9 000022A8            324                  JSR     PRINTNULL                       ; prints MOVEM
000013B4                           325                  
000013B4                           326                  ; finds and prints size
000013B4  3200                     327                  MOVE.W  D0,D1                           ; copies D0
000013B6  C27C 0040                328                  AND.W   #$0040,D1                       ; gets the size bit
000013BA  6600 000C                329                  BNE     REG2MEMLONG                     ; if it isn't 0 go to REG2MEMLONG
000013BE                           330  
000013BE  4BF9 00002607            331  REG2MEMWORD     LEA     MSG_W,A5                        ; loads .W
000013C4  6000 0008                332                  BRA     PRINTREG2MEM                    ; prints the registers           
000013C8                           333                  
000013C8  4BF9 0000260A            334  REG2MEMLONG     LEA     MSG_L,A5                        ; loads .L
000013CE                           335             
000013CE  4EB9 000022A8            336  PRINTREG2MEM    JSR     PRINTNULL                       ; prints size
000013D4  4BF9 000025E6            337                  LEA     MSG_3SPACES,A5                  ; loads spaces
000013DA  4EB9 000022A8            338                  JSR     PRINTNULL                       ; prints out spaces
000013E0  383C 0001                339                  MOVE.W  #1,D4                           ; loads 1 into D4 to represent type
000013E4  4EB9 00001EE0            340                  JSR     PRINTREGISTERS                  ; prints registers
000013EA  4BF9 000025DD            341                  LEA     MSG_COMMA,A5                    ; loads comma
000013F0  4EB9 000022A8            342                  JSR     PRINTNULL                       ; prints comma
000013F6  4EB9 00001FB6            343                  JSR     EA_TO_STRING                    ; prints EA
000013FC  4E75                     344                  RTS
000013FE                           345  
000013FE                           346  MOVEM_MEM2REG  ; loads EA and XN
000013FE  3E3C 0000                347                  MOVE.W  #0,D7                           ; Marks EA and Xn as in being in source location
00001402  4BF9 0000232D            348                  LEA     VALIDEA_MOVEM_MEMTOREG,A5       ; loads list of valid EA
00001408  4DF9 00002356            349                  LEA     VALIDXN_SHORTLONG,A6            ; loads list of valid Xn
0000140E  4EB9 00001E48            350                  JSR     CHECKGET_EAXN
00001414  B27C 0001                351                  CMP.W   #1,D1                           ; checks if D1 invalid
00001418  6700 09D2                352                  BEQ     CASE_DATA                       ; if invalid go to CASE_DATA
0000141C  4BF9 0000252C            353                  LEA     MSG_MOVEM,A5                    ; loads MOVEM
00001422  4EB9 000022A8            354                  JSR     PRINTNULL                       ; prints MOVEM
00001428                           355                  
00001428                           356                  ; finds and prints size
00001428  3200                     357                  MOVE.W  D0,D1                           ; copies D0
0000142A  C27C 0040                358                  AND.W   #$0040,D1                       ; gets the size bit
0000142E  6600 000C                359                  BNE     MEM2REGLONG                     ; if it isn't 0 go to MEM2REGLONG
00001432                           360  
00001432  4BF9 00002607            361  MEM2REGWORD     LEA     MSG_W,A5                        ; loads .W
00001438  6000 0008                362                  BRA     PRINTMEM2REG                    ; prints the registers           
0000143C                           363                  
0000143C  4BF9 0000260A            364  MEM2REGLONG     LEA     MSG_L,A5                        ; loads .L
00001442                           365             
00001442  4EB9 000022A8            366  PRINTMEM2REG    JSR     PRINTNULL                       ; prints out size
00001448  4BF9 000025E6            367                  LEA     MSG_3SPACES,A5                  ; loads spaces
0000144E  4EB9 000022A8            368                  JSR     PRINTNULL                       ; prints out spaces
00001454  4EB9 00001FB6            369                  JSR     EA_TO_STRING                    ; prints EA
0000145A  4BF9 000025DD            370                  LEA     MSG_COMMA,A5                    ; loads comma
00001460  4EB9 000022A8            371                  JSR     PRINTNULL                       ; prints comma
00001466  383C FFFF                372                  MOVE.W  #-1,D4                          ; loads -1 into D4 to represent type
0000146A  4EB9 00001EE0            373                  JSR     PRINTREGISTERS                  ; prints registers
00001470  4E75                     374                  RTS
00001472                           375                          
00001472                           376  
00001472                           377  *---------------MOVEQ opcode----------------------
00001472  3200                     378  CASE_MOVEQ      MOVE.W  D0,D1
00001474  C27C F100                379                  AND.W   #$F100,D1
00001478  B27C 7000                380                  CMP.W   #$7000,D1
0000147C  6600 007C                381                  BNE     CASE_ADD
00001480                           382                  
00001480                           383                  ;loads Register
00001480  323C 0001                384                  MOVE.W  #1,D1                           ; copies instruction word to D1
00001484  4EB9 00001E1E            385                  JSR     GET_XN                          ; gets XN and puts in D1
0000148A  3601                     386                  MOVE.W  D1,D3                           ; copies Xn to D3 so it won't be overwritten
0000148C                           387                  
0000148C                           388                  ;loads DATA
0000148C  3200                     389                  MOVE.W  D0,D1
0000148E  C27C 00FF                390                  AND.W   #$00FF,D1                       ;bit mask to get DATA
00001492  3801                     391                  MOVE.W  D1,D4                           ;copy data into D4
00001494                           392                                                          ;must convert bits to hex
00001494                           393                                  
00001494  4BF9 00002525            394  PRINT_MOVEQ     LEA     MSG_MOVEQ,A5                    ;PRINT MOVEQ
0000149A  4EB9 000022A8            395                  JSR     PRINTNULL  
000014A0                           396                                  
000014A0  4BF9 0000260A            397                  LEA     MSG_L,A5                        ;PRINT SIZE L
000014A6  4EB9 000022A8            398                  JSR     PRINTNULL
000014AC                           399      
000014AC  4BF9 000025E6            400                  LEA     MSG_3SPACES,A5                  ;PRINT THREE TABS
000014B2  4EB9 000022A8            401                  JSR     PRINTNULL
000014B8                           402                  
000014B8  4BF9 000025D9            403                  LEA     MSG_POUND, A5                   ;PRINT HASHTAG
000014BE  4EB9 000022A8            404                  JSR     PRINTNULL
000014C4                           405                  
000014C4  4BF9 000025DB            406                  LEA     MSG_HEX, A5                     ;PRINT DOLLAR SIGN
000014CA  4EB9 000022A8            407                  JSR     PRINTNULL
000014D0                           408                  
000014D0  3204                     409                  MOVE.W  D4,D1                           ;PRINT DATA
000014D2  4EB9 0000216E            410                  JSR     PRINTHEXNUM                           
000014D8                           411                  
000014D8  4BF9 000025DD            412                  LEA     MSG_COMMA, A5                   ;PRINT COMMA
000014DE  4EB9 000022A8            413                  JSR     PRINTNULL
000014E4                           414                  
000014E4  4BF9 000025CD            415                  LEA     MSG_DR,A5                       ;PRINT D
000014EA  4EB9 000022A8            416                  JSR     PRINTNULL
000014F0                           417            
000014F0  3203                     418                  MOVE.W  D3,D1                           ;PRINT REGISTER NUMBER
000014F2  4EB9 0000215E            419                  JSR     PRINTNUM                         
000014F8                           420                  
000014F8  4E75                     421                  RTS
000014FA                           422                  
000014FA                           423  *---------------ADD opcode----------------------                
000014FA                           424  * get bits 0-5, 9-11, and 12-15 first (similarities between ADD and ADDA)
000014FA  3200                     425  CASE_ADD        MOVE.W  D0,D1
000014FC  C27C F000                426                  AND.W   #$F000,D1
00001500  B27C D000                427                  CMP.W   #$D000,D1
00001504  6600 01D0                428                  BNE     CASE_ADDQ
00001508                           429                   
00001508  4EB9 00001522            430                  JSR     ADD_SUB_HELP
0000150E                           431                  
0000150E                           432                  ; bits 7-8 determine if it is ADDA or ADD
0000150E  3200                     433                  MOVE.W  D0,D1
00001510  E149                     434                  LSL.W   #8,D1                   ; get rid of left 8 bits
00001512  E049                     435                  LSR.W   #8,D1
00001514  EC49                     436                  LSR.W   #6,D1                   ; get rid of right 6 bits
00001516  B27C 0003                437                  CMP.W   #3,D1                   ; if bits 7-8 are 3 (11) then it is ADDA
0000151A  6700 0136                438                  BEQ     CASE_ADDA
0000151E                           439                  
0000151E  6000 0040                440                  BRA     PRINTADD                ; Branches to print add
00001522                           441                  
00001522                           442                  ; Check bits 0-5 
00001522  4BF9 0000231C            443  ADD_SUB_HELP    LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001528  4DF9 00002352            444                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
0000152E  3E3C 0000                445                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001532  4EB9 00001E48            446                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001538  B27C 0001                447                  CMP.W       #1,D1                    ; checks if invalid
0000153C  6700 08AE                448                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001540  3802                     449                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001542  3A03                     450                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5
00001544                           451                  
00001544                           452                  ; Check 6-11
00001544  4BF9 0000231C            453                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
0000154A  4DF9 00002356            454                  LEA         VALIDXN_SHORTLONG,A6     ; Loads valid Xn types in A6
00001550  3E3C 0001                455                  MOVE.W      #1,D7                    ; Marks D7 as "Destination" for CHECKGETEAXN
00001554  4EB9 00001E48            456                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
0000155A  3C02                     457                  MOVE.W      D2,D6                    ; Moves D2 (destination effective address) to D6
0000155C  3E03                     458                  MOVE.W      D3,D7                    ; Moves D3 (destination Xn if applicable) to D7
0000155E                           459    
0000155E  4E75                     460                  RTS                
00001560                           461                    
00001560  4BF9 00002533            462  PRINTADD        LEA         MSG_ADD,A5              ; loads string pointer for MOVE into A5
00001566  4EB9 000022A8            463                  JSR         PRINTNULL               ; print ADD
0000156C  3200                     464                  MOVE.W      D0,D1                   ; bits 7-8 contain size
0000156E  4EB9 00001584            465                  JSR         ADD_SUB_SIZE            ; D1 = size
00001574  4BF9 000025EF            466                  LEA         MSG_5SPACES,A5          ; loads spaces
0000157A  4EB9 000022A8            467                  JSR         PRINTNULL               ; prints out spaces
00001580  6000 0050                468                  BRA         FINISH_ADD
00001584                           469                    
00001584  3200                     470  ADD_SUB_SIZE    MOVE.W      D0,D1
00001586  E149                     471                  LSL.W       #8,D1
00001588  E049                     472                  LSR.W       #8,D1
0000158A  EC49                     473                  LSR.W       #6,D1                   ; gets bits 6-7
0000158C                           474                    
0000158C  B27C 0000                475                  CMP.W       #0,D1
00001590  6700 0016                476                  BEQ         ADD_SUB_BYTE
00001594  B27C 0001                477                  CMP.W       #1,D1                   ; if 1, it is a word
00001598  6700 001C                478                  BEQ         ADD_SUB_WORD
0000159C  B27C 0002                479                  CMP.W       #2,D1                   ; if 2, it is a long
000015A0  6700 0022                480                  BEQ         ADD_SUB_LONG
000015A4  6000 02AE                481                  BRA         CASE_SUBA               ; error
000015A8                           482                    
000015A8  4BF9 00002604            483  ADD_SUB_BYTE    LEA         MSG_B,A5
000015AE  4EB9 000022A8            484                  JSR         PRINTNULL
000015B4  4E75                     485                  RTS
000015B6                           486                    
000015B6  4BF9 00002607            487  ADD_SUB_WORD    LEA         MSG_W,A5
000015BC  4EB9 000022A8            488                  JSR         PRINTNULL
000015C2  4E75                     489                  RTS
000015C4                           490    
000015C4  4BF9 0000260A            491  ADD_SUB_LONG    LEA         MSG_L,A5
000015CA  4EB9 000022A8            492                  JSR         PRINTNULL
000015D0  4E75                     493                  RTS
000015D2                           494        
000015D2  4EB9 000015DA            495  FINISH_ADD      JSR         ADD_SUB_OPERAND
000015D8  4E75                     496                  RTS
000015DA                           497    
000015DA  3200                     498  ADD_SUB_OPERAND MOVE.W      D0,D1
000015DC  EF49                     499                  LSL.W       #7,D1
000015DE  EE49                     500                  LSR.W       #7,D1
000015E0  E049                     501                  LSR.W       #8,D1
000015E2  B27C 0001                502                  CMP.W       #1,D1
000015E6  6600 0036                503                  BNE         Dn_PLUS_EA          
000015EA                           504                    
000015EA                           505                  ; print Data Register
000015EA  4BF9 000025CD            506                  LEA         MSG_DR,A5
000015F0  4EB9 000022A8            507                  JSR         PRINTNULL
000015F6  3207                     508                  MOVE.W      D7,D1
000015F8  4EB9 0000215E            509                  JSR         PRINTNUM                
000015FE                           510                  
000015FE                           511                  ; prints a comma to seperate
000015FE  4BF9 000025DD            512                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001604  4EB9 000022A8            513                  JSR         PRINTNULL                ; prints out MOVE
0000160A                           514                 
0000160A                           515                  ; below is EA+Dn->Dn  
0000160A  3404                     516                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
0000160C  3605                     517                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3
0000160E  3200                     518                  MOVE.W      D0,D1
00001610  E149                     519                  LSL.W       #8,D1
00001612  E049                     520                  LSR.W       #8,D1
00001614  EC49                     521                  LSR.W       #6,D1                   ; gets bits 6-7 
00001616  4EB9 00001FB6            522                  JSR         EA_TO_STRING             ; outputs it into a string
0000161C  4E75                     523                  RTS                                 ; exits subroutine 
0000161E                           524  
0000161E                           525  Dn_PLUS_EA      ; below is Dn+EA->EA  
0000161E  3404                     526                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001620  3605                     527                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001622  3200                     528                  MOVE.W      D0,D1
00001624  E149                     529                  LSL.W       #8,D1
00001626  E049                     530                  LSR.W       #8,D1
00001628  EC49                     531                  LSR.W       #6,D1                   ; gets bits 6-7
0000162A  4EB9 00001FB6            532                  JSR         EA_TO_STRING             ; outputs it into a string   
00001630                           533                  
00001630                           534                  ; prints a comma to seperate
00001630  4BF9 000025DD            535                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001636  4EB9 000022A8            536                  JSR         PRINTNULL                ; prints out MOVE
0000163C                           537                  
0000163C                           538                  ; below is Dn+EA->EA
0000163C  4BF9 000025CD            539                  LEA         MSG_DR,A5                ; print data register
00001642  4EB9 000022A8            540                  JSR         PRINTNULL
00001648  3207                     541                  MOVE.W      D7,D1
0000164A  4EB9 0000215E            542                  JSR         PRINTNUM             
00001650  4E75                     543                  RTS                                  ; exits subroutine          
00001652                           544                        
00001652                           545  *---------------ADDA opcode----------------------
00001652                           546  CASE_ADDA       ; gets bit 8 (size bit)
00001652  3200                     547                  MOVE.W      D0,D1
00001654  EF49                     548                  LSL.W       #7,D1
00001656  EE49                     549                  LSR.W       #7,D1
00001658  E049                     550                  LSR         #8,D1                   
0000165A                           551                  
0000165A  4BF9 00002538            552                  LEA         MSG_ADDA,A5             ; print ADDA
00001660  4EB9 000022A8            553                  JSR         PRINTNULL
00001666                           554                   
00001666  B27C 0001                555                  CMP.W       #1,D1
0000166A  6700 001E                556                  BEQ         ADDA_LONG
0000166E                           557                    
0000166E  4BF9 00002607            558                  LEA         MSG_W,A5
00001674  4EB9 000022A8            559                  JSR         PRINTNULL
0000167A  4BF9 000025EA            560                  LEA         MSG_4SPACES,A5          ; loads spaces
00001680  4EB9 000022A8            561                  JSR         PRINTNULL               ; prints out spaces
00001686  6000 0022                562                  BRA         FINISH_ADDA   
0000168A                           563                    
0000168A  323C 0002                564  ADDA_LONG       MOVE.W      #2,D1                   ;sets D1 to be word sized for EA to string
0000168E  4BF9 0000260A            565                  LEA         MSG_L,A5
00001694  4EB9 000022A8            566                  JSR         PRINTNULL
0000169A  4BF9 000025EA            567                  LEA         MSG_4SPACES,A5          ; loads spaces
000016A0  4EB9 000022A8            568                  JSR         PRINTNULL               ; prints out spaces
000016A6  6000 0002                569                  BRA         FINISH_ADDA
000016AA                           570                    
000016AA  3404                     571  FINISH_ADDA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
000016AC  3605                     572                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
000016AE  4EB9 00001FB6            573                  JSR         EA_TO_STRING             ; outputs it into a string
000016B4                           574                    
000016B4                           575                  ; prints a comma to seperate
000016B4  4BF9 000025DD            576                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
000016BA  4EB9 000022A8            577                  JSR         PRINTNULL                ; prints out MOVE
000016C0                           578            
000016C0  4BF9 000025CF            579                  LEA         MSG_AR,A5                ; print address register
000016C6  4EB9 000022A8            580                  JSR         PRINTNULL
000016CC  3207                     581                  MOVE.W      D7,D1
000016CE  4EB9 0000215E            582                  JSR         PRINTNUM             
000016D4  4E75                     583                  RTS                              ; exits subroutine
000016D6                           584                  
000016D6                           585  *---------------ADDQ opcode----------------------                  
000016D6  3200                     586  CASE_ADDQ       MOVE.W      D0,D1
000016D8  C27C F000                587                  AND.W       #$F000,D1       
000016DC  B27C 5000                588                  CMP.W       #$5000,D1
000016E0  6600 00F0                589                  BNE         CASE_SUB
000016E4                           590                                                      
000016E4                           591                  ; Check bits 0-5 
000016E4  4BF9 0000231C            592                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
000016EA  4DF9 00002352            593                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
000016F0  3E3C 0000                594                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
000016F4  4EB9 00001E48            595                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
000016FA  B27C 0001                596                  CMP.W       #1,D1                    ; checks if invalid
000016FE  6700 06EC                597                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001702                           598                  
00001702  4BF9 0000253E            599                  LEA         MSG_ADDQ,A5             ; print ADDQ
00001708  4EB9 000022A8            600                  JSR         PRINTNULL
0000170E                           601                  
0000170E  3802                     602                  MOVE.W      D2,D4                    ; Moves D2 (source effective address) to D4
00001710  3A03                     603                  MOVE.W      D3,D5                    ; Moves D3 (source Xn if applicable) to D5  
00001712                           604                  
00001712                           605                   ; get bits 6-7 (size bits)
00001712  3200                     606                  MOVE.W      D0,D1
00001714  E149                     607                  LSL.W       #8,D1
00001716  E049                     608                  LSR.W       #8,D1
00001718  EC49                     609                  LSR.W       #6,D1
0000171A  3207                     610                  MOVE.W      D7,D1                  ; stores D1 in D7 so it won't get overwritten
0000171C  B27C 0001                611                  CMP.W       #1,D1
00001720  6700 0026                612                  BEQ         ADDQ_WORD
00001724  B27C 0002                613                  CMP.W       #2,D1
00001728  6700 003A                614                  BEQ         ADDQ_LONG
0000172C                           615                    
0000172C  4BF9 00002604            616  ADDQ_BYTE       LEA         MSG_B,A5
00001732  4EB9 000022A8            617                  JSR         PRINTNULL
00001738  4BF9 000025EA            618                  LEA         MSG_4SPACES,A5          ; loads spaces
0000173E  4EB9 000022A8            619                  JSR         PRINTNULL               ; prints out spaces
00001744  6000 003A                620                  BRA         FINISH_ADDQ  
00001748                           621   
00001748  4BF9 00002607            622  ADDQ_WORD       LEA         MSG_W,A5
0000174E  4EB9 000022A8            623                  JSR         PRINTNULL
00001754  4BF9 000025EA            624                  LEA         MSG_4SPACES,A5          ; loads spaces
0000175A  4EB9 000022A8            625                  JSR         PRINTNULL               ; prints out spaces
00001760  6000 001E                626                  BRA         FINISH_ADDQ                 
00001764                           627    
00001764  4BF9 0000260A            628  ADDQ_LONG       LEA         MSG_L,A5
0000176A  4EB9 000022A8            629                  JSR         PRINTNULL
00001770  4BF9 000025EA            630                  LEA         MSG_4SPACES,A5          ; loads spaces
00001776  4EB9 000022A8            631                  JSR         PRINTNULL               ; prints out spaces
0000177C  6000 0002                632                  BRA         FINISH_ADDQ                  
00001780                           633                    
00001780  4EB9 000017A0            634  FINISH_ADDQ     JSR         PRINT_ADDQ_DATA
00001786                           635   
00001786                           636                  ; prints a comma to seperate
00001786  4BF9 000025DD            637                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
0000178C  4EB9 000022A8            638                  JSR         PRINTNULL                ; prints out MOVE
00001792                           639                    
00001792                           640                  ; prints destination
00001792  3404                     641                  MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001794  3605                     642                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001796  3207                     643                  MOVE.W      D7,D1                    ; Moves size bit to D1
00001798  4EB9 00001FB6            644                  JSR         EA_TO_STRING             ; outputs it into a string
0000179E                           645                 
0000179E  4E75                     646                  RTS
000017A0                           647   
000017A0  4BF9 000025D9            648  PRINT_ADDQ_DATA LEA         MSG_POUND,A5
000017A6  4EB9 000022A8            649                  JSR         PRINTNULL
000017AC                           650                  ; gets bits 9-11 (data bits)
000017AC  3200                     651                  MOVE.W      D0,D1                               ; gets D0
000017AE  E949                     652                  LSL.W       #4,D1
000017B0  E849                     653                  LSR.W       #4,D1                               ; get rid of left 4 bits
000017B2  E049                     654                  LSR.W       #8,D1
000017B4  E249                     655                  LSR.W       #1,D1                               ; get rid of right 9 bits
000017B6                           656                  
000017B6  B27C 0000                657                  CMP.W       #0,D1
000017BA  6700 000A                658                  BEQ         PRINT_8
000017BE  4EB9 0000215E            659                  JSR         PRINTNUM
000017C4  4E75                     660                  RTS 
000017C6                           661  
000017C6  123C 0008                662  PRINT_8         MOVE.B      #8,D1
000017CA  4EB9 0000215E            663                  JSR         PRINTNUM
000017D0  4E75                     664                  RTS   
000017D2                           665         
000017D2                           666  *---------------SUB opcode---------------------- 
000017D2  3200                     667  CASE_SUB        MOVE.W      D0,D1                                ; Copies instruction word to D1
000017D4  C27C F000                668                  AND.W       #$F000,D1                            ; Applies a bitmask to get first 4 bits                
000017D8  B27C 9000                669                  CMP.W       #$9000,D1                            ; Checks if it fits the first four bits of LEA opcode
000017DC  6600 008C                670                  BNE         CASE_LEA
000017E0                           671                 
000017E0  4EB8 1522                672                  JSR         ADD_SUB_HELP
000017E4                           673                  
000017E4  6000 0002                674                  BRA         PRINTSUB                            ; Branches to print sub
000017E8                           675  
000017E8  4BF9 00002544            676  PRINTSUB        LEA         MSG_SUB,A5                          ; loads string pointer for SUB into A5
000017EE  4EB9 000022A8            677                  JSR         PRINTNULL
000017F4  3200                     678                  MOVE.W      D0,D1                               ; bits 6-7 contain size
000017F6  4EB8 1584                679                  JSR         ADD_SUB_SIZE
000017FA  4BF9 000025EF            680                  LEA         MSG_5SPACES,A5                      ; loads spaces
00001800  4EB9 000022A8            681                  JSR         PRINTNULL                           ; prints out spaces
00001806  3200                     682                  MOVE.W      D0,D1
00001808  E149                     683                  LSL.W       #8,D1
0000180A  E049                     684                  LSR.W       #8,D1
0000180C  EC49                     685                  LSR.W       #6,D1
0000180E  B27C 0003                686                  CMP.W       #3,D1
00001812  6600 0006                687                  BNE         FINISH_SUB
00001816  6000 0008                688                  BRA         FINISH_SUBA                         ; same as ADDA
0000181A                           689                  
0000181A  4EB8 15DA                690  FINISH_SUB      JSR         ADD_SUB_OPERAND
0000181E  4E75                     691                  RTS
00001820                           692                    
00001820  3404                     693  FINISH_SUBA     MOVE.W      D4,D2                    ; Moves D4 (source effective address) to D2
00001822  3605                     694                  MOVE.W      D5,D3                    ; Moves D5 (source Xn) to D3 
00001824  4EB9 00001FB6            695                  JSR         EA_TO_STRING             ; outputs it into a string
0000182A                           696                
0000182A                           697                  ; prints a comma to seperate
0000182A  4BF9 000025DD            698                  LEA         MSG_COMMA,A5             ; loads string pointer into A5
00001830  4EB9 000022A8            699                  JSR         PRINTNULL                ; prints out MOVE
00001836                           700                  
00001836  4BF9 000025CF            701                  LEA         MSG_AR,A5                ; print address register
0000183C  4EB9 000022A8            702                  JSR         PRINTNULL
00001842  3200                     703                  MOVE.W      D0,D1
00001844  E949                     704                  LSL.W       #4,D1
00001846  E849                     705                  LSR.W       #4,D1
00001848  E049                     706                  LSR.W       #8,D1
0000184A  E249                     707                  LSR.W       #1,D1
0000184C  4EB9 0000215E            708                  JSR         PRINTNUM             
00001852  4E75                     709                  RTS                              ; exits subroutine
00001854                           710  
00001854                           711  
00001854                           712  *---prints out a SUBA instruction as SUB (ex. SUB.L A3,A5)
00001854  3200                     713  CASE_SUBA       MOVE.W      D0,D1
00001856  EF49                     714                  LSL.W       #7,D1
00001858  EE49                     715                  LSR.W       #7,D1
0000185A  E049                     716                  LSR.W       #8,D1
0000185C  B23C 0000                717                  CMP.B       #0,D1
00001860  6700 FD54                718                  BEQ         ADD_SUB_WORD
00001864  6000 FD5E                719                  BRA         ADD_SUB_LONG
00001868  4E75                     720                  RTS         
0000186A                           721                   
0000186A  3200                     722  CASE_LEA        MOVE.W  D0,D1                                ; Copies instruction word to D1
0000186C  C27C F000                723                  AND.W   #$F000,D1                            ; Applies a bitmask to get first 4 bits                
00001870  B27C 4000                724                  CMP.W   #$4000,D1                            ; Checks if it fits the first four bits of LEA opcode
00001874  6600 0092                725                  BNE.W   CASE_AND                             ; If its not, check AND
00001878  3200                     726                  MOVE.W  D0,D1                                ; Copies instruction word to D1
0000187A  C27C 01C0                727                  AND.W   #$01C0,D1                            ; Applies a bitmask to get 3 bits from places 6 to 8             
0000187E  B27C 01C0                728                  CMP.W   #$01C0,D1                            ; Checks if it matches 111/#3
00001882  6600 0084                729                  BNE.W   CASE_AND                             ; If its not, check AND
00001886                           730                  
00001886                           731                  ; Check source
00001886  4BF9 0000233C            732                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
0000188C  4DF9 00002356            733                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
00001892  3E3C 0000                734                  MOVE.W  #0,D7                                ; Marks D7 as "Source" for CHECKGETEAXN
00001896  4EB9 00001E48            735                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
0000189C  3802                     736                  MOVE.W  D2,D4                                ; Saves D2 in D4
0000189E  3A03                     737                  MOVE.W  D3,D5                                ; Saves D2 in D4
000018A0                           738                  
000018A0                           739                  ; Check destination
000018A0  4BF9 0000233C            740                  LEA     VALIDEA_LEA,A5                       ; Loads valid EA types in A5
000018A6  4DF9 00002356            741                  LEA     VALIDXN_SHORTLONG,A6                 ; Loads valid Xn types in A6
000018AC  3E3C 0001                742                  MOVE.W  #1,D7                                ; Marks D7 as "destination" for CHECKGETEAXN
000018B0  4EB9 00001E48            743                  JSR     CHECKGET_EAXN                        ; checks the EA and XN
000018B6  3C02                     744                  MOVE.W  D2,D6                                ; Saves D2 in D4
000018B8  3E03                     745                  MOVE.W  D3,D7                                ; Saves D2 in D4
000018BA                           746  
000018BA  4BF9 00002555            747                  LEA     MSG_LEA,A5                           ; loads string pointer for LEA into A5
000018C0  4EB9 000022A8            748                  JSR     PRINTNULL                            ; prints LEA
000018C6  4BF9 000025FC            749                  LEA     MSG_7SPACES,A5                       ; loads spaces
000018CC  4EB9 000022A8            750                  JSR     PRINTNULL                            ; prints out spaces
000018D2                           751                  
000018D2                           752                  ; print source
000018D2  3404                     753                  MOVE.W  D4,D2
000018D4  3605                     754                  MOVE.W  D5,D3
000018D6  4EB9 00001FB6            755                  JSR     EA_TO_STRING                         ; Prints out the EA
000018DC                           756                  
000018DC                           757                  ; comma
000018DC  4BF9 000025DD            758                  LEA     MSG_COMMA,A5                         ; prints out a comma for formatting
000018E2  4EB9 000022A8            759                  JSR     PRINTNULL                       
000018E8                           760                   
000018E8                           761                  ; register
000018E8  4BF9 000025CF            762                  LEA     MSG_AR,A5                            ; loads A into A5 (we already checked for it)
000018EE  4EB9 000022A8            763                  JSR     PRINTNULL 
000018F4  3401                     764                  MOVE.W  D1,D2                                ; saves Xn to D3 so it doesn't get overwritten
000018F6  323C 0001                765                  MOVE.W  #1,D1                                ; specifies that we are looking for destination Xn
000018FA  4EB9 00001E1E            766                  JSR     GET_XN                               ; Gets Xn, puts it into D1
00001900  4EB9 0000215E            767                  JSR     PRINTNUM                             ; Prints the number in D1
00001906  4E75                     768                  RTS
00001908                           769  
00001908                           770  *---------------AND opcode----------------------
00001908  3200                     771  CASE_AND        MOVE.W      D0,D1                           ; bitmask for 4 MSB
0000190A  C27C F000                772                  AND.W       #$F000,D1       
0000190E  B27C C000                773                  CMP.W       #$C000,D1
00001912  6600 00CA                774                  BNE         CASE_OR
00001916                           775                  
00001916  3200                     776                  MOVE.W      D0,D1
00001918  E149                     777                  LSL.W       #8,D1
0000191A  E049                     778                  LSR.W       #8,D1
0000191C  EC49                     779                  LSR.W       #6,D1                           ; get bits 6-7 (size)
0000191E  3C01                     780                  MOVE.W      D1,D6
00001920  BC7C 0003                781                  CMP.W       #3,D6
00001924  6700 0086                782                  BEQ         INV_INSTR
00001928                           783                  
00001928  4BF9 0000255A            784                  LEA         MSG_AND,A5                      ; print AND
0000192E  4EB9 000022A8            785                  JSR         PRINTNULL
00001934                           786                  
00001934  3206                     787                  MOVE.W      D6,D1
00001936  B27C 0000                788                  CMP.W       #0,D1
0000193A  6700 0012                789                  BEQ         AND_BYTE
0000193E  B27C 0001                790                  CMP.W       #1,D1                   ; if 1, it is a word
00001942  6700 0026                791                  BEQ         AND_WORD
00001946  B27C 0002                792                  CMP.W       #2,D1                   ; if 2, it is a long
0000194A  6700 003A                793                  BEQ         AND_LONG
0000194E                           794                  
0000194E  4BF9 00002604            795  AND_BYTE        LEA         MSG_B,A5
00001954  4EB9 000022A8            796                  JSR         PRINTNULL
0000195A  4BF9 000025EF            797                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001960  4EB9 000022A8            798                  JSR         PRINTNULL                       ; prints out spaces
00001966  6000 003A                799                  BRA         FINISH_AND
0000196A                           800                                    
0000196A  4BF9 00002607            801  AND_WORD        LEA         MSG_W,A5
00001970  4EB9 000022A8            802                  JSR         PRINTNULL
00001976  4BF9 000025EF            803                  LEA         MSG_5SPACES,A5                  ; loads spaces
0000197C  4EB9 000022A8            804                  JSR         PRINTNULL                       ; prints out spaces
00001982  6000 001E                805                  BRA         FINISH_AND
00001986                           806    
00001986  4BF9 0000260A            807  AND_LONG        LEA         MSG_L,A5
0000198C  4EB9 000022A8            808                  JSR         PRINTNULL
00001992  4BF9 000025EF            809                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001998  4EB9 000022A8            810                  JSR         PRINTNULL                       ; prints out spaces
0000199E  6000 0002                811                  BRA         FINISH_AND
000019A2                           812        
000019A2  4EB8 1522                813  FINISH_AND      JSR         ADD_SUB_HELP                    ; AND has the same structure as ADD and SUB
000019A6  4EB8 15DA                814                  JSR         ADD_SUB_OPERAND
000019AA  4E75                     815                  RTS
000019AC                           816                  
000019AC  4BF9 00002497            817  INV_INSTR       LEA         INVALID_INSTR,A5
000019B2  4EB9 000022A8            818                  JSR         PRINTNULL
000019B8  4BF9 000025F5            819                  LEA         MSG_6SPACES,A5
000019BE  4EB9 000022A8            820                  JSR         PRINTNULL
000019C4  4BF9 000025DB            821                  LEA         MSG_HEX,A5
000019CA  4EB9 000022A8            822                  JSR         PRINTNULL
000019D0  2200                     823                  MOVE.L      D0,D1
000019D2  383C 0000                824                  MOVE.W      #0,D4
000019D6  4EB9 00002182            825                  JSR         PRINTSHORTLONGNUM
000019DC  4E75                     826                  RTS               
000019DE                           827                  
000019DE                           828  *---------------OR opcode----------------------            
000019DE  3200                     829  CASE_OR         MOVE.W      D0,D1                           ; bitmask for 4 MSB
000019E0  C27C F000                830                  AND.W       #$F000,D1       
000019E4  B27C 8000                831                  CMP.W       #$8000,D1
000019E8  6600 0054                832                  BNE         CASE_NOT
000019EC                           833                                                
000019EC  3200                     834                  MOVE.W      D0,D1
000019EE  E149                     835                  LSL.W       #8,D1
000019F0  E049                     836                  LSR.W       #8,D1
000019F2  EC49                     837                  LSR.W       #6,D1                           ; get bits 6-7 (size)
000019F4  B27C 0003                838                  CMP.W       #3,D1
000019F8  67B2                     839                  BEQ         INV_INSTR
000019FA  3C01                     840                  MOVE.W      D1,D6
000019FC                           841  
000019FC                           842                  
000019FC  4BF9 0000255F            843                  LEA         MSG_OR,A5
00001A02  4EB9 000022A8            844                  JSR         PRINTNULL                       ; print "OR"
00001A08                           845                  
00001A08  3206                     846                  MOVE.W      D6,D1
00001A0A  4EB9 00001A26            847                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A10  4BF9 000025F5            848                  LEA         MSG_6SPACES,A5                  ; loads spaces
00001A16  4EB9 000022A8            849                  JSR         PRINTNULL                       ; prints out spaces
00001A1C                           850  
00001A1C  4EB8 1522                851                  JSR         ADD_SUB_HELP                    ; OR has the same structure as ADD and SUB
00001A20  4EB8 15DA                852                  JSR         ADD_SUB_OPERAND                 ; print 
00001A24  4E75                     853                  RTS
00001A26                           854  
00001A26  B27C 0000                855  OR_SIZE         CMP.W       #0,D1
00001A2A  6700 FB7C                856                  BEQ         ADD_SUB_BYTE
00001A2E  B27C 0001                857                  CMP.W       #1,D1                   ; if 1, it is a word
00001A32  6700 FB82                858                  BEQ         ADD_SUB_WORD
00001A36  B27C 0002                859                  CMP.W       #2,D1                   ; if 2, it is a long
00001A3A  6700 FB88                860                  BEQ         ADD_SUB_LONG
00001A3E                           861                  ; no need for rts, since ADD_SUB_ already has                
00001A3E                           862  
00001A3E                           863  *---------------NOT opcode----------------------
00001A3E  3200                     864  CASE_NOT        MOVE.W      D0,D1                           ; bitmask for 4 MSB
00001A40  C27C FF00                865                  AND.W       #$FF00,D1       
00001A44  B27C 4600                866                  CMP.W       #$4600,D1
00001A48  6600 0058                867                  BNE         CASE_LSDASDROD
00001A4C                           868                 
00001A4C                           869                  ; get bits 6-7 (size)
00001A4C  3200                     870                  MOVE.W      D0,D1
00001A4E  E149                     871                  LSL.W       #8,D1
00001A50  E049                     872                  LSR.W       #8,D1
00001A52  EC49                     873                  LSR.W       #6,D1 
00001A54  3C01                     874                  MOVE.W      D1,D6                         
00001A56  BC7C 0003                875                  CMP.W       #3,D6
00001A5A  6700 FF50                876                  BEQ         INV_INSTR
00001A5E                           877                                  
00001A5E  4BF9 00002563            878                  LEA         MSG_NOT,A5
00001A64  4EB9 000022A8            879                  JSR         PRINTNULL                       ; print "NOT"
00001A6A                           880                                 
00001A6A  3206                     881                  MOVE.W      D6,D1
00001A6C                           882  
00001A6C  4EB8 1A26                883                  JSR         OR_SIZE                         ; print ".B",".W",".L"
00001A70  4BF9 000025EF            884                  LEA         MSG_5SPACES,A5                  ; loads spaces
00001A76  4EB9 000022A8            885                  JSR         PRINTNULL                       ; prints out spaces
00001A7C                           886                  
00001A7C                           887                  ; get bits 0-5 
00001A7C  4BF9 0000231C            888                  LEA         VALIDEA_ALL,A5           ; Loads valid EA types in A5
00001A82  4DF9 00002352            889                  LEA         VALIDXN_ALL,A6           ; Loads valid Xn types in A6
00001A88  3E3C 0000                890                  MOVE.W      #0,D7                    ; Marks D7 as "Source" for CHECKGETEAXN
00001A8C  4EB9 00001E48            891                  JSR         CHECKGET_EAXN            ; getting if its valid (D1), EA (D2), and Xn (D3)
00001A92  B27C 0001                892                  CMP.W       #1,D1                    ; checks if invalid
00001A96  6700 0354                893                  BEQ         CASE_DATA                ; branches to CASE_DATA if invalid
00001A9A  4EB9 00001FB6            894                  JSR         EA_TO_STRING             ; outputs it into a string
00001AA0                           895    
00001AA0  4E75                     896                  RTS
00001AA2                           897  
00001AA2  3200                     898  CASE_LSDASDROD  MOVE.W      D0,D1                            ; copies D0 to D1
00001AA4  C27C F000                899                  AND.W       #$F000, D1                       ; gets first 4 bits
00001AA8  B27C E000                900                  CMP.W       #$E000,D1                        ; checks if next 4 bits is E (confirm if ASd/LSd)
00001AAC  6600 0240                901                  BNE         CASE_BRA                         ; if not equal ASd/LSd check BRA
00001AB0  3400                     902                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AB2  4EB9 00001ED0            903                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001AB8  B47C 0003                904                  CMP.W       #$3, D2                          ; checks if it is memory or register option
00001ABC  6600 00D4                905                  BNE         CASE_SHIFTREG                    ; if rotation size not equal to 3, go to shift reg         
00001AC0                           906                  
00001AC0  3400                     907  CASE_SHIFTMEM   MOVE.W      D0,D2                            ; copies D0 to D2
00001AC2  4EB9 00001EBE            908                  JSR         GETROTATION                      ; gets rotation value of D2
00001AC8  B47C 0000                909                  CMP.W       #ASd_MEM,D2                      ; checks if rotation value is ASdMem
00001ACC  6700 0014                910                  BEQ         CASE_ASdMEM                      ; branches to ASd_MEM if value matches
00001AD0  B47C 0003                911                  CMP.W       #ROd_MEM,D2                      ; checks if rotation value is ASdMem
00001AD4  6700 0016                912                  BEQ         CASE_ROdMEM                      ; branches to ASd_MEM if value matches
00001AD8                           913                  
00001AD8  4BF9 00002568            914  CASE_LSdMEM     LEA         MSG_LSd,A5                       ; loads LS into A5
00001ADE  6000 0012                915                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AE2                           916  
00001AE2  4BF9 0000256C            917  CASE_ASdMEM     LEA         MSG_ASd,A5                       ; loads AS into A5  
00001AE8  6000 0008                918                  BRA         PRINTSHIFTMEM                    ; branches to PRINTSHIFTMEM
00001AEC                           919  
00001AEC  4BF9 00002570            920  CASE_ROdMEM     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001AF2                           921                  
00001AF2  4EB9 000022A8            922  PRINTSHIFTMEM   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001AF8  3400                     923                  MOVE.W      D0,D2                            ; copies D0 to D2
00001AFA  4EB9 00001EC8            924                  JSR         GETDIRECTION                     ; gets direction
00001B00  B47C 0000                925                  CMP.W       #0,D2                            ; checking if its right
00001B04  6700 000C                926                  BEQ         CASE_RIGHTMEM                    ; shifts to the right 
00001B08                           927  
00001B08  4BF9 000025CB            928  CASE_LEFTMEM    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001B0E  6000 0008                929                  BRA         PRINT_MEMDIR                     ; branches for printing
00001B12                           930          
00001B12  4BF9 000025C9            931  CASE_RIGHTMEM   LEA         MSG_RIGHT,A5                     ; loads R into A5  
00001B18                           932  
00001B18  4EB9 000022A8            933  PRINT_MEMDIR    JSR         PRINTNULL                        ; Prints L or R
00001B1E  4BF9 00002607            934                  LEA         MSG_W,A5                         ; loads .W into A5
00001B24  4EB9 000022A8            935                  JSR         PRINTNULL                        ; Prints .W
00001B2A  4BF9 000025EF            936                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001B30  4EB9 000022A8            937                  JSR         PRINTNULL                        ; prints out spaces
00001B36  6000 0002                938                  BRA         GETMEMSOURCE                     ; checks the source 
00001B3A                           939                  
00001B3A                           940  ; get source addressing mode       
00001B3A                           941  GETMEMSOURCE                                                 
00001B3A  323C 0000                942                  MOVE.W      #0,D1                            ; specifies that we are looking for source addressing mode
00001B3E  4EB9 00001DF4            943                  JSR         GET_EA                           ; gets effective address, output: D1 = EA
00001B44  3801                     944                  MOVE.W      D1,D4                            ; saves EA to D4 so it doesn't get overwritten
00001B46  323C 0000                945                  MOVE.W      #0,D1                            ; specifies that we are looking for source Xn
00001B4A  4EB9 00001E1E            946                  JSR         GET_XN                           ; Gets Xn, puts it into D1
00001B50  3A01                     947                  MOVE.W      D1,D5                            ; saves Xn to D5 so it doesn't get overwritten
00001B52                           948  
00001B52  4BF9 0000234A            949  CHECKMEMSOURE   LEA         VALIDEA_SHIFT,A5                 ; load valid move EA
00001B58  3204                     950                  MOVE.W      D4,D1                            ; marks down that we are checking EA
00001B5A  4EB9 00001F82            951                  JSR         CHECKEAXN_IFVALID                ; checks if EA is valid
00001B60  B27C 0002                952                  CMP.W       #2,D1                            ; checks if it is Xn
00001B64  6700 0016                953                  BEQ         CHECKSHIFT_XN                    ; branches to CHECKXn if it is
00001B68  B27C 0001                954                  CMP.W       #1,D1                            ; Checks if it is invalid
00001B6C  6700 027E                955                  BEQ         CASE_DATA                        ; branches to CASE_DATA if it is
00001B70                           956  
00001B70  3404                     957  EASHIFT_VALID   MOVE.W      D4,D2                            ; moves EA to D2
00001B72  3605                     958                  MOVE.W      D5,D3                            ; moves EA to D3
00001B74  4EB9 00001FB6            959                  JSR         EA_TO_STRING                     ; prints out the EA
00001B7A  4E75                     960                  RTS                
00001B7C                           961                  
00001B7C                           962                  
00001B7C  4BF9 00002356            963  CHECKSHIFT_Xn   LEA         VALIDXN_SHORTLONG,A5             ; Loads Xn into A5
00001B82  3205                     964                  MOVE.W      D5,D1                            ; Loads D5 into D1 to check the Xn
00001B84  4EB9 00001F82            965                  JSR         CHECKEAXN_IFVALID                ; checks if the Xn is valid, put result in D1
00001B8A  4A41                     966                  TST.W       D1                               ; checks if it is valid
00001B8C  67E2                     967                  BEQ         EASHIFT_VALID                    ; go to EA_SHIFT to print
00001B8E  6000 025C                968                  BRA         CASE_DATA                        ; branches to CASE_DATA if not                
00001B92                           969  
00001B92                           970  
00001B92  3602                     971  CASE_SHIFTREG   MOVE.W      D2,D3                            ; copies D2 to D3
00001B94  3200                     972                  MOVE.W      D0,D1                            ; copies D0 to D1
00001B96  C27C 0018                973                  AND.W       #$0018,D1                        ; gets bits representing type (bitmask: 0000 0000 0001 1000)
00001B9A  E649                     974                  LSR.W       #3,D1                            ; shifts 3 bits to the right so we only have 2 bits left   
00001B9C  B27C 0000                975                  CMP.W       #ASd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001BA0  6700 0014                976                  BEQ         CASE_ASdReg                      ; goes to ASd case if so    
00001BA4  B27C 0003                977                  CMP.W       #ROd_REG,D1                      ; Compares D1 to 0, if it is 0, it is ASd
00001BA8  6700 0016                978                  BEQ         CASE_ROdReg                      ; goes to ASd case if so                 
00001BAC                           979                  
00001BAC  4BF9 00002568            980  CASE_LSdREG     LEA         MSG_LSd,A5                       ; loads LS into A5
00001BB2  6000 0012                981                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BB6                           982  
00001BB6  4BF9 0000256C            983  CASE_ASdREG     LEA         MSG_ASd,A5                       ; loads AS into A5
00001BBC  6000 0008                984                  BRA         PRINTSHIFTREG                    ; branches to PRINTSHIFTREG
00001BC0                           985  
00001BC0  4BF9 00002570            986  CASE_ROdREG     LEA         MSG_ROd,A5                       ; loads AS into A5          
00001BC6                           987                  
00001BC6  4EB9 000022A8            988  PRINTSHIFTREG   JSR         PRINTNULL                        ; Prints LS or AS or RO 
00001BCC  3400                     989                  MOVE.W      D0,D2                            ; copies D0 to D2
00001BCE  4EB9 00001EC8            990                  JSR         GETDIRECTION                     ; gets direction
00001BD4  B47C 0000                991                  CMP.W       #0,D2                            ; checking if its right
00001BD8  6700 000C                992                  BEQ         CASE_RIGHTREG                    ; shifts to the right 
00001BDC                           993  
00001BDC  4BF9 000025CB            994  CASE_LEFTREG    LEA         MSG_LEFT,A5                      ; loads L into A5 
00001BE2  6000 000C                995                  BRA         PRINT_REGDIR                     ; branches for printing
00001BE6                           996          
00001BE6  4BF9 000025C9            997  CASE_RIGHTREG   LEA         MSG_RIGHT,A5                     ; loads R into A5 
00001BEC  6000 0002                998                  BRA         PRINT_REGDIR                     ; branches for printing
00001BF0                           999                  
00001BF0  4EB9 000022A8           1000  PRINT_REGDIR    JSR         PRINTNULL                        ; Prints L or R
00001BF6                          1001  
00001BF6  3400                    1002  PRINTREGSIZE    MOVE.W      D0,D2                            ; loads D0 into D2 to get unmodified instruction word
00001BF8  4EB9 00001ED0           1003                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001BFE  B47C 0001               1004                  CMP.W       #1,D2                            ; Checks if it is word size
00001C02  6700 0014               1005                  BEQ         REG_WORD                         ; Prints .W
00001C06  B47C 0002               1006                  CMP.W       #2,D2                            ; Checks if it is long size
00001C0A  6700 0016               1007                  BEQ         REG_LONG                         ; Prints .L
00001C0E                          1008  
00001C0E  4BF9 00002604           1009  REG_BYTE        LEA         MSG_B,A5                         ; loads .B into A5
00001C14  6000 0012               1010                  BRA         PRINTREGEA      
00001C18                          1011  
00001C18  4BF9 00002607           1012  REG_WORD        LEA         MSG_W,A5                         ; loads .W into A5
00001C1E  6000 0008               1013                  BRA         PRINTREGEA      
00001C22                          1014                             
00001C22  4BF9 0000260A           1015  REG_LONG        LEA         MSG_L,A5                         ; loads .L into A5
00001C28                          1016  
00001C28  4EB9 000022A8           1017  PRINTREGEA      JSR         PRINTNULL                        ; Prints size
00001C2E  4BF9 000025EF           1018                  LEA         MSG_5SPACES,A5                   ; loads spaces
00001C34  4EB9 000022A8           1019                  JSR         PRINTNULL                        ; prints out spaces
00001C3A  3400                    1020                  MOVE.W      D0,D2                            ; copies D0 to D2
00001C3C  4EB9 00001ED8           1021                  JSR         GETROTATIONLOCATION              ; finds out if its immediate or register 
00001C42  B47C 0001               1022                  CMP.W       #$1,D2                           ; Compares D1 to 1, if it is 1, it is a data register
00001C46  6700 0060               1023                  BEQ         REG_REGISTER                     ; goes to register case if so
00001C4A                          1024                                  
00001C4A  3400                    1025  REG_IMMEDIATE   MOVE.W      D0,D2                            ; copies D0 to D2
00001C4C  4EB9 00001EBE           1026                  JSR         GETROTATION                      ; gets the rotation size
00001C52  B47C 0000               1027                  CMP.W       #0,D2                            ; checks if D2 is 0 (shift count of 8)
00001C56  6600 0006               1028                  BNE         COMPLETE_REGIM                   ; if not shigt count of 8, then branch to start printing
00001C5A                          1029                  
00001C5A  343C 0008               1030  MAKESHIFT8      MOVE.W      #8,D2                            ; sets shift cound to 8 (shift count of 8 is 000 in the opcode)
00001C5E                          1031                  
00001C5E  4BF9 000025D9           1032  COMPLETE_REGIM  LEA         MSG_POUND, A5                    ; loads # into A5
00001C64  4EB9 000022A8           1033                  JSR         PRINTNULL                        ; prints #
00001C6A  4BF9 000025DB           1034                  LEA         MSG_HEX, A5                      ; loads $ into A5
00001C70  4EB9 000022A8           1035                  JSR         PRINTNULL                        ; prints $
00001C76  3202                    1036                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001C78  4EB9 0000216E           1037                  JSR         PRINTHEXNUM                      ; prints shift count
00001C7E  4BF9 000025DD           1038                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001C84  4EB9 000022A8           1039                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001C8A  4BF9 000025CD           1040                  LEA         MSG_DR, A5                       ; loads D into A5
00001C90  4EB9 000022A8           1041                  JSR         PRINTNULL                        ; prints out D 
00001C96  323C 0000               1042                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001C9A  4EB9 00001E1E           1043                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CA0  4EB9 0000215E           1044                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CA6  4E75                    1045                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CA8                          1046                  
00001CA8  3400                    1047  REG_REGISTER    MOVE.W      D0,D2                            ; copies D0 to D2
00001CAA  4EB9 00001ED0           1048                  JSR         GETROTATIONSIZE                  ; gets the rotation size
00001CB0  3202                    1049                  MOVE.W      D2, D1                           ; moves rotation size to D1
00001CB2  4BF9 000025CD           1050                  LEA         MSG_DR, A5                       ; loads D into A5
00001CB8  4EB9 000022A8           1051                  JSR         PRINTNULL                        ; prints D
00001CBE  4EB9 0000215E           1052                  JSR         PRINTNUM                         ; prints register number
00001CC4  4BF9 000025DD           1053                  LEA         MSG_COMMA, A5                    ; loads , into A5
00001CCA  4EB9 000022A8           1054                  JSR         PRINTNULL                        ; prints the comma out to divide the source and destination  
00001CD0  4BF9 000025CD           1055                  LEA         MSG_DR, A5                       ; loads D into A5
00001CD6  4EB9 000022A8           1056                  JSR         PRINTNULL                        ; prints out D 
00001CDC  323C 0000               1057                  MOVE.W      #0,D1                            ; marks that we are looking for Xn (data register number) in the source location  
00001CE0  4EB9 00001E1E           1058                  JSR         GET_XN                           ; gets the data register number, stores in D1
00001CE6  4EB9 0000215E           1059                  JSR         PRINTNUM                         ; prints data register number in D1          
00001CEC  4E75                    1060                  RTS                                          ; ends subroutine to go onto the next instruction opcode
00001CEE                          1061               
00001CEE  3200                    1062  CASE_BRA        MOVE.W  D0,D1                                ; Copies instruction word to D1
00001CF0  C27C FF00               1063                  AND.W   #$FF00,D1                            ; Applies a bitmask to get first 8 bits                
00001CF4  B27C 6000               1064                  CMP.W   #$6000,D1                            ; Checks if it fits the BRA opcode
00001CF8  6600 0024               1065                  BNE.W   CASE_BCC                             ; If its not, check BCC
00001CFC                          1066                  
00001CFC  4BF9 000025C4           1067                  LEA     MSG_BRA,A5                           ; loads string pointer for BRA into A5
00001D02  4EB9 000022A8           1068                  JSR     PRINTNULL                            ; prints BRA
00001D08  4BF9 000025FC           1069                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D0E  4EB9 000022A8           1070                  JSR     PRINTNULL                            ; prints out spaces
00001D14                          1071  
00001D14  3400                    1072                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D16  4EB9 00001E90           1073                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D1C  4E75                    1074                  RTS
00001D1E                          1075                  
00001D1E                          1076  ; DO NOT MOVE THIS FORM UNDER CASE_BRA. IS DEPENDENT ON RESULTS OF BRA
00001D1E  3200                    1077  CASE_BCC        MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D20  C27C F000               1078                  AND.W   #$F000,D1                            ; get top 4 bits
00001D24  B27C 6000               1079                  CMP.W   #$6000,D1                            ; make sure top 4 bits are 6
00001D28  6600 0060               1080                  BNE.W   CASE_JSR                             ; checks next case if not Bcc
00001D2C  3200                    1081                  MOVE.W  D0,D1                                ; copies instruction word from D0 to D1
00001D2E  C27C 0F00               1082                  AND.W   #$0F00,D1                            ; get next 4 bits, condition code
00001D32  E049                    1083                  LSR.W   #8,D1                                ; shifts 8 bits to the right
00001D34                          1084                  
00001D34  B27C 000E               1085                  CMP.W   #$E,D1                               ; checks if D1 is BGT (1 1 1 0)
00001D38  6700 002A               1086                  BEQ     CASE_BGT                             ; branches to BGT if it is
00001D3C                          1087                  
00001D3C  B27C 000F               1088                  CMP.W   #$F,D1                               ; checks if D1 is BLE (1 1 1 1)
00001D40  6700 0018               1089                  BEQ     CASE_BLE                             ; branches to BLE if it is
00001D44                          1090                      
00001D44  B27C 0007               1091                  CMP.W   #$7,D1                               ; checks if D1 is BEQ (0 1 1 1)
00001D48  6700 0006               1092                  BEQ     CASE_BEQ                             ; branches to BEQ if it is
00001D4C  6000 009E               1093                  BRA     CASE_DATA                            ; BCC condition code not in the system
00001D50                          1094     
00001D50  4BF9 0000257E           1095  CASE_BEQ        LEA     MSG_BEQ,A5                           ; loads string pointer for BEQ into A5
00001D56  6000 0016               1096                  BRA     PRINTBCC
00001D5A                          1097  
00001D5A  4BF9 00002597           1098  CASE_BLE        LEA     MSG_BLE,A5                           ; loads string pointer for BLE into A5
00001D60  6000 000C               1099                  BRA     PRINTBCC
00001D64                          1100                  
00001D64  4BF9 0000258D           1101  CASE_BGT        LEA     MSG_BGT,A5                           ; loads string pointer for BGT into A5
00001D6A  6000 0002               1102                  BRA     PRINTBCC
00001D6E                          1103  
00001D6E  4EB9 000022A8           1104  PRINTBCC        JSR     PRINTNULL                            ; prints BEQ/BLE/BGT
00001D74  4BF9 000025FC           1105                  LEA     MSG_7SPACES,A5                       ; loads spaces
00001D7A  4EB9 000022A8           1106                  JSR     PRINTNULL                            ; prints out spaces
00001D80  3400                    1107                  MOVE.W  D0,D2                                ; Copies instruction word to D1
00001D82  4EB9 00001E90           1108                  JSR     GETDISPLACEMENT                      ; finds the displacement
00001D88  4E75                    1109                  RTS              
00001D8A                          1110                  
00001D8A                          1111  
00001D8A  3200                    1112  CASE_JSR        MOVE.W  D0,D1                                ; check if JSR mandatory bits exist
00001D8C  C27C FFC0               1113                  AND.W   #$FFC0,D1
00001D90  B27C 4E80               1114                  CMP.W   #$4E80,D1
00001D94  6600 0040               1115                  BNE     CASE_RTS
00001D98                          1116                  
00001D98  1E3C 0000               1117                  MOVE.B  #0,D7
00001D9C  4BF9 0000234F           1118                  LEA     VALIDEA_JSR,A5                       ; loads string of valid addresses
00001DA2  4DF9 00002356           1119                  LEA     VALIDXN_SHORTLONG,A6                 ; loads string of valid addresses
00001DA8  4EB9 00001E48           1120                  JSR     CHECKGET_EAXN                        ; checks if has valid effective address
00001DAE  B27C 0001               1121                  CMP     #1,D1
00001DB2  6700 0038               1122                  BEQ     CASE_DATA                            ; goes to case data if EA is invalid
00001DB6                          1123                  
00001DB6                          1124  PRINT_JSR       ;print JSR
00001DB6  4BF9 000025BA           1125                  LEA     MSG_JSR,A5
00001DBC  4EB9 000022A8           1126                  JSR     PRINTNULL
00001DC2                          1127                  
00001DC2                          1128                  ;print spaces
00001DC2  4BF9 000025FC           1129                  LEA     MSG_7SPACES,A5
00001DC8  4EB9 000022A8           1130                  JSR     PRINTNULL
00001DCE                          1131                                  
00001DCE                          1132                  ;print address
00001DCE  4EB9 00001FB6           1133                  JSR     EA_TO_STRING
00001DD4  4E75                    1134                  RTS     
00001DD6                          1135  
00001DD6  B07C 4E75               1136  CASE_RTS        CMP.W   #$4E75,D0           ; compares to RTS opcode in hex
00001DDA  6600 0010               1137                  BNE     CASE_DATA           ; checks the next case if not equal
00001DDE  4BF9 000025BF           1138                  LEA     MSG_RTS,A5          ; loads string pointer into A5
00001DE4  4EB9 000022A8           1139                  JSR     PRINTNULL           ; prints RTS                
00001DEA  4E75                    1140                  RTS                         ; returns from the subroutine
00001DEC                          1141  
00001DEC  4EB8 19AC               1142  CASE_DATA       JSR INV_INSTR  
00001DF0  4E75                    1143                  RTS               
00001DF2                          1144  
00001DF2  4E75                    1145  CASE_EPICFAIL   RTS
00001DF4                          1146  
00001DF4                          1147  
00001DF4                          1148  * Finds the EA type
00001DF4                          1149  * Inputs: D0 = the instruction word, D1 = 0 (source EA), 1 (dest EA)
00001DF4                          1150  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001DF4  48E7 3000               1151  GET_EA              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001DF8  4A41                    1152                      TST.W     D1                    ; compares D1 to 0
00001DFA  6700 000E               1153                      BEQ       SOURCEEA              ; branch to SOURCEEA if it is 0
00001DFE                          1154                      
00001DFE  343C 01C0               1155  DESTEA              MOVE.W    #$01C0,D2             ; stores bitmask to get the destination EA into D2
00001E02  363C 0006               1156                      MOVE.W    #6,D3                 ; stores the shift amount to D3
00001E06  6000 000A               1157                      BRA       FINDTYPEEA            
00001E0A                          1158  
00001E0A  343C 0038               1159  SOURCEEA            MOVE.W    #$0038,D2             ; stores bitmask to get the source EA into D2
00001E0E  363C 0003               1160                      MOVE.W    #3,D3                 ; stores the shift amount to D3
00001E12                          1161  
00001E12                          1162  
00001E12  3200                    1163  FINDTYPEEA          MOVE.W    D0,D1                 ; copies D0 in D1
00001E14  C242                    1164                      AND.W     D2,D1                 ; applies bitmask to D1
00001E16  E669                    1165                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E18  4CDF 000C               1166                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E1C  4E75                    1167                      RTS                             ; returns from subroutine    
00001E1E                          1168                      
00001E1E                          1169  * Finds Xn type
00001E1E                          1170  * Inputs: D0 = the instruction word, D1 = 0 (source Xn), 1 (dest Xn)
00001E1E                          1171  * Output: Addressing Mode (3 bits, 0 to 7) in D1
00001E1E  48E7 3000               1172  GET_XN              MOVEM.L   D2-D3, -(SP)          ; stores D2 and D3
00001E22  4A41                    1173                      TST.W     D1                    ; compares D1 to 0
00001E24  6700 000E               1174                      BEQ       SOURCEXN              ; branch to SOURCEEA if it is 0
00001E28                          1175  
00001E28  343C 0E00               1176  DESTXN              MOVE.W    #$0E00,D2             ; stores bitmask to get the destination Xn into D2
00001E2C  363C 0009               1177                      MOVE.W    #9,D3                 ; stores the shift amount to D3
00001E30  6000 000A               1178                      BRA       FINDTYPEXN            ; finds the type of Xn
00001E34                          1179  
00001E34  343C 0007               1180  SOURCEXN            MOVE.W    #$0007,D2             ; applies bitmask to D2
00001E38  363C 0000               1181                      MOVE.W    #0,D3                 ; stores the shift amount to D3
00001E3C                          1182                      
00001E3C  3200                    1183  FINDTYPEXN          MOVE.W    D0,D1                 ; copies D0 in D1
00001E3E  C242                    1184                      AND.W     D2,D1                 ; applies bitmask to D1
00001E40  E669                    1185                      LSR.W     D3,D1                 ; shifts D1, moves the result to the end
00001E42  4CDF 000C               1186                      MOVEM.L   (SP)+,D2-D3           ; restores D2 and D3
00001E46  4E75                    1187                      RTS                             ; returns from subroutine 
00001E48                          1188                      
00001E48                          1189  * Checks and gets the EA and Xn
00001E48                          1190  * Input: A5 = EA LIST, A6 = Xn LIST, D0 = INSTRUCTION WORD,  D7 = 0 (source EA/Xn), 1 (dest EA/Xn) 
00001E48                          1191  * Output: D1(0 = VALID, 1 = INVALID), D2 = EA, D3 = Xn
00001E48  3207                    1192  CHECKGET_EAXN   MOVE.W  D7,D1                   ; loads value representing position of EA     
00001E4A  4EB8 1DF4               1193                  JSR     GET_EA                  ; Gets EA
00001E4E  3401                    1194                  MOVE.W  D1,D2                   ; Stores EA in D2
00001E50  3207                    1195                  MOVE.W  D7,D1                   ; loads value representing position of EA   
00001E52  4EB8 1E1E               1196                  JSR     GET_XN                  ; Gets Xn
00001E56  3601                    1197                  MOVE.W  D1,D3                   ; Stores Xn in D3
00001E58  3202                    1198                  MOVE.W  D2,D1                   ; Stores EA in D1 for comparisons
00001E5A                          1199                  
00001E5A  4EB9 00001F82           1200                  JSR     CHECKEAXN_IFVALID       ; checks if EA is valid
00001E60  B27C 0002               1201                  CMP.W   #2,D1                   ; checks if it is Xn
00001E64  6700 0012               1202                  BEQ     CHECK_XN                ; branches to CHECKXn if it is
00001E68  B27C 0001               1203                  CMP.W   #1,D1                   ; Checks if it is invalid
00001E6C  6700 001C               1204                  BEQ     EAXN_INVALID            ; branches to CHECKXn if it is
00001E70                          1205                  
00001E70                          1206                  
00001E70  323C 0000               1207  EAXN_VALID      MOVE.W  #0,D1                   ; loads 0 (VALID) into D1
00001E74  6000 0018               1208                  BRA     END_CHECKGET
00001E78                          1209        
00001E78                          1210  ; need XN
00001E78  2A4E                    1211  CHECK_Xn        MOVEA.L A6,A5                   ; Loads Xn into A5  
00001E7A  3203                    1212                  MOVE.W  D3,D1                   ; MOves Xn to D1 to be checked
00001E7C  4EB9 00001F82           1213                  JSR     CHECKEAXN_IFVALID       ; checks if Xn is valid
00001E82  4A41                    1214                  TST.W   D1                      ; checks if it is valid
00001E84  67EA                    1215                  BEQ     EAXN_VALID              ; go to EA_VALID to print
00001E86  6000 0002               1216                  BRA     EAXN_INVALID            ; branches to EA_INVALID if not  
00001E8A                          1217   
00001E8A  323C 0001               1218  EAXN_INVALID    MOVE.W  #1,D1                   ; loads 1 (INVALID) into D
00001E8E                          1219  
00001E8E  4E75                    1220  END_CHECKGET    RTS          
00001E90                          1221                                            
00001E90                          1222                                            
00001E90                          1223  * Gets the displacement and pritns it 
00001E90                          1224  * Inputs: D2 = instruction word, A2 = address of next word
00001E90                          1225  * Outputs: prints out displacement
00001E90  48E7 4004               1226  GETDISPLACEMENT     MOVEM.L    D1/A5, -(SP)         ; saves D1
00001E94  3A4A                    1227                      MOVE.W    A2,A5                 ; copies A2 to A5
00001E96  C47C 00FF               1228                      AND.W     #$00FF,D2             ; applies a bitmask to get rid of the first 8 bits
00001E9A  6600 0004               1229                      BNE       PRINTADDRESS          ; prints address if not 0
00001E9E  341A                    1230                      MOVE.W    (A2)+,D2               ; gets 16 bit displacement                    
00001EA0                          1231                      
00001EA0  D44D                    1232  PRINTADDRESS        ADD.W     A5,D2                 ; Adds address to D2 to get displacement
00001EA2  3202                    1233                      MOVE.W    D2,D1                 ; moves address to D1 for printing
00001EA4  183C 0000               1234                      MOVE.B    #0,D4                 ; marks address as word length
00001EA8  4BF9 000025DB           1235                      LEA       MSG_HEX,A5            ; loads hex sign to A5
00001EAE  4EB9 000022A8           1236                      JSR       PRINTNULL             ; prints null
00001EB4  4EB9 00002182           1237                      JSR       PRINTSHORTLONGNUM     ; prints address
00001EBA                          1238                      
00001EBA  4CDF 2002               1239                      MOVEM.L    (SP)+,D1/A5              ; restores D1
00001EBE                          1240                      
00001EBE                          1241                     
00001EBE                          1242  * Gets the rotation value for ASd and LSd
00001EBE                          1243  * Input: D2 = instruction word copy (of D0)                                    
00001EBE                          1244  * Output: rotation  value in D2             
00001EBE  C47C 0E00               1245  GETROTATION         AND.W      #$0E00,D2             ; gets the rotation bits
00001EC2  E04A                    1246                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001EC4  E24A                    1247                      LSR.W      #1,D2                ; shifts 1 bits to the right to only have the rotation bits
00001EC6  4E75                    1248                      RTS                             ; return from subroutine
00001EC8                          1249  
00001EC8                          1250  * Gets the direction value for ASd and LSd
00001EC8                          1251  * Input: D2 = instruction word copy (of D0)                                    
00001EC8                          1252  * Output: direction value in D2             
00001EC8  C47C 0100               1253  GETDIRECTION        AND.W      #$0100,D2             ; gets the rotation bits
00001ECC  E04A                    1254                      LSR.W      #8,D2                ; shifts 8 bits to the right to only have the rotation bits
00001ECE  4E75                    1255                      RTS                             ; return from subroutine
00001ED0                          1256  
00001ED0                          1257  * Gets the rotation size value for ASd and LSd
00001ED0                          1258  * Input: D2 = instruction word copy (of D0)                                    
00001ED0                          1259  * Output: rotation size value in D2             
00001ED0  C47C 00C0               1260  GETROTATIONSIZE     AND.W      #$00C0,D2            ; gets the rotation bits
00001ED4  EC4A                    1261                      LSR.W      #6,D2                ; shifts 6 bits to the right to only have the rotation bits
00001ED6  4E75                    1262                      RTS                             ; return from subroutine
00001ED8                          1263  
00001ED8                          1264  * Gets the rotation location  value for ASd and LSd
00001ED8                          1265  * Input: D2 = instruction word copy (of D0)                                    
00001ED8                          1266  * Output: rotation location value in D2             
00001ED8  C47C 0020               1267  GETROTATIONLOCATION AND.W      #$0020,D2            ; gets the rotation location bits
00001EDC  EA4A                    1268                      LSR.W      #5,D2                ; shifts 5 bits to the right to only have the rotation bits
00001EDE  4E75                    1269                      RTS                             ; return from subroutine
00001EE0                          1270  
00001EE0                          1271  * Prints out registers for MOVEM
00001EE0                          1272  * Input: A2 = pointer to next instruction, D4 = -1(MEM TO REG) or 1(REG TO MEM)
00001EE0                          1273  * Output: printed out registers
00001EE0                          1274  * D5 = counter for loop, D6 = current number, D7 = bitmask location
00001EE0  48E7 4706               1275  PRINTREGISTERS      MOVEM.L    D1/D5-D7/A5-A6,-(SP) ; saves D1/D5-D7/A5-A6
00001EE4  3A3C 0000               1276                      MOVE.W     #0,D5                ; sets counter to 0
00001EE8  3E1A                    1277                      MOVE.W     (A2)+, D7            ; gets the register bitmask    
00001EEA  B83C 0001               1278                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001EEE  6600 0010               1279                      BNE        MEMTOREG1            ; branches to MEMTOREG1 if not REGTOMEM1
00001EF2                          1280  
00001EF2  3C3C 0000               1281  REGTOMEM1           MOVE.W     #0,D6                ; moves 0 to D1
00001EF6  4BF9 000025CD           1282                      LEA        MSG_DR,A5            ; loads D to A5
00001EFC  6000 000C               1283                      BRA        PRINTREGISTERLOOP    ; branches to loop        
00001F00                          1284                      
00001F00  3C3C 0007               1285  MEMTOREG1           MOVE.W     #7,D6                ; moves 1 to D1
00001F04  4BF9 000025CF           1286                      LEA        MSG_AR,A5            ; loads A to A5
00001F0A                          1287                      
00001F0A  E34F                    1288  PRINTREGISTERLOOP   LSL.W      #1,D7                ; shifter out bitmask, see if it was a 1
00001F0C  6500 0018               1289                      BCS        PRINTREG             ; if pushes out a 1
00001F10  DC44                    1290                      ADD.W      D4,D6                ; decrements or increments
00001F12  5245                    1291                      ADD.W      #1,D5                ; increments D5
00001F14  BA7C 0008               1292                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F18  66F0                    1293                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F1A  B83C 0001               1294                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F1E  6600 0052               1295                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F22  6000 0042               1296                      BRA        REGTOMEM2            ; branches to REGTOMEM2 if not MEMTOREG2 
00001F26                          1297                      
00001F26  4EB9 000022A8           1298  PRINTREG            JSR        PRINTNULL
00001F2C  3206                    1299                      MOVE.W     D6,D1
00001F2E  4EB9 0000215E           1300                      JSR        PRINTNUM 
00001F34                          1301    
00001F34  BE7C 0000               1302  CHECKMOREBITS       CMP.W      #$0000,D7            ; checks if the register bitmask is 0
00001F38  6600 0006               1303                      BNE        PRINTMORE            ; continue if there is more
00001F3C  6000 0040               1304                      BRA        DONEPRINTINGREG      ; exit case
00001F40                          1305  
00001F40  2C4D                    1306  PRINTMORE           MOVEA.L    A5,A6                ; temporarily stores A5 in A6 so its not overwritten
00001F42  4BF9 000025E0           1307                      LEA        MSG_SLASH,A5         ; leads / into A5
00001F48  4EB9 000022A8           1308                      JSR        PRINTNULL            ; prints the slash
00001F4E  2A4E                    1309                      MOVEA.L    A6,A5                ; reloads A6 into A5
00001F50  DC44                    1310                      ADD.W      D4,D6                ; decrements or increments
00001F52  5245                    1311                      ADD.W      #1,D5                ; increments D5
00001F54  BA7C 0008               1312                      CMP.W      #8,D5                ; if counter has reached 8, swap
00001F58  66B0                    1313                      BNE        PRINTREGISTERLOOP    ; if not 8, return to the loop
00001F5A  B83C 0001               1314                      CMP.B      #1,D4                ; checks if MEM TO REG or REG TO MEM
00001F5E  6600 0012               1315                      BNE        MEMTOREG2            ; branches to MEMTOREG2 if not REGTOMEM2        
00001F62  6000 0002               1316                      BRA        REGTOMEM2            ; loops
00001F66                          1317  
00001F66  3C3C 0000               1318  REGTOMEM2           MOVE.W     #0,D6                ; moves 1 to D1
00001F6A  4BF9 000025CF           1319                      LEA        MSG_AR,A5            ; loads A to A5
00001F70  6098                    1320                      BRA        PRINTREGISTERLOOP    ; loops
00001F72                          1321  
00001F72  3C3C 0007               1322  MEMTOREG2           MOVE.W     #7,D6                ; moves 0 to D1
00001F76  4BF9 000025CD           1323                      LEA        MSG_DR,A5            ; loads D to A5
00001F7C  608C                    1324                      BRA        PRINTREGISTERLOOP    ; loops
00001F7E                          1325  
00001F7E  4CDF 60E2               1326  DONEPRINTINGREG     MOVEM.L    (SP)+,D1/D5-D7/A5-A6 ; saves D1/D5-D7/A5-A6
00001F82                          1327  
00001F82                          1328                          
00001F82                          1329  * Checks if EA or Xn is valid
00001F82                          1330  * Inputs: A5 = Pointer to -1 terminated list of valid addressing modes, D1 = Addressing Mode (3 bit)
00001F82                          1331  * Outputs: D1 (0 = Valid, 1 = Invalid, 2 = Check Xn)                   
00001F82  2F02                    1332  CHECKEAXN_IFVALID  MOVE.L     D2,-(SP)              ; saves D2
00001F84                          1333  
00001F84  141D                    1334  CHECKEAMLOOP       MOVE.B     (A5)+,D2              ; load possible EA
00001F86  B43C 00FF               1335                     CMP.B      #-$1,D2               ; compares to -1 to see if loop is over
00001F8A  6700 000A               1336                     BEQ        INVALIDEA             ; branches to INVALIDEA if its over
00001F8E  B202                    1337                     CMP.B      D2,D1                 ; check addressing mode, check if current one is one of those
00001F90  6700 000C               1338                     BEQ        VALIDEA               ; branches to valid EA
00001F94  60EE                    1339                     BRA        CHECKEAMLOOP          ; loops if it isn't valid
00001F96                          1340                     
00001F96  323C 0001               1341  INVALIDEA          MOVE.W     #$1,D1                ; marks that it is invalid
00001F9A  6000 0016               1342                     BRA        CHECKEAEXIT           ; exists the subroutine        
00001F9E                          1343                    
00001F9E  B43C 0007               1344  VALIDEA            CMP.B      #Other,D2             ; check if its Xn
00001FA2  6700 000A               1345                     BEQ        OTHEREA               ; branches to OTHEREA if it is Xn
00001FA6  323C 0000               1346                     MOVE.W     #$0,D1                ; marks that it is valid
00001FAA  6000 0006               1347                     BRA        CHECKEAEXIT           ; exits the subroutine
00001FAE                          1348  
00001FAE  323C 0002               1349  OTHEREA            MOVE.W     #$2,D1                ; marks that it is invalid
00001FB2                          1350  
00001FB2  241F                    1351  CHECKEAEXIT        MOVE.L    (SP)+,D2               ; restores D2
00001FB4  4E75                    1352                     RTS                              ; returns from subroutine
00001FB6                          1353  
00001FB6                          1354  * Converts EA and Xn into a string                                
00001FB6                          1355  * Inputs: D1 = operation size, D2 = EA, D3 = Xn, A2 = NEXT INSTRUCTION WORD
00001FB6                          1356  * Outputs: Prints out EA and Xn into a string
00001FB6  48E7 C004               1357  EA_TO_STRING       MOVEM.L  D0-D1/A5,-(SP)          ; saves D1, D0, and A5
00001FBA  B47C 0001               1358                     CMP.W    #An,D2                  ; checks if it is An
00001FBE  6700 003A               1359                     BEQ      CASE_AR                 ; branches to CASE_AR if address register
00001FC2                          1360                     
00001FC2  B47C 0002               1361                     CMP.W    #AnIndirect,D2          ; checks if it is (An)
00001FC6  6700 004A               1362                     BEQ      CASE_ARI                ; branches to CASE_ARI if address register indirect
00001FCA                          1363                     
00001FCA  B47C 0003               1364                     CMP.W    #AnPost,D2              ; checks if it is (An)+
00001FCE  6700 0072               1365                     BEQ      CASE_ARIPOST            ; branches to CASE_ARIPOST if address register indirect post increment
00001FD2                          1366                     
00001FD2  B47C 0004               1367                     CMP.W    #AnPre,D2               ; checks if it is -(An)
00001FD6  6700 00A6               1368                     BEQ      CASE_ARIPRE             ; branches to CASE_ARIPRE if address register indirect pre increment
00001FDA                          1369                     
00001FDA  B47C 0007               1370                     CMP.W    #Other,D2               ; checks if it is other (has an Xn/D3)
00001FDE  6700 00DA               1371                     BEQ      CASE_OTHER              ; branches to CASE_AR if address register
00001FE2                          1372                     ; otherwise assumes D2 = #Dn which means its a data register                   
00001FE2                          1373  
00001FE2                          1374  * data register, Dn
00001FE2  4BF9 000025CD           1375  CASE_DR            LEA      MSG_DR,A5               ; Loads D into A5
00001FE8  4EB9 000022A8           1376                     JSR      PRINTNULL               ; Prints D
00001FEE  3203                    1377                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00001FF0  4EB9 0000215E           1378                     JSR      PRINTNUM                ; Prints the Xn
00001FF6  6000 0160               1379                     BRA      EA_TO_STRING_EXIT       ; exits           
00001FFA                          1380  
00001FFA                          1381  
00001FFA                          1382  * address register
00001FFA  4BF9 000025CF           1383  CASE_AR            LEA      MSG_AR,A5               ; Loads A into A5
00002000  4EB9 000022A8           1384                     JSR      PRINTNULL               ; Prints A
00002006  3203                    1385                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
00002008  4EB9 0000215E           1386                     JSR      PRINTNUM                ; Prints the Xn
0000200E  6000 0148               1387                     BRA      EA_TO_STRING_EXIT       ; exits
00002012                          1388  
00002012                          1389  * address register indirect
00002012  4BF9 000025D1           1390  CASE_ARI           LEA      MSG_LB,A5               ; Loads ( into A5
00002018  4EB9 000022A8           1391                     JSR      PRINTNULL               ; Prints (
0000201E  4BF9 000025CF           1392                     LEA      MSG_AR,A5               ; Loads A into A5
00002024  4EB9 000022A8           1393                     JSR      PRINTNULL               ; Prints A
0000202A  3203                    1394                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000202C  4EB9 0000215E           1395                     JSR      PRINTNUM                ; Prints the Xn
00002032  4BF9 000025D3           1396                     LEA      MSG_RB,A5               ; Loads ) into A5
00002038  4EB9 000022A8           1397                     JSR      PRINTNULL               ; Prints )
0000203E  6000 0118               1398                     BRA      EA_TO_STRING_EXIT       ; exits
00002042                          1399  
00002042                          1400  * address register indirect post increment
00002042  4BF9 000025D1           1401  CASE_ARIPOST       LEA      MSG_LB,A5               ; Loads ( into A5
00002048  4EB9 000022A8           1402                     JSR      PRINTNULL               ; Prints (
0000204E  4BF9 000025CF           1403                     LEA      MSG_AR,A5               ; Loads A into A5
00002054  4EB9 000022A8           1404                     JSR      PRINTNULL               ; Prints A
0000205A  3203                    1405                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
0000205C  4EB9 0000215E           1406                     JSR      PRINTNUM                ; Prints the Xn
00002062  4BF9 000025D3           1407                     LEA      MSG_RB,A5               ; Loads ) into A5
00002068  4EB9 000022A8           1408                     JSR      PRINTNULL               ; Prints )
0000206E  4BF9 000025D5           1409                     LEA      MSG_PLUS,A5             ; Loads + into A5
00002074  4EB9 000022A8           1410                     JSR      PRINTNULL               ; Prints +
0000207A  6000 00DC               1411                     BRA      EA_TO_STRING_EXIT       ; exits
0000207E                          1412  
0000207E                          1413  
0000207E                          1414  * address register indirect pre increment
0000207E  4BF9 000025D7           1415  CASE_ARIPRE        LEA      MSG_MINUS,A5            ; Loads - into A5
00002084  4EB9 000022A8           1416                     JSR      PRINTNULL               ; Prints -
0000208A  4BF9 000025D1           1417                     LEA      MSG_LB,A5               ; Loads ( into A5
00002090  4EB9 000022A8           1418                     JSR      PRINTNULL               ; Prints (
00002096  4BF9 000025CF           1419                     LEA      MSG_AR,A5               ; Loads A into A5
0000209C  4EB9 000022A8           1420                     JSR      PRINTNULL               ; Prints A
000020A2  3203                    1421                     MOVE.W   D3, D1                  ; Loads D3 (the Xn) into D1 for printing 
000020A4  4EB9 0000215E           1422                     JSR      PRINTNUM                ; Prints the Xn
000020AA  4BF9 000025D3           1423                     LEA      MSG_RB,A5               ; Loads ) into A5
000020B0  4EB9 000022A8           1424                     JSR      PRINTNULL               ; Prints )
000020B6  6000 00A0               1425                     BRA      EA_TO_STRING_EXIT       ; exits
000020BA                          1426  
000020BA                          1427  * other (long, short, immediate) with Xn yes
000020BA  301A                    1428  CASE_OTHER         MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word 
000020BC  B67C 0000               1429                     CMP.W    #ABSShort,D3            ; checks if it is a word
000020C0  6700 0054               1430                     BEQ      CASE_WORD               ; branches to CASE_WORD if is a short
000020C4                          1431                     
000020C4  B67C 0001               1432                     CMP.W    #ABSLong,D3             ; checks if it is (An)
000020C8  6700 0068               1433                     BEQ      CASE_LONG               ; branches to CASE_LONG if is a long
000020CC                          1434  
000020CC                          1435  * immediate
000020CC  4BF9 000025D9           1436  CASE_IMMEDIATE     LEA      MSG_POUND,A5            ; Loads # into A5
000020D2  4EB9 000022A8           1437                     JSR      PRINTNULL               ; Prints #  
000020D8  4BF9 000025DB           1438                     LEA      MSG_HEX,A5              ; Loads $ into A5
000020DE  4EB9 000022A8           1439                     JSR      PRINTNULL               ; Prints $
000020E4                          1440                     
000020E4  B27C 0002               1441                     CMP.W    #2,D1                   ; checks if it is long size
000020E8  6700 000E               1442                     BEQ      IMMEDIATE_LONG          ; branches if it is a long
000020EC                          1443                     
000020EC  3200                    1444                     MOVE.W   D0, D1                  ; moves instruction word into d1
000020EE  4EB9 0000216E           1445                     JSR      PRINTHEXNUM 
000020F4  6000 0062               1446                     BRA      EA_TO_STRING_EXIT       ; exits subroutine  
000020F8                          1447  
000020F8  3200                    1448  IMMEDIATE_LONG     MOVE.W   D0, D1                  ; moves instruction word into d1
000020FA  383C 0000               1449                     MOVE.W   #0, D4                  ; moves word size into d4
000020FE  4EB9 00002182           1450                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002104  301A                    1451                     MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002106  3200                    1452                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002108  383C 0000               1453                     MOVE.W   #0, D4                  ; moves word size into d4
0000210C  4EB9 00002182           1454                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002112                          1455                     *MOVE     (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002112  6000 0044               1456                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00002116                          1457                     
00002116                          1458  * word address
00002116                          1459  CASE_WORD          
00002116  4BF9 000025DB           1460                     LEA      MSG_HEX,A5              ; Loads $ into A5
0000211C  4EB9 000022A8           1461                     JSR      PRINTNULL               ; Prints $
00002122  3200                    1462                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002124  383C 0000               1463                     MOVE.W   #0, D4                  ; moves length size (word) into d4
00002128  4EB9 00002182           1464                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000212E  6000 0028               1465                     BRA      EA_TO_STRING_EXIT       ; exits subroutine
00002132                          1466  
00002132                          1467  * long address 
00002132                          1468  CASE_LONG          
00002132  4BF9 000025DB           1469                     LEA      MSG_HEX,A5              ; Loads $ into A5
00002138  4EB9 000022A8           1470                     JSR      PRINTNULL               ; Prints $
0000213E  3200                    1471                     MOVE.W   D0, D1                  ; moves instruction word into d1
00002140  383C 0000               1472                     MOVE.W   #0, D4                  ; moves word size into d4
00002144  4EB9 00002182           1473                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
0000214A  301A                    1474                     MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
0000214C  3200                    1475                     MOVE.W   D0, D1                  ; moves instruction word into d1
0000214E  383C 0000               1476                     MOVE.W   #0, D4                  ; moves word size into d4
00002152  4EB9 00002182           1477                     JSR      PRINTSHORTLONGNUM       ; reformats the number to the proper length and prints out the number
00002158                          1478                     *MOVE.W   (A2)+, D0               ; Moves next instruction word into D1 since A2 is auxilliary instruction word
00002158                          1479                     
00002158                          1480  * exits subroutine
00002158  4CDF 2003               1481  EA_TO_STRING_EXIT   MOVEM.L  (SP)+,D0-D1/A5          ; restoers D1, D0, and A5
0000215C  4E75                    1482                      RTS                              ; returns from subroutine
0000215E                          1483  
0000215E                          1484  * Prints out the content of D1 as a decimal number
0000215E                          1485  * Input: number in D1 to be printed
0000215E                          1486  * Output: contents of D1 printed
0000215E  48E7 C000               1487  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00002162  103C 0003               1488                   MOVE.B      #3,D0               ; prints D1
00002166  4E4F                    1489                   TRAP        #15                 ; is trap task 3
00002168                          1490              
00002168  4CDF 0003               1491                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
0000216C  4E75                    1492                   RTS                             ; returns from subroutine
0000216E                          1493                   
0000216E                          1494  * Prints out the content of D1 as a hex number
0000216E                          1495  * Input: number in D1 to be printed
0000216E                          1496  * Output: contents of D1 printed
0000216E  48E7 C000               1497  PRINTHEXNUM      MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
00002172  143C 0010               1498                   MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
00002176  103C 000F               1499                   MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000217A  4E4F                    1500                   TRAP        #15                 ; is trap task 15
0000217C  4CDF 0003               1501                   MOVEM.L     (SP)+,D0-D1         ; returns D0 and D1
00002180  4E75                    1502                   RTS                             ; returns from subroutine
00002182                          1503                   
00002182                          1504  * Prints out the content of D1 as a hex number and formats it to have the length of WORD or a LONG
00002182                          1505  * Input: number in D1 to be printed, D4 = length (0 = WORD, 1 = LONG)
00002182                          1506  * Output: contents of D1 printed
00002182  48E7 E000               1507  PRINTSHORTLONGNUM         MOVEM.L     D0-D2, -(SP)        ; saves D0 to D2
00002186  B83C 0001               1508                            CMP.B       #1,D4               ; checks size of number
0000218A  6700 0042               1509                            BEQ         PRINTLONGZERO       ; if it is a long then branch to PRINTLONGZERO
0000218E                          1510  
0000218E  3401                    1511  PRINTSHORTZERO            MOVE.W      D1,D2               ; copies number to D2
00002190  C47C F000               1512                            AND.W       #$F000,D2           ; gets the first digit
00002194  B47C 0000               1513                            CMP.W       #0, D2              ; checks if it is 0
00002198  6600 00DC               1514                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
0000219C  4EB9 00002286           1515                            JSR         PRINTZERO           ; prints a zero
000021A2                          1516                            
000021A2  3401                    1517                            MOVE.W      D1,D2               ; copies number to D2
000021A4  C47C 0F00               1518                            AND.W       #$0F00,D2           ; gets the second digit
000021A8  B47C 0000               1519                            CMP.W       #0, D2              ; checks if it is 0
000021AC  6600 00C8               1520                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021B0  4EB9 00002286           1521                            JSR         PRINTZERO           ; prints a zero
000021B6                          1522                            
000021B6  3401                    1523                            MOVE.W      D1,D2               ; copies number to D2
000021B8  C47C 00F0               1524                            AND.W       #$00F0,D2           ; gets the third digit
000021BC  B47C 0000               1525                            CMP.W       #0, D2              ; checks if it is 0
000021C0  6600 00B4               1526                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021C4  4EB9 00002286           1527                            JSR         PRINTZERO           ; prints a zero
000021CA  6000 00AA               1528                            BRA         PRINTASHEX          ; prints last digit
000021CE                          1529                            
000021CE  2401                    1530  PRINTLONGZERO             MOVE.L      D1,D2               ; copies number to D2
000021D0  C4BC F0000000           1531                            AND.L       #$F0000000,D2       ; gets the first digit
000021D6  B4BC 00000000           1532                            CMP.L       #0, D2              ; checks if it is 0
000021DC  6600 0098               1533                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021E0  4EB9 00002286           1534                            JSR         PRINTZERO           ; prints a zero
000021E6                          1535                            
000021E6  2401                    1536                            MOVE.L      D1,D2               ; copies number to D2
000021E8  C4BC 0F000000           1537                            AND.L       #$0F000000,D2       ; gets the second digit
000021EE  B4BC 00000000           1538                            CMP.L       #0, D2              ; checks if it is 0
000021F4  6600 0080               1539                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
000021F8  4EB9 00002286           1540                            JSR         PRINTZERO           ; prints a zero
000021FE                          1541                            
000021FE  2401                    1542                            MOVE.L      D1,D2               ; copies number to D2
00002200  C4BC 00F00000           1543                            AND.L       #$00F00000,D2       ; gets the third digit
00002206  B4BC 00000000           1544                            CMP.L       #0, D2              ; checks if it is 0
0000220C  6600 0068               1545                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002210  4EB9 00002286           1546                            JSR         PRINTZERO           ; prints a zero
00002216                          1547                            
00002216  2401                    1548                            MOVE.L      D1,D2               ; copies number to D2
00002218  C4BC 000F0000           1549                            AND.L       #$000F0000,D2       ; gets the fourth digit
0000221E  B4BC 00000000           1550                            CMP.L       #0, D2              ; checks if it is 0
00002224  6600 0050               1551                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002228  4EB9 00002286           1552                            JSR         PRINTZERO           ; prints a zero
0000222E                          1553                            
0000222E  2401                    1554                            MOVE.L      D1,D2               ; copies number to D2
00002230  C4BC 0000F000           1555                            AND.L       #$0000F000,D2       ; gets the fith digit
00002236  B4BC 00000000           1556                            CMP.L       #0, D2              ; checks if it is 0
0000223C  6600 0038               1557                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002240  4EB9 00002286           1558                            JSR         PRINTZERO           ; prints a zero
00002246                          1559                            
00002246  2401                    1560                            MOVE.L      D1,D2               ; copies number to D2
00002248  C4BC 00000F00           1561                            AND.L       #$00000F00,D2       ; gets the sixth digit
0000224E  B4BC 00000000           1562                            CMP.L       #0, D2              ; checks if it is 0
00002254  6600 0020               1563                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002258  4EB9 00002286           1564                            JSR         PRINTZERO           ; prints a zero
0000225E                          1565                            
0000225E  2401                    1566                            MOVE.L      D1,D2               ; copies number to D2
00002260  C4BC 000000F0           1567                            AND.L       #$000000F0,D2       ; gets the seventh digit
00002266  B4BC 00000000           1568                            CMP.L       #0, D2              ; checks if it is 0
0000226C  6600 0008               1569                            BNE         PRINTASHEX          ; if the digit is not equal to zero then print the full number
00002270  4EB9 00002286           1570                            JSR         PRINTZERO           ; prints a zero
00002276                          1571  
00002276  143C 0010               1572  PRINTASHEX                MOVE.B      #16,D2              ; for trap task 15 to print it out as hex
0000227A  103C 000F               1573                            MOVE.B      #15,D0              ; converts D1 to Hex and prints it out
0000227E  4E4F                    1574                            TRAP        #15                 ; is trap task 15
00002280  4CDF 0007               1575                            MOVEM.L     (SP)+,D0-D2         ; returns D0 and D1
00002284  4E75                    1576                            RTS                             ; returns from subroutine    
00002286                          1577  * Prints a zero
00002286                          1578  * Input: nothing
00002286                          1579  * Output: 0 printed out to the console
00002286  2F01                    1580  PRINTZERO                 MOVE.L      D1,-(SP)            ; saves D1
00002288  7200                    1581                            MOVE.L      #0,D1               ; moves 0 to D1
0000228A  4EB8 215E               1582                            JSR         PRINTNUM            ; prints the number
0000228E  221F                    1583                            MOVE.L      (SP)+,D1            ; restores D1
00002290  4E75                    1584                            RTS                             ; returns from subroutine
00002292                          1585              
00002292                          1586  * Prints contents of things between a range
00002292                          1587  * input: A5, A6 (the range)
00002292                          1588  * output: prints memory contents from A5 to A6 as strings   
00002292  48E7 C040               1589  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
00002296  224D                    1590                  MOVEA.L     A5, A1           ; loads A5 into A1
00002298  9DCD                    1591                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
0000229A  320E                    1592                  MOVE.W      A6, D1           ; move n into D1
0000229C  103C 0001               1593                  MOVE.B      #1, D0           ; display n characters of string at A1
000022A0  4E4F                    1594                  TRAP        #15              ; is trap task 1
000022A2  4CDF 0203               1595                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
000022A6  4E75                    1596                  RTS                          ; returns
000022A8                          1597      
000022A8                          1598  * Prints null terminated string
000022A8                          1599  * input: string pointed to by A5
000022A8                          1600  * output: prints out the null terminated string
000022A8  48E7 8040               1601  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
000022AC  224D                    1602                  MOVE.L      A5,A1           ; loads A5 into A1
000022AE  103C 000E               1603                  MOVE.B      #14,D0          ; prints null terminated string
000022B2  4E4F                    1604                  TRAP        #15             ; is trap task 10
000022B4  4CDF 0201               1605                  MOVEM.L     (SP)+,D0/A1     ; saves D0-D1 and A1
000022B8  4E75                    1606                  RTS                         ; returns from subroutine
000022BA                          1607                  
000022BA  2F0D                    1608  PRINTENTER      MOVE.L      A5, -(SP)       ; saves A5
000022BC  4BF9 0000250C           1609                  LEA         NEW_LINE,A5     ; Prints null
000022C2  4EB8 22A8               1610                  JSR         PRINTNULL       ; prints the new line
000022C6  2A5F                    1611                  MOVE.L      (SP)+,A5        ; returns A5
000022C8  4E75                    1612                  RTS
000022CA                          1613  
000022CA                          1614  * Prints the size of the MOVE or MOVEA operation  
000022CA                          1615  * input: D0
000022CA                          1616  * output: prints out the size of a MOVE or MOVEA operation        
000022CA  48E7 0004               1617  PRINTMOVESIZE   MOVEM.L A5,-(SP)         ; saves D0 and A5
000022CE  3200                    1618                  MOVE.W  D0,D1               ; stores d0 in d1
000022D0  C27C 3000               1619                  AND.W   #$3000,D1           ; gets the size
000022D4  B27C 2000               1620                  CMP.W   #$2000,D1           ; checks if is long
000022D8  6700 001E               1621                  BEQ     MOVE_LONG
000022DC  B27C 3000               1622                  CMP.W   #$3000,D1           ; checks if is word
000022E0  6700 000C               1623                  BEQ     MOVE_WORD      
000022E4                          1624                  
000022E4  4BF9 00002604           1625  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
000022EA  6000 0012               1626                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000022EE                          1627  
000022EE  4BF9 00002607           1628  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
000022F4  6000 0008               1629                  BRA     FINISHMOVE          ; branches to FINISHMOVE
000022F8                          1630  
000022F8  4BF9 0000260A           1631  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000022FE                          1632                  
000022FE  4EB8 22A8               1633  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
00002302  E049                    1634                  LSR.W   #8,D1               ; shifts bytes 8 to the right
00002304  E849                    1635                  LSR.W   #4,D1               ; shifts bytes 4 to the right
00002306  4CDF 2000               1636                  MOVEM.L (SP)+,A5            ; restores D0 and A5
0000230A  4E75                    1637                  RTS
0000230C                          1638  
0000230C  43F9 0000247B           1639  ERROR           LEA     ERROR_MSG,A1
00002312  103C 000E               1640                  MOVE.B  #14,D0
00002316  4E4F                    1641                  TRAP    #15 
00002318                          1642            
00002318  FFFF FFFF               1643      SIMHALT             ; halt simulator
0000231C                          1644  
0000231C                          1645  * Put variables and constants here
0000231C                          1646  
0000231C  =0000000D               1647  CR                              EQU     $0D
0000231C  =0000000A               1648  LF                              EQU     $0A 
0000231C  =00000009               1649  TAB                             EQU     $09  
0000231C                          1650  
0000231C                          1651  * Addressing Modes
0000231C  =00000000               1652  Dn                              EQU     0
0000231C  =00000001               1653  An                              EQU     1
0000231C  =00000002               1654  AnIndirect                      EQU     2
0000231C  =00000003               1655  AnPost                          EQU     3
0000231C  =00000004               1656  AnPre                           EQU     4
0000231C  =00000007               1657  Other                           EQU     7           ; short, long, immediate
0000231C                          1658  
0000231C                          1659  * Xn
0000231C  =00000000               1660  ABSShort                        EQU     0
0000231C  =00000001               1661  ABSLong                         EQU     1
0000231C  =00000004               1662  XnImmediate                     EQU     4
0000231C                          1663  
0000231C                          1664  * Valid Addressing Modes
0000231C= 00 01 02 03 04 07 FF    1665  VALIDEA_ALL                     DC.B    Dn,An,AnIndirect,AnPost,AnPre,Other,-1          
00002323                          1666  ; MOVE (source),MOVEA, ADD, ADDA, ADDQ, and SUB
00002323= 00 02 03 04 07 FF       1667  VALIDEA_MOVEQ                   DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002329= 02 04 07 FF             1668  VALIDEA_MOVEM_REGTOMEM          DC.B    AnIndirect,AnPre,Other,-1
0000232D= 02 03 07 FF             1669  VALIDEA_MOVEM_MEMTOREG          DC.B    AnIndirect,AnPost,Other,-1
00002331= 02 03 04 07 FF          1670  VALIDEA_ADDSUB_DESTOPERAND      DC.B    AnIndirect,AnPost,AnPre,Other,-1
00002336= 00 02 03 04 07 FF       1671  VALIDEA_MULSDIVU                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
0000233C= 01 07 FF                1672  VALIDEA_LEA                     DC.B    An,Other,-1
0000233F= 00 02 03 04 07 FF       1673  VALIDEA_ANDORNOT                DC.B    Dn,AnIndirect,AnPost,AnPre,Other,-1
00002345= 02 03 04 07 FF          1674  VALIDEA_ANDOR_DESTOPERAND       DC.B    AnIndirect,AnPost,AnPre,Other,-1
0000234A= 02 03 04 07 FF          1675  VALIDEA_SHIFT                   DC.B    AnIndirect,AnPost,AnPre,Other,-1                ; LSL, LSR, ASL, ASR, ROR, ROL
0000234F= 02 07 FF                1676  VALIDEA_JSR                     DC.B    AnIndirect, Other,-1
00002352                          1677  
00002352                          1678  * Valid Xn
00002352= 00 01 04 FF             1679  VALIDXN_ALL                     DC.B    ABSShort,ABSLong,XnImmediate,-1                 
00002356                          1680  ; MOVE (source), MOVEA, ADD, ADDA, SUB, MULS, DIVU, AND, OR, 
00002356= 00 01 FF                1681  VALIDXN_SHORTLONG               DC.B    ABSShort,ABSLong,-1                             
00002359                          1682  ; MOVE (dest), MOVEM, ADD (destination operand), ADDQ, SUB (destination operand), LEA, AND (destination operand),
00002359                          1683  ; OR (destination operand), NOT, LSL/R, ASL/R, JSR
00002359                          1684  
00002359                          1685  * posible memory ASd/LSd rotation values
00002359  =00000000               1686  ASd_MEM                         EQU     0   
00002359  =00000001               1687  LSd_MEM                         EQU     1 
00002359  =00000003               1688  ROd_MEM                         EQU     3
00002359                          1689   
00002359  =00000000               1690  ASd_REG                         EQU     0   
00002359  =00000001               1691  LSd_REG                         EQU     1 
00002359  =00000003               1692  ROd_REG                         EQU     3
00002359                          1693  
00002359                          1694  * Messages
00002359= 57 65 6C 63 6F 6D ...   1695  WELCOME                         DC.B    'Welcome to Team Big Blue Disassembler',CR,LF,0
00002381= 46 6F 72 6D 61 74 ...   1696  FORMAT1                         DC.B    'Format: 8 digit address in hexadecimal format. Numbers and letters only.',CR,LF,0
000023CC= 4C 65 74 74 65 72 ...   1697  FORMAT2                         DC.B    'Letters must be capital case.',CR,LF,0
000023EC= 50 6C 65 61 73 65 ...   1698  STARTING                        DC.B    'Please enter a starting location in the above format',CR,LF,0
00002423= 50 6C 65 61 73 65 ...   1699  ENDING                          DC.B    'Please enter an ending location in the above format',CR,LF,0
00002459= 49 6E 76 61 6C 69 ...   1700  BAD_INPUT                       DC.B    'Invalid input. Please try again',CR,LF,0
0000247B= 45 72 72 6F 72 20 ...   1701  ERROR_MSG                       DC.B    'Error while disassembling',CR,LF,0
00002497= 09 44 41 54 41 00       1702  INVALID_INSTR                   DC.B    TAB,'DATA',0
0000249D= 46 69 6E 69 73 68 ...   1703  DONE                            DC.B    'Finished Disassembling. Press R to restart. Any other key to end.',CR,LF,0
000024E1= 0D 0A 50 72 65 73 ...   1704  CONTINUE                        DC.B    CR,LF,'Press ENTER to continue disassembling.',CR,LF,0
0000250C= 0D 0A 00                1705  NEW_LINE                        DC.B    CR,LF,0
0000250F= 09 09 09 00             1706  THREE_TAB                       DC.B    TAB,TAB,TAB,0
00002513                          1707  
00002513                          1708  * Opcode Messages
00002513= 09 4E 4F 50 00          1709  MSG_NOP                         DC.B    TAB,'NOP',0
00002518= 09 4D 4F 56 45 00       1710  MSG_MOVE                        DC.B    TAB,'MOVE',0  
0000251E= 09 4D 4F 56 45 41 00    1711  MSG_MOVEA                       DC.B    TAB,'MOVEA',0
00002525= 09 4D 4F 56 45 51 00    1712  MSG_MOVEQ                       DC.B    TAB,'MOVEQ',0
0000252C= 09 4D 4F 56 45 4D 00    1713  MSG_MOVEM                       DC.B    TAB,'MOVEM',0
00002533= 09 41 44 44 00          1714  MSG_ADD                         DC.B    TAB,'ADD',0
00002538= 09 41 44 44 41 00       1715  MSG_ADDA                        DC.B    TAB,'ADDA',0
0000253E= 09 41 44 44 51 00       1716  MSG_ADDQ                        DC.B    TAB,'ADDQ',0
00002544= 09 53 55 42 00          1717  MSG_SUB                         DC.B    TAB,'SUB',0
00002549= 09 4D 55 4C 53 00       1718  MSG_MULS                        DC.B    TAB,'MULS',0
0000254F= 09 44 49 56 55 00       1719  MSG_DIVU                        DC.B    TAB,'DIVU',0
00002555= 09 4C 45 41 00          1720  MSG_LEA                         DC.B    TAB,'LEA',0
0000255A= 09 41 4E 44 00          1721  MSG_AND                         DC.B    TAB,'AND',0
0000255F= 09 4F 52 00             1722  MSG_OR                          DC.B    TAB,'OR',0
00002563= 09 4E 4F 54 00          1723  MSG_NOT                         DC.B    TAB,'NOT',0
00002568= 09 4C 53 00             1724  MSG_LSd                         DC.B    TAB,'LS',0
0000256C= 09 41 53 00             1725  MSG_ASd                         DC.B    TAB,'AS',0
00002570= 09 52 4F 00             1726  MSG_ROd                         DC.B    TAB,'RO',0
00002574= 09 42 43 43 00          1727  MSG_BCC                         DC.B    TAB,'BCC',0
00002579= 09 42 43 53 00          1728  MSG_BCS                         DC.B    TAB,'BCS',0
0000257E= 09 42 45 51 00          1729  MSG_BEQ                         DC.B    TAB,'BEQ',0
00002583= 09 42 4E 45 00          1730  MSG_BNE                         DC.B    TAB,'BNE',0
00002588= 09 42 47 45 00          1731  MSG_BGE                         DC.B    TAB,'BGE',0
0000258D= 09 42 47 54 00          1732  MSG_BGT                         DC.B    TAB,'BGT',0
00002592= 09 42 48 49 00          1733  MSG_BHI                         DC.B    TAB,'BHI',0
00002597= 09 42 4C 45 00          1734  MSG_BLE                         DC.B    TAB,'BLE',0
0000259C= 09 42 4C 53 00          1735  MSG_BLS                         DC.B    TAB,'BLS',0
000025A1= 09 42 4C 54 00          1736  MSG_BLT                         DC.B    TAB,'BLT',0
000025A6= 09 42 4D 49 00          1737  MSG_BMI                         DC.B    TAB,'BMI',0
000025AB= 09 42 50 4C 00          1738  MSG_BPL                         DC.B    TAB,'BPL',0
000025B0= 09 42 56 43 00          1739  MSG_BVC                         DC.B    TAB,'BVC',0
000025B5= 09 42 56 53 00          1740  MSG_BVS                         DC.B    TAB,'BVS',0
000025BA= 09 4A 53 52 00          1741  MSG_JSR                         DC.B    TAB,'JSR',0
000025BF= 09 52 54 53 00          1742  MSG_RTS                         DC.B    TAB,'RTS',0
000025C4= 09 42 52 41 00          1743  MSG_BRA                         DC.B    TAB,'BRA',0
000025C9                          1744  
000025C9                          1745  * Direction for LSd and ASd
000025C9= 52 00                   1746  MSG_RIGHT                       DC.B    'R',0
000025CB= 4C 00                   1747  MSG_LEFT                        DC.B    'L',0
000025CD                          1748  
000025CD                          1749  * Effective Addresses Messages
000025CD= 44 00                   1750  MSG_DR                          DC.B    'D',0
000025CF= 41 00                   1751  MSG_AR                          DC.B    'A',0
000025D1= 28 00                   1752  MSG_LB                          DC.B    '(',0       ; left bracket, NEVER PRINTED WITHOUT RB
000025D3= 29 00                   1753  MSG_RB                          DC.B    ')',0       ; right bracket, ALWAYS FOLLOWS AFTER LB
000025D5= 2B 00                   1754  MSG_PLUS                        DC.B    '+',0
000025D7= 2D 00                   1755  MSG_MINUS                       DC.B    '-',0
000025D9= 23 00                   1756  MSG_POUND                       DC.B    '#',0 
000025DB= 24 00                   1757  MSG_HEX                         DC.B    '$',0 
000025DD= 2C 20 00                1758  MSG_COMMA                       DC.B    ', ',0
000025E0= 2F 00                   1759  MSG_SLASH                       DC.B    '/',0  
000025E2= 20 00                   1760  MSG_SPACE                       DC.B    ' ',0
000025E4= 09 00                   1761  MSG_TAB                         DC.B    TAB,0
000025E6= 20 20 20 00             1762  MSG_3SPACES                     DC.B    '   ',0
000025EA= 20 20 20 20 00          1763  MSG_4SPACES                     DC.B    '    ',0
000025EF= 20 20 20 20 20 00       1764  MSG_5SPACES                     DC.B    '     ',0
000025F5= 20 20 20 20 20 20 00    1765  MSG_6SPACES                     DC.B    '      ',0
000025FC= 20 20 20 20 20 20 ...   1766  MSG_7SPACES                     DC.B    '       ',0
00002604                          1767  
00002604                          1768  * Size Messages
00002604= 2E 42 00                1769  MSG_B                           DC.B    '.B',0
00002607= 2E 57 00                1770  MSG_W                           DC.B    '.W',0
0000260A= 2E 4C 00                1771  MSG_L                           DC.B    '.L',0
0000260D                          1772  
0000260D                          1773  * Variables
0000260D  =00000100               1774  STARTING_ADDRESS                EQU     $100
0000260D  =00000150               1775  ENDING_ADDRESS                  EQU     $150
0000260D  =00000200               1776  CURRENT_INSTR                   EQU     $200
0000260D  =00000250               1777  REG_VAR                         EQU     $250 * Hold bits 11-9
0000260D  =00000300               1778  OPMODE_VAR                      EQU     $300 * Hold bits 8-6
0000260D  =00000350               1779  EA_MODE                         EQU     $350 * Hold bits 5-3
0000260D  =00000400               1780  EA_REG                          EQU     $400 * Hold bits 2-0
0000260D= 00                      1781  LINE_COUNT                      DC.B     0
0000260E= 19                      1782  LINE_MAX                        DC.B     25
0000260F                          1783              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             1
ABSSHORT            0
ADDA_LONG           168A
ADDQ_BYTE           172C
ADDQ_LONG           1764
ADDQ_WORD           1748
ADD_SUB_BYTE        15A8
ADD_SUB_HELP        1522
ADD_SUB_LONG        15C4
ADD_SUB_OPERAND     15DA
ADD_SUB_SIZE        1584
ADD_SUB_WORD        15B6
AN                  1
AND_BYTE            194E
AND_LONG            1986
AND_WORD            196A
ANINDIRECT          2
ANPOST              3
ANPRE               4
ASD_MEM             0
ASD_REG             0
BAD_INPUT           2459
CASE_ADD            14FA
CASE_ADDA           1652
CASE_ADDQ           16D6
CASE_AND            1908
CASE_AR             1FFA
CASE_ARI            2012
CASE_ARIPOST        2042
CASE_ARIPRE         207E
CASE_ASDMEM         1AE2
CASE_ASDREG         1BB6
CASE_BCC            1D1E
CASE_BEQ            1D50
CASE_BGT            1D64
CASE_BLE            1D5A
CASE_BRA            1CEE
CASE_DATA           1DEC
CASE_DR             1FE2
CASE_EPICFAIL       1DF2
CASE_IMMEDIATE      20CC
CASE_JSR            1D8A
CASE_LEA            186A
CASE_LEFTMEM        1B08
CASE_LEFTREG        1BDC
CASE_LONG           2132
CASE_LSDASDROD      1AA2
CASE_LSDMEM         1AD8
CASE_LSDREG         1BAC
CASE_MOVE           12A6
CASE_MOVEM          136C
CASE_MOVEQ          1472
CASE_NOP            1290
CASE_NOT            1A3E
CASE_OR             19DE
CASE_OTHER          20BA
CASE_RIGHTMEM       1B12
CASE_RIGHTREG       1BE6
CASE_RODMEM         1AEC
CASE_RODREG         1BC0
CASE_RTS            1DD6
CASE_SHIFTMEM       1AC0
CASE_SHIFTREG       1B92
CASE_SUB            17D2
CASE_SUBA           1854
CASE_WORD           2116
CHECKEAEXIT         1FB2
CHECKEAMLOOP        1F84
CHECKEAXN_IFVALID   1F82
CHECKGET_EAXN       1E48
CHECKMEMSOURE       1B52
CHECKMOREBITS       1F34
CHECKSHIFT_XN       1B7C
CHECK_LENGTH        11DE
CHECK_LINE          1186
CHECK_ODD           1274
CHECK_ORDER         10AE
CHECK_XN            1E78
CLEAR_SCREEN        11BA
COMPLETE_REGIM      1C5E
CONCAT              1226
CONTINUE            24E1
CONVERT             11F0
CR                  D
CURRENT_INSTR       200
DESTEA              1DFE
DESTXN              1E28
DISASSEMBLE         10D4
DN                  0
DN_PLUS_EA          161E
DONE                249D
DONEPRINTINGREG     1F7E
EASHIFT_VALID       1B70
EAXN_INVALID        1E8A
EAXN_VALID          1E70
EA_MODE             350
EA_REG              400
EA_TO_STRING        1FB6
EA_TO_STRING_EXIT   2158
ENDING              2423
ENDING_ADDRESS      150
END_CHECKGET        1E8E
ERROR               230C
ERROR_MSG           247B
FINDTYPEEA          1E12
FINDTYPEXN          1E3C
FINISHED            10F8
FINISHMOVE          22FE
FINISH_ADD          15D2
FINISH_ADDA         16AA
FINISH_ADDQ         1780
FINISH_AND          19A2
FINISH_SUB          181A
FINISH_SUBA         1820
FORMAT1             2381
FORMAT2             23CC
GETDIRECTION        1EC8
GETDISPLACEMENT     1E90
GETMEMSOURCE        1B3A
GETROTATION         1EBE
GETROTATIONLOCATION  1ED8
GETROTATIONSIZE     1ED0
GET_EA              1DF4
GET_XN              1E1E
IMMEDIATE_LONG      20F8
INPUT1              1020
INPUT2              1066
INSERTA             132C
INVALID             123E
INVALIDEA           1F96
INVALID_INSTR       2497
INV_INSTR           19AC
ISNUMBER            1206
LF                  A
LINE_COUNT          260D
LINE_MAX            260E
LSD_MEM             1
LSD_REG             1
MAKESHIFT8          1C5A
MEM2REGLONG         143C
MEM2REGWORD         1432
MEMTOREG1           1F00
MEMTOREG2           1F72
MOVEM_MEM2REG       13FE
MOVEM_REG2MEM       138A
MOVE_BYTE           22E4
MOVE_LONG           22F8
MOVE_WORD           22EE
MSG_3SPACES         25E6
MSG_4SPACES         25EA
MSG_5SPACES         25EF
MSG_6SPACES         25F5
MSG_7SPACES         25FC
MSG_ADD             2533
MSG_ADDA            2538
MSG_ADDQ            253E
MSG_AND             255A
MSG_AR              25CF
MSG_ASD             256C
MSG_B               2604
MSG_BCC             2574
MSG_BCS             2579
MSG_BEQ             257E
MSG_BGE             2588
MSG_BGT             258D
MSG_BHI             2592
MSG_BLE             2597
MSG_BLS             259C
MSG_BLT             25A1
MSG_BMI             25A6
MSG_BNE             2583
MSG_BPL             25AB
MSG_BRA             25C4
MSG_BVC             25B0
MSG_BVS             25B5
MSG_COMMA           25DD
MSG_DIVU            254F
MSG_DR              25CD
MSG_HEX             25DB
MSG_JSR             25BA
MSG_L               260A
MSG_LB              25D1
MSG_LEA             2555
MSG_LEFT            25CB
MSG_LSD             2568
MSG_MINUS           25D7
MSG_MOVE            2518
MSG_MOVEA           251E
MSG_MOVEM           252C
MSG_MOVEQ           2525
MSG_MULS            2549
MSG_NOP             2513
MSG_NOT             2563
MSG_OR              255F
MSG_PLUS            25D5
MSG_POUND           25D9
MSG_RB              25D3
MSG_RIGHT           25C9
MSG_ROD             2570
MSG_RTS             25BF
MSG_SLASH           25E0
MSG_SPACE           25E2
MSG_SUB             2544
MSG_TAB             25E4
MSG_W               2607
NEW_LINE            250C
NEXT_SCREEN         119A
NOTNUMBER           120E
OPCODE_DECODE       1288
OPMODE_VAR          300
OR_SIZE             1A26
OTHER               7
OTHEREA             1FAE
PRINTADD            1560
PRINTADDRESS        1EA0
PRINTASHEX          2276
PRINTBCC            1D6E
PRINTENTER          22BA
PRINTHEXNUM         216E
PRINTLONGZERO       21CE
PRINTMEM2REG        1442
PRINTMORE           1F40
PRINTMOVE           134A
PRINTMOVESIZE       22CA
PRINTNULL           22A8
PRINTNUM            215E
PRINTRANGE          2292
PRINTREG            1F26
PRINTREG2MEM        13CE
PRINTREGEA          1C28
PRINTREGISTERLOOP   1F0A
PRINTREGISTERS      1EE0
PRINTREGSIZE        1BF6
PRINTSHIFTMEM       1AF2
PRINTSHIFTREG       1BC6
PRINTSHORTLONGNUM   2182
PRINTSHORTZERO      218E
PRINTSUB            17E8
PRINTZERO           2286
PRINT_8             17C6
PRINT_ADDQ_DATA     17A0
PRINT_ADDR          127C
PRINT_JSR           1DB6
PRINT_MEMDIR        1B18
PRINT_MOVEQ         1494
PRINT_REGDIR        1BF0
READ_KEY            11AA
REG2MEMLONG         13C8
REG2MEMWORD         13BE
REGTOMEM1           1EF2
REGTOMEM2           1F66
REG_BYTE            1C0E
REG_IMMEDIATE       1C4A
REG_LONG            1C22
REG_REGISTER        1CA8
REG_VAR             250
REG_WORD            1C18
RESET_INPUT         11D6
RESTART             1120
RETURN              123C
ROD_MEM             3
ROD_REG             3
SOURCEEA            1E0A
SOURCEXN            1E34
START               1000
STARTING            23EC
STARTING_ADDRESS    100
TAB                 9
TEST_RANGE          125C
THREE_TAB           250F
VALIDEA             1F9E
VALIDEA_ADDSUB_DESTOPERAND  2331
VALIDEA_ALL         231C
VALIDEA_ANDORNOT    233F
VALIDEA_ANDOR_DESTOPERAND  2345
VALIDEA_JSR         234F
VALIDEA_LEA         233C
VALIDEA_MOVEM_MEMTOREG  232D
VALIDEA_MOVEM_REGTOMEM  2329
VALIDEA_MOVEQ       2323
VALIDEA_MULSDIVU    2336
VALIDEA_SHIFT       234A
VALIDXN_ALL         2352
VALIDXN_SHORTLONG   2356
WELCOME             2359
XNIMMEDIATE         4
