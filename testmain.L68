00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/28/2020 6:18:33 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Final Project
00000000                             3  * Written by : Nick Young, Audrey Nguyen, Khiam Rehman
00000000                             4  * Date       : 5/1/20
00000000                             5  * Description: Final Project
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000  43F9 000011B2             12                  LEA     WELCOME,A1          ; output welcome startup message
00001006  103C 000E                 13                  MOVE.B  #14,D0
0000100A  4E4F                      14                  TRAP    #15
0000100C                            15              
0000100C  43F9 00001228             16  INPUT1          LEA     STARTING,A1         ; output starting address message
00001012  103C 000E                 17                  MOVE.B  #14,D0
00001016  4E4F                      18                  TRAP    #15
00001018                            19              
00001018  103C 0002                 20                  MOVE.B  #2,D0                   
0000101C  4E4F                      21                  TRAP    #15                 ; take input from user
0000101E  143C 0001                 22                  MOVE.B  #1,D2               ; D2 stores if starting or ending address
00001022                            23  
00001022  4EB9 00001064             24                  JSR     CHECK_LENGTH
00001028  1C3C 0007                 25                  MOVE.B  #7,D6               ; D6 stores counter               
0000102C  4EB9 00001076             26                  JSR     CONVERT
00001032  2445                      27                  MOVEA.L D5,A2               ; store first input in A2
00001034                            28    
00001034  143C 0002                 29  INPUT2          MOVE.B  #2,D2
00001038  43F9 0000125F             30                  LEA     ENDING,A1           ; output ending address message
0000103E  103C 000E                 31                  MOVE.B  #14,D0
00001042  4E4F                      32                  TRAP    #15         
00001044                            33  
00001044  103C 0002                 34                  MOVE.B  #2,D0
00001048  4E4F                      35                  TRAP    #15
0000104A  4EB9 00001064             36                  JSR     CHECK_LENGTH
00001050  1C3C 0007                 37                  MOVE.B  #7,D6               ; D6 stores counter
00001054  4285                      38                  CLR.L   D5
00001056  4EB9 00001076             39                  JSR     CONVERT
0000105C  2645                      40                  MOVEA.L D5,A3               ; store second input in A3
0000105E                            41                  
0000105E                            42  *DISASSEMBLE     MOVE.L  A2, D1              ; loads current address in D1
0000105E                            43  *                JSR     PRINTNUM            ; prints out address                    
0000105E                            44  *                JSR     OPCODE_DECODE       ; decode the opcode
0000105E                            45  *                JSR     PRINTENTER          ; prints a new line
0000105E                            46  *                CMP.L   A2, A3              ; checks if A2 has reached A3
0000105E                            47  *                BLE     DISASSEMBLE         ; if not, loop
0000105E                            48  
0000105E  103C 0009                 49  STOP            MOVE.B  #9,D0
00001062  4E4F                      50                  TRAP    #15
00001064                            51  
00001064                            52  *--------------------SUBROUTINES------------------                
00001064                            53                  
00001064  7800                      54  CHECK_LENGTH    MOVEQ      #$0,D4           ; check if input is null    
00001066  B204                      55                  CMP.B      D4,D1            ; D1 stores length
00001068  6700 005A                 56                  BEQ        INVALID          ; input is null
0000106C  0C41 0008                 57                  CMPI       #$8,D1           ; check if input is longer than a longword
00001070  6E00 0052                 58                  BGT        INVALID          ; input is longer than a longword
00001074  4E75                      59                  RTS
00001076                            60                              
00001076  4283                      61  CONVERT         CLR.L   D3
00001078  4284                      62                  CLR.L   D4
0000107A  1619                      63                  MOVE.B  (A1)+,D3            ; D3 stores current char
0000107C  B63C 0039                 64                  CMP.B   #57,D3
00001080  6E00 0012                 65                  BGT     NOTNUMBER
00001084                            66                  
00001084  B63C 002F                 67                  CMP.B   #47,D3
00001088  6E00 0002                 68                  BGT     ISNUMBER
0000108C                            69                  
0000108C  0603 00D0                 70  ISNUMBER        ADD.B   #-48,D3             ; current char is number
00001090  6000 001A                 71                  BRA     CONCAT
00001094                            72              
00001094  B63C 0041                 73  NOTNUMBER       CMP.B   #65,D3
00001098  6D00 002A                 74                  BLT     INVALID
0000109C  B63C 005A                 75                  CMP.B   #90,D3
000010A0  6E00 0022                 76                  BGT     INVALID  
000010A4  0603 00C9                 77                  ADD.B   #-55,D3             ; is letter             
000010A8  6000 0002                 78                  BRA     CONCAT
000010AC                            79              
000010AC  BC3C 0000                 80  CONCAT          CMP.B   #0,D6               ; D6 stores counter
000010B0  6D00 0010                 81                  BLT     RETURN
000010B4  1806                      82                  MOVE.B  D6,D4               ; D4 stores modified counter 
000010B6  E50C                      83                  LSL.B   #2,D4               ; multiply counter by 4 to scale hex to binary, 8 -> 32, 7 -> 28, etc.
000010B8  E9AB                      84                  LSL.L   D4,D3               ; moves current char to correct position  
000010BA  DA83                      85                  ADD.L   D3,D5               ; D5 stores converted input so far
000010BC  0606 00FF                 86                  ADD.B   #-1,D6  
000010C0  60B4                      87                  BRA     CONVERT             ; continue loop for remaining chars
000010C2                            88                  
000010C2  4E75                      89  RETURN          RTS
000010C4                            90                  
000010C4  43F9 00001295             91  INVALID         LEA     BAD_INPUT,A1        ; output invalid message
000010CA  103C 000E                 92                  MOVE.B  #14,D0
000010CE  4E4F                      93                  TRAP    #15
000010D0  B47C 0001                 94                  CMP     #1,D2
000010D4  6700 FF36                 95                  BEQ     INPUT1
000010D8  6000 FF5A                 96                  BRA     INPUT2 
000010DC                            97  
000010DC                            98  * Checks every single possible opcode we could have. Jump table
000010DC                            99  * Inputs: (A2) which is a pointer to intruction word to be translated
000010DC                           100  * Outputs: Prints out dissasembled content to console and A2 will increment appropriatley
000010DC                           101  
000010DC  301A                     102  OPCODE_DECODE   MOVE.W  (A2)+,D0            ; load instruction word from memory
000010DE                           103                  
000010DE  B07C 4E71                104  CASE_NOP        CMP.W   #$4E71,D0           ; compares to NOP opcode in hex
000010E2  6600 0010                105                  BNE     CASE_MOVE           ; checks the next case if not equal
000010E6  4BF9 000012BA            106                  LEA     MSG_NOP,A5          ; loads string pointer into A5
000010EC  4EB9 0000114E            107                  JSR     PRINTNULL           ; prints NOP                
000010F2  4E75                     108                  RTS                         ; returns from the subroutine
000010F4                           109                  
000010F4                           110                  * if first two bits are 00, next two are not 00
000010F4  3200                     111  CASE_MOVE       MOVE.W  D0,D1               ; stores d0 in d1
000010F6  C27C C000                112                  AND.W   #$C000, D1          ; applies a bitmask to get 4 bits, want 00XX
000010FA  6600 002C                113                  BNE     CASE_MOVEQ          ; if not 0, not a  move instruction
000010FE  B07C 0FFF                114                  CMP.W   #$0FFF, D0          ; checks if it exceeds 0FFF
00001102  6F00 0024                115                  BLE     CASE_MOVEQ          ; if less than or equal to, not a move 
00001106  3200                     116                  MOVE.W  D0,D1               ; stores d0 in d1
00001108  C27C 01C0                117                  AND.W   #$01C0, D1          ; appplies a bitmask to get 3 bits, check if its 001
0000110C  B27C 0040                118                  CMP.W   #$0040, D1          ; confirms if it is a MOVEA
00001110  6700 0016                119                  BEQ     CASE_MOVEA          ; branches to MOVEA, otherwise it is a normal MOVE
00001114  4BF9 000012BE            120                  LEA     MSG_MOVE,A5         ; loads string pointer into A5
0000111A  4EB9 0000114E            121                  JSR     PRINTNULL           ; prints out MOVE
00001120  4EB9 00001170            122                  JSR     PRINTMOVESIZE       ; prints out the size                
00001126                           123                  * OTHER STUFF PROBABLY
00001126  4E75                     124                  RTS
00001128                           125  
00001128                           126  CASE_MOVEA      
00001128                           127  
00001128                           128  CASE_MOVEM
00001128                           129  
00001128                           130  CASE_MOVEQ
00001128                           131  
00001128                           132  CASE_ADD
00001128                           133  
00001128                           134  CASE_ADDA
00001128                           135  
00001128                           136  CASE_ADDQ
00001128                           137  
00001128                           138  CASE_SUB
00001128                           139  
00001128                           140  CASE_MULS
00001128                           141  
00001128                           142  CASE_DIVU
00001128                           143  
00001128                           144  CASE_LEA
00001128                           145  
00001128                           146  CASE_AND
00001128                           147  
00001128                           148  CASE_OR
00001128                           149  
00001128                           150  CASE_NOT
00001128                           151  
00001128                           152  CASE_LSL
00001128                           153  
00001128                           154  CASE_LSR
00001128                           155  
00001128                           156  CASE_ASL
00001128                           157  
00001128                           158  CASE_ASR
00001128                           159  
00001128                           160  CASE_BCC
00001128                           161  
00001128                           162  CASE_JSR
00001128                           163  
00001128                           164  CASE_RTS
00001128                           165  
00001128                           166  CASE_BRA                
00001128                           167  
00001128                           168  
00001128                           169  * 
00001128                           170  * 
00001128                           171  GET_EA
00001128                           172  
00001128                           173  * data register
00001128                           174  CASE_DR
00001128                           175  
00001128                           176  * address register
00001128                           177  CASE_AR
00001128                           178  
00001128                           179  * address register indirect
00001128                           180  CASE_ARI
00001128                           181  
00001128                           182  * immediate data
00001128                           183  CASE_ID
00001128                           184  
00001128                           185  * address register indirect post increment
00001128                           186  CASE_ARIPOST
00001128                           187  
00001128                           188  * address register indirect pre increment
00001128                           189  CASE_ARIPRE
00001128                           190  
00001128                           191  * long address
00001128                           192  CASE_LONG
00001128                           193  
00001128                           194  * word address
00001128                           195  CASE_WORD
00001128                           196  
00001128                           197  
00001128                           198  EA_TO_STRING                
00001128                           199  
00001128                           200  
00001128                           201  * DELETE LATER: sorry the formatting is weird here we can fix it later or whenever you want  im just lazy for now
00001128                           202  
00001128                           203  * Prints out the content of D1
00001128                           204  * Input: number in D1 to be printed
00001128                           205  * Output: contents of D1 printed
00001128  48E7 C000                206  PRINTNUM         MOVEM.L     D0-D1, -(SP)        ; saves D0 and D1
0000112C  103C 0003                207                   MOVE.B      #3,D0               ; prints D1
00001130  4E4F                     208                   TRAP        #15                 ; is trap task 3
00001132                           209              
00001132  4CDF 0003                210                   MOVEM.L     (SP)+,D0-D1        ; returns D0 and D1
00001136  4E75                     211                  RTS                             ; returns from subroutune
00001138                           212              
00001138                           213  * Prints contents of things between a range
00001138                           214  * input: A5, A6 (the range)
00001138                           215  * output: prints memory contents from A5 to A6 as strings   
00001138  48E7 C040                216  PRINTRANGE      MOVEM.L     D0-D1/A1, -(SP)  ; saves D0-D1 and A1
0000113C  224D                     217                  MOVEA.L     A5, A1           ; loads A5 into A1
0000113E  9DCD                     218                  SUB.L       A5, A6           ; subtracts A5 to A6, gets us n (number of characters)
00001140  320E                     219                  MOVE.W      A6, D1           ; move n into D1
00001142  103C 0001                220                  MOVE.B      #1, D0           ; display n characyers of string at A1
00001146  4E4F                     221                  TRAP        #15              ; is trap task 1
00001148  4CDF 0203                222                  MOVEM.L     (SP)+, D0-D1/A1  ; restores D0-D1, A1
0000114C  4E75                     223                  RTS                          ; returns
0000114E                           224      
0000114E                           225  * Prints null terminated string
0000114E                           226  * input: string pointed to by A5
0000114E                           227  * output: prints out the null terminated string
0000114E  48E7 8040                228  PRINTNULL       MOVEM.L     D0/A1, -(SP)    ; saves D0-D1 and A1
00001152  224D                     229                  MOVE.L      A5,A1           ; loads A5 into A1
00001154  103C 000A                230                  MOVE.B      #10,D0          ; prints null terminated string
00001158  4E4F                     231                  TRAP        #15            ; is trap task 10
0000115A  4CDF 0201                232                  MOVEM.L     (SP)+,D0/A1    ; saves D0-D1 and A1
0000115E  4E75                     233                  RTS                        ; returns
00001160                           234                  
00001160  2F0D                     235  PRINTENTER      MOVE.L      A5, -(SP)      ; saves A5
00001162  4BF9 000012B7            236                  LEA         NEW_LINE,A5    ; Prints null
00001168  4EB8 114E                237                  JSR         PRINTNULL      ; prints the new line
0000116C  2A5F                     238                  MOVE.L      (SP)+,A5       ; returns A5
0000116E  4E75                     239                  RTS
00001170                           240                  
00001170  48E7 8004                241  PRINTMOVESIZE   MOVEM.L D0/A5,-(SP)         ; saves D0 and A5
00001174  3200                     242                  MOVE.W  D0,D1               ; stores d0 in d1
00001176  C07C 3000                243                  AND.W   #$3000,D0           ; gets the size
0000117A  B07C 2000                244                  CMP.W   #$2000,D0           ; checks if is long
0000117E  6700 001E                245                  BEQ     MOVE_LONG
00001182  B07C 3000                246                  CMP.W   #$3000,D0           ; checks if is word
00001186  6700 000C                247                  BEQ     MOVE_WORD
0000118A                           248                  
0000118A  4BF9 00001354            249  MOVE_BYTE       LEA     MSG_B,A5            ; loads string pointer into a1
00001190  6000 0012                250                  BRA     FINISHMOVE          ; branches to FINISHMOVE
00001194                           251  
00001194  4BF9 00001357            252  MOVE_WORD       LEA     MSG_W,A5            ; loads string pointer into a1
0000119A  6000 0008                253                  BRA     FINISHMOVE          ; branches to FINISHMOVE
0000119E                           254  
0000119E  4BF9 0000135A            255  MOVE_LONG       LEA     MSG_L,A5            ; loads string pointer into a1         
000011A4                           256                  
000011A4  4EB8 114E                257  FINISHMOVE      JSR     PRINTNULL           ; prints out the size
000011A8  4CDF 2001                258                  MOVEM.L (SP)+,D0/A5         ; restores D0 and A5
000011AC  4E75                     259                  RTS
000011AE                           260                  
000011AE  FFFF FFFF                261      SIMHALT             ; halt simulator
000011B2                           262  
000011B2                           263  * Put variables and constants here
000011B2                           264  
000011B2  =0000000D                265  CR          EQU     $0D
000011B2  =0000000A                266  LF          EQU     $0A   
000011B2= 57 65 6C 63 6F 6D ...    267  WELCOME     DC.B    'Welcome to Team Big Blue Disassembler',CR,LF
000011D9= 46 6F 72 6D 61 74 ...    268              DC.B    'Format: 8 digit address in hexadecimal format. Letters must be capital case.',CR,LF,0
00001228= 50 6C 65 61 73 65 ...    269  STARTING    DC.B    'Please enter a starting location in the above format',CR,LF,0
0000125F= 50 6C 65 61 73 65 ...    270  ENDING      DC.B    'Please enter an ending location in the above format',CR,LF,0
00001295= 49 6E 76 61 6C 69 ...    271  BAD_INPUT   DC.B    'Invalid input. Please try again',CR,LF,0
000012B7= 0D 0A 00                 272  NEW_LINE    DC.B    CR,LF,0
000012BA                           273  
000012BA                           274  * Opcode messages
000012BA= 4E 4F 50 00              275  MSG_NOP     DC.B    'NOP',0
000012BE= 4D 4F 56 45 00           276  MSG_MOVE    DC.B    'MOVE',0  
000012C3= 4D 4F 56 45 41 00        277  MSG_MOVEA   DC.B    'MOVEA',0
000012C9= 4D 4F 56 45 51 00        278  MSG_MOVEQ   DC.B    'MOVEQ',0
000012CF= 4D 4F 56 45 4D 00        279  MSG_MOVEM   DC.B    'MOVEM',0
000012D5= 41 44 44 00              280  MSG_ADD     DC.B    'ADD',0
000012D9= 41 44 44 41 00           281  MSG_ADDA    DC.B    'ADDA',0
000012DE= 41 44 44 51 00           282  MSG_ADDQ    DC.B    'ADDQ',0
000012E3= 53 55 42 00              283  MSG_SUB     DC.B    'SUB',0
000012E7= 4D 55 4C 53 00           284  MSG_MULS    DC.B    'MULS',0
000012EC= 44 49 56 55 00           285  MSG_DIVU    DC.B    'DIVU',0
000012F1= 4C 45 41 00              286  MSG_LEA     DC.B    'LEA',0
000012F5= 41 4E 44 00              287  MSG_AND     DC.B    'AND',0
000012F9= 4F 52 00                 288  MSG_OR      DC.B    'OR',0
000012FC= 4E 4F 54 00              289  MSG_NOT     DC.B    'NOT',0
00001300= 4C 53 4C 00              290  MSG_LSL     DC.B    'LSL',0
00001304= 4C 53 52 00              291  MSG_LSR     DC.B    'LSR',0
00001308= 41 53 4C 00              292  MSG_ASL     DC.B    'ASL',0
0000130C= 41 53 52 00              293  MSG_ASR     DC.B    'ASR',0
00001310= 42 43 43 00              294  MSG_BCC     DC.B    'BCC',0
00001314= 42 43 53 00              295  MSG_BCS     DC.B    'BCS',0
00001318= 42 45 51 00              296  MSG_BEQ     DC.B    'BEQ',0
0000131C= 42 4E 45 00              297  MSG_BNE     DC.B    'BNE',0
00001320= 42 47 45 00              298  MSG_BGE     DC.B    'BGE',0
00001324= 42 47 54 00              299  MSG_BGT     DC.B    'BGT',0
00001328= 42 48 49 00              300  MSG_BHI     DC.B    'BHI',0
0000132C= 42 4C 45 00              301  MSG_BLE     DC.B    'BLE',0
00001330= 42 4C 53 00              302  MSG_BLS     DC.B    'BLS',0
00001334= 42 4C 54 00              303  MSG_BLT     DC.B    'BLT',0
00001338= 42 4D 49 00              304  MSG_BMI     DC.B    'BMI',0
0000133C= 42 50 4C 00              305  MSG_BPL     DC.B    'BPL',0
00001340= 42 56 43 00              306  MSG_BVC     DC.B    'BVC',0
00001344= 42 56 53 00              307  MSG_BVS     DC.B    'BVS',0
00001348= 4A 53 52 00              308  MSG_JSR     DC.B    'JSR',0
0000134C= 52 54 53 00              309  MSG_RTS     DC.B    'RTS',0
00001350= 42 52 41 00              310  MSG_BRA     DC.B    'BRA',0
00001354                           311  
00001354                           312  * Sizes
00001354= 2E 42 00                 313  MSG_B       DC.B    '.B',0
00001357= 2E 57 00                 314  MSG_W       DC.B    '.W',0
0000135A= 2E 4C 00                 315  MSG_L       DC.B    '.L',0
0000135D                           316  
0000135D                           317  * Effective address messages
0000135D                           318  
0000135D                           319              END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BAD_INPUT           1295
CASE_ADD            1128
CASE_ADDA           1128
CASE_ADDQ           1128
CASE_AND            1128
CASE_AR             1128
CASE_ARI            1128
CASE_ARIPOST        1128
CASE_ARIPRE         1128
CASE_ASL            1128
CASE_ASR            1128
CASE_BCC            1128
CASE_BRA            1128
CASE_DIVU           1128
CASE_DR             1128
CASE_ID             1128
CASE_JSR            1128
CASE_LEA            1128
CASE_LONG           1128
CASE_LSL            1128
CASE_LSR            1128
CASE_MOVE           10F4
CASE_MOVEA          1128
CASE_MOVEM          1128
CASE_MOVEQ          1128
CASE_MULS           1128
CASE_NOP            10DE
CASE_NOT            1128
CASE_OR             1128
CASE_RTS            1128
CASE_SUB            1128
CASE_WORD           1128
CHECK_LENGTH        1064
CONCAT              10AC
CONVERT             1076
CR                  D
EA_TO_STRING        1128
ENDING              125F
FINISHMOVE          11A4
GET_EA              1128
INPUT1              100C
INPUT2              1034
INVALID             10C4
ISNUMBER            108C
LF                  A
MOVE_BYTE           118A
MOVE_LONG           119E
MOVE_WORD           1194
MSG_ADD             12D5
MSG_ADDA            12D9
MSG_ADDQ            12DE
MSG_AND             12F5
MSG_ASL             1308
MSG_ASR             130C
MSG_B               1354
MSG_BCC             1310
MSG_BCS             1314
MSG_BEQ             1318
MSG_BGE             1320
MSG_BGT             1324
MSG_BHI             1328
MSG_BLE             132C
MSG_BLS             1330
MSG_BLT             1334
MSG_BMI             1338
MSG_BNE             131C
MSG_BPL             133C
MSG_BRA             1350
MSG_BVC             1340
MSG_BVS             1344
MSG_DIVU            12EC
MSG_JSR             1348
MSG_L               135A
MSG_LEA             12F1
MSG_LSL             1300
MSG_LSR             1304
MSG_MOVE            12BE
MSG_MOVEA           12C3
MSG_MOVEM           12CF
MSG_MOVEQ           12C9
MSG_MULS            12E7
MSG_NOP             12BA
MSG_NOT             12FC
MSG_OR              12F9
MSG_RTS             134C
MSG_SUB             12E3
MSG_W               1357
NEW_LINE            12B7
NOTNUMBER           1094
OPCODE_DECODE       10DC
PRINTENTER          1160
PRINTMOVESIZE       1170
PRINTNULL           114E
PRINTNUM            1128
PRINTRANGE          1138
RETURN              10C2
START               1000
STARTING            1228
STOP                105E
WELCOME             11B2
